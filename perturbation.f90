!
!  This unit is not the perturbation theory anymore, it solves the Schroedinger equation
!  variationally.  
!
module perturbation 
  use accuracy
  use molecules, only : MOrepres_arkT,MLsymmetry_transform_func,polintark,MLrotsymmetry_func,MLrotsymmetry_generate
  use moltype, only : MLlinur,MLlinurark,ML_rjacobi_fit_ark
  use lapack
  use plasma
  use fields
  use timer
  use symmetry , only : SymmetryInitialize,sym,max_irreps
  use me_numer
  use diag
  ! use omp_lib


  implicit none
  private
  public  PTinit,PTzeroorder,PTrun,PTdiagonalization,PThamiltonianMat
  public  PTcontracted_prediagonalization,PTsymmetrization,PTactive_space_init
  public  PTcontracted_matelem_class,PTeigenfunction_orthogonality
  public  PThamiltonian_contract,PTget_primitive_matelements,PTDVR_initialize
  public  PTcheck_point_contracted_space,PT_conctracted_rotational_bset
  public  PTTest_eigensolution,PTanalysis_density,PTstore_icontr_cnu

  public  PTintcoeffsT,PTrotquantaT,PTNclasses,PTdefine_contr_from_eigenvect,PTeigenT,PTrepresT
  public  PTstore_contr_matelem,PTcontracted_matelem_class_fast,PTstore_contr_matelem_II,PTcontracted_matelem_class_fast_II

   ! 
   ! files with the eigenvectors 
   !
   type  PTeigenfile
     !
     character(len=cl)  :: dscr       ! file with fingeprints and descriptions of each levels + energy values
     character(len=cl)  :: primitives ! file with the primitive quantum numbres   
     character(len=cl)  :: vectors    ! eigenvectors stored here 
     !
   end type  PTeigenfile 


 !
 ! Number of expansion terms in the kinetic, potential parts of the Hamiltonian
 !
   type PTexp_termsT                          
      integer(ik)   :: poten
      integer(ik)   :: maximal
      integer(ik)   :: gvib
      integer(ik)   :: grot
      integer(ik)   :: gcor
      integer(ik)   :: jmax
   end type PTexp_termsT


  type :: PTrotquantaT
     !
     integer(ik) :: J     ! angular momentum 
     integer(ik) :: k     ! projection of the angular momentum 
     integer(ik) :: tau   ! parity
     !
  end type PTrotquantaT

!
! This type is expected to collect arbitrary integer information, e.g. - Index_nu data
!
   type PTintcoeffsT       
      !
      character(len=cl)     :: type          ! type/name
      integer(ik),pointer   :: icoeffs(:,:)  ! iCoeffs indexes - arbitrary information
      integer(ik)           :: size1,size2
      !
   end type PTintcoeffsT


!
! Here we collect only information relevant for the running perturbation order, say, #N
!
   type PTcoeffsT                        ! PT stands for perturbation theory
      real(rk),pointer   :: coeffs(:,:)  ! Coeffs, indexes:
                                         ! 1) <bra| alpha1,alpha2,alpha3... - quanta within the polyad P
                                         ! 2) |ket> beta1,beta2, ... all basis set qunta, 
                                         !    reachable at the Ntp pert. order
   end type PTcoeffsT

   type PTcoeffs_arkT
      real(ark),pointer   :: coeffs(:,:)  
   end type PTcoeffs_arkT

   type PTcoeffs1dT
      real(ark),pointer :: coeff1d(:)
   end type PTcoeffs1dT

   type PTcoeffs2dT
      real(rk),pointer :: coeff2d(:,:)
   end type PTcoeffs2dT

   type PTcoeffs3dT
      real(rk),pointer :: coeff3d(:,:,:)
   end type PTcoeffs3dT

   type PTintcoeffs1dT
      integer(ik)      :: isize(1)
      integer(ik),pointer :: imat(:)
   end type PTintcoeffs1dT

   type PTintcoeffs2dT
      integer(ik)      :: isize(2)
      integer(ik),pointer :: iimat(:,:)
   end type PTintcoeffs2dT

   type PTintcoeffs3dT
      integer(ik)      :: isize(3)
      integer(ik),pointer :: iiimat(:,:,:)
   end type PTintcoeffs3dT

!
!   Type that will define all objects for contracted mat. elements 
!
   type PTcontrME
      integer(ik)          :: isize        ! Number of expansion coeffs.
      !real(rk),pointer     :: icoeff(:,:)  ! Expansion powers 
      real(rk),pointer     :: me(:,:)      ! matrix elements 
      !
   end type PTcontrME

   type PTcoeffT
      integer(ik)          :: Ncoeff
      integer(ik)          :: MaxNterms
      integer(ik),pointer  :: iorder(:)     
      real(rk),pointer     :: coeff(:,:,:) 
      integer(ik),pointer  :: IndexQ(:,:) 
      integer(ik),pointer  :: ifromsparse(:)
      !integer(ik),pointer  :: itosparse(:)
      type(PTintcoeffs1dT),pointer  :: icoeff(:)
      type(PTintcoeffs1dT),pointer  :: iuniq(:)
      integer(ik),pointer  :: ifield(:)
      integer(ik),pointer  :: nterms(:) 
      integer(ik),pointer  :: iterm(:,:) 
      integer(ik),pointer  :: uniq(:,:) 
   end type PTcoeffT

   !
   ! Type for all DVR fields
   !
   type PTdvrT
     logical                     :: initialized = .false.
     type(PTcoeffs1dT),pointer   :: abcissa(:) 
     type(PTcoeffs1dT),pointer   :: weight(:) 
     !type(PTcoeffs3dT),pointer   :: deriv(:) 
     real(rk),pointer            :: poten(:) 
     real(rk),pointer            :: gvib(:,:,:) 
     real(rk),pointer            :: grot(:,:,:) 
     real(rk),pointer            :: gcor(:,:,:) 
     real(rk),pointer            :: extF(:,:) 
     real(rk),pointer            :: L2(:,:,:)  ! Vibrational angular momentum L2
     type(PTcoeffsT),pointer :: prim_func(:)
     type(PTcoeffsT),pointer :: prim_dfunc(:)
     integer(ik),pointer         :: kindex(:,:)   ! distribution of the points between modes
     integer(ik),pointer         :: kindex2c(:,:) ! distribution of the points between classes
     integer(ik),pointer         :: icheck_deriv(:,:)  
     integer(ik),pointer         :: nsize(:)    ! number of points along each mode 
     integer(hik)                :: total_size  ! total size of the dvr basis set
     real(ark),pointer           :: drho(:)     ! dvr integration step

   end type PTdvrT


   type PTswapT 
      real(rk),pointer    :: vec(:)
      integer(ik),pointer :: icoeff(:)
      integer(ik)         :: cdimen
   end type PTswapT



   type PTprimMET
      !
      type(PTcoeffT),pointer :: poten
      type(PTcoeffT),pointer :: gvib(:,:)
      type(PTcoeffT),pointer :: grot(:,:)
      type(PTcoeffT),pointer :: gcor(:,:)
      type(PTcoeffT),pointer :: L2(:,:)   ! vibrational angulal momentum L2
      type(PTcoeffT),pointer :: rot (:) 
      type(PTcoeffT),pointer :: vibmode(:,:)  ! the imode    primitive vibrational matrix elemenits
      type(PTcoeffT),pointer :: vib(:,:)      ! the ispecies primitive vibrational matrix elemenits
      type(PTcoeffT),pointer :: extF(:)   ! arbitrary external field or function, e.g. dipole moment
      real(rk),pointer       :: rot_contr(:,:,:,:,:)
      !
   end type PTprimMET


 type PTeigenT
    integer(ik)          :: ndeg
    integer(ik)          :: igamma
    integer(ik), pointer :: irec(:)
    integer(ik), pointer :: iroot(:)
    integer(ik)          :: ilevel
    integer(ik), pointer :: quanta(:)
    integer(ik), pointer :: normal(:)
    character(len=4), pointer :: cgamma(:)
    real(rk)             :: energy
    integer(ik)          :: jind
    integer(ik)          :: icoeff
    integer(ik)          :: jval
    integer(ik)          :: krot
    integer(ik)          :: taurot
    real(rk)             :: largest_coeff     ! the largest coeff. in the expansion of the eigenvector
 end type PTeigenT


!
!   Type that will define the wavefunction coeffitients theta_{alpha,beta}^{Norder}:
!   psi_alpha^N = sum theta_{alpha,beta}^N |beta>
!
!
! Here we collect all information that relates to the PT calculations in general 
!
   type PTelementsT     ! PT stands for perturbation theory
      integer(ik)         :: Norder         ! Number of PT orders
      integer(ik)         :: Nmodes         ! Number of modes = 3*Natoms-6
      real(ark),pointer   ::  res_coeffs(:) ! coeffitients that define poliads number or resonanses 
                                            ! P = sum( res_coeffs(:)*nu(:) )
      integer(ik)         :: Npolyads       ! polyad number at the zero-order
      integer(ik)         :: Polyad_max     ! actual number of polyad 
      integer(ik),pointer :: quant_max(:)   ! maximal quanta for every mode, size = Nmodes
      integer(ik),pointer :: range   (:,:)  ! Index range for the given mode 
      integer(ik),pointer :: overlap (:)    ! Index overlaping  for the given mode <v|q|v+overlap>
      integer(ik)         :: maxoverlap     ! maximal value  of the overlapping = maxval(PT%overlap)
      !integer(ik),pointer :: nu_max(:)     ! maximal quanta

      integer(hik)        :: Maxcoeffs      ! Maximal number of coeffs at the maximal Polyad and highest PT order
                                            ! used to count the primitive basis set functions 
      integer(hik)        :: Maxprimitive   ! Truncated number of primitive basis functions 
      integer(ik)         :: Maxcontrcoeffs ! Maximal number of the contracted basis functions 
      integer(ik)         :: Maxsymcoeffs   ! Maximal number of the cases 
      integer(ik)         :: Maxcontracts   ! Total number of the contracted basis functions 
                                            
      integer(ik)         :: max_deg_size   ! Maximal number of degenerate elements 
      !
      integer(ik),pointer :: Max_sym_levels(:) ! Maximal number of symm. coeffs at the maximal Polyad and highest PT order
      integer(ik),pointer :: MaxIndex_nu(:) ! Max number of different main nu modes vs the Polyad number 
      integer(ik),pointer ::  RangeOrder(:)   ! Max number of different quanta at different orders: icoeffs(RangeOrder(N-1)..RangeOrder(N))
      character(len=cl),pointer  :: BasissetType(:) ! Defines type of the basis set functions, e.g. 'HARMONIC'
      type(PTintcoeffsT),pointer :: Index_nu(:)  ! main polyads-index number of coeffs -> nu(i), (Polyad)%icoeffs(Nmodes,Maxcoeffs) - 
      type(PTintcoeffsT),pointer :: Index_deg(:)  ! stores the degeneracy of Index_nu
      type(PTintcoeffsT),pointer :: active_space ! all quanta-index number of coeffs -> nu(i), (Nmodes,Polyad,Maxcoeffs)

      type(PTprimindexT),pointer :: p_active_space ! all quanta-index number of coeffs -> nu(i), (Nmodes,Polyad,Maxcoeffs)
      type(PTsymindexT) ,pointer :: symactive_space(:) ! symmetrized active space: all quanta-index number of coeffs -> nu(i), (Nmodes,Polyad,Maxcoeffs)
      type(PTintcoeffsT),pointer :: symactive_degen(:) ! symmetrized active space: degeneracy quanta-index 
      integer(ik)       ,pointer :: contractive_space(:,:) ! contracted active space: all quanta-index number of coeffs -> nu(i), (Nmodes,Polyad,Maxcoeffs)
      integer(ik)       ,pointer :: icontr2icase(:,:)   ! contracted active space: (i,1) = icase, (i,2) = ideg
      integer(ik)       ,pointer :: Ncontr02icase0(:,:) ! from icontr0 to icase0, limits of the contracted active space: (i,1) = icontr1, (i,2) = icontr2
      integer(ik)       ,pointer :: Ncontr0icase(:,:)   ! from the icontr0 (J=0) to the current icase for any, limits of the contracted active space: (i,1) = icase1, (i,2) = icase2
      integer(ik)       ,pointer :: icase2icontr(:,:)   ! from (icase,ide) to icontr
      integer(ik)       ,pointer :: icontr_cnu(:,:)      ! store cnu  vs icontr index
      integer(ik)       ,pointer :: icontr_ideg(:,:)     ! store ideg vs icontr index
      !integer(ik)       ,pointer :: icontr_chk(:)        ! when reading the vectors mark not used
      type(PTglobindexT),pointer :: globactive_space  ! global active space: all quanta-index number of coeffs -> nu(i), (Nmodes,Polyad,Maxcoeffs)

      !type(PTintcoeffsT),pointer :: index_global(:)   ! global indexing 


      type(PTrepresT),pointer :: irr(:) ! contracted active space: all quanta-index number of coeffs -> nu(i), (Nmodes,Polyad,Maxcoeffs)
      integer(ik),pointer :: mode_class(:,:)       ! which mode correspond to this class
      integer(ik),pointer :: mode_iclass(:)        ! Number of modes within a class
      integer(ik),pointer :: mode_species(:,:)   ! which mode correspond to this species
      integer(ik),pointer :: mode_ispecies(:)    ! Number of modes within a species
      integer(ik),pointer :: Mspecies(:)         ! Species distribution
      integer(ik)         :: Nspecies            ! Number of specieses
      integer(ik)         :: Nclasses            ! Number of classe
      !
      type(PTcoeffsT),pointer    :: Ener0        ! Zero-order energy 
      real(rk)                   :: zpe_contr=0  ! contracted zero point energy
      type(PTcoeffsT),pointer    :: Htotal       ! Total hamiltonian matrix for the variational calcs.
      type(PTintcoeffsT),pointer :: quanta       ! To store the eigenvalue assignment
      type(PTcoeffsT),pointer    :: Ewhole       ! Resutls of the diagonalization of the Htotal hamiltonian matrix
      type(PTcoeffsT),pointer    :: Hclass       ! To store the reduced Hamiltonian  
      type(PTcoeffsT),pointer    :: largest      ! To store the value of the largest coefficient 
      type(PTintcoeffsT),pointer :: lquant       ! Resutls of the diagonalization of the Htotal hamiltonian matrix
      type(PTintcoeffsT),pointer :: polyad_n     ! Polyad quantum numbers of Htotal will be stored in polyad_n
      !
                                                           ! define this value relative to the calculation accuracy 
      type(PTcoeffsT),pointer    :: eigenvalues(:,:)  ! Resulted eigenvalues for every polyad at every order
      type(PTcoeffsT),pointer    :: Hpol(:,:)   ! At Norder (index #1) Every polyad (resonans -> second index) block consists 
                                                ! of <alpha|beta> matrix elements (second and third), written in coeffs
                                                ! This matrix will be finally summed up and diagonalized
      type(PTcoeffsT),pointer    :: Hmat(:,:,:) ! Matrix elements of the hamiltonian at PTorder for the <Npolyad,i|Mpolyad,j> brakets
                                                !
      type(PTcoeffsT),pointer    :: theta(:,:)   ! Theta coeffs, indexes:
                                                 ! 1) Norder 
                                                 ! 2) <bra| polyad number P=0..PolMax
                                                 ! 3) |ket> polyad number P=0..PolMax
      type(PTrotquantaT),pointer :: rot_index(:,:)  ! Array to store j,k,tau vs {level,deg} for rotational eigenfunctions

      type(PTrotquantaT),pointer :: rot_primindex(:)  ! Array to store j,k,tau vs {level,deg} for rotational eigenfunctions


      !type(PTglobalindex),pointer :: global_index(:) ! the field to sore all bookkeeping information relative to the same global indexing

      !
      integer(ik)                 :: max_threads=16
      !
      type(PTexp_termsT)          :: Nterms

   end type PTelementsT



!
! Here we collect all information relating the solution if an eigenvalue problem
   type PSolutionT     
      integer(ik)            :: dimen      ! size of the primitive basis set
      integer(ik)            :: nroots     ! how many roots found (all including degenerate)
      integer(ik)            :: nlevels    ! how many eigenvalues found (not including degenerate)
      type(PTlevelT),pointer :: eigen(:)   ! all found levels 
      type(PTintcoeffsT)     :: prim_bs    ! quantum numbers of the primitive basis set
      integer(ik)            :: max_degen  ! maximal degeneracy, or size of the degeneracy matrix
                                            ! different objects for matrix elemenst 
                                            ! in the contracted basis set representation 
      type(PTcoeffs3dT),pointer :: rot(:)     ! rotational part
      !
      integer(ik),pointer      :: ilevel_chk(:) ! selection of the vectors for calculations from the set stored to the checkpoint file 
      !
      integer(ik),pointer      :: ilevel(:)
      integer(ik),pointer      :: ideg(:)
      integer(ik),pointer      :: iroot(:,:)
      integer(ik),pointer      :: dvr_kindex(:,:)
      integer(ik)              :: Ndvrpoints
      !
   end type PSolutionT 

!
! This is for the irreducibale representation 
!
   type PTrepresT
      real(rk),pointer     :: repres(:,:,:)  
      integer(ik),pointer  :: N(:)
   end type PTrepresT

   type PTrepres_arkT
      real(ark),pointer     :: repres(:,:,:)  
   end type PTrepres_arkT


!
! Here we collect all information relating to each level, which is a solution of an eigenvalue problem
   type PTlevelT     
      integer(ik),pointer :: nu(:)         ! assignment - quantum numbers, including the rotational J
      integer(ik)         :: isym          ! Symmetry of the level (number)
      character(len=10)   :: gamma         ! Symmetry of the level (label)
      integer(ik)         :: degeneracy    ! ----- 
      real(rk)            :: value           ! energy value
      real(rk),pointer    :: vect(:,:)       ! wavefunction
      real(rk),pointer    :: dvr_func(:,:,:) ! wavefunction and its first derivative in the dvr representaion 
      integer(ik)         :: ilarge_coeff    ! the address of the largest coeff. in the expansion of the eigenvector
      real(rk)            :: largest_coeff     ! the largest coeff. in the expansion of the eigenvector
      integer(ik),pointer :: normal(:)       ! assignment - normal mode
      integer(ik)         :: lquant          ! l-qauntum number: vibrational angular momentum
   end type PTlevelT  


   type PTprimindexT    
      integer(ik)          :: size       ! size of the primitive active spice - subject to the energy cut off
      integer(ik),pointer  :: primt(:,:) ! primitive   quanta in primitve active space representation 
      integer(ik),pointer  :: in(:)      !>>>>
      integer(ik),pointer  :: out(:)      !>>>>
      integer(ik),pointer  :: inout(:)      !>>>>
   end type PTprimindexT 



   type PTglobindexT     
      integer(ik),pointer  :: size(:)      ! primitive   quanta in global active space representation 
      integer(ik),pointer  :: primt(:,:)   ! primitive   quanta in global active space representation 
      integer(ik),pointer  :: degen(:,:)     ! degeneracy  quanta in global active space representation 
      integer(ik),pointer :: contr(:,:,:) ! contracted  quanta in global active space representation 
      !type(PTintcoeffsT),pointer :: cnu  ! contracred assignement
   end type PTglobindexT 


   type PTsymindexT     
      integer(ik),pointer  :: sym_N(:,:)   ! symmetric   quanta in global active space representation 
   end type PTsymindexT 


   !
   type  PTfmtT 
     !
     character(len=10)          :: Nspecies   ! a character parameter for format output of fields of size (0:Nspecies)
     character(len=10)          :: Nclasses   ! a character parameter for format output of fields of size (0:Nclasses)
     character(len=10)          :: Nclasses0  ! a character parameter for format output of fields of size (0:Nclasses)
     character(len=10)          :: Aclasses   ! a character parameter for format output of character fields of size (0:Nclasse)
     character(len=10)          :: Nmodes     ! a character parameter for format output of fields of size (0:Nmodes)
     character(len=10)          :: Nmodes0    ! a character parameter for format output of fields of size (0:Nmodes)
     !
   end type  PTfmtT 
   !

   !
   type me_type
     real(rk), allocatable :: me(:,:,:,:,:)
     integer(ik) :: nterms
   end type me_type


   type me_class
     real(rk), allocatable :: me(:,:,:)
     integer(ik) :: nterms
   end type me_class


   ! some parameters that can be used for bechmarking at compilation level
   !
   integer, parameter :: verbose     = 3       ! Verbosity level
   logical, parameter :: debug_check_symmetries  = .true.   ! For debug purposes to check if the non-diagonal symmetries do not vanish in Hamiltonian matrix
   logical, parameter :: debug_cut_matelem_with_enermax  = .false.   ! For debug purposes to check if the non-diagonal symmetries do not vanish in Hamiltonian matrix


!  The PT elements object
!
   type(PTelementsT),save  :: PT ! the main PT structure, that contains all information on the PT
!
! The zero order for the potential function starts from the harmonic approximation (usually)
! Since it can be something else, in general, we introduce a parameter "pot_pt_shift",
! which, in principal, can be also transformed into a variable if necessary
!
   real(rk)                :: screen_enerlimit ! This value will be used to limit the screening for small coeffitients 
                                               ! in the contracted scheme 
   !
   type(PSolutionT),allocatable,save    :: contr(:)    ! solution of the contracted problems
   type(PTcontrME)         :: poten      ! potential part
   type(PTcontrME),pointer :: gvib(:,:)  ! vib. kinetic part 
   type(PTcontrME)         :: hvib       ! vib. part of the hamiltonian 
   type(PTcontrME),pointer :: grot(:,:)  ! rot. kinetic part
   type(PTcontrME),pointer :: gcor(:)    ! coriolis kinetic part
   logical :: contr_bset_initialized = .false.    !  defaul value is false - to make sure that we do not use the basis set before it has been initialized
   type(PTfmtT)            :: fmt
   type(PTprimMET)         :: me   ! 1D primitive matrix elements
   type(PTdvrT),save       :: dvr  ! DVR objects
   !
   logical :: PTvibrational_me_calc = .true.    ! If all vibrational (J=0) matrix elements have been calculated before 
                                                ! there would be no need to compute them for J/=0
                                                ! This can be used if we employ the contracted basis set for J/=0 
                                                ! constructed with all vib. modes (J=0) combined as one class.   
   logical :: PTreduced_model                   ! whether reduced model has been employed for the contracted basis set construction
   !integer(ik)   :: PTMaxcontracts ! Maximal number of the contracted basis functions 
   integer(ik)   :: PTNclasses     ! Number of different classes
   integer(ik)   :: PTNspecies     ! Number of different species
   !
   integer(ik)   :: PTNlevels = 0,PTNroots = 0     ! Number of levels previously computed
   type(PTrepresT),pointer :: irr(:,:) ! contracted active space: all quantum-index number of coeffs -> nu(i), (Nmodes,Polyad,Maxcoeffs)
   !
   type(me_type), allocatable :: gvib_me(:)
   type(me_type), allocatable :: grot_me(:)
   type(me_type), allocatable :: gcor_me(:)
   type(me_type), allocatable :: vpot_me(:)
   type(me_type), allocatable :: pseudo_me(:)
   type(me_type), allocatable :: extF_me(:)
   !
   type(me_class), allocatable :: gvib_class(:,:,:)
   type(me_class), allocatable :: vpot_class(:)
   type(me_class), allocatable :: grot_class(:)
   type(me_class), allocatable :: gcor_class(:,:)
   type(me_class), allocatable :: extF_class(:)
   !
  contains
!
!
! Initilizing the perturbation theory elements, e.g.: theta,Hpol,...
!
  subroutine PTinit(NPTorder,Nmodes,Npolyads)

    integer(ik),intent(in)        :: NPTorder         ! Maximal perturbation order 
    integer(ik),intent(in)        :: Nmodes           ! Number of modes = 3*Natoms-6
    integer(ik),intent(inout)     :: Npolyads         ! maximal polyad number
    !
    integer(ik)                   :: alloc,i
    integer(ik)                   :: imode,ispecies,Nspecies,Nclasses,iclass

    if (job%verbose>=5) write(out,"(/'PTinit/start: Initialization of the perturbation theory elements ')") 


    ! Define the PT-elements 
    !
    PT%Nmodes        = Nmodes
    PT%Npolyads      = Npolyads
    PT%Polyad_max    = Npolyads
    PT%Norder        = NPTorder
    !
    screen_enerlimit = job%enercutoff%contr
    !
    ! This value will be used to limit the screening for small coeffitients 
    ! in the contracted scheme 
    !
    if (job%upper_ener<1e9) screen_enerlimit = job%upper_ener
    !
    ! check the degen_threshold 
    !
    if (job%verbose>=4) then 
      write(out,"(/'The degeneracy is checked with the threshold value',e18.8)") job%degen_threshold
    endif 
    !
    ! Defining resonanses (polyads)
    !
    Nspecies = 0 
    Nclasses = 0 

    do imode = 1,PT%Nmodes
      !
      if (Nspecies<job%bset(imode)%species) Nspecies = job%bset(imode)%species
      if (Nclasses<job%bset(imode)%class  ) Nclasses = job%bset(imode)%class
      ! 
    enddo
    !
    PT%Nspecies = Nspecies
    PT%Nclasses = Nclasses
    !
    ! We also save them as global variable to be seen everywhere:
    !
    PTNspecies = Nspecies
    PTNclasses = Nclasses
    !
    ! Check: the vibrational contraction is designed only for a single class case
    !
    if (job%vib_contract.and.PT%Nclasses/=1) then 
       !
       write (out,"('FLinput: VIBRATIONAL CONTRACTION is only for a single class case (',i8,')')") PT%Nclasses
       stop 'PTinit - illegal Nclasses for Vibrational contraction'
       !
    endif 
    !
    if (job%vib_contract.and.job%Npolyads_prim/=PT%Npolyads) then 
      !
      write (out,"('FLinput: VIBRATIONAL CONTRACTION Npolyads_prim and Npolyads must be the same',2i8)") & 
             job%Npolyads_prim,PT%Npolyads
      stop 'PTinit - illegal Npolyads_prim for Vibrational contraction'
      !
    endif 
    !
    write(fmt%Nspecies,"(i3,'i6')") Nspecies+1
    fmt%Nspecies = adjustl(fmt%Nspecies)
    write(fmt%Nclasses,"(i3,'i6')") Nclasses+1
    fmt%Nclasses = adjustl(fmt%Nclasses)
    write(fmt%Nclasses0,"(i3,'i6')") Nclasses
    fmt%Nclasses0 = adjustl(fmt%Nclasses0)
    write(fmt%Aclasses,"(i3,'(a4,',')')") Nclasses
    fmt%Aclasses = adjustl(fmt%Aclasses)
    write(fmt%Nmodes,"(i3,'i4')") Nmodes+1
    fmt%Nmodes = adjustl(fmt%Nmodes)
    write(fmt%Nmodes0,"(i3,'i4')") Nmodes
    fmt%Nmodes0= adjustl(fmt%Nmodes0)
    !
    allocate (PT%res_coeffs(0:Nmodes),PT%mode_species(PT%Nspecies,PT%Nmodes),&
              PT%mode_ispecies(PT%Nspecies),PT%Mspecies(PT%Nmodes),contr(0:PT%Nclasses),&
              PT%mode_iclass(PT%Nclasses),PT%mode_class(PT%Nclasses,PT%Nmodes),stat=alloc)
    if (alloc/=0) then
       write (out,"(' Error ',i9,' initializing the resonanses ')") alloc
       stop 'PTinit: resonanses - alloc'
    end if
    !
    PT%res_coeffs(1:Nmodes) = job%bset(1:Nmodes)%res_coeffs
    PT%res_coeffs(0) = 0.0_ark
    !
    PT%mode_ispecies  = 0 
    PT%mode_iclass    = 0 
    !
    do imode = 1,PT%Nmodes
      !
      ispecies = job%bset(imode)%species
      !
      PT%mode_ispecies(ispecies) = PT%mode_ispecies (ispecies) + 1 
      PT%mode_species(ispecies,PT%mode_ispecies (ispecies)) = imode
      !
      iclass = job%bset(imode)%class
      !
      PT%mode_iclass(iclass) = PT%mode_iclass (iclass) + 1 
      PT%mode_class(iclass,PT%mode_iclass (iclass)) = imode
      ! 
    enddo
    !
    do ispecies = 1,PT%Nspecies
      do i = 1,PT%mode_ispecies(ispecies)
         imode = PT%mode_species(ispecies,i)
         PT%Mspecies(imode) =  ispecies
      enddo
    enddo
    !
    if (job%verbose>=5) write(out,"(/'PTinit/end')")

  end subroutine PTinit


!
!
! Initilizing the basis set and the Hamiltonian matrix
!
  subroutine PTactive_space_init(bs_t)

    type(FLbasissetT),intent(in)  :: bs_t(0:PT%Nmodes)          ! Basis set specifications: range and type

    integer(ik)                   :: icoeffs,ipol,ipt,ipol_t,alloc,imode,i0,iorder,ib,PTPolyad_active
    integer(ik)                   :: nu_max(0:PT%Nmodes),nu(0:PT%Nmodes),nu_min(0:PT%Nmodes),pol_t(0:PT%Nmodes),j,i,jrot
    real(rk)                      :: ener0,mat_ij
    integer(ik)                   :: nmodes,nmodes1,NPTorder,NPTorder1,Npolyads,Npolyads1,PTDeltaQuanta,dimen,tau0,k0
    integer(ik)                   :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
    integer(ik),allocatable       :: active_nu(:,:)
    real(rk),allocatable          :: a(:),b(:)
    character(len=cl) :: my_fmt !format for I/O specification


    if (job%verbose>=4) write(out,"(/'PTactive_space_init/start: Initialization of the primitive active space')") 
    !
    ! check and deallocate all fields, if necessary
    !
    call PTactive_space_deinit
    !
    nmodes = PT%Nmodes
    NPTorder = PT%Norder
    PTDeltaQuanta = job%PTDeltaQuanta
    Nmodes1 = Nmodes+1
    NPTorder1 = NPTorder + 1
    !
    ! Definition and Verbose for the rotations
    !
    ! Allocate Index_rot%range, where we collect on ranges of J,K,tau
    !
    ! in the current version of the program the calculations are run only for a given J 
    !
    jrot = bs_t(0)%range(1)
    !
    write(out,"(/'NOTE: In the current version of the program')")
    write(out,"( 'NOTE: the calculations are run only for a given J =',i4)") jrot
    !
    ! Allocate and compute Index_rot%icoeffs, 
    ! where we collect information on J,K,tau as as number in a 1D array
    !
    if (job%verbose>=2) then 
      !
      write(out,"(/'Rotational basis: ',a)") trim(bs_t(0)%type)
      write(out,"( 'range for J ',2i5)")  bs_t(0)%range(1:2) 
      write(out,"( 'dvr points:',i0)") bs_t(0)%dvrpoints
    endif 
    !
    ! Verbose (resonanses):  
    !
    if (job%verbose>=2.and.nmodes<=30) then 
       write(out,"('Resonans (polyad) coeffitients are  ',30f16.2)") (PT%res_coeffs(imode),imode=1,min(Nmodes,30))
    endif
    !
    ! Allocation of the the range, overlap of the quanta, and num_max
    !
    allocate (PT%range(2,0:Nmodes),PT%overlap(0:Nmodes),stat=alloc)
    if (alloc/=0) then
        write (out,"(/' Error ',i9,' trying to allocate range and overlap')") alloc
        stop 'PTactive_space_init, range and overlap - out of memory'
    end if
    !
    ! define  range
    !
    ! vibrational modes 
    !
    do imode = 1,Nmodes
      PT%range(:,imode) = bs_t(imode)%range(:)
      PT%overlap(imode) = bs_t(imode)%dvrpoints
      PT%res_coeffs(imode) = bs_t(imode)%res_coeffs
    enddo
    !
    ! Here we adjust the rotational range and overlaps 
    ! as we use just one quantum number ktau=2*k+tau 
    !
    PT%range(1,0) =  0 
    PT%range(2,0) =  jrot*2
    PT%overlap(0) = bs_t(0)%dvrpoints*2
    !
    PT%maxoverlap =  maxval(PT%overlap(1:Nmodes))
    !
    if (job%verbose>=4) then 
      write(my_fmt,'(a,i0,a)') "(a,",nmodes+1,"i5)"
      write(out,"( 'Rotational mode is  assigned to index =',i5/)") 0
      write(out,my_fmt) 'quanta range vs imode ',(imode,imode=0,Nmodes)
      write(out,my_fmt) 'from              ->  ',(PT%range(1,imode),imode=0,Nmodes)
      write(out,my_fmt) 'to                ->  ',(PT%range(2,imode),imode=0,Nmodes)
      write(out,"( 'quanta overlaping')") 
      write(out,my_fmt) ' <v|q|v+overlap>  ->  ',(PT%overlap(imode),imode=0,Nmodes)
    endif 
    !
    ! define  basis set function types
    !
    ! Allocation of the the range of the quanta
    !
    allocate (PT%BasissetType(0:Nmodes),stat=alloc)
    if (alloc/=0) then
        write (out,"(/' Error ',i9,' trying to allocate BasissetType')") alloc
        stop 'PTactive_space_init, BasissetType - out of memory'
    end if
    !
    PT%BasissetType(0:Nmodes)     = bs_t(0:Nmodes)%type
    !
    if (job%verbose>=4) then 
       write(out,"(/'Basis set vs imode ')")
       do imode = 0,Nmodes
         write(out,"(I5,' -> ',a)") imode,PT%BasissetType(imode)
       enddo
    endif 
    !
    nu_max(:) = PT%range(2,:)
    ! 
    ! For PT we also need to defined the active space:
    ! all quantum numbers, that will be activated through different PT orders.
    ! The active space is defined using two factors
    ! 1) It is limited by the PT%range(2), given in the input, and
    ! 2) It is using the rule, that each PT order increases the 
    !    active space by the factor "PTDeltaQuanta"  (ca be given in the input).
    ! The active space is the defined by the smallest of these two factors.
    ! 
    ! First we astimate the active space at the zero PT order, defined by NPolyad:
    ! 
    nu_min(1:Nmodes) = int(real(PT%Npolyads,rk)/PT%res_coeffs(1:Nmodes),ik)
    !
    ! make sure that it doesn't exceed the PT%range 
    !
    nu_min(1:Nmodes) = min(PT%range(2,1:Nmodes),nu_min(1:Nmodes))
    !
    ! The maximal quantum numbers in the active space are 
    ! first defined as
    ! 
    nu_max(1:Nmodes) = nu_min(1:Nmodes) + PT%Norder *job%PTDeltaQuanta
    !
    ! and then adjusted the PT%range number 
    ! 
    nu_max(1:Nmodes) = min(PT%range(2,1:Nmodes),nu_max(1:Nmodes))
    !
    ! Now we can estimte the highest polyad for our active space
    !
    pol_t(1:Nmodes) = int(real(nu_max(1:Nmodes),rk)*PT%res_coeffs(1:Nmodes),ik)
    !
    ! active space maximal polyad number 
    !
    PTPolyad_active = maxval(pol_t(1:Nmodes))
    !
    if (NPTorder==0) then
       !
       !
       PT%Polyad_max = maxval(pol_t(1:Nmodes))
       !
       else
       !
       PT%Polyad_max = PT%Npolyads
       !
    endif 
    !
    if (job%verbose>=2) then 
      write(my_fmt,'(a,i0,a)') "(/a,",Nmodes,"i5)"
      write(out,my_fmt) 'Polyads estimated from range: ',(imode,imode=1,Nmodes)
      write(out,my_fmt) '                          ->  ',(pol_t(imode),imode=1,Nmodes)
      write(out,"(/'Adjusted (input) maximal polyad is: ',i5,'(',i5,')')") PT%Polyad_max,PT%Npolyads
    endif 
    !
    ! Adjust Npolyads to the new estimated value 
    !
    !PT%Npolyads = PT%Polyad_max
    Npolyads = PT%Polyad_max
    Npolyads1 = Npolyads+1
    !
    ! Be verbose !
    !
    if (job%verbose>=2) then
       write(out,"(/'Number of modes ',I5)") Nmodes
       write(out,"( 'Number of polyads at zero order ',I5)") Npolyads
       write(out,"( 'Diagonalizer used: ',a)") trim(job%diagonalizer)
       !
       if (NPTorder/=0) then 
         write(out,"( 'Number of PT orders  ',I5)") NPTorder
         write(out,"( 'every new PT order increases the number of polyads by ',I5)") PTDeltaQuanta
         write(out,"( 'with PT threshold we control if PT is valid, i.e. F/Delta_ener << 1 ',d18.8)") job%PTthreshold
       endif 
       !
    endif 
    !
    ! Allocation of the eigenvalues matrix
    !
    allocate (PT%eigenvalues(0:NPTorder,0:PT%Polyad_max),stat=alloc)
    if (alloc/=0) then
        write (out,"(' Error ',i9,' trying to allocate eigenvalues')") alloc
        stop 'PTactive_space_init, eigenvalues - out of memory'
    end if
    !
    ! Allocation of the Hpol matrix
    !
    allocate (PT%Hpol(0:NPTorder,0:PT%Polyad_max),stat=alloc)
    if (alloc/=0) then
        write (out,"(' Error ',i9,' trying to allocate Hpol')") alloc
        stop 'PTactive_space_init, Hpol - out of memory'
    end if
    !
    ! Allocation of the theta,Hmat element
    !
    ! The second index runs over the polyads defined for the zero-order. 
    ! Only these polyads corrspond to the main energies and will be included 
    ! in the output. At every PT order they are expanded with respect basis 
    ! functions with extended expansion, which is reflected by the third index.
    !
    if (NPTorder>0) then
       !
       allocate (PT%theta(0:max(0,max(0,NPTorder-1)),0:PT%Polyad_max),stat=alloc)
       if (alloc/=0) then
           write (out,"(' Error ',i9,' trying to allocate theta')") alloc
           stop 'PTactive_space_init, theta - out of memory'
       end if
       !
    endif 
    !
    ! Allocate Index_nu, where we collect information on the nu(i) vs number of 1D index 
    ! only for the polyads we are interested at and keeping track of   
    ! 
    allocate (PT%Index_nu(0:PT%Polyad_max),stat=alloc)
    if (alloc/=0) then
        write (out,"(' Error ',i9,' Index_nu ')") alloc
        stop 'PTactive_space_init, Index_nu - out of memory'
    end if

    ! Allocate MaxIndex_nu
    ! 
    allocate (PT%MaxIndex_nu(0:PT%Polyad_max),stat=alloc)
    if (alloc/=0) then
       write (out,"(' Error ',i9,' MaxIndex_nu ')") alloc
       stop 'PTactive_space_init, MaxIndex_nu - out of memory'
    end if
    !     
    ! Allocate active_space, where we collect information on the nu(i) vs number of 1D index 
    ! for all quantum numbers accesible throughout PT
    ! 
    allocate (PT%active_space,stat=alloc)
    if (alloc/=0) then
        write (out,"(' Error ',i9,' active_space ')") alloc
        stop 'PTactive_space_init, active_space - out of memory'
    end if
    !
    ! Allocate RangeOrder   
    ! 
    allocate (PT%RangeOrder(0:NPTorder),stat=alloc)
    if (alloc/=0) then
       write (out,"(' Error ',i9,' RangeOrder ')") alloc
       stop 'PTactive_space_init, RangeOrder - out of memory'
    end if
    !
    ! Here we define the matrix Index_nu(pol)%icoeffs
    ! It will store the quantum numbers as a 1d array 
    ! for each polyad ipol in [0..Npolyads]. 
    ! Maximal number of polyads Npolyads defines
    ! a) the basis set size for the variational problem, or
    ! b) the resonans blocks (zero order) for the Pert. Theory (PT) calculations. 
    !
    do ipol = 0,PT%Polyad_max
       !
       ! We find the ultimate combination of quanta nu_i that corresponds to PTpolyadRules 
       !
       PT%MaxIndex_nu(ipol) = PTnu_index(nu_max,ipol)
       !
       if (PT%MaxIndex_nu(ipol)==0) PT%MaxIndex_nu(ipol) = 1
       !
       ipol_t = PT%MaxIndex_nu(ipol)
       !
       ! Allocate Index_nu%icoeffs, where we collect information on the nu(i) vs number of 1D index 
       ! 
       allocate (PT%Index_nu(ipol)%icoeffs(0:Nmodes,PT%MaxIndex_nu(ipol)),stat=alloc)
       call ArrayStart('Index_nu:icoeffs',alloc,size(PT%Index_nu(ipol)%icoeffs),kind(PT%Index_nu(ipol)%icoeffs))
       !
       PT%Index_nu(ipol)%icoeffs = 0 
       !
       i0 = PTnu_index(nu_max,ipol,PT%Index_nu(ipol)%icoeffs(:,:))
       ! 
    enddo 
    !
    icoeffs = 0
    !
    do ipol = 0,PTPolyad_active
       !
       i0 = PTnu_index(nu_max,ipol)
       !
       icoeffs = icoeffs+i0
       !
    enddo
    !
    PT%Maxcoeffs = int(icoeffs,hik)

    !
    ! We are ready to allocate active_space%icoeffs, where we collect information on the nu(i) vs number of 1D index 
    ! 
    allocate (PT%active_space%icoeffs(0:Nmodes,PT%Maxcoeffs),stat=alloc)
    call ArrayStart('PTactive_space:icoeffs',alloc,size(PT%active_space%icoeffs),kind(PT%active_space%icoeffs))
    !
    ! We can now fill the active_space with the quntum numbers 
    !
    icoeffs = 0
    !
    do ipol = 0,PTPolyad_active
       !
       i0 = PTnu_index(nu_max,ipol)
       i0 = PTnu_index(nu_max,ipol,PT%active_space%icoeffs(:,icoeffs+1:icoeffs+i0))
       !
       icoeffs = icoeffs+i0
       !
    enddo
    !
    ! We also provide ourselves with more specific information 
    ! on the growth of the active space vs PT order:
    !
    do iorder = 0,NPTorder
       !
       nu(1:Nmodes) = nu_min(1:Nmodes) + iorder*PTDeltaQuanta
       nu(1:Nmodes) = min(PT%range(2,1:Nmodes),nu(1:Nmodes))
       pol_t(1:Nmodes) = int(real(nu(1:Nmodes),rk)*PT%res_coeffs(1:Nmodes),ik)
       ipt = minval(pol_t(1:Nmodes))
       !
       icoeffs = 0
       !
       do ipol = 0,ipt
          !
          i0 = PTnu_index(nu_max,ipol)
          icoeffs = icoeffs+i0
          !
       enddo
       !
       PT%RangeOrder(iorder) = icoeffs
       !
    enddo
    !
    ! We can reduce the basis set even by studing the matrix elements of the Hamiltonian. 
    ! We select a number of target states below the ener_thresh threshold and check 
    ! the PT contributions from all other states to corresponding energies of these target states. 
    ! States with small contributions (<coeff_thresh) will be left away. 
    !
    if (job%ener_thresh>0) then 
       !
       call TimerStart('PTactive_space: PT reduction')
       !
       write(out,"(/'Reduce the basis functions according with their PT contribution to the energy... ')")
       !
       dimen = PT%Maxcoeffs
       allocate (a(PT%Maxcoeffs),b(PT%Maxcoeffs),stat=alloc)
       call ArrayStart('PTactive_space_init:ab',alloc,size(b),kind(b))
       b = 0
       !
       !allocate (hmat(PT%Maxcoeffs,PT%Maxcoeffs),stat=alloc)
       !call ArrayStart('PTactive_space_init:hmat',alloc,size(hmat),kind(hmat))
       !
       allocate (active_nu(0:Nmodes,PT%Maxcoeffs),stat=alloc)
       call ArrayStart('PTactive_space_init:active_nu',alloc,size(active_nu),kind(active_nu))
       !
       active_nu = PT%active_space%icoeffs
       !
       write(out,"('  Compute the diagonal primitive matrix elements (total = ',i9,') ... ')") dimen
       !
       !$omp parallel do private(i,nu_i) shared(a) schedule(dynamic)
       do i = 1,dimen
          !
          nu_i(:) = active_nu(:,i)
          a(i) = PTmatrixelements(0,nu_i,nu_i)
          !
          !hmat(i,i) = a(i)
          !
       enddo
       !$omp end parallel do 
       !
       write(out,"('  ...done!')")
       !
       write(out,"('  Compute the non-diagonal primitive matrix elements ... ')")
       !
       ib = 0
       !
       ! collect all j-contributions from matrix elements for a given component i into 
       ! the vector b(j)
       !
       do i = 1,dimen
          !
          if (job%verbose>=5.and.mod(i,100)==0) print("('  i = ',i7)"), i
          !
          nu_i(:) = active_nu(:,i)
          !
          if ( a(i)-a(1)>job%ener_thresh ) cycle
          !
          ib = ib + 1
          !
          !$omp parallel do private(j,nu_j,mat_ij) shared(b) schedule(dynamic)
          do j = i+1,dimen
             !
             if ( a(j)-a(1)<job%ener_thresh ) cycle
             !
             nu_j(:) = active_nu(:,j)
             !
             mat_ij = PTmatrixelements(0,nu_i,nu_j)
             !
             !hmat(i,j) = mat_ij
             !
             b(j)  = b(j) + mat_ij**2/( a(j)-a(i) )
             !
          enddo 
          !$omp end parallel do
          !
       enddo
       !
       ! normalize b(j) to the number of target components i
       !
       b = b/real(ib,rk)
       !
       write(out,"(/'  ...done!')")
       !
       ! count the compressed active basis functions
       icoeffs = 0
       PT%MaxIndex_nu = 0
       do i = 1,dimen
          !
          if ( a(i)-a(1)>job%ener_thresh.and.b(i)<job%coeff_thresh ) cycle
          !
          icoeffs = icoeffs + 1
          ipol = PTpolyadRules(nu_i)
          PT%MaxIndex_nu(ipol) = PT%MaxIndex_nu(ipol) + 1
          !
       enddo
       !
       write(out,'("  The number of target states for E <  ",f14.4," is ",i0," ")') job%ener_thresh,ib
       write(out,'("  The active space is reduced from ",i0," to ",i0," using the small-number threshold of ",g18.8)') &
                   PT%Maxcoeffs,icoeffs,job%coeff_thresh
       !
       PT%Maxcoeffs = icoeffs
       PT%RangeOrder(0) = icoeffs
       !
       deallocate(PT%active_space%icoeffs)
       call ArrayStop('PTactive_space:icoeffs')
       !
       allocate (PT%active_space%icoeffs(0:Nmodes,PT%Maxcoeffs),stat=alloc)
       call ArrayStart('PTactive_space:icoeffs',alloc,size(PT%active_space%icoeffs),kind(PT%active_space%icoeffs))
       !
       call ArrayStop('Index_nu:icoeffs')
       do ipol=0,Npolyads
         deallocate(PT%Index_nu(ipol)%icoeffs)
         allocate (PT%Index_nu(ipol)%icoeffs(0:Nmodes,PT%MaxIndex_nu(ipol)),stat=alloc)
         call ArrayStart('Index_nu:icoeffs',alloc,size(PT%Index_nu(ipol)%icoeffs),kind(PT%Index_nu(ipol)%icoeffs))
       enddo
       !
       icoeffs = 0
       PT%MaxIndex_nu = 0
       do i = 1,dimen
          !
          if ( a(i)-a(1)>job%ener_thresh.and.b(i)<job%coeff_thresh ) cycle
          !
          icoeffs = icoeffs + 1
          PT%active_space%icoeffs(:,icoeffs) = active_nu(:,i)
          !
          ipol = PTpolyadRules(nu_i)
          PT%MaxIndex_nu(ipol) = PT%MaxIndex_nu(ipol) + 1
          PT%Index_nu(ipol)%icoeffs(:,PT%MaxIndex_nu(ipol)) = active_nu(:,i)
          !
       enddo
       !
       deallocate(a,b,active_nu)
       call ArrayStop('PTactive_space_init:ab')
       call ArrayStop('PTactive_space_init:active_nu')
       !
       write(out,"('...done!')")
       !
       call TimerStop('PTactive_space: PT reduction')
       !
    endif
    !
    ! verbose 
    !
    if (job%verbose>=4) then 
      write(my_fmt,'(a,i0,a)') "(a,",nmodes+1,"i5)"
      write(out,my_fmt) 'quanta range vs imode ',(imode,imode=0,Nmodes)
      write(out,my_fmt) 'from              ->  ',(PT%range(1,imode),imode=0,Nmodes)
      write(out,my_fmt) 'to                ->  ',(PT%range(2,imode),imode=0,Nmodes)
      write(out,"( 'quanta overlaping')") 
      write(out,my_fmt) ' <v|q|v+overlap>  ->  ',(PT%overlap(imode),imode=0,Nmodes)
    endif 
    ! 
    if (job%verbose>=4) then
       write(my_fmt,'(a,i0,a)') "(/a,",NPTorder1,"i8)"
       write(out,my_fmt) 'RangeOrder vs order ',(iorder               ,iorder=0,NPTorder)
       write(out,my_fmt) 'RangeOrder       -> ',(PT%RangeOrder(iorder),iorder=0,NPTorder)
    endif 
    !
    ! verbose 
    ! 
    if (job%verbose>=4) then 
      write(out,"(/'Max Number of nu (icoeffs): ',i8)") sum(PT%MaxIndex_nu(:))
    endif 
    !
    ! Be verbose !
    ! 
    if (job%verbose>=4) then
       write(my_fmt,'(a,i0,a)') "(/a,",Npolyads1,"i8)"
       write(out,my_fmt) 'MaxIndex_nu vs polyad ',(ipol,ipol=0,Npolyads)
       write(out,my_fmt) '                   -> ',(PT%MaxIndex_nu(ipol),ipol=0,Npolyads)
    endif 
    !
    ! Be verbose
    !
    if (job%verbose>=4) then 
      write(out,"(/'Primitive basis set table:')")
      write(out,"(' polyad     i   Ener0  nu_i:')")
      !
      write(my_fmt,'(a,i0,a)') "(i5,1x,i8,2x,f12.2,",nmodes+1,"i8)"
      !
      do ipol = 0,PT%Polyad_max
         do ib = 1,PT%MaxIndex_nu(ipol)
            ener0 = FLenergy_zero(PT%Index_nu(ipol)%icoeffs(:,ib))
            write(out,my_fmt) ipol,ib,ener0,& 
                        (PT%Index_nu(ipol)%icoeffs(imode,ib),imode=0,Nmodes)
         enddo 
      enddo 
    endif 
    !
    ! rotational indexes : 
    !
    if (associated(PT%rot_primindex)) deallocate(PT%rot_primindex)
    allocate (PT%rot_primindex(0:bs_t(0)%range(2)),stat=alloc)
    !
    icoeffs = 0
    !
    PT%rot_primindex(0)%j = jrot
    PT%rot_primindex(0)%k = 0
    PT%rot_primindex(0)%tau = mod(jrot,2)
    !
    do k0 = 1,jrot
      !
      do tau0 = 0,1
        icoeffs = icoeffs + 1
        !
        PT%rot_primindex(icoeffs)%j = jrot
        PT%rot_primindex(icoeffs)%k = k0
        PT%rot_primindex(icoeffs)%tau = tau0
        !
      enddo 
      !
    enddo  
    !
    if (job%verbose>=4) then 
      write(out,"(/'Active_space table')")
      write(out,"('i   nu_i')")
      write(my_fmt,'(a,i0,a)') "(i8,1x,",nmodes+1,"i4)"
      do ib = 1,PT%Maxcoeffs
            write(out,my_fmt) ib,(PT%active_space%icoeffs(imode,ib),imode=0,PT%Nmodes)
      enddo 
    endif 
    !
    ! Fields needed for the variational problem
    !
    allocate (PT%Htotal,PT%Ewhole,PT%largest,PT%polyad_n,PT%quanta,PT%lquant,PT%Hclass,stat=alloc)
    if (alloc/=0) then
       write (out,"(' Error ',i9,' Htotal ',i9)") alloc
       stop 'PTactive_space_init, Htotal - out of memory'
    end if
    !
    !determine the size of the Htotal:
    !
    dimen = sum(PT%MaxIndex_nu(0:PT%Polyad_max))
    !
    dimen = min(dimen,PT%Maxcoeffs)
    !
    if (job%verbose>=6) then 
        write (out,"('Size of the variational matrix  = ',i7,' out of ',i7,' elements.')") dimen,PT%Maxcoeffs
    endif
    !
    allocate (PT%Htotal%coeffs(dimen,dimen),PT%Ewhole%coeffs(dimen,1),PT%largest%coeffs(dimen,1),PT%Hclass%coeffs(dimen,dimen),&
              PT%polyad_n%icoeffs(dimen,2),PT%quanta%icoeffs(dimen,0:PT%Nmodes),PT%lquant%icoeffs(dimen,1),stat=alloc)

    call ArrayStart('PTactive_space_init:Htotal' ,alloc,1_ik,kind(PT%Htotal%coeffs),size(PT%Htotal%coeffs,kind=hik))
    call ArrayStart('PTactive_space_init:Hclass' ,alloc,1_ik,kind(PT%Hclass%coeffs),size(PT%Hclass%coeffs,kind=hik))
    call ArrayStart('PTactive_space_init:Ewhole' ,alloc,size(PT%Ewhole%coeffs),kind(PT%Ewhole%coeffs))
    call ArrayStart('PTactive_space_init:largest' ,alloc,size(PT%largest%coeffs),kind(PT%largest%coeffs))
    call ArrayStart('PTactive_space_init:polyad_n' ,alloc,size(PT%polyad_n%icoeffs),kind(PT%polyad_n%icoeffs))
    call ArrayStart('PTactive_space_init:quanta' ,alloc,size(PT%quanta%icoeffs),kind(PT%quanta%icoeffs))
    call ArrayStart('PTactive_space_init:lquant' ,alloc,size(PT%lquant%icoeffs),kind(PT%lquant%icoeffs))
    !
    ! Ener0 
    !
    allocate (PT%Ener0,stat=alloc)
    if (alloc/=0) then
       write (out,"(' Error ',i9,' Ener0 ',i9)") alloc
       stop 'PTactive_space_init, Ener0 - out of memory'
    end if
    !
    allocate (PT%Ener0%coeffs(1,PT%Maxcoeffs),stat=alloc)
    !
    call ArrayStart('PTactive_space_init:Ener0' ,alloc,size(PT%Ener0%coeffs),kind(PT%Ener0%coeffs))
    !
    ! assign the target energies with the primite basis set values
    ! and the eigenvectors with the primitive basis set vectors
    !
    PT%Htotal%coeffs = 0
    PT%Hclass%coeffs = 0
    PT%lquant%icoeffs = 0 
    !
    do ib = 1,dimen
      !
      nu(:) = PT%active_space%icoeffs(:,ib)
      !
      PT%quanta%icoeffs(ib,:) = nu(:)
      !
      PT%Ewhole%coeffs(ib,1) = FLenergy_zero(nu(:))
      !
      PT%largest%coeffs(ib,1) = 1.0_rk
      !
      PT%Htotal%coeffs(ib,ib) = 1.0_ark
      !
      PT%Hclass%coeffs(ib,ib) = 1.0_ark
      !
    enddo
    !
    !if (job%ener_thresh>0) then
    !   deallocate(hmat)
    !   call ArrayStop('PTactive_space_init:hmat')
    !endif
    !
    do ipt = 0,NPTorder

       do ipol = 0,PT%Polyad_max

          icoeffs =  PT%MaxIndex_nu(ipol)
          !
          ! verbose 
          ! 
          !if (verbose>=4) then 
          !  write(out,"(' ipt',i5,' ipol ',i5,' icoeffs: ',i8)") ipt,ipol,icoeffs
          !endif 
          !
          ! ipol in Hpol is defined only for the polyads from the zero-order level
          !
          ! Allocate coeffs of Hpol
          ! 
          allocate (PT%Hpol(ipt,ipol)%coeffs(icoeffs,icoeffs),stat=alloc)
          if (alloc/=0) then
              write (out,"(' Error ',i9,' Hpol/coeffs at ipt,ipol = ',3i8)") alloc,ipt,ipol
              stop 'PTactive_space_init, Hpol/coeffs - out of memory'
          end if
          !
          PT%Hpol(ipt,ipol)%coeffs = 0 
          !
          ! Allocate coeffs of eigenvalues
          ! 
          allocate(PT%eigenvalues(ipt,ipol)%coeffs(icoeffs,1),stat=alloc)
          !
          if (alloc/=0) then
              write (out,"(' Error ',i9,' eigenvalues/coeffs at ipt,ipol = ',2i8)") alloc,ipt,ipol
              stop 'PTactive_space_init, eigenvalues/coeffs - out of memory'
          end if
          !
          PT%eigenvalues(ipt,ipol)%coeffs = 0 
          !
          ! Allocate coeffs of theta
          ! 
          !
          if (ipt<NPTorder) then 
             allocate (PT%theta(ipt,ipol)%coeffs(icoeffs,PT%Maxcoeffs),stat=alloc)
             !
             if (alloc/=0) then
                write (out,"(' Error ',i9,' theta /coeffs at ipt,ipol,= ',4i8)") alloc,ipt,ipol
                stop 'PTactive_space_init, theta /coeffs - out of memory'
             end if
             !
             PT%theta(ipt,ipol)%coeffs = 0 
             !
          endif 
          !
       enddo
    enddo
    !
    if (job%verbose>=4) write(out,"(/'PTactive_space_init/done!')") 

  end subroutine PTactive_space_init


!
!
! Deinitilizing the basis set and the Hamiltonian matrix
!
  subroutine PTactive_space_deinit

    if (job%verbose>=6) write(out,"(/'PTactive_space_deinit/start: Deinitialization of the active space elements ')") 
    !
    ! Deallocation of the the primitive objects
    !
    if (associated(PT%range)) deallocate(PT%range)
    if (associated(PT%overlap)) deallocate(PT%overlap)
    !
    if (associated(PT%range)) deallocate(PT%range)
    if (associated(PT%BasissetType)) deallocate(PT%BasissetType)

    if (associated(PT%eigenvalues)) deallocate(PT%eigenvalues)
    if (associated(PT%Hpol)) deallocate(PT%Hpol)
    if (associated(PT%theta)) deallocate(PT%theta)
    !
    if (associated(PT%Index_nu)) deallocate(PT%Index_nu)
    if (associated(PT%MaxIndex_nu)) deallocate(PT%MaxIndex_nu)
    if (associated(PT%active_space)) deallocate(PT%active_space)
    if (associated(PT%RangeOrder)) deallocate(PT%RangeOrder)

    if (associated(PT%Htotal)) deallocate(PT%Htotal)
    if (associated(PT%Hclass)) deallocate(PT%Hclass)
    if (associated(PT%Ewhole)) deallocate(PT%Ewhole)
    if (associated(PT%largest)) deallocate(PT%largest)
    if (associated(PT%polyad_n)) deallocate(PT%polyad_n)
    if (associated(PT%quanta)) deallocate(PT%quanta)
    if (associated(PT%lquant)) deallocate(PT%lquant)
    if (associated(PT%Ener0)) then
       ! 
       deallocate(PT%Ener0)
       !
       call ArrayStop('PTactive_space_init:Htotal'  )
       call ArrayStop('PTactive_space_init:Hclass'  )
       call ArrayStop('PTactive_space_init:Ewhole'  )
       call ArrayStop('PTactive_space_init:largest' )
       call ArrayStop('PTactive_space_init:polyad_n')
       call ArrayStop('PTactive_space_init:quanta'  ) 
       call ArrayStop('PTactive_space_init:lquant'  )
       !
    endif
    !
    if (job%verbose>=6) write(out,"(/'PTactive_space_deinit/end')") 

  end subroutine PTactive_space_deinit




!
! Here we define the resonans (polyad) rules
!
  function PTpolyadRules(nu) result(polynom)


    integer(ik),intent(in) :: nu(:)
    integer(ik) :: polynom

    !
    polynom  = int(sum( PT%res_coeffs(:)*real(nu(:),rk) ),ik)
    !

  end function PTpolyadRules

!
! Computed the quanrum index spread - needed to define the cluster method of basis set construction 
!
  function PTquanta_spread(nu) result(spread)

    integer(ik),intent(in) :: nu(0:trove%nmodes)
    integer(ik) :: iref
    real(rk) :: spread,factor(0:trove%nmodes)

    spread = 0

    if (job%cluster<0) return
    !
    iref = maxloc(nu(:),dim=1)-1
    !
    iref = max(1,iref)
    iref = min(trove%nmodes,iref)
    !
    !polynom  = int(sum( PT%res_coeffs(:)*real(nu(:),rk) ),ik)
    !
    factor(:) = real(nu(:))*PT%res_coeffs(:) ! /maxval( PT%res_coeffs(:),dim=1 )
    !
    factor(iref) = 0
    !
    !factor(trove%nmodes) = nu(trove%nmodes)
    !
    spread = sum(factor(1:))
    !
    !do i=1,trove%nmodes
    !  if ( i/=iref.and.nu(i)/=0 ) spread = spread + factor(i)
    !enddo
    !
    !spread = product(factor(1:trove%nmodes))
    !
  end function PTquanta_spread

  

!
! Since the "field" module doesn't know much about the 
! the basis set size, we let it get to know using this routine:  
! at the given mode the basis size is defined as the number, 
! which corresponds to the maximal  number nu_max
! at all other modes being zero 
! 
  subroutine PTgetsizeandorder(numax)

     integer(ik),pointer      ::  numax(:)
     integer(ik)              ::  alloc

       !
       allocate (numax(0:PT%Nmodes),stat=alloc)
       if (alloc/=0) then
          write (out,"(' Error ',i9,' allocating numax ')") alloc
          stop 'PTgetsizeandorder - cannot allocate numax'
       end if
       !
       !numax(:) = min(PT%NquantaMax,PT%range(2,:))
       !numax(:) = PT%nu_max(:)
       !
  end subroutine PTgetsizeandorder


!
! We transform the Nmodes-dimension nu-quanta object 
! into a 1D array 
! By default PTnu_index computes the number of (nu1,nu2,nu3...) quanta in the 1D array 
! Index_nu(i,j) is optional, it gives the nu(i) quantum corresponding to the j-number in the 1D quanta-array 
!
  function PTnu_index(nu_target,npol,Index_nu) result (isum)

     integer(ik),intent(in) :: nu_target(:)
     integer(ik),intent(in) :: npol
     integer(ik),intent(inout), optional  :: Index_nu(:,:)

     integer(ik)            :: nu_search(size(nu_target))
     integer(ik) :: ipol,imodes,Nmodes,isum,dm1,dm2
     logical     :: flag_go

      if (present(Index_nu)) then 
        dm1 = size(Index_nu,dim=1)
        dm2 = size(Index_nu,dim=2)
        ! Must explode if wrong 
        if (size(nu_target)/=dm1) then 
            write(out,"('PTnu_index: number of modes in Index_nu /= Nmodes:',2i8)") dm1,size(nu_target)
            stop 'number of modes in Index_nu /= Nmodes'
        endif 
      endif 


      ipol = PTpolyadRules(nu_target)
      if (ipol<npol) then 
          write(out,"('PTnu_index: ipol<npol:',2i8)") ipol,npol
          stop 'PTnu_index: ipol<npol'
      endif 

      imodes = 1
      Nmodes = size(nu_target)
      !
      nu_search = 0 
      flag_go = .true.
      !
      isum = 0 
      call gsum(Nmodes,npol,imodes,nu_search,isum) 
      !
  contains
   ! 
   recursive subroutine gsum(Nmodes,Npol,imodes,nu_search,isum)
     integer(ik),intent(in) :: Nmodes
     integer(ik),intent(in)    :: Npol,imodes
     integer(ik) :: nu_t,Npol_t,isum
     !
     integer(ik)            :: nu_search(size(nu_target))
     real(rk)    :: ener0

     ! start cycle for the current-level nu-mode from 0 and untill npol_t<Npol
     nu_t = 0
     Npol_t   = PTpolyadRules(nu_search)
     !
     do while (npol_t<=Npol.and.flag_go.and.nu_search(imodes)<=nu_target(imodes))
        !
        if (imodes == Nmodes) then
           if (npol_t==Npol) then
             !
             ener0 = FLenergy_zero(nu_search(:))
             !
             ! .and.mod(nu_search(Nmodes),2)==1 ! odd or even
             !
             if (ener0<=job%enercut)  then 
                isum = isum +1
                !write(out,"('isum,-> nu_search',20i4)") isum,nu_search(:)
                if (present(index_nu)) then 
                   if (isum>dm2) then 
                      write(out,"('PTnu_index: isum > size of Index_nu:',2i8)") isum,dm2
                      stop 'PTnu_index: isum > size of Index_nu'
                   endif 
                   index_nu(:,isum) = nu_search(:)
                endif
              endif 
           endif 
           if (all(nu_target(:)==nu_search(:))) flag_go = .false.
        else
           !
           ! go to the next mode (imodes+1)
           !
           call gsum(Nmodes,Npol,imodes+1_ik,nu_search,isum)
        endif 
        nu_t = nu_t +1 
        !
        ! Check the current value for the polyad number 
        !
        nu_search(imodes) = nu_t
        !
        Npol_t = PTpolyadRules(nu_search)
        !
     enddo
     nu_search(imodes:Nmodes)=0
   end subroutine gsum
   !
   !
  end function PTnu_index



!
! We transform the Nmodes-dimension nu-quanta object 
! into a 1D array 
! By default PTnu_active_index computes the number of (nu1,nu2,nu3...) quanta in the 1D array 
! Index_nu(i,j) is optional, it gives the nu(i) quantum corresponding to the j-number in the 1D quanta-array 
!
  function PTnu_active_index(nu_target,Index_nu) result (isum)

     integer(ik),intent(in) :: nu_target(:)
     integer(ik),intent(inout), optional  :: Index_nu(:,:)

     integer(ik)            :: nu_search(size(nu_target))
     integer(ik) :: imodes,Nmodes,isum,dm1,dm2
     logical     :: flag_go

      if (present(Index_nu)) then 
        dm1 = size(Index_nu,dim=1)
        dm2 = size(Index_nu,dim=2)
        ! Must explode if wrong 
        if (size(nu_target)/=dm1) then 
            write(out,"('PTnu_active_index: number of modes in Index_nu /= Nmodes:',2i8)") dm1,size(nu_target)
            stop 'number of modes in Index_nu /= Nmodes'
        endif 
      endif 

      imodes = 1
      Nmodes = size(nu_target)
      !
      nu_search = 0 
      flag_go = .true.
      !
      isum = 0 
      call gsum(Nmodes,imodes,nu_search,isum) 
      !
  contains
   ! 
   recursive subroutine gsum(Nmodes,imodes,nu_search,isum)
     integer(ik),intent(in) :: Nmodes
     integer(ik),intent(in)    :: imodes
     integer(ik) :: nu_t,isum
     !
     integer(ik)            :: nu_search(size(nu_target))
     real(rk)    :: ener0

     ! start cycle for the current-level nu-mode from 0
     nu_t = 0
     !
     do while (flag_go.and.nu_search(imodes)<=nu_target(imodes))
        !
        if (imodes == Nmodes) then
          !
          ener0 = FLenergy_zero(nu_search(:))
          !
          ! .and.mod(nu_search(Nmodes),2)==1 ! odd or even
          !
          if (ener0<=job%enercut)  then 
             isum = isum +1
             !write(out,"('isum,-> nu_search',20i4)") isum,nu_search(:)
             if (present(index_nu)) then 
                if (isum>dm2) then 
                   write(out,"('PTnu_active_index: isum > size of Index_nu:',2i8)") isum,dm2
                   stop 'PTnu_active_index: isum > size of Index_nu'
                endif 
                index_nu(:,isum) = nu_search(:)
             endif
           endif 
           if (all(nu_target(:)==nu_search(:))) flag_go = .false.
        else
           !
           ! go to the next mode (imodes+1)
           !
           call gsum(Nmodes,imodes+1_ik,nu_search,isum)
        endif 
        nu_t = nu_t +1 
        !
        ! Check the current value for the polyad number 
        !
        nu_search(imodes) = nu_t
        !
     enddo
     nu_search(imodes:Nmodes)=0
   end subroutine gsum
   !
  end function PTnu_active_index


!
! We transform the contracted quantum numbers of Nspecies-dimension 
! into a 1D array 
! this a version of PTcontr_index developed for the contracted basis set cases.
! By default PTcontr_index computes the number of (n1,n2,n3...) quanta in the 1D array 
! Index_nu(i,j) is optional, it gives the nu(i) quantum corresponding to the j-number in the 1D quanta-array 
!
  function PTcontr_index(jrot,v_target,Index_v) result (isum)

     integer(ik),intent(in) :: jrot,v_target(0:PT%Nclasses)
     integer(ik),intent(inout), optional  :: Index_v(:,:)

     integer(ik)            :: v_search(size(v_target)),v_target_vr(0:PT%Nclasses)
     integer(ik) :: iclass,Nclasses,isum,dm1,dm2
     logical     :: flag_go

      if (present(Index_v)) then 
        dm1 = size(Index_v,dim=1)
        dm2 = size(Index_v,dim=2)
        ! Must explode if wrong 
        if (size(v_target)/=dm1) then 
            write(out,"('PTcontr_index: number of modes in Index_v /= Nclasses:',2i8)") dm1,size(v_target)
            stop 'number of modes in Index_v /= Nclasses'
        endif 
      endif 
      !
      Nclasses = PT%Nclasses
      !
      iclass = 0
      !
      v_search = 1 
      flag_go = .true.
      !
      isum = 0
      !
      if (job%vib_rot_contr) then
        !
        v_target_vr = cshift(v_target,1)
        !
        call gsum_vib_rot(Nclasses,iclass,v_search,isum)
        !
        if (present(index_v)) index_v = cshift(index_v,-1)
        !
      else
        !
        call gsum(Nclasses,iclass,v_search,isum)
        !
      endif 
      !
  contains
   ! 
   recursive subroutine gsum(Nclasses,iclass,v_search,isum)
     integer(ik),intent(in) :: Nclasses
     integer(ik),intent(in)    :: iclass
     integer(ik) :: v_t,isum,i,pol,jclass,kclass,lquant,kgamma,krot
     integer(ik) :: nu(0:PT%Nmodes)
     !
     integer(ik) :: v_search(0:PT%Nclasses)
     real(rk)    :: ener0,spread
     logical     :: switch 

     v_t = 1
     !
     npol_loop: do while (flag_go.and.v_search(iclass)<=v_target(iclass))
        !
        if (iclass == Nclasses) then
          !
          ener0 = PTcontrenergy_zero(v_search(:))

          nu = 0
          do jclass = 1,Nclasses
            nu(1:PT%Nmodes) = nu(1:PT%Nmodes) + contr(jclass)%eigen(v_search(jclass))%nu(1:PT%Nmodes)
          enddo
          pol = PTpolyadRules(nu)
          !
          spread = PTquanta_spread(nu)
          !
          lquant = 0
          !
          !krot = PT%rot_primindex(v_search(0)-1)%k
          krot = PT%rot_index(v_search(0),1)%k
          !
          !if (trim(job%bset(PT%Nmodes)%type)=='SINRHO'.and.krot>0) krot = min(krot,1)
          !
          if (trove%lincoord/=0) then 
            !
            ! assume that the vib. angular momentum is not zero only for one class or that 
            ! the total vib. ang. momenum is the sum of from each class, which will need to be veryfied 
            !
            do kclass=1,PT%NClasses
              !
              kgamma = contr(kclass)%eigen(v_search(kclass))%isym
              !
              !lquant = lquant + sym%lquant(kgamma)
              !
              !if (trim(job%bset(PT%Nmodes)%type)=='LEGENDRE') then
              !   lquant = lquant + contr(kclass)%eigen(v_search(kclass))%nu(0) 
              !else
              lquant = lquant + contr(kclass)%eigen(v_search(kclass))%lquant 
              !endif
              ! 
            enddo
            !
          endif
          !
          switch = (ener0<=job%enercutoff%contr.and.( pol<=job%Npolyads_contr).or.(spread<=job%cluster.and.pol<=PT%Npolyads) )
          if (trove%triatom_sing_resolve) then
             if ( (job%vib_contract.and..not.trim(job%IOcontr_action)=='SAVE').or.jrot>0) then 
                switch = switch.and.( lquant==krot )
             endif
          elseif(trove%lincoord/=0) then
             switch = switch.and.( lquant==krot.or.jrot==0 )
          endif
          !
          !if ( ( ener0<=job%enercutoff%contr.and.( pol<=job%Npolyads_contr).or.(spread<=job%cluster.and.pol<=PT%Npolyads) ) & ! ) then
          !    ! LINEAR MOLECULE -> requires optimization !!!
          !    .and.( trove%lincoord==0.or.( lquant==krot.or.jrot==0 ) )           ) then
             ! .and.( trove%lincoord==0.or.( lquant==krot.or.jrot==0.or.( trim(job%bset(PT%Nmodes)%type)/='LEGENDRE'.or..not.job%vib_contract ) ) ) ) then
             ! .and.( trove%lincoord==0.or.( lquant==krot.or.( jrot==0.and.( trim(job%bset(PT%Nmodes)%type)/='LEGENDRE' ) ) ) ) ) then
             ! .and.( trove%lincoord==0.or.( contr(0)%eigen(v_search(0))%gamma==contr(PT%Nclasses)%eigen(v_search(PT%Nclasses))%gamma ) ) ) then
             ! .and.(trove%lincoord==0.or.( v_search(0)==contr(0)%nlevels.or.v_search(0)==contr(0)%nlevels-1 ) ) ) then
          !
          if (switch) then 
            !
            isum = isum +1
            if (present(index_v)) then 
               if (isum>dm2) then 
                  write(out,"('PTcontr_index: isum > size of Index_v:',2i8)") isum,dm2
                  stop 'PTcontr_index: isum > size of Index_v'
               endif 
               index_v(:,isum) = v_search(:)
            endif
          endif 
          if (all(v_target(:)==v_search(:))) flag_go = .false.
        else
           !
           ! go to the next class (iclass+1)
           !
           call gsum(Nclasses,iclass+1_ik,v_search,isum)
           !
        endif 
        !
        v_t = v_t +1 
        !
        ! Check the current value for the polyad number 
        !
        v_search(iclass) = v_t

        if (v_search(iclass)> v_target(iclass)) exit npol_loop
        !
     enddo npol_loop
     !
     v_search(iclass:Nclasses)=1
     !
   end subroutine gsum
   !
   ! vib-rot contraction sheeme: the vib. indeces before K
   ! 
   recursive subroutine gsum_vib_rot(Nclasses,iclass,v_search,isum)
     integer(ik),intent(in) :: Nclasses
     integer(ik),intent(in)    :: iclass
     integer(ik) :: v_t,isum,i,pol,jclass,kclass,lquant,kgamma,krot
     integer(ik) :: nu(0:PT%Nmodes)
     !
     integer(ik) :: v_search(0:PT%Nclasses)
     real(rk)    :: ener0,spread

     v_t = 1
     !
     npol_loop: do while (flag_go.and.v_search(iclass)<=v_target_vr(iclass))
        !
        if (iclass == Nclasses) then
          !
          ener0 = PTcontrenergy_zero(cshift(v_search(:),-1))
          !
          nu = 0
          do jclass = 1,Nclasses
            nu(1:PT%Nmodes) = nu(1:PT%Nmodes) + contr(jclass)%eigen(v_search(jclass-1))%nu(1:PT%Nmodes)
          enddo
          pol = PTpolyadRules(nu)
          !
          spread = PTquanta_spread(nu)  
          !
          lquant = 0
          !
          !krot = PT%rot_primindex(v_search(0)-1)%k
          krot = PT%rot_index(v_search(Nclasses),1)%k
          !
          if (trove%lincoord/=0) then 
            !
            ! assume that the vib. angular momentum is not zero only for one class or that 
            ! the total vib. ang. momenum is the sum of from each class, which will need to be veryfied 
            !
            do kclass=1,PT%NClasses
              !
              kgamma = contr(kclass)%eigen(v_search(kclass-1))%isym
              !
              !lquant = lquant + sym%lquant(kgamma)
              !
              lquant = lquant + contr(kclass)%eigen(v_search(kclass))%lquant
              ! 
            enddo
            !
          endif
          !
          if ( (ener0<=job%enercutoff%contr.and.( pol<=job%Npolyads_contr).or.(spread<=job%cluster.and.pol<=PT%Npolyads) ) & ! ) then
              ! LINEAR MOLECULE -> requires optimization !!!
              .and.( trove%lincoord==0.or.( lquant==krot.or.jrot==0 ) ) ) then
             ! .and.( trove%lincoord==0.or.( contr(0)%eigen(v_search(0))%gamma==contr(PT%Nclasses)%eigen(v_search(PT%Nclasses))%gamma ) ) ) then
             ! .and.(trove%lincoord==0.or.( v_search(0)==contr(0)%nlevels.or.v_search(0)==contr(0)%nlevels-1 ) ) ) then
            !
            isum = isum +1
            if (present(index_v)) then 
               if (isum>dm2) then 
                  write(out,"('PTcontr_index: isum > size of Index_v:',2i8)") isum,dm2
                  stop 'PTcontr_index: isum > size of Index_v'
               endif 
               index_v(:,isum) = v_search(:)
            endif
          endif 
          if (all(v_target_vr(:)==v_search(:))) flag_go = .false.
        else
           !
           ! go to the next class (iclass+1)
           !
           call gsum_vib_rot(Nclasses,iclass+1_ik,v_search,isum)
           !
        endif 
        !
        v_t = v_t +1 
        !
        ! Check the current value for the polyad number 
        !
        v_search(iclass) = v_t

        if (v_search(iclass)> v_target_vr(iclass)) exit npol_loop
        !
     enddo npol_loop
     !
     v_search(iclass:Nclasses)=1
     !
   end subroutine gsum_vib_rot
   !
  end function PTcontr_index




  subroutine PTdegener_index(Index_v,Index_deg,isum)

     integer(ik),intent(in) :: Index_v(0:PT%Nclasses)
     integer(ik),intent(inout) :: Index_deg(:,:)
     integer(ik),intent(out) :: isum
     !
     integer(ik)            :: deg_search(0:PT%Nclasses)
     integer(ik) :: iclasses,Nclasses
     logical     :: flag_go
      !
      Nclasses = PT%Nclasses
      !
      iclasses = 0
      !
      deg_search = 1 
      flag_go = .true.
      !
      isum = 0 
      call gsum(Nclasses,iclasses,deg_search,isum) 
      !
  contains
   ! 
   recursive subroutine gsum(Nclasses,iclasses,deg_search,isum)
     integer(ik),intent(in) :: Nclasses
     integer(ik),intent(in)    :: iclasses
     integer(ik) :: v_t,isum,level,ideg
     !
     integer(ik)            :: deg_search(0:PT%Nclasses)

     v_t = 1
     level = Index_v(iclasses)
     if (isum<size(Index_deg,dim=2)) then
       flag_go = .true.
     endif 
     !
     do while (flag_go)
        !
        if (iclasses == Nclasses) then
          !
          do ideg=1,contr(iclasses)%eigen(level)%degeneracy
             isum = isum +1
             deg_search(iclasses) = ideg
             Index_deg(:,isum) = deg_search(:)
             !
          enddo
          flag_go = .false.
        else
           !
           ! go to the next mode (iclasses+1)
           !
           do ideg=1,contr(iclasses)%eigen(level)%degeneracy
             deg_search(iclasses) = ideg
             call gsum(Nclasses,iclasses+1_ik,deg_search,isum)
           enddo 
       endif 
        v_t = v_t +1 
        !
        ! Check the current value for the polyad number 
        !
        deg_search(iclasses) = v_t
        !
     enddo
     deg_search(iclasses:Nclasses)=1
     !
   end subroutine gsum
   !
   !
  end subroutine PTdegener_index



  subroutine PTglobalind_count(max_deg_size,isum,iactive,Index_icnu,Index_ideg,Index_prim,Index_active)

     integer(ik),intent(in)    :: max_deg_size
     integer(ik),intent(out),optional   :: Index_icnu(:,:,:)
     integer(ik),intent(out),optional   :: Index_ideg(:,:)
     integer(ik),intent(out),optional   :: Index_prim(:,:)
     integer(ik),intent(out),optional   :: Index_active(:,:)
     integer(ik),intent(out)   :: isum(:),iactive
     integer(ik) :: iclasses,Nclasses,icase,ideg,nu_c(0:PT%Nclasses),Ncoeffs
     logical     :: flag_go

     integer(ik) :: nu_search(0:PT%Nmodes)
     real(rk)    :: coeff2(0:PT%Nclasses)
     !
     Nclasses = PT%Nclasses
     Ncoeffs = size(isum,dim=1)
     !
     nu_c = 0 
     isum = 0 
     !
     iclasses = 0
     nu_search = 0 
     iactive = 0 
     call gsum(Nclasses,iclasses,nu_search,isum) 
     !
  contains
   ! 
   recursive subroutine gsum(Nclasses,iclasses,nu_search,isum)
     integer(ik),intent(in) :: Nclasses
     integer(ik),intent(in)    :: iclasses
     integer(ik) :: isum(1:max_deg_size),nu(0:PT%Nmodes),nu_t(0:PT%Nmodes),i,ilevel
     !
     integer(ik) :: nu_search(0:PT%Nmodes),cnu(0:PT%Nclasses),npol,j0,jclasses,j,k,tau,cpol
     real(rk) :: ener0,f_t,coeff2_t(0:PT%Nclasses),ener_c
     !
     !if (any(isum(:)<size(Index_nu,dim=2))) then
     flag_go = .true.
     !endif
     !
     do while (flag_go)
        !
        !
        ! go to the next mode (iclasses+1)
        !
        do i=1,contr(iclasses)%dimen 
          !
          nu_c(iclasses) = i
          !
          nu = nu_search(:) + contr(iclasses)%prim_bs%icoeffs(:,i)
          !
          if (iclasses == Nclasses) then
            !
            j   = PT%rot_primindex(nu(0))%j
            k   = PT%rot_primindex(nu(0))%k
            tau = PT%rot_primindex(nu(0))%tau
            !
            nu_t = nu
            nu_t(0) = k+( j*(j+1) )/2
            !
            ener0  = FLenergy_zero(nu_t(:))
            npol   = PTpolyadRules(nu(:))
            !
            !
            coeff2 = 0 
            !
            ! Screen out the transformation matrix from small contributions.
            ! We take only those prim. basis functions that 
            ! are represented by large coefficients in the expansion of 
            ! contr. basis functions. The later ones are taken only below 
            ! job%upper_ener and enercut_contr. 
            !
            do ilevel =1,PT%Maxsymcoeffs
              !
              cnu(:) = PT%contractive_space(:,ilevel)

              nu_t = 0
              do jclasses = 1,Nclasses
                nu_t(1:PT%Nmodes) = nu(1:PT%Nmodes) + contr(jclasses)%eigen(cnu(jclasses))%nu(1:PT%Nmodes)
              enddo
              cpol = PTpolyadRules(nu) 
              !
              ener_c = PTcontrenergy_zero(cnu(:))
              !
              if (ener_c<=screen_enerlimit.and.cpol<=job%Npolyads_contr) then 
                !
                do jclasses = 1,PT%Nclasses
                  !
                  f_t = contr(jclasses)%eigen(cnu(jclasses))%vect(nu_c(jclasses),1)
                  coeff2(jclasses) = max(coeff2(jclasses),sum(contr(jclasses)%eigen(cnu(jclasses))%vect(nu_c(jclasses),:)**2))
                  !
                enddo
                ! 
              endif 
              !
            enddo
            !
            f_t = product(coeff2(1:))
            !
            if ( f_t >= job%coeff_thresh .and.&  ! ener0 <=job%enercutoff%primt.and.npol<=PT%Polyad_max.and.&
               all( nu(1:)>=PT%range(1,1:)).and.all( nu(1:)<=PT%range(2,1:) ) ) then 
              !
              !write(out,"('isum = ',i8)") isum
              !
              iactive = iactive + 1 
              !
              if (present(Index_active)) then 
                 !
                 j0 = iactive
                 !
                 Index_active(:,iactive) = nu(:)
                 !
                 if (ener0>job%enercutoff%primt.or.npol>job%Npolyads_prim) Index_active(:,iactive) = -nu(:)

              endif 
              !
              do icase = 1,max_deg_size
                !
                do ideg = 1,icase
                    !
                    isum(icase) = isum(icase)+1
                    !
                    if (present(Index_icnu)) &
                    Index_icnu(icase,isum(icase),:) = nu_c(:)
                    !
                    if (present(Index_ideg)) &
                    Index_ideg(icase,isum(icase)) = ideg
                    !
                    if (present(Index_ideg)) then 
                       Index_prim(icase,isum(icase)) = iactive

                       if(ener0>job%enercutoff%primt.or.npol>job%Npolyads_prim) Index_prim(icase,isum(icase)) = -iactive
                       !
                    endif 

                  !
                enddo 
                !
              enddo 
              !
            endif 
            !
            flag_go = .false.
            !
          else
            !
            call gsum(Nclasses,iclasses+1_ik,nu,isum)
            !
          endif 
          !
        enddo
        !
     enddo
     !
   end subroutine gsum
   !
   !
  end subroutine PTglobalind_count




!
! Zero order energy calculated from the 1d zero order Hamiltonians
!
   function PTcontrenergy_zero(cnu) result (e_t) 

     integer(ik),intent(in)    :: cnu(0:PT%Nclasses)
     !
     real(rk)                  :: e_t

     integer(ik)               :: iclasses
     !
     if (verbose>=7) write(out,"(/'PTcontrenergy_zero/start')") 
       !
       e_t = 0 
       !
       if (contr_bset_initialized) then 
         !
         do iclasses = 0,PT%Nclasses
           !
           if (cnu(iclasses)>size( contr(iclasses)%eigen(:) ) ) then 
              e_t = huge(1.0_rk)
              return 
           endif  
           !
           e_t = e_t + contr(iclasses)%eigen(cnu(iclasses))%value
           ! 
         enddo
         !
         e_t = e_t - PT%zpe_contr
         !
       else 
         !
         write(out,"('PTcontrenergy_zero: contracted bset was not initialized')") 
         stop 'PTcontrenergy_zero: contracted bset was not initialized'
         !
       endif 
       !
     if (verbose>=7) write(out,"('PTcontrenergy_zero/end')") 
     !
   end function PTcontrenergy_zero
!

   ! a version which starts from class=1, not zero 
   !
   function PTcontrenergy_zero_1(cnu) result (e_t) 

     integer(ik),intent(in)    :: cnu(1:PT%Nclasses)
     !
     real(rk)                  :: e_t

     integer(ik)               :: iclasses
     !
     if (verbose>=7) write(out,"(/'PTcontrenergy_zero_1/start')") 
       !
       e_t = 0 
       !
       if (contr_bset_initialized) then 
         !
         do iclasses = 1,PT%Nclasses
           !
           if (cnu(iclasses)>size( contr(iclasses)%eigen(:) ) ) then 
              e_t = huge(1.0_rk)
              return 
           endif  
           !
           e_t = e_t + contr(iclasses)%eigen(cnu(iclasses))%value
           ! 
         enddo
         !
         e_t = e_t - PT%zpe_contr
         !
       else 
         !
         write(out,"('PTcontrenergy_zero_1: contracted bset was not initialized')") 
         stop 'PTcontrenergy_zero_1: contracted bset was not initialized'
         !
       endif 
       !
     if (verbose>=7) write(out,"('PTcontrenergy_zero_1/end')") 
     !
   end function PTcontrenergy_zero_1


! 
! Rotational quanta J,K,tau are presented as a 1d array
! i.e. a 3-dimension rot-quanta object is transformed into a 1D array 
! J=0..rotbasis%range(2), K=0..J, tau = 0,1
! By default PTrot_index computes an order number of (J,K,tau) quantum in the 1D array 
! Index_rot(i,j) is optional, it gives the rot(i) (i=1,2,3 for J,K,tau) 
! corresponding to the j-number in the 1D quanta-array 
!
  function PTrot_index(rot_target,index_rot) result (jktau)

     integer(ik),intent(in) :: rot_target(:)
     integer(ik),intent(inout), optional  :: index_rot(:,:)

     integer(ik) :: jktau,dm1,dm2,j,k,tau

      if (present(index_rot)) then 
        dm1 = size(index_rot,dim=1)
        dm2 = size(index_rot,dim=2)
        ! Must explode if wrong 
        if (size(rot_target)/=dm1) then 
            write(out,"('PTrot_index: rotmber of modes in Index_rot /= 3:',2i8)") dm1,size(rot_target)
            stop 'rotmber of modes in Index_rot /= 3'
        endif 
      endif
      !
      jktau = 0
      !
      j   = rot_target(1) 
      k   = rot_target(2) 
      tau = rot_target(3) 
      !
      select case (trim(PT%BasissetType(PT%Nmodes)))
         !
      case default
         write (out,"('PTrot_index: type of rotbasis ',a,' unknown')") trim(PT%BasissetType(PT%Nmodes))
         stop 'PTrot_index - bad basis set'
         !
      case ('JKTAU')
         !
         ! in general case this routive will give just an inetger number - 
         ! position of J,K,tau in the 1d array Index_rot
         !
         jktau=1+tau+K*2+J*(J+1)
         !
         ! if the array index_rot supplied, it is allocated and filled with J,k,tau addresses
         !
         if (present(index_rot)) then 
            !
            do j=0,rot_target(1) 
               do k=0,j
                  do tau=0,1
                     !
                     jktau=1+tau+K*2+J*(J+1)
                     !
                     !
                     if (jktau>dm2) then 
                        write(out,"('PTrot_index: jktau > size of index_rot:',2i8)") jktau,dm2
                        stop 'PTrot_index: jktau > size of index_rot'
                     endif
                     !
                     index_rot(1,jktau) = J
                     index_rot(2,jktau) = k
                     index_rot(3,jktau) = tau
                     !
                  enddo
               enddo
            enddo
            ! 
         endif
         !
      end select
      !
      !
  end function PTrot_index


!
! Here we define the zero-order solution: Hpol, theta ..
!
  subroutine PTzeroorder
    integer(ik) :: imode,nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes),ib,ipol
    type(PTcoeffsT),pointer    ::  cf
    integer(ik) :: jpol,i0,jb
    !
    real(rk) :: mat_elem,mat_elem_
    !
    !
    if (verbose>=4) write(out,"(/'PTzeroorder/start: zero order solution ')") 

    if (size(PT%BasissetType)/=PT%Nmodes+1) then 
       write(out,"('PTzeroorder: size(BasissetType)/=PT%Nmodes+1',2i8)") size(PT%BasissetType),PT%Nmodes+1
       stop 'PTzeroorder: size(BasissetType)/=PT%Nmodes+1'
    endif
    !
    if (.not.associated(PT%theta)) then 
       write(out,"('PTzeroorder: PT%theta  has not been associated')") 
       stop 'PTzeroorder: PT%theta not associated'
    elseif (.not.associated(PT%theta(0,0)%coeffs)) then 
       write(out,"('PTzeroorder: PT%theta  has not been associated')") 
       stop 'PTzeroorder: PT%theta not associated'
    endif
    !
    ! Only to check if the BasissetTypes are known
    !
    do imode = 1,PT%Nmodes 
       !
       select case (PT%BasissetType(imode)) 
          case default
            write (out,"('PTzeroorder: type of basis set ',a,' unknown')") trim(PT%BasissetType(imode))
            stop 'PTzeroorder - bad basis set'
          case('NORMAL','MORSE','NUMEROV','HARMONIC') 
            
       end select 
       !
    enddo
    !
    if (verbose>=5) then 
        write(out,"('PTzeroorder: ipol   ib    nu')") 
    endif 
    ! 
    ! Construct the zero-order Hamiltonian and its eigenvalues/vectors
    !
    do ipol = 0,PT%Polyad_max
       !
       do ib = 1,PT%MaxIndex_nu(ipol)
          !
          nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,ib)
          !
          do jb = 1,PT%MaxIndex_nu(ipol)
             !
             nu_j = PT%Index_nu(ipol)%icoeffs(:,jb)
             !
             mat_elem = 0
             !
             if (all( nu_i(1:)>=PT%range(1,1:) ).and. all( nu_i(1:)<=PT%range(2,1:) ).and. & 
                 !
                 all( nu_j(1:)>=PT%range(1,1:) ).and. all( nu_j(1:)<=PT%range(2,1:) ) ) then
                 !
                 ! check the PT-type 
                 select case (trim(job%PTtype))
                 !
                 case default
                      write (out,"('PTzeroorder: type of PT ',a,' unknown')") trim(job%PTtype)
                      stop 'PTzeroorder: type of PT'
                 !
                 ! The 'DIAGONAL' type means that the zero-order H corresponds to all diagonal elements 
                 ! while everything rest (non-diagonal) goes to the 1st order of PT 
                 ! 
                 case ('DIAGONAL') 
                    !
                    if ( ib==jb ) then 
                       !
                       do i0 = 0,PT%Norder
                         !
                         mat_elem_ = FLmatrixelements(i0,nu_i,nu_i)
                         !
                         mat_elem = mat_elem+mat_elem_
                         !
                       enddo 
                       !
                       PT%Hpol(0,ipol)%coeffs(ib,ib) = mat_elem
                       !
                       !
                    else 
                       !
                       mat_elem = FLmatrixelements(0,nu_i,nu_j)
                       !
                       ! Non-diagonal matrix elements at the zero-order - only to report how many no-zero elements 
                       ! at the zero-order
                       !
                       if(abs(mat_elem)>job%zeroerror) then 
                          !
                          ! Zero-order matrix is assumed to be diagonal,
                          ! let's check if it is the case
                          !
                          write(out,"('PTzeroorder: nondiagonal mat-element of the zero-order Hpol = ',2e18.8)") & 
                                       mat_elem,job%zeroerror
                          write(out,"('             for <nu_i| = ',30i4)") nu_i(0:min(30,PT%Nmodes))
                          write(out,"('             for |nu_j> = ',30i4)") nu_j(0:min(30,PT%Nmodes))
                          !
                          !stop 'PTzeroorder: nondiagonal zero-order Hamilt.'
                          !
                       endif 
                       !
                    endif 
                 !
                 ! This is a standard type according to their powers - all terms that have been previously assigned (see FLpt_orders_distribution)
                 ! as zero order will contribute to the zero order Hamiltonian 
                 !
                 case ('POWERS')
                     !
                     !write(out,"('PTzeroorder: POWERS-PTtype is not working')") 
                     !
                     !stop 'PTzeroorder: POWERS-PTtype is not working'
                     !
                     mat_elem = FLmatrixelements(0,nu_i,nu_j)
                     !
                     ! PT%Hpol(0,ipol)%coeffs(ib,ib) = mat_elem
                     !
                     if ( ib==jb ) then 
                        !
                        PT%Hpol(0,ipol)%coeffs(ib,jb) = mat_elem
                        !
                        continue 
                        !
                     elseif(abs(mat_elem)>job%zeroerror) then 
                        !
                        ! Zero-order matrix is assumed to be diagonal,
                        ! let's check if it is the case
                        !
                        write(out,"('PTzeroorder: nondiag mat-eleme of the zero-order Hpol=',2e18.8)") mat_elem,job%zeroerror
                        write(out,"('             for <nu_i| = ',30i4)") nu_i(0:min(30,PT%Nmodes))
                        write(out,"('             for |nu_j> = ',30i4)") nu_j(0:min(30,PT%Nmodes))
                        !
                        if (all(nu_i(1:)<PT%range(2,1:)).and.all(nu_j(1:)<PT%range(2,1:))) then 
                          !stop 'PTzeroorder: nondiagonal zero-order Hamilt.'
                        endif 
                        !
                     endif 
                     !
                 end select
                 !
             endif 
             !
          enddo
          !
       enddo 
       !
    enddo 
    !
    ! Here is the same things, but without polynomail structure, which is neended to fill the zero-order energy array
    ! PT%Ener0%coeffs(1,ib)
    !
    do ib = 1,PT%Maxcoeffs
       !
       nu_i = PT%active_space%icoeffs(:,ib)
       !
       ! Compute the polyad number 
       !
       ipol =  PTpolyadRules(nu_i)
       !
       do jb = 1,PT%Maxcoeffs
          !
          nu_j = PT%active_space%icoeffs(:,jb)
          !
          ! Compute the poliad number 
          !
          jpol =  PTpolyadRules(nu_j)
          !
          mat_elem = 0 
          !
          if (all( nu_i(1:)>=PT%range(1,1:) ).and. all( nu_i(1:)<=PT%range(2,1:) ).and. & 
              !
              all( nu_j(1:)>=PT%range(1,1:) ).and. all( nu_j(1:)<=PT%range(2,1:) ) ) then
              !
              ! check the PT-type 
              select case (trim(job%PTtype))
              !
              case ('DIAGONAL') 
                 !
                 if ( ib==jb ) then 
                    !
                    do i0 = 0,PT%Norder
                      !
                      mat_elem_ = FLmatrixelements(i0,nu_i,nu_i)
                      !
                      mat_elem = mat_elem+mat_elem_
                      !
                    enddo 
                    !
                    PT%Ener0%coeffs(1,ib) =mat_elem
                    !
                 else 
                    !
                    mat_elem = FLmatrixelements(0,nu_i,nu_j)
                    !
                    ! Non-diagonal matrix elements at the zero-order - only to report how many no-zero elements 
                    ! at the zero-order
                    !
                    if(abs(mat_elem)>job%zeroerror) then 
                       !
                       ! Zero-order matrix is assumed to be diagonal,
                       ! let's check if it is the case
                       !
                       write(out,"('PTzeroorder: nondiagonal mat-element of the zero-order Hpol = ',2e18.8)") mat_elem,job%zeroerror
                       write(out,"('             for <nu_i| = ',30i4)") nu_i(0:min(30,PT%Nmodes))
                       write(out,"('             for |nu_j> = ',30i4)") nu_j(0:min(30,PT%Nmodes))
                       !
                       !stop 'PTzeroorder: nondiagonal zero-order Hamilt.'
                       !
                    endif 
                    !
                 endif 
                 !
              case ('POWERS')
                  !
                  if (verbose>=5) then 
                    !
                    mat_elem = FLmatrixelements(0,nu_i,nu_j)
                    !
                    if ( ib==jb ) then 
                      !
                      PT%Ener0%coeffs(1,ib) =mat_elem
                      !
                    else
                      ! 
                      ! Non-diagonal matrix elements at the zero-order - only to report how many no-zero elements 
                      ! at the zero-order
                      !
                      if(abs(mat_elem)>job%zeroerror) then 
                         !
                         ! Zero-order matrix is assumed to be diagonal,
                         ! let's check if it is the case
                         !
                         write(out,"('PTzeroorder: nondiagonal mat-element of the zero-order Hpol = ',2e18.8)") & 
                                                   mat_elem,job%zeroerror
                         write(out,"('             for <nu_i| = ',30i4)") nu_i(0:min(30,PT%Nmodes))
                         write(out,"('             for |nu_j> = ',30i4)") nu_j(0:min(30,PT%Nmodes))
                         !
                         !stop 'PTzeroorder: nondiagonal zero-order Hamilt.'
                         !
                      endif 
                      !
                    endif 
                    !
                  else
                    !
                    if ( ib==jb ) then 
                      !
                      mat_elem = FLmatrixelements(0,nu_i,nu_j)
                      PT%Ener0%coeffs(1,ib) =mat_elem
                      !
                    endif
                      !
                  endif 
                  !
              end select
              !
          endif 
          !
       enddo
       !
    enddo
    !
    ! Now we need also zero eigenfunctions coeffitiens theta(0)%coeffs
    ! which are given by theta_i_j = delta_i_j, i.e.
    ! zero-order theta functions are zero-order eigenfunctions of the Schroedinger equation 
    !
    do ipol = 0,PT%Polyad_max
       cf => PT%theta(0,ipol)
       do ib = 1,PT%MaxIndex_nu(ipol)
          nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,ib)
          do jb = 1,PT%Maxcoeffs
             nu_j = PT%active_space%icoeffs(:,jb)
             if ( all(nu_i(:)==nu_j(:)) ) then 
               cf%coeffs(ib,jb)  = 1.0_ark
             endif 
          enddo
          !
       enddo 
    enddo
    !
    ! be verbose
    !
    if (verbose>=4) then 
       write(out,"(/'Energy(zero) - start')")
       write(out,"('  pol   nn       Ener          quanta')") 
       do ib = 1,PT%Maxcoeffs
          nu_i(:) = PT%active_space%icoeffs(:,ib)
          write(out,"(i8,f19.8,30i4)") ib,PT%Ener0%coeffs(1,ib),(nu_i(i0),i0=0,min(PT%Nmodes,30))
       enddo 
       write(out,"('Energy(zero) - end '/)")
    endif 
    !
    if (verbose>=4) write(out,"('PTzeroorder/end ')") 
    !
  end subroutine PTzeroorder


!

!
!
! Here we construct and diagonalize reduced Hamiltonian matrices for each type of modes
!
  subroutine PTcontracted_prediagonalization(j)

    integer(ik),intent(in) :: j     ! current rotational quantum    
    !type(FLbasissetT),intent(in)  :: bs(0:PT%Nmodes)          ! Basis set specifications: range and type
    type(FLbasissetT)             :: bs_t(0:PT%Nmodes)        ! Basis set specifications: range and type

    real(ark)                     :: res_min,rhostep(PT%Nmodes)
    real(ark)                     :: fmax

    type(PTcoeffs_arkT)           :: bs_funct(PT%Nspecies)
    integer(ik)                   :: ispecies

    real(ark) ,allocatable        :: transform(:,:,:),sample_vector(:)

    real(ark) ,allocatable        :: tmat(:,:,:)
    integer(ik),allocatable       :: count_index(:,:),count_degen(:),numpoints(:)
    real(ark),allocatable         :: chi_t(:,:,:),transform_t(:),transform_maxval(:),fv(:)
    real(ark)                     :: characters(sym%Nclasses)

    integer(ik),parameter         :: Nr_t = 2         ! (2*Nr_t+1) Number of points in the polinom interpolation
                                                      ! used to determine the wavefunction value at a given geometry
    real(ark)                     :: r_t(-Nr_t:Nr_t),func_t(-Nr_t:Nr_t)

    integer(ik)        :: Nclasses,imode,i,iclasses,dimen,alloc,npoints,io_slot,pshift,kmode
    integer(ik)        :: v,bs_size,ilevel,k,ipol,ib,nu(0:PT%Nmodes),i_eq(PT%Nmodes),Nirr(sym%Nrepresen)
    integer(ik)        :: ipoint_t,iroot,gamma,info,jlevel,iroot_in
    character(len=cl)  :: unitfname,diag_
    real(ark)          :: f_value,f_prim,f_t
    real(ark)          :: df_t,fval,xval
    integer(ik)        :: nroots,jrot,icount,ideg,kdeg,ndeg,Ncount,k0,ioper
    integer(ik)        :: ipoint,jpoint,jdeg,im1,im2,level_degen,Nelem,ielem,jroot,kroot,iroot_t,nmodes
    type(PTlevelT),pointer    ::  cf
    integer(ik)       ::  mpoints, iattempts,maxattempts, mpoints_max
    logical           ::  reduced_model,diagonal
    real(ark)           ::  Nirr_rk(sym%Nrepresen)
    real(rk)          :: spread,tol
    !
    real(rk),allocatable  :: mat(:,:),mat_(:,:)
    double precision,parameter :: alpha = 1.0d0,beta=0.0d0
 
    type(PTcoeffs_arkT)    :: overlap(PT%Nspecies,sym%Noper)
    real(rk)               :: zpe,largest_coeff
    integer(ik)            :: ilargest_coeff
    character(len=cl)      :: my_fmt !format for I/O specification

    if (job%verbose>=2) call TimerStart('Contraction & symmetrization')
    !
    ! The contracted solutions will be computed at J=0
    !
    jrot = 0
    !
    !call random_seed() ! Processor reinitializes the seed randomly from the date and time
    Nclasses = PT%Nclasses
    nmodes = PT%Nmodes
    !
    bs_t = job%bset
    !
    ! number of sample points samplings attemptss
    !
    mpoints = job%msample_points
    maxattempts = job%msample_attempts
    !
    do imode = 1,PT%Nmodes
      !
      ! step size
      !
      rhostep(imode) = (job%bset(imode)%borders(2)-job%bset(imode)%borders(1))/real(job%bset(imode)%npoints,kind=ark)
      !
      ! equilibrium position 
      !
    enddo
    !
    do iclasses = 1,Nclasses
       !
       ! initiallize a reduced basis set for the running type of modes
       ! we use the general initialization routine where we set "range" 
       ! so that it would have only quanta from this type  
       !
       do imode = 0,PT%Nmodes
         bs_t(imode)%range(:) = 0 
         bs_t(imode)%res_coeffs = 10000.0
         bs_t(imode)%dvrpoints = 1
       enddo
       !
       res_min = huge(1)
       !
       reduced_model = .false.
       !
       do i = 1,PT%mode_iclass(iclasses)
         !
         imode = PT%mode_class(iclasses,i)
         res_min =  min(res_min,job%bset(imode)%res_coeffs)
         !
       enddo
       !
       kmode = PT%mode_class(iclasses,1)
       !
       do i = 1,PT%mode_iclass(iclasses)
         !
         imode = PT%mode_class(iclasses,i)
         bs_t(imode)%range(:) = job%bset(imode)%range(:) 
         bs_t(imode)%res_coeffs = job%bset(imode)%res_coeffs !/res_min
         bs_t(imode)%dvrpoints = job%bset(imode)%dvrpoints
         !
         ! if specified in the input we solve  a reduced quadratic model  
         ! hamiltonian fully separated from other modes
         ! for constructing the corresponding contracted basis set. 
         ! in this way we supose to get better accuaracy in the symmetrization.
         ! This is important for multi-dimensional mixed basis sets. 
         !
         if (bs_t(imode)%model /= 1000) then 
           !
           reduced_model = .true.
           !
         endif 
         !
       enddo
       !
       call PTactive_space_init(bs_t)
       ! 
       ! This is the diagonalization of the reduced Hamiltonian 
       ! to get the corresponding contracted basis set. 
       !
       ! In case the input gives the truncated order lower than 2 it will mean 
       ! that it is actualy 2 but all non-diagonal terms of the reduced hamiltonian are zero.
       !
       diagonal = .false.
       !
       if (bs_t(kmode)%model<2) then 
          !
          bs_t(kmode)%model = 2
          diagonal = .true.
          !
       endif
       !
       if (reduced_model) then 
         !
         im1 = PT%mode_class(iclasses,1)
         im2 = PT%mode_class(iclasses,PT%mode_iclass(iclasses))
         !
         call PT_exclude_specific_modes(im1,im2,bs_t(kmode)%model,diagonal)
         !
       endif 
       !
       if (trove%DVR) then 
         !
         ! The reduced model in case of DVR is slighlty different as in FBR:
         !
         !if (bs_t(imode)%model == trove%NPotOrder) reduced_model = .true.
         !
         !if (reduced_model) then
           !
           call PTDVR_initialize(j,bs_t,iclasses,reduced_model)
           !
         !else
         !  !
         !  call PTDVR_initialize(j,job%bset,iclasses,reduced_model)
         !  !
         !endif 
         !
       endif
       !
       ! For the Harmonic oscilator basis set and the qudratic PES (bs_t(imode)%model=2) 
       ! we are dealing with the N-dimensional isotropic harmonic oscilator. 
       ! We skip the diagonalization  of the reduced Hamiltonian in this case 
       ! and use the primitive basis functions as the contracted basis set.
       !
       if (bs_t(kmode)%type=='HARMONIC'.and.bs_t(kmode)%model<=2) then 
         !
         ! for the N-dim Harmonic osilator we do not need to diagonalize the rediced Hamiltonian 
         ! to learn the symmetric properties of the contracted basis function. 
         ! In this trivial case there is no contraction and the "contracted" basis functions 
         ! are exactly the primitive basis functions. 
         !
         dimen = size(PT%Htotal%coeffs,dim=1)
         !
         diag_='SYEV'
         !
         if (FLl2_coeffs.and.job%bset(kmode)%lvib) then
           !
           call PThamiltonianMat(jrot=-1_ik,nroots=nroots,diagonalizer_=diag_,postprocess_=bs_t(kmode)%postprocess)
           !
           if (nroots<1) then 
             !
             write(out,"('No eigensolutions found')") 
             stop 'No eigensolutions found'
             !
           endif
           ! 
         endif
         !
         ! count the Harmonic levels with Eharmonic < ecut
         !
         nroots = 0 
         !
         do icount = 1,dimen
           !
           if (PT%Ewhole%coeffs(icount,1)<=job%enercutoff%primt)  then 
             !
             nroots = nroots + 1
             !
           endif
           !
         enddo
         !
       elseif (bs_t(kmode)%type=='HARMONIC'.and.bs_t(kmode)%model>2) then 
         !
         dimen = size(PT%Htotal%coeffs,dim=1)
         !
         diag_='SYEV'
         !
         call PThamiltonianMat(jrot=-3_ik,nroots=nroots,diagonalizer_=diag_,postprocess_=bs_t(kmode)%postprocess)
         !
         if (nroots<1) then 
           !
           write(out,"('No eigensolutions found')") 
           stop 'No eigensolutions found'
           !
         endif
         !
         ! count the Harmonic levels with Eharmonic < ecut
         !
         nroots = 0 
         !
         do icount = 1,dimen
           !
           if (PT%Ewhole%coeffs(icount,1)<=job%enercutoff%primt)  then 
             !
             nroots = nroots + 1
             !
           endif
           !
         enddo
         !
       elseif (FLl2_coeffs.and.job%bset(kmode)%lvib) then 
         !
         ! for the N-dim Harmonic osilator we do not need to diagonalize the rediced Hamiltonian 
         ! to learn the symmetric properties of the contracted basis function. 
         ! In this trivial case there is no contraction and the "contracted" basis functions 
         ! are exactly the primitive basis functions. 
         !
         dimen = size(PT%Htotal%coeffs,dim=1)
         !
         diag_='SYEV'
         !
         call PThamiltonianMat(jrot=-2_ik,nroots=nroots,diagonalizer_=diag_,postprocess_=bs_t(kmode)%postprocess)
         !
         if (nroots<1) then 
           !
           write(out,"('No eigensolutions found')") 
           stop 'No eigensolutions found'
           !
         endif
         !
       else 
         !
         diagonal = .false.
         !
         dimen = size(PT%Htotal%coeffs,dim=1)
         !
         diag_='SYEVR'
         !diag_ = job%diagonalizer
         !
         call PThamiltonianMat(jrot,nroots,diag_,job%enercutoff%contr)
         !
         if (nroots<1) then 
           !
           write(out,"('No eigensolutions found')") 
           stop 'No eigensolutions found'
           !
         endif 
         !
       endif 
       !
       ! bring all mode-reductions back
       !
       if (reduced_model) call PT_exclude_specific_modes(-1,PT%Nmodes+1)
       !
       ! Copy the constructed solution to the contr-field. 
       ! Check if there are degenerate solution, which we want to count to count only once
       !
       ! Bringing the basis set range parameters back: 
       !
       do imode = 1,PT%Nmodes
         PT%range(:,imode) = job%bset(imode)%range(:)
         PT%overlap(imode) = job%bset(imode)%dvrpoints
         PT%res_coeffs(imode) = job%bset(imode)%res_coeffs
       enddo
       !
       icount = 1
       kdeg = 1
       Ndeg = nroots  ! maximal degeneracy - cannot be larger than the number of calculated levels
       if (job%verbose>=6) write(out,"(/'Number of roots after diagonalization: ',i8)") nroots
       !
       !Ndeg = maxval(sym%degen(:),dim=1)  ! maximal degeneracy
       !
       ! Now when we know number of unique levels we can orginize a storage place for the eigensolution 
       !
       allocate (contr(iclasses)%ilevel(nroots),contr(iclasses)%ideg(nroots),stat=alloc)
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate ilevel-field')") alloc
          stop 'PTcontracted_prediagonalization, ilevel -  out of memory'
       end if
       !
       allocate (count_index(nroots,Ndeg),count_degen(nroots),& 
                 sample_vector(dimen),tmat(Ndeg,sym%maxdegen,Ndeg),fv(dimen),stat=alloc)
                 !
       call ArrayStart('PTcontracted:count_index' ,alloc,size(count_index),kind(count_index))
       call ArrayStart('PTcontracted:count_degen' ,alloc,size(count_degen),kind(count_degen))
       call ArrayStart('PTcontracted:sample_vector' ,alloc,size(sample_vector),kind(sample_vector))
       call ArrayStart('PTcontracted:tmat' ,alloc,size(tmat),kind(tmat))
       call ArrayStart('PTcontracted:fv' ,alloc,size(fv),kind(fv))
       !
       contr(iclasses)%ilevel = 0 
       contr(iclasses)%ideg = 0 
       !
       ispecies = 0
       !
       do i = 1,PT%mode_iclass(iclasses)
         !
         imode = PT%mode_class(iclasses,i)
         !
         npoints = job%bset(imode)%npoints
         !
         ! size of the primitive basis set 
         !
         bs_size = job%bset(imode)%range(2) 
         !
         if (PT%Mspecies(imode)/=ispecies) then 
           !
           ispecies = PT%Mspecies(imode)
           !
           if (trim(bs_t(imode)%type)=='NUMEROV'.or.&
               trim(bs_t(imode)%type)=='BOX'.or.&
               trim(bs_t(imode)%type)=='MORSE'.or.&
               trim(bs_t(imode)%type)=='FOURIER'.or.&
               trim(bs_t(imode)%type)=='SINRHO'.or.&
               trim(bs_t(imode)%type)=='LEGENDRE') then 
             !
             allocate (bs_funct(ispecies)%coeffs(0:bs_size,0:npoints),stat=alloc)
             call ArrayStart('bs_funct(ispecies)%coeffs' ,alloc,size( bs_funct(ispecies)%coeffs ),&
                              kind( bs_funct(ispecies)%coeffs))
             !
             ! get the i/o unit with stored numerov or dvr-poilynomial basis functions
             !
             if (trove%DVR) then ! .and.trim(bs_t(imode)%dvr)=='NUMEROV-POL'
               !
               write(unitfname,"('Polynomial dvr basis set # ',i6)") imode
               !
             else
               !
               write(unitfname,"('Numerov basis set # ',i6)") imode
               !
             endif
             !
             call IOStart(trim(unitfname),io_slot)
             !
             ! read the functions in
             !
             do v = 0,bs_size
               !
               read (io_slot,rec=v+1) (bs_funct(ispecies)%coeffs(v,k0),k0=0,npoints)
               !
             enddo
             !
             fmax = maxval(bs_funct(ispecies)%coeffs(0,:),dim=1)-small_
             !
             fmax = 0
             i_eq(imode) = npoints/2
             !
             do ipoint = 0,npoints
               !
               if (abs(bs_funct(ispecies)%coeffs(0,ipoint))>fmax) then 
                  i_eq(imode) = ipoint
                  fmax = bs_funct(ispecies)%coeffs(0,ipoint)
               endif 
               !
             enddo
             !
           endif 
           !
         else
           !
           i_eq(imode) = i_eq(imode-1)
           !
         endif   
         !
         bs_t(imode)%range(:) = job%bset(imode)%range(:) 
         bs_t(imode)%res_coeffs = 1
         bs_t(imode)%dvrpoints = job%bset(imode)%dvrpoints
         !
       enddo
       !
       allocate (mat(sym%maxdegen,sym%maxdegen),mat_(sym%maxdegen,dimen),stat=alloc)
       !
       call ArrayStart('PTcontracted:mat' ,alloc,size(mat),kind(mat))
       call ArrayStart('PTcontracted:mat' ,alloc,size(mat_),kind(mat_))
       !
       if (job%verbose>=5) call MemoryReport
       !
       ! loop over the contracted solution to assign the symmetry to each level
       !
       !cf => PT%Htotal
       !
       if (job%verbose>=2) then 
         !
         write(out,"(//'Symmetry of the contracted solution, class:',i4)") iclasses
         write(out,"('      i       ener         deg  symmetry  quanta:')")
         !
       end if 
       !
       tol = job%symm_toler(imode)
       !
       !call calc_overlap(iclasses)
       !
       count_index = 0
       count_index(1,1) = 1
       count_degen(1) = 1
       !
       icount = 1
       ideg = 1
       iroot_in = 1
       !
       ! A rough estimation of the number unique levels. 
       ! Degeneracy is counted if levels are close enough (less than the threshold).  
       !
       do iroot = 2,nroots
         !
         ! We can truncate the contracted basis set acoording to the polyad_contr threshold  
         !
         nu = PT%quanta%icoeffs(iroot,:)
         ipol = PTpolyadRules(nu)
         spread = PTquanta_spread(nu)
         !
         ! apply the polyad- and cluster-thresholds only for the non-Harmonic basis 
         !
         if ( ipol>job%Npolyads_contr.and.spread>job%cluster.and. &
              .not.( bs_t(kmode)%postprocess.and.bs_t(kmode)%type=='HARMONIC'.and.bs_t(kmode)%model/=1000.and..not.trove%DVR ).and.&
              .not.( abs( PT%Ewhole%coeffs(iroot,1)-PT%Ewhole%coeffs(iroot-1,1) )<job%degen_threshold.and.iroot-1==iroot_in ).and.& 
              .not.( FLl2_coeffs .and.abs( PT%lquant%icoeffs(iroot,1)-PT%lquant%icoeffs(iroot-1,1) )==0.and.iroot-1==iroot_in ) &  
              ) then
            !
            cycle 
            !
         endif
         !
         ! check if a co-degenerate component is already out and remove 
         if ( abs( PT%Ewhole%coeffs(iroot,1)-PT%Ewhole%coeffs(iroot-1,1) )<job%degen_threshold .and. iroot-1/=iroot_in ) then 
            cycle 
         endif
         !
         ! check if a co-degenerate component is already out and remove 
         if  ( FLl2_coeffs .and.abs( PT%lquant%icoeffs(iroot,1)-PT%lquant%icoeffs(iroot-1,1) )==0.and.iroot-1/=iroot_in ) then 
            cycle 
         endif
         !
         ! check the vibrational angular momentum values threshold 
         !if ( ( bs_t(kmode)%type=='HARMONIC'.and.bs_t(kmode)%model<=2.and.FLl2_coeffs).and.( PT%lquant%icoeffs(iroot,1)>job%MaxVibMomentum_contr) ) then
         !   !
         !   cycle 
         !   !
         !endif
         !
         ! check the vibrational angular momentum values threshold 
         if ( (FLl2_coeffs).and.( PT%lquant%icoeffs(iroot,1)>job%MaxVibMomentum_contr) ) then
            !
            cycle 
            !
         endif
         !
         if ( abs(PT%Ewhole%coeffs(iroot,1)-PT%Ewhole%coeffs(iroot_in,1))<job%degen_threshold.and. &
            (.not.FLl2_coeffs.or.( abs( PT%lquant%icoeffs(iroot,1)-PT%lquant%icoeffs(iroot_in,1) )==0 ) ) ) then 
            !
            ideg = ideg + 1
            !
         else
            !
            ideg = 1
            icount = icount + 1
            !
         endif 
         !
         count_index(icount,ideg) = iroot
         count_degen(icount) = ideg
         !
         ! last iroot takin in
         iroot_in = iroot
         !
       enddo
       !
       Ncount = icount
       !
       !mpoints = job%msample_points
       !
       mpoints_max = max(int(real(maxval(count_degen(1:Ncount)),rk)*1.5_rk),job%msample_points)
       mpoints = mpoints_max
       !
       do i = 1,PT%mode_iclass(iclasses)
         !
         imode = PT%mode_class(iclasses,i)
         !
         if (mpoints>job%bset(imode)%npoints) then 
           !
           write(out,"('PTcontracted_prediag..: For class ',i4,' number of points is too small.')") iclasses
           stop 'PTcontracted_prediag..: illegal number of points in class'
           !
         endif
         !
       enddo
       !
       if (job%verbose>=3) then
         write (out,"(/i6,'-points interpolation will be used;')") 2*Nr_t+1
         write (out,"( i6,' sample points will be selected for symmetry reconstruction.'/)") mpoints
       end if
       !
       allocate (chi_t(PT%Nmodes,sym%Noper,1:mpoints),&
                 transform_t(mpoints),&
                 transform_maxval(mpoints),numpoints(mpoints),stat=alloc)
                 !
       call ArrayStart('PTcontracted:chi_t' ,alloc,size(chi_t),kind(chi_t))
       call ArrayStart('PTcontracted:transform_t' ,alloc,size(transform_t),kind(transform_t))
       call ArrayStart('PTcontracted:transform_maxval' ,alloc,size(transform_maxval),kind(transform_maxval))
       call ArrayStart('PTcontracted:numpoints' ,alloc,size(numpoints),kind(numpoints))
       !
       ! Select sample points at which we check the transformation of the eigenfunctions
       !
       call PTselect_sample_points(iclasses,mpoints,Nr_t,rhostep,chi_t)
       !
       call ArrayStart('PTcontracted:transform' ,alloc,size(transform),kind(transform))
       allocate (transform(sym%Noper,Ndeg,mpoints),stat=alloc)
       !
       ! This found number of levels and their degeneracy will be checked and corrected 
       ! using a more accurate procedure. We apply a reduction to the irr. representation 
       ! for the levels that though to be degenerate. 
       !
       allocate (contr(iclasses)%eigen(nroots),&
                 contr(iclasses)%iroot(nroots,sym%maxdegen),stat=alloc)
       !
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate eigen-field')") alloc
          stop 'PTcontracted_prediagonalization, eigen -  out of memory'
       end if
       !
       contr(iclasses)%max_degen = 1
       !
       ! Count the degeneracy of each level 
       !
       ilevel  = 0
       jroot   = 0
       iroot_t = 0 
       icount = 1
       iattempts = 0
       !
       icount_loop : do while(icount<=Ncount.and.iattempts<=maxattempts)
         !
         iroot  = count_index(icount,1)
         Nelem  = count_degen(icount)
         !
         mpoints = max(min(int(real(count_degen(icount))*1.5_rk),Nelem),job%msample_points)
         !
         ! In case the number of degenerate levels exceeds the maximal allowed degeneracy 
         ! the degenerate set has to be splitted. 
         ! A similar solution occurs when the deneneracy is wronlgly defined. 
         ! We reconstruct the transformation matrix and check whether it can be separated 
         ! into independent blocks corresponding to their symmetries. 
         !
         if (job%verbose>=6) call TimerStart('Contract: The points')
         !
         info = 0
         !
         do ideg=1,Nelem
           !
           if (job%sym_C) exit
           !
           do ioper = 1,sym%Noper
             do jpoint=1,mpoints
               !
               fv = 0
               !
               !$omp parallel do private(k,nu,f_prim,i,imode,ispecies,xval,ipoint_t,v,r_t,func_t,fval,df_t,kroot) &
               !$omp& shared(fv) schedule(dynamic) reduction(max:info)
               do k = 1,dimen
                 !
                 nu(:) = PT%active_space%icoeffs(:,k)
                 !
                 ! primitive basis contribution
                 !
                 f_prim = 1.0_ark
                 !
                 do i = 1,PT%mode_iclass(iclasses)
                    !
                    imode = PT%mode_class(iclasses,i)
                    ispecies = PT%Mspecies(imode)
                    !
                    xval = chi_t(imode,ioper,jpoint) 
                    !
                    if (trim(bs_t(imode)%type)=='NUMEROV'.or.&
                        trim(bs_t(imode)%type)=='BOX'.or.&
                        trim(bs_t(imode)%type)=='MORSE'.or.&
                        trim(bs_t(imode)%type)=='FOURIER'.or.&
                        trim(bs_t(imode)%type)=='SINRHO'.or.&
                        trim(bs_t(imode)%type)=='LEGENDRE') then
                        !
                      ipoint_t = nint( ( xval-job%bset(imode)%borders(1) )/rhostep(imode),kind=ik )
                      !
                      do v = -Nr_t,Nr_t
                        !
                        r_t(v)=job%bset(imode)%borders(1) + rhostep(imode)*real(ipoint_t+v,ark)
                        !
                      enddo
                      !
                      func_t(-Nr_t:Nr_t) = bs_funct(ispecies)%coeffs(nu(imode),ipoint_t-Nr_t:ipoint_t+Nr_t)
                      !
                      call polintark(r_t,func_t,xval,fval,df_t)
                      !
                      if (df_t>100.0*sqrt(small_)) then
                         !
                         info = max(info,1)
                         ! 
                         write(out,"('PTcontr..: Error in polint is too large: ',g18.8,'; id,iop,jpoint,k,i= ',5i8)") & 
                                      df_t,ideg,ioper,jpoint,k,i
                         write(out,"('xval = ',g18.8,' func = ',30g18.8)") xval,& 
                                      bs_funct(ispecies)%coeffs(nu(imode),ipoint_t-Nr_t:ipoint_t+Nr_t)
                         !
                      endif 
                      !
                    elseif (trim(bs_t(imode)%type)=='HARMONIC'.or.trim(bs_t(imode)%type)=='NORMAL') then 
                      !
                      fval = Harmonic_oscillator(xval,nu(imode))
                      !
                    else
                      !
                      write(out,"('PTcontracted_prediag: this coordinates are not defined here ',a)") trim(bs_t(imode)%type)
                      stop 'PTcontracted_prediag: not implemented coord. type for the symmetry block'
                      !
                    endif 
                    !
                    f_prim = f_prim*fval
                    !
                 enddo
                 !
                 kroot = count_index(icount,ideg)
                 !
                 fv(k) = PT%Htotal%coeffs(k,kroot)*f_prim
                 !
               enddo 
               !$omp end parallel do
               !
               transform(ioper,ideg,jpoint) = sum(fv(1:dimen))
               !
               if (info/=0) then 
                  !
                  call PTselect_sample_points(iclasses,mpoints,Nr_t,rhostep,chi_t)
                  !
                  iattempts = iattempts + 1
                  !
                  if (job%verbose>=4) write(out,"(28x,'attempt # ',i4,' select sample points again')") iattempts
                  !
                  if (iattempts>=maxattempts) then
                    !
                    write(out,"('PTcontracted_prediag: optimal sample points not found after ',i8,' attempts')") iattempts
                    stop 'PTcontracted_prediag: not possible to select optimal points'
                    !
                  endif
                  !
                  cycle icount_loop
                  !
               endif 
               !
             enddo 
           enddo 
         enddo 
         !
         if (job%verbose>=6) call TimerStop('Contract: The points')
         !
         call degenerate_symmetrization(Nelem,mpoints,transform(1:sym%Noper,1:Nelem,1:mpoints),&
                                        tmat(1:Nelem,1:sym%maxdegen,1:Nelem),tol,Nirr,Nirr_rk,characters,info)
         !
         ! Sometimes the last level in the list does not have all degenerate components.
         ! In this case we remove the last root and set nroots = nroots - 1
         !
         if (info==1.and.count_index(icount,1)+Nelem-1>nroots) then 
           !
           write(out,"(//'PTcontracted_prediag: the last level is  missing its pair, remove it!')")
           Ncount = Ncount - 1
           contr(iclasses)%nlevels = Ncount
           contr(iclasses)%nroots  = nroots - Nelem
           !
           cycle icount_loop
           !
         elseif (info/=0) then
           !
           info = 0
           !
           call PTselect_sample_points(iclasses,mpoints,Nr_t,rhostep,chi_t)
           !
           iattempts = iattempts + 1
           !
           if (job%verbose>=4) write(out,"(28x,'attempt # ',i4,' select sample points again')") iattempts
           !
           if (iattempts>=maxattempts) then
             !
             write(out,"('PTcontracted_prediag: optimal sample points not found after ',i8,' attempts')") iattempts
             !
             kroot = count_index(icount,1) 
             write(my_fmt,'(a,i0,a)') "(a,i8,a,",sym%Nrepresen,"g12.4)"
             !
             write(out,my_fmt) 'PTcontracted_prediag: Cannot define symmetry for level ',ilevel,'; Nirr = ',Nirr_rk
             write(out,"(4x,'Consider reducing symm_toler, increasing points unless something wrong with symmetry.f90, ')") 
             write(out,"(4x,'potential or kineic.')")
             write(out,"('                      nelem = ',i8,' kroot = ',i8,' to ',i8,' icount = ',i8,' Ncount = ',i8)") &
                   nelem,kroot,count_index(icount,Nelem),icount,Ncount

             write(my_fmt,'(a,i0,a)') "(a,",count_index(icount,Nelem)-kroot,"f17.7)"
             write(out,my_fmt) ' Characters = ',characters(1:min(40,sym%Nclasses))
             write(out,my_fmt) 'Energies = ',PT%Ewhole%coeffs(kroot:count_index(icount,Nelem),1)-PT%Ewhole%coeffs(1,1)
             stop 'impossible to define symmetry'
             !
             stop 'PTcontracted_prediag: not possible to select optimal points'
             !
           endif
           !
           cycle icount_loop
           !
         elseif (info==5) then
           !
           kroot = count_index(icount,1) 
           !
           write(out,"('PTcontracted_prediag: Cannot define symmetry for level ',i8,'; Nirr = ',40f12.4)") ilevel,Nirr_rk
           write(out,"(' Characters = ',40f17.7)") characters(1:min(40,sym%Nclasses))
           write(out,"('Energies = ',40f17.7)") PT%Ewhole%coeffs(kroot:count_index(icount,Nelem),1)-PT%Ewhole%coeffs(1,1)
           stop 'impossible to define symmetry'
           ! 
         endif 
         !
         ielem = 0
         !
         do gamma = 1,sym%Nrepresen
           !
           level_degen = sym%degen(gamma)
           !
           do ideg = 1,Nirr(gamma)
             !
             ielem = ielem + 1
             !
             ilevel = ilevel + 1
             !
             ! adjust the counting 
             !
             !count_index(ilevel,ideg) = jroot+ideg
             !
             do i = 1,level_degen
              !
              iroot_t = iroot_t + 1
              !
              contr(iclasses)%ilevel(iroot_t) = ilevel
              contr(iclasses)%ideg(iroot_t)   = i
              contr(iclasses)%iroot(ilevel,i) = iroot_t
              !
             enddo 
             !
             allocate (contr(iclasses)%eigen(ilevel)%vect(dimen,level_degen),&
                       contr(iclasses)%eigen(ilevel)%nu(0:PT%Nmodes),&
                       contr(iclasses)%eigen(ilevel)%normal(0:PT%Nmodes),stat=alloc)
             !
             call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%eigen(ilevel)%vect),& 
                                                kind(contr(iclasses)%eigen(ilevel)%vect))
             call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%eigen(ilevel)%nu),& 
                                                kind(contr(iclasses)%eigen(ilevel)%nu))
             call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%eigen(ilevel)%normal),& 
                                                kind(contr(iclasses)%eigen(ilevel)%normal))
             !
             contr(iclasses)%eigen(ilevel)%degeneracy = level_degen
             contr(iclasses)%eigen(ilevel)%value   = PT%Ewhole%coeffs(iroot,1)
             contr(iclasses)%eigen(ilevel)%nu(:)   = PT%quanta%icoeffs(iroot,:)
             contr(iclasses)%eigen(ilevel)%largest_coeff   = PT%largest%coeffs(iroot,1)
             contr(iclasses)%eigen(ilevel)%ilarge_coeff = 1
             contr(iclasses)%eigen(ilevel)%lquant  = PT%lquant%icoeffs(iroot_t,1)
             !
             if (trim(trove%symmetry)=="DNH".or.trim(trove%symmetry)=="DNH(M)") then
               contr(iclasses)%eigen(ilevel)%lquant  = sym%lquant(gamma)
             endif
             !
             !if (trim(job%bset(Nmodes)%type)=='LEGENDRE') then
             !  contr(iclasses)%eigen(ilevel)%nu(0) = contr(iclasses)%eigen(ilevel)%lquant
             !endif
             !
             ! assume at this stage that the normal quanta are identical with the local quanta
             !
             !contr(iclasses)%eigen(ilevel)%normal(:)   = contr(iclasses)%eigen(ilevel)%nu(:)
             !
             ! normal mode quantum numbers: 1st is the sum of all quanta, second is lquant, if available
             !
             contr(iclasses)%eigen(ilevel)%normal = 0
             imode = PT%mode_class(iclasses,1)
             contr(iclasses)%eigen(ilevel)%normal(imode) = sum(contr(iclasses)%eigen(ilevel)%nu(:))
             !
             if (PT%mode_iclass(iclasses)>1) then
               imode = PT%mode_class(iclasses,2)
               contr(iclasses)%eigen(ilevel)%normal(imode) = contr(iclasses)%eigen(ilevel)%lquant
             endif
             !
             if (trove%triatom_sing_resolve) then
               contr(iclasses)%eigen(ilevel)%normal(0) = contr(iclasses)%eigen(ilevel)%lquant
               imode = PT%mode_class(iclasses,1)
               contr(iclasses)%eigen(ilevel)%normal(imode) = contr(iclasses)%eigen(ilevel)%lquant
             endif
             !
             cf => contr(iclasses)%eigen(ilevel)
             !
             cf%isym = gamma    
             cf%gamma = trim(sym%label(gamma))
             !
             ! determine the maximal degeneracy for all values of the given classes
             !
             contr(iclasses)%max_degen = max(contr(iclasses)%max_degen,cf%degeneracy)
             !
             do kdeg = 1,level_degen
               !
               do k = 1,dimen
                 cf%vect(k,kdeg) = sum(tmat(ielem,kdeg,1:Nelem)*PT%Htotal%coeffs(k,count_index(icount,1):count_index(icount,Nelem)))
               enddo
             enddo
             !
             if (job%verbose>=6) call TimerStart('Contract: Orthonaliz')
             ! 
             ! Check the orthogonality of the (transformed) contracted eigenfunctions 
             !
             do kdeg = 1,level_degen
               !
               !f_value = dot_product(contr(iclasses)%eigen(ilevel)%vect(:,kdeg),contr(iclasses)%eigen(ilevel)%vect(:,kdeg))
               !
               !sample_vector(:) = contr(iclasses)%eigen(ilevel)%vect(:,kdeg)
               !
               f_value = sum(contr(iclasses)%eigen(ilevel)%vect(:,kdeg)*contr(iclasses)%eigen(ilevel)%vect(:,kdeg))
               !
               if (job%verbose>=6.and.abs(f_value-1.0_rk)>sqrt(small_)) then 
                 !
                 write(out,"(//'ilevel,kdeg,f_value ',2i8,f18.10)") ilevel,kdeg,f_value
                 !
               endif 
               !contr(iclasses)%eigen(ilevel)%vect(:,kdeg) = contr(iclasses)%eigen(ilevel)%vect(:,kdeg)/sqrt(f_value)

               !$omp parallel do private(ib) schedule(dynamic)
               do ib = 1,dimen
                 !
                 contr(iclasses)%eigen(ilevel)%vect(ib,kdeg) = contr(iclasses)%eigen(ilevel)%vect(ib,kdeg)/sqrt(f_value)
                 !
               enddo
               !$omp end parallel do
               !
               do jlevel = 1,ilevel
                 !
                 do jdeg=1,contr(iclasses)%eigen(jlevel)%degeneracy
                   !
                   if (jlevel<ilevel.or.jdeg<kdeg) then 
                     !
                     !sample_vector(:) = contr(iclasses)%eigen(jlevel)%vect(:,jdeg)
                     !
                     f_value = sum(cf%vect(:,kdeg)*contr(iclasses)%eigen(jlevel)%vect(:,jdeg))
                     !
                     if (abs(f_value)>sqrt(small_)) then 
                      !
                      if (job%verbose>=6) then 
                        !
                        write(out,"(//'ilevel,kdeg,f_value ',2i8,f18.10)") ilevel,kdeg,f_value
                        !
                      endif 
                       !f_value = dot_product(cf%vect(:,kdeg),contr(iclasses)%eigen(jlevel)%vect(:,jdeg))
                       !
                       !$omp parallel do private(ib) schedule(dynamic)
                       do ib = 1,dimen
                         !
                         cf%vect(ib,kdeg) = cf%vect(ib,kdeg) - f_value*contr(iclasses)%eigen(jlevel)%vect(ib,jdeg)
                         !
                       enddo
                       !$omp end parallel do
                       !
                       !f_value = dot_product(cf%vect(:,kdeg),cf%vect(:,kdeg))
                       !
                       f_value = sum(cf%vect(:,kdeg)*cf%vect(:,kdeg))
                       !
                       if (f_value<(small_)) then 
                         !
                         write(out,"('PTcontracted_prediagonalization: vanishing normal of vector: ')") 
                         write(out,"('                  (ilevel,kdeg): ',2i8,f18.10)") ilevel,kdeg,f_value
                         stop 'vanishing the vector normalization'
                         !
                       endif 
                       !
                       !$omp parallel do private(ib) schedule(dynamic)
                       do ib = 1,dimen
                         !
                         cf%vect(ib,kdeg) = cf%vect(ib,kdeg)/sqrt(f_value)
                         !
                       enddo
                       !$omp end parallel do
                       !
                     endif
                     !
                   endif 
                   !
                 enddo 
                 !
               enddo 
             enddo
             !
             if (ilevel==1) then
               !
               zpe = contr(iclasses)%eigen(1)%value
               !
             endif
             !
             ! This part was to transform the H-reduced matrix to the representation 
             ! of Lz^2 and then to use its diagonal matrix elements as the energy-estimates.
             ! Now a different approach is used with the Lz^2 matrix fully diagonal as obtained at the 
             ! Hmat-reduced stage by diagonalizing Lz^2 for the degenerate states only. 
             !
             if (.false..and.bs_t(kmode)%type=='HARMONIC'.and.bs_t(kmode)%model<=2.and.FLl2_coeffs) then
                 !
                 if (ilevel==1) then
                   !
                   zpe = 1e9
                   !
                   do i=1,dimen 
                      zpe = min(PT%Hclass%coeffs(i,i),zpe)
                   enddo
                   !
                 endif
                 !
                 ! transformation to the symmetrized basis: 
                 !
                 !call dgemm('T','N',level_degen,dimen,dimen,alpha,& 
                 !            cf%vect,dimen,&
                 !            PT%Hclass,dimen,beta,&
                 !            mat,dimen)
                 !   
                 !call dgemm('N','N',level_degen,level_degen,dimen,alpha,&
                 !           mat,dimen,&
                 !           cf%vect,dimen,beta,&
                 !           mat_,dimen)
                 !
                 mat_(1:level_degen,:) = matmul(transpose(cf%vect),PT%Hclass%coeffs)
                 mat (1:level_degen,1:level_degen) = matmul(mat_(1:level_degen,:),cf%vect)
                 !
                 !PT%lquant%icoeffs(ilevel,1) = contr(iclasses)%iroot(ilevel,1)
                 !
                 contr(iclasses)%eigen(ilevel)%value   = mat(1,1)
                 contr(iclasses)%eigen(ilevel)%lquant  = PT%lquant%icoeffs(contr(iclasses)%iroot(ilevel,1),1)
                 !
                 ! redefine the assignement based on the largest coeff o fhe new basis 
                 !
                 largest_coeff = maxval(cf%vect(:,1)**2,dim=1)-small_
                 ilargest_coeff = maxloc(cf%vect(:,1)**2,dim=1,mask=cf%vect(:,1)**2.ge.largest_coeff)
                 contr(iclasses)%eigen(ilevel)%nu(:)     = PT%active_space%icoeffs(:,ilargest_coeff)
                 contr(iclasses)%eigen(ilevel)%normal(:) = contr(iclasses)%eigen(ilevel)%nu(:)
                 contr(iclasses)%eigen(ilevel)%largest_coeff   = largest_coeff
                 contr(iclasses)%eigen(ilevel)%ilarge_coeff = ilargest_coeff
                 !
             endif
             !
             if (job%verbose>=2) then 
               !
               write(my_fmt,'(a,i0,a)') "(i7,f18.8,2i4,2x,a4,",nmodes,"i4,1x,i4)"
               write(out,my_fmt) ilevel,cf%value-zpe,cf%degeneracy,cf%isym,cf%gamma,cf%nu(1:),contr(iclasses)%eigen(ilevel)%lquant 
               !
             end if 
             !
             if (job%verbose>=6) call TimerStop('Contract: Orthonaliz')
             !
           enddo 
           ! 
         enddo 
         !
         jroot = count_index(icount,Nelem)
         !
         icount = icount + 1
         iattempts = 0
         !
       enddo icount_loop
       !      
       !
       Ncount = ilevel
       !
       if (bs_t(kmode)%type=='HARMONIC'.and.bs_t(kmode)%model<=2.and.FLl2_coeffs) then
         !
         ! Sort according the energy increasing 
         !
         call sort_contr_eigen(Ncount,dimen)
         !
       endif 
       !
       dimen = size(PT%Htotal%coeffs,dim=1)
       !
       ! Remove from the list roots that out of the polyad or energy ranges
       !
       count_index(:,1) = contr(iclasses)%ilevel(:)
       !
       do iroot = 1,nroots
         !
         if (verbose>=6) &
             write(out,"('ilevel,ideg = ',3i8)") iroot,contr(iclasses)%ilevel(iroot),contr(iclasses)%ideg(iroot)
         !
         if (contr(iclasses)%ilevel(iroot)==0) then 
           !
           ilevel = iroot
           !
           do while(ilevel<nroots.and.contr(iclasses)%ilevel(ilevel)==0)
             !
             ilevel = ilevel  + 1
             !
           enddo 
           !
           pshift = ilevel - iroot
           !
           count_index(iroot:nroots,1) = eoshift(count_index(iroot:nroots,1),shift=pshift)
           !
           contr(iclasses)%ilevel(iroot:nroots) = eoshift(contr(iclasses)%ilevel(iroot:nroots),shift=pshift)
           contr(iclasses)%ideg  (iroot:nroots) = eoshift(contr(iclasses)%ideg  (iroot:nroots),shift=pshift)
           !
         endif 
         !
       enddo 
       !
       ! count the roots
       !
       iroot = 0
       !
       do jroot = 1,nroots
         !
         if (contr(iclasses)%ilevel(jroot)==0) exit
         !
         iroot = iroot + 1
         !
       enddo 
       !
       if (job%verbose>=6) write(out,"(/'Number of roots  after symmetrization: ',i8)") iroot
       !
       contr(iclasses)%dimen  = dimen
       contr(iclasses)%nlevels = Ncount
       contr(iclasses)%nroots  = iroot
       !
       ! Now we can do a second contracted diagonalization in case the first 
       ! has been done using only the reduced Harmonic Hamiltonian
       !
       !if ((bs_t(kmode)%type=='HARMONIC'.and.bs_t(kmode)%model<=2).and.job%Npolyads_contr<PT%Npolyads) then
       !
       if ( bs_t(kmode)%postprocess.and.job%Npolyads_contr<PT%Npolyads ) then
         !
         call PThamiltonianMat_contracted_reduced(jrot,iclasses,nroots)
         !
       endif
       !
       nroots = contr(iclasses)%nroots
       !
       ! This object will be used later for reducing the set of checkpointed contr. wavefunctions
       !
       allocate (contr(iclasses)%ilevel_chk(nroots),stat=alloc)
       call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%ilevel_chk),& 
                        kind(contr(iclasses)%ilevel_chk))
       !
       do iroot = 1,nroots
         !
         contr(iclasses)%ilevel_chk(iroot) = iroot
         !
       enddo 
       !
       iroot = 0 
       !
       do ib = 1,contr(iclasses)%nlevels
         !
         iroot = iroot + contr(iclasses)%eigen(ib)%degeneracy
         contr(iclasses)%ilevel_chk(ib) = ib
         !
       enddo 
       !
       if (iroot/=contr(iclasses)%nroots) then
         write (out,"('/PTcontracted_prediagonalization:')")
         write (out,"('Number of roots do not agree with total number of degenerate levels: ',2i8,' iclass = ',i8)") & 
                       contr(iclasses)%nroots,iroot,iclasses
         stop 'PTcontracted_prediagonalization - not consistent nroots and levels/degeneracy'
       end if
       !
       if (job%verbose>=6) write(out,"(/'Number of levels after symmetrization: ',i8)") contr(iclasses)%nlevels
       !
       ! Now when we know number of unique levels we can orginize a storage place for the eigensolution 
       !
       allocate (contr(iclasses)%prim_bs%icoeffs(0:PT%Nmodes,dimen),stat=alloc)
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate icoeffs-field')") alloc
          stop 'PTcontracted_prediagonalization, icoeffs -  out of memory'
       end if
       !
       if (job%verbose>=6) write(out,"(/'sizes of prim_bs and active_space ',2i8)") size(contr(iclasses)%prim_bs%icoeffs,dim=2),&
                                                                                    size(contr(iclasses)%prim_bs%icoeffs,dim=2)
       !
       ! store the primitive quantum numbers for the later use
       !
       do k = 1,dimen
         ! 
         contr(iclasses)%prim_bs%icoeffs(:,k)=PT%active_space%icoeffs(:,k)
         !
       enddo
        !
       if (job%verbose>=4) then 
           write(out,"(/'max degeneracy =  ',i7,' for class =  ',i5)") contr(iclasses)%max_degen,iclasses
       endif 
       !
       call PTactive_space_deinit
       !
       if (job%verbose>=6) write(out,"(/'Number of roots  after deinit: ',i8)") contr(1)%nroots 
       !
       if (allocated(fv)) deallocate(fv)
       if (allocated(sample_vector)) deallocate(sample_vector)
       if (allocated(transform)) deallocate(transform)
       if (allocated(tmat)) deallocate(tmat)
       if (allocated(count_index)) deallocate(count_index)
       if (allocated(count_degen)) deallocate(count_degen)
       if (allocated(chi_t)) deallocate(chi_t)
       if (allocated(transform_t)) deallocate(transform_t)
       if (allocated(transform_maxval)) deallocate(transform_maxval) 
       if (allocated(numpoints)) deallocate(numpoints)
       if (allocated(mat)) deallocate(mat)
       if (allocated(mat_)) deallocate(mat_) 
       !
       call ArrayStop('PTcontracted:count_index')
       call ArrayStop('PTcontracted:count_degen')
       call ArrayStop('PTcontracted:transform')
       call ArrayStop('PTcontracted:sample_vector')
       call ArrayStop('PTcontracted:tmat')
       call ArrayStop('PTcontracted:fv')
       call ArrayStop('PTcontracted:chi_t')
       call ArrayStop('PTcontracted:transform_t')
       call ArrayStop('PTcontracted:transform_maxval')
       call ArrayStop('PTcontracted:numpoints')
       call ArrayStop('PTcontracted:mat')
       !
       ispecies = 0
       !
       do i = 1,PT%mode_iclass(iclasses)
         !
         imode = PT%mode_class(iclasses,i)
         !
         if (trim(bs_t(imode)%type)=='NUMEROV'.or.&
             trim(bs_t(imode)%type)=='BOX'.or.&
             trim(bs_t(imode)%type)=='MORSE'.or.&
             trim(bs_t(imode)%type)=='FOURIER'.or.&
             trim(bs_t(imode)%type)=='SINRHO'.or.&
             trim(bs_t(imode)%type)=='LEGENDRE') then
           !
           if (PT%Mspecies(imode)/=ispecies) then 
             ispecies = PT%Mspecies(imode)
             deallocate( bs_funct(ispecies)%coeffs)
           endif 
           !
         endif
       enddo
       !
       if (trim(bs_t(imode)%type)=='NUMEROV'.or.&
           trim(bs_t(imode)%type)=='BOX'.or.&
           trim(bs_t(imode)%type)=='MORSE'.or.&
           trim(bs_t(imode)%type)=='FOURIER'.or.&
           trim(bs_t(imode)%type)=='SINRHO'.or.&
           trim(bs_t(imode)%type)=='LEGENDRE') then
           !
           call ArrayStop('bs_funct(ispecies)%coeffs')
           !
       endif
       !
       ! define the vib. angular momentum and redefine the quanta of the contr. functions 
       ! from (v1,v2,v3,...) -> (V,la,lb,...), 
       ! where V = v1+v2+v3+..., la,lb are the vib. angular momenta
       !
       !call compute_vib_angular_momentum(iclasses) 
       !
    enddo
    !
    ! ZPE for the contracted eigenvalues
    !
    PT%zpe_contr = 0 
    !
    do iclasses = 1,PT%Nclasses
       cf => contr(iclasses)%eigen(1)
       !
       PT%zpe_contr = PT%zpe_contr + cf%value
       ! 
    enddo

    !
    ! Saving the contracted basis set vectors and all auxilery informaion.
    !
    if (trim(job%IOcontr_action)=='SAVE') then
      !
      call PTcheck_point_contracted_space('SAVE')
      !
    endif
    !
    !
    ! The rotational part of the contracted basis set to finish its constraction:
    !
    !call PT_conctracted_rotational_bset(j,bs)
    !
    ! contracted basis set is initialized and ready for use 
    !
    if (job%verbose>=4) call MemoryReport
    if (job%verbose>=6) call TimerReport
    !
    if (job%verbose>=2) call TimerStop('Contraction & symmetrization')
    !
    contains 


    subroutine sort_contr_eigen(Nlevels,dimen)
      !
      integer(ik),intent(in) :: Nlevels,dimen
      real(rk) :: energy
      integer(ik) :: ilevel,jlevel,alloc,iroot,ideg
      type(PTlevelT) :: eigen_t   ! temporal object used for sorting 'eigen'

         !
         allocate (eigen_t%vect(dimen,sym%maxdegen),&
                   eigen_t%nu(0:PT%Nmodes),&
                   eigen_t%normal(0:PT%Nmodes),stat=alloc)
         !
         call ArrayStart('eigen_t%vect',alloc,size(eigen_t%vect),kind(eigen_t%vect))
         call ArrayStart('eigen_t%vect',alloc,size(eigen_t%nu),kind(eigen_t%nu))
         call ArrayStart('eigen_t%vect',alloc,size(eigen_t%normal),kind(eigen_t%normal))
         !
         do ilevel =1,Nlevels
           !
           energy = contr(iclasses)%eigen(ilevel)%value
           !
           do jlevel =ilevel+1,Nlevels
             !
             if (energy>contr(iclasses)%eigen(jlevel)%value) then 
               !
               energy        = contr(iclasses)%eigen(jlevel)%value
               !
               eigen_t%value = contr(iclasses)%eigen(jlevel)%value
               contr(iclasses)%eigen(jlevel)%value = contr(iclasses)%eigen(ilevel)%value
               contr(iclasses)%eigen(ilevel)%value = eigen_t%value
               !
               eigen_t%isym = contr(iclasses)%eigen(jlevel)%isym
               contr(iclasses)%eigen(jlevel)%isym = contr(iclasses)%eigen(ilevel)%isym
               contr(iclasses)%eigen(ilevel)%isym = eigen_t%isym
               !
               eigen_t%gamma = contr(iclasses)%eigen(jlevel)%gamma
               contr(iclasses)%eigen(jlevel)%gamma = contr(iclasses)%eigen(ilevel)%gamma
               contr(iclasses)%eigen(ilevel)%gamma = eigen_t%gamma
               !
               eigen_t%degeneracy = contr(iclasses)%eigen(jlevel)%degeneracy
               contr(iclasses)%eigen(jlevel)%degeneracy = contr(iclasses)%eigen(ilevel)%degeneracy
               contr(iclasses)%eigen(ilevel)%degeneracy = eigen_t%degeneracy
               !
               eigen_t%vect = contr(iclasses)%eigen(jlevel)%vect
               contr(iclasses)%eigen(jlevel)%vect = contr(iclasses)%eigen(ilevel)%vect
               contr(iclasses)%eigen(ilevel)%vect = eigen_t%vect
               !
               eigen_t%ilarge_coeff = contr(iclasses)%eigen(jlevel)%ilarge_coeff
               contr(iclasses)%eigen(jlevel)%ilarge_coeff = contr(iclasses)%eigen(ilevel)%ilarge_coeff
               contr(iclasses)%eigen(ilevel)%ilarge_coeff = eigen_t%ilarge_coeff
               !
               eigen_t%largest_coeff = contr(iclasses)%eigen(jlevel)%largest_coeff
               contr(iclasses)%eigen(jlevel)%largest_coeff = contr(iclasses)%eigen(ilevel)%largest_coeff
               contr(iclasses)%eigen(ilevel)%largest_coeff = eigen_t%largest_coeff
               !
               eigen_t%normal = contr(iclasses)%eigen(jlevel)%normal
               contr(iclasses)%eigen(jlevel)%normal = contr(iclasses)%eigen(ilevel)%normal
               contr(iclasses)%eigen(ilevel)%normal = eigen_t%normal
               !
               eigen_t%nu = contr(iclasses)%eigen(jlevel)%nu
               contr(iclasses)%eigen(jlevel)%nu = contr(iclasses)%eigen(ilevel)%nu
               contr(iclasses)%eigen(ilevel)%nu = eigen_t%nu
               !
               eigen_t%lquant = contr(iclasses)%eigen(jlevel)%lquant
               contr(iclasses)%eigen(jlevel)%lquant = contr(iclasses)%eigen(ilevel)%lquant
               contr(iclasses)%eigen(ilevel)%lquant = eigen_t%lquant
               !
             endif 
             !
           enddo
           !
         enddo
         !
         iroot = 0 
         !
         do ilevel =1,Nlevels
           do ideg = 1,contr(iclasses)%eigen(ilevel)%degeneracy 
             !
             iroot = iroot +1 
             contr(iclasses)%ilevel(iroot) = ilevel
             contr(iclasses)%ideg(iroot)   = ideg
             contr(iclasses)%iroot(ilevel,ideg) = iroot
             !
           enddo
         enddo   
         !
         deallocate (eigen_t%vect,eigen_t%nu,eigen_t%normal)
         !
         call ArrayStop('eigen_t%vect')
         !   
 end subroutine sort_contr_eigen


 recursive subroutine PTpolintark(n,xa, ya, x, y, dy)
     !
     integer(ik),intent(in) :: n
     real(ark),intent(in)   :: xa(n), ya(n)
     real(ark), intent(in)  :: x
     real(ark), intent(out) :: y, dy
     !
     ! given arrays xa and ya of length n, and given a value x, this routine
     ! returns a value y, and an error estimate dy. if p(x) is the polynomial
     ! of degree n - 1 such that p(x a_i) = y a_i, i = 1, ..., n, then the
     ! returned value y = p(x).
     !
     integer(ik) :: m, ns
     real(ark), dimension(size(xa)) :: c, d, den, ho
     !
     if (verbose>=6) write(out,"('PTpolintark')")
     !
     !if (size(ya)/=n) then 
     !    stop  'polint: wrong sizes'
     !endif 
     !
     c = ya                          ! initialize the tableau of c's and d's
     d = ya
     ho = xa - x
     ns = minloc(abs(x - xa),dim=1)  ! find index ns of closest table entry
     y = ya(ns)                      ! initial approximation to y.
     ns = ns - 1
     do m = 1, n - 1                        ! for each column of the tableau
        den(1:n-m) = ho(1:n-m) - ho(1+m:n)  ! we loop over c's and d's and
        !if (any(den(1:n-m) == 0.0)) &       ! update them
        !     call nrerror('polint: calculation failure')
        !
        if (any(den(1:n-m) == 0.0)) then                   ! interpolating function
             write(out,"('failure in polint, has a pole here')")
             stop 'failure in polint'
             !call nrerror('failure in polint')         ! has a pole here
        endif 
        ! this error can occur only if two input xa's are (to within roundoff)
        ! identical.
        !
        den(1:n - m) = (c(2:n-m+1) - d(1:n-m))/den(1:n-m)
        d(1:n-m) = ho(1+m:n) * den(1:n-m)   ! here c's and d's get updated
        c(1:n-m) = ho(1:n-m) * den(1:n-m)
        if (2 * ns < n-m) then       ! after each column in the tableau is
           dy=c(ns+1)                ! completed decide, which correction
        else                         ! c or d we add to y. we take the
           dy=d(ns)                  ! straightest line through the tableau
           ns=ns-1                   ! to its apex. the partial approximations
        end if                       ! are thus centred on x. the last dy
        y = y+dy                     ! is the measure of error.
     end do
     !
     if (verbose>=6) write(out,"('PTpolintark')")
     !
  end subroutine PTpolintark


    subroutine compute_vib_angular_momentum(iclasses)

       integer(ik),intent(in) :: iclasses
       integer(ik) :: im1,im2,iprim,jprim,nu_i(PT%Nmodes),nu_j(PT%Nmodes),imode,alloc
       type(PTcoeffT) :: vib(-1:1)
       double precision,parameter :: alpha = 1.0d0,beta=0.0d0
       real(rk)                   :: lvib,mat_q(PT%Nmodes),mat_p(PT%Nmodes),smat(sym%maxdegen,sym%maxdegen),evib(sym%maxdegen)
       character(len=cl)  :: job_is
       integer(ik)        :: dimen_p,nroots,iroot,bsize,k2,imoment,ideg,jdeg,jroot,ndeg
       integer(ik)        :: poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,MaxExpOrder,extF_rank,nmodes,L2vib_N
       real(rk),allocatable :: tmat(:,:),mat_tt(:,:)
       real(rk),allocatable :: mat_t(:,:)
       real(rk),allocatable :: me_t(:,:)
       integer(ik),allocatable :: extF_N(:)
       character(len=cl)       :: my_fmt !format for I/O specification
       !
       nmodes = PT%Nmodes
       !
       extF_rank = FLread_extF_rank()
       !
       allocate(extF_N(max(extF_rank,1)))
       !
       im1 = PT%mode_class(iclasses,1)
       im2 = PT%mode_class(iclasses,PT%mode_iclass(iclasses))
       !
       ispecies = PT%Mspecies(im1)
       !
       job_is = 'vib'
       !
       bsize = job%bset(im1)%range(2)
       call FLread_fields_dimensions(poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,extF_N,L2vib_N)
       !
       MaxExpOrder= max(potorder,kinorder,extForder)
       !
       do k2 = -1,1
         !
         allocate (vib(k2)%coeff(0:MaxExpOrder,0:bsize,0:bsize),stat=alloc)
         !
         call FLread_coeff_matelem(job_is,ispecies,k2,vib(k2)%coeff(:,:,:))
         !
       enddo
       !
       dimen   = contr(iclasses)%nlevels
       nroots  = contr(iclasses)%nroots
       dimen_p = contr(iclasses)%dimen
       !
       ! Prepare the transformation matrix T^+ H T 
       !
       allocate(tmat(dimen_p,nroots),stat=alloc)
       call ArrayStart('tmat',alloc,size(tmat),kind(f_t))
       allocate(mat_tt(nroots,nroots),stat=alloc)
       call ArrayStart('mat_tt',alloc,size(mat_tt),kind(f_t))
       allocate(me_t(dimen_p,dimen_p),stat=alloc)
       call ArrayStart('me_t',alloc,dimen_p**2,kind(me_t))
       allocate(mat_t(nroots,dimen_p),stat=alloc)
       call ArrayStart('mat_t',alloc,nroots*dimen_p,kind(mat_t))
       !
       ! Construct the unitary transformation matrix
       !
       do iroot=1,nroots
         ! 
         ilevel = contr(iclasses)%ilevel(iroot)
         ideg = contr(iclasses)%ideg(iroot)
         !
         tmat(:,iroot) = contr(iclasses)%eigen(ilevel)%vect(:,ideg)
         !
       enddo 
       !
       do imoment = 1,im2-im1
         !
         do iprim=1,contr(iclasses)%dimen
           !
           nu_i(im1:im2) = contr(iclasses)%prim_bs%icoeffs(im1:im2,iprim)
           !
           do jprim=1,contr(iclasses)%dimen
             !
             nu_j(im1:im2) = contr(iclasses)%prim_bs%icoeffs(im1:im2,jprim)
             !
             ! Primitive matrix elements of the vib. momentum operator
             !
             do imode = im1+imoment-1,im1+imoment
                ! 
                mat_q(imode) = me%vibmode(imode,-1)%coeff(1,nu_i(imode),nu_j(imode))
                mat_p(imode) = me%vibmode(imode, 1)%coeff(0,nu_i(imode),nu_j(imode))
                ! 
             enddo  
             ! 
             me_t(iprim,jprim) = mat_q(im1+imoment-1)*mat_p(im1+imoment)-mat_q(im1+imoment)*mat_p(im1+imoment-1)
             !
           enddo
           ! 
         enddo 
         ! 
         call dgemm('T','N',nroots,dimen_p,dimen_p,alpha,tmat(1:dimen_p,1:nroots),dimen_p,& 
                  me_t(1:dimen_p,1:dimen_p),dimen_p,beta,mat_t(1:nroots,1:dimen_p),nroots)
         call dgemm('N','N',nroots,nroots,dimen_p,alpha,mat_t(1:nroots,1:dimen_p),nroots,& 
                  tmat(1:dimen_p,1:nroots),dimen_p,beta,mat_tt(1:nroots,1:nroots),nroots)
         !
         do ilevel = 1,dimen
           !
           lvib = 0
           !
           ndeg = contr(iclasses)%eigen(ilevel)%degeneracy
           !
           do ideg = 1,ndeg
              !
              iroot = contr(iclasses)%iroot(ilevel,ideg)
              !
              do jdeg = 1,ndeg
                !
                jroot = contr(iclasses)%iroot(ilevel,jdeg)
                !
                smat(ideg,jdeg) = mat_tt(iroot,jroot)
                !
              enddo
              !
           enddo
           !
           call lapack_syev(smat(1:ndeg,1:ndeg),evib(1:ndeg))
           !
           lvib = evib(1)
           !
           cf => contr(iclasses)%eigen(ilevel)
           !
           nu_i(im1:im2) = cf%nu(im1:im2)
           !
           if (imoment==1) cf%nu(im1) = sum(nu_i(im1:im2))
           !
           cf%nu(im1+imoment) = nint(lvib)
           !
         enddo
         !
       enddo
       !
       do ilevel = 1,dimen
         !
         cf => contr(iclasses)%eigen(ilevel)
         !
         write(my_fmt,'(a,i0,a)') "(i7,f18.8,2i4,2x,a4,",nmodes,"i4)"
         !
         write(out,my_fmt) ilevel,cf%value-contr(iclasses)%eigen(1)%value,&
                                                      cf%degeneracy,cf%isym,cf%gamma,cf%nu(1:)
         !
       enddo
       !
       deallocate(tmat,mat_t,mat_tt,me_t,extF_N)
       !
       do k2 = -1,1
         !
         deallocate(vib(k2)%coeff)
         !
       enddo
       !
     end subroutine compute_vib_angular_momentum
 

    subroutine calc_overlap(iclasses)

     integer(ik),intent(in)  :: iclasses
     integer(ik)  :: ispecies,i,imode,ioper,vi,vj,jpoint,ipoint,ipshift,npoints_t,nmodes,imode1,imode2,jmode,bs_size
     real(rk)     :: xval_i,xval_j
     real(ark)    :: r_t(-Nr_t:Nr_t),fval,df_t,chi_i,chi_j(PT%Nmodes),chi_(PT%Nmodes),rho_range
     real(ark),allocatable  :: chi_t(:,:,:)
     real(ark),allocatable :: funct_t(:),phipsi(:)
     character(len=cl)     :: my_fmt !format for I/O specification
       !
       nmodes = PT%Nmodes
       !
       imode1 = PT%mode_class(iclasses,1)
       imode2 = PT%mode_class(iclasses,PT%mode_iclass(iclasses))
       npoints = job%bset(imode1)%npoints
       !
       allocate (phipsi(0:npoints),funct_t(0:npoints),chi_t(sym%Noper,0:npoints,nmodes),stat=alloc)
       if (alloc/=0) then
         write (out,"(' Error ',i9,' trying to allocate points-fields')") alloc
         stop 'PTcontracted_prediagonalization, funct_t -  out of memory'
       end if
       !
       do i = 1,PT%mode_iclass(iclasses)
          !
          imode = PT%mode_class(iclasses,i)
          npoints_t = job%bset(imode)%npoints
          !
          if (npoints_t/=npoints) then
            !
            write(out,"('calc_overlap: not the same number of points in class = ',i7)") iclasses
            stop 'calc_overlap: wrong npoints'
            !
          endif
          !
       enddo
       !
       chi_j = 0
       chi_t(:,:,:) = 0 
       !
       do jpoint=0,npoints
         !
         do i = 1,PT%mode_iclass(iclasses)
           !
           jmode = PT%mode_class(iclasses,i)
           chi_j(jmode) = job%bset(jmode)%borders(1) + rhostep(jmode)*real(jpoint,ark)
           !
         enddo
         jmode  =1  ! ?????????
         !
         do ioper = 1,sym%Noper
            !
            call MLsymmetry_transform_func(ioper,Nmodes,chi_j,chi_)
            chi_t(ioper,jpoint,:) = chi_
            !
            if (any( chi_t(ioper,jpoint,imode1:imode2)<job%bset(jmode)%borders(1) ).or.&
                any(chi_t(ioper,jpoint,imode1:imode2)>job%bset(jmode)%borders(2))) then 
              write(my_fmt,'(a,i0,a)') "(a,4i5,",nmodes,"f12.6)"
              write(out,"('PTcontracted_prediagonalization: calc_overlap, point is out of the range:')")
              write(out,my_fmt) 'iclass,imode,ioper,jpoint,xval_j,xval_i: ',iclasses,imode,ioper,jpoint,&
                                 chi_t(ioper,jpoint,:)
              stop 'PTcontracted_prediagonalization: calc_overlap, point is out of the range'
            endif
            !
         enddo
         !
       enddo
       !
       do i = 1,PT%mode_iclass(iclasses)
         !
         !jmode = PT%mode_class(iclasses,1)
         !chi_j(jmode) = job%bset(imode)%borders(1) + rhostep(jmode)*real(jpoint,rk)
         !
         ! size of the primitive basis set 
         !
         bs_size = job%bset(jmode)%range(2)
         !
         rho_range = job%bset(jmode)%borders(2)-job%bset(jmode)%borders(1)
         !
         ispecies = 0 
         !
         if (PT%Mspecies(jmode)/=ispecies) then 
           !
           ispecies = PT%Mspecies(jmode)
           !
           do ioper = 1,sym%Noper
             !
             do vj = 0,bs_size
                !
                do jpoint=0,npoints
                  !
                  chi_i = chi_t(ioper,jpoint,jmode)
                  !
                  ipoint = mod(nint( ( chi_i-job%bset(jmode)%borders(1) )/rhostep(jmode ),kind=ik)+npoints,npoints)
                  !
                  ipshift = 0
                  if (ipoint-Nr_t<0) then 
                    ipshift = min(jpoint-Nr_t,0)
                  elseif(ipoint+Nr_t>npoints) then 
                    ipshift = mod(ipoint+Nr_t,npoints)
                  endif 
                  !
                  do k = -Nr_t,Nr_t
                    !
                    r_t(k)=job%bset(jmode)%borders(1) + rhostep(jmode)*real((ipoint+k-ipshift),ark)
                    !
                  enddo
                  !
                  call polintark(r_t(-Nr_t:Nr_t),bs_funct(ispecies)%coeffs(vj,ipoint-Nr_t-ipshift:ipoint+Nr_t-ipshift),chi_i,&
                       fval,df_t)
                  !
                  funct_t(jpoint) = fval
                  !
                enddo
                !
                do vi = 0,bs_size
                   !
                   phipsi(:) = bs_funct(ispecies)%coeffs(vi,:)*funct_t(:)
                   !
                   overlap(ispecies,ioper)%coeffs(vi,vj) = simpsonintegral_ark(npoints,rho_range,phipsi)
                   !
                enddo
                !
             enddo
             !
           enddo
           !
         endif
         !
       enddo
       !
       deallocate(phipsi,funct_t,chi_t)
       !
    end subroutine calc_overlap



    subroutine symm_matrix(Ndeg)
      !
      integer(ik),intent(in) :: Ndeg
      real(rk)               :: transformmat(sym%Noper,Ndeg,Ndeg)
      integer(ik)  :: ioper,ideg,jdeg,k_i,k_j,i,kroot_i,kroot_j,nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes),Nentries
      real(rk)     :: f_value
         !
         Nentries = PT%mode_iclass(iclasses)
         !
         if (job%verbose>=6) call TimerStart('Contract: The points')
         !
         do ioper = 1,sym%Noper
           do ideg=1,Nelem
             do jdeg=1,Nelem
               !
               !jpoint = numpoints(ipoint_t) 
               !
               f_value = 0
               !
               !omp parallel do private(k,nu,f_prim,i,imode,ispecies,v,r_t,xval,fval,df_t) reduction(+:f_value) schedule(dynamic)
               do k_i = 1,dimen
                 !
                 nu_i(:) = PT%active_space%icoeffs(:,k_i)
                 !
                 do k_j = 1,dimen
                   !
                   nu_j(:) = PT%active_space%icoeffs(:,k_i)
                   !
                   ! primitive basis contribution
                   !
                   f_prim = 1.0_ark
                   !
                   do i = 1,Nentries
                    !
                    imode = PT%mode_class(iclasses,i)
                    ispecies = PT%Mspecies(imode)
                    !
                    f_prim = f_prim*overlap(ispecies,ioper)%coeffs(nu_i(imode),nu_j(imode))
                    !
                    !f_prim = f_prim*( bs_funct(ispecies)%coeffs(nu(imode),ipoint(imode,ioper,jpoint) )+&
                    !                 dbs_funct(ispecies)%coeffs(nu(imode),ipoint(imode,ioper,jpoint))*&
                    !                 ( chi_t(imode,ioper,jpoint)-chi_i(imode,ioper,jpoint) ) )
                    !
                   enddo
                   !
                   kroot_i = count_index(icount,ideg)
                   kroot_j = count_index(icount,jdeg)
                   !
                   f_value = f_value + f_prim*PT%Htotal%coeffs(k_i,kroot_i)*PT%Htotal%coeffs(k_j,kroot_j)
                   !
                   continue
                   !
                 enddo 
                 !
               enddo 
               !omp end parallel do 
               !
               transformmat(ioper,ideg,jdeg) = f_value
               !
             enddo 
           enddo 
         enddo
         !
         continue
         !
         !
    end subroutine symm_matrix


    function Harmonic_oscillator(xval,nu)  result (fval)

      real(ark),intent(in)   :: xval
      integer(ik),intent(in) :: nu
      real(ark)              :: fval,c_t,xi,p1,p2,p3,v,vm1,pi4
      integer(ik)            :: n
         !
         !c_t = 1.0_rk
         !
         !if (bs_t(imode)%range(2)>0) c_t = me%vib(ispecies,0)%coeff(1,1,0)
         !
         c_t = trove%coord_f(imode)
         !
         xi  = xval/c_t
         !
         !p1 = 0.751125444649425_ark*exp(-xi**2*0.5_ark)/sqrt(c_t)  ! 1/pi^(1/4)
         !
         pi4 = 1.0_ark/sqrt(sqrt(pi))
         !
         !p1 = .75112554446494248285870300477622_ark/sqrt(c_t)*exp(-xi**2*0.5_ark)
         !
         p1 = pi4/sqrt(c_t)*exp(-xi**2*0.5_ark)
         !
         p2 = 0
         !
         do n = 1,nu
           !
           v = real(n,ark)
           vm1 = real(n-1,ark)
           !
           p3 = p2
           p2 = p1
           p1 = xi*sqrt(2.0_ark/v)*p2-sqrt(vm1/v)*p3
           !
         enddo
         !
         fval = p1
         !
    end function Harmonic_oscillator

    !
  end subroutine PTcontracted_prediagonalization



  subroutine PTselect_sample_points(iclasses,mpoints,Nr_t,rhostep,chi_t)
     !
     integer(ik),intent(in)  :: iclasses,mpoints,Nr_t
     real(ark),intent(in)    :: rhostep(PT%Nmodes)
     real(ark),intent(out)   :: chi_t(:,:,:)
     integer(ik)             :: jpoint,i,ipoint_t,imode,ioper,pshift
     real(ark)               :: chi(PT%Nmodes),f_t,chi_(PT%Nmodes),b1(PT%Nmodes),b2(PT%Nmodes)
     logical                 :: go
     !
     ! choose the geometry that we use to check the symmetry
     !
     if (job%sym_C) return
     !
     if (job%verbose>=5) call TimerStart('PTselect_sample_points')
     !
     call random_seed()
     !
     do imode = 1,PT%Nmodes
       !
       b1(imode) = job%bset(imode)%borders(1)+rhostep(imode)*real(2*Nr_t)
       b2(imode) = job%bset(imode)%borders(2)-rhostep(imode)*real(2*Nr_t)
       !
     enddo
     !
     if (verbose>=4) write(out,"('PTselect_sample_points...')")   
     !
     !$omp parallel do private(jpoint,chi,pshift,go,i,imode,f_t,ipoint_t,ioper,chi_) shared(chi_t) schedule(dynamic)
     do jpoint = 1,mpoints
       !
       chi_t(:,:,jpoint) = huge(1.0_ark)
       chi = 0 
       !
       pshift = 0 
       !
       go = .true.
       !
       do while(go)  ! cycle_go
         !
         do i = 1,PT%mode_iclass(iclasses)
           !
           imode = PT%mode_class(iclasses,i)
           !
           call random_number(f_t)
           !
           ipoint_t = mod(nint(job%bset(imode)%npoints*f_t)+Nr_t,job%bset(imode)%npoints) !  mod(i_eq(imode)+pshift,bs(imode)%npoints)
           !
           !ipoint_t = mod(jpoint*(bs(imode)%npoints/mpoints)+i*(bs(imode)%npoints/50+i)+pshift,bs(imode)%npoints) !  mod(i_eq(imode)+pshift,bs(imode)%npoints)
           !
           if (ipoint_t<Nr_t.or.ipoint_t>job%bset(imode)%npoints-Nr_t) ipoint_t = mod(ipoint_t+10,job%bset(imode)%npoints)
           !
           !ipoint_t = 2*jpoint + Nr_t
           !
           chi(imode) = job%bset(imode)%borders(1) + rhostep(imode)*real(ipoint_t,ark)
           !
         enddo
         !
         go = .false.
         !
         !do iclass = 1,sym%Nclasses
         !
         ioper = 0
         !
         do while (.not.go.and.ioper <sym%Noper)
           !
           !do ioper = 1,sym%Noper
           !
           ioper = ioper+1
           !
           call MLsymmetry_transform_func(ioper,PT%Nmodes,chi,chi_)
           chi_t(:,ioper,jpoint) = chi_(:)
           !
           i = 0 
           do while(.not.go.and.i<PT%mode_iclass(iclasses))
             !
             i = i + 1
             !
             imode = PT%mode_class(iclasses,i)
             !
             if (chi_(imode)<b1(imode).or.&
                 chi_(imode)>b2(imode) ) then 
                 go = .true.
                 !
                 pshift = pshift + imode
                 !cycle cycle_go
             endif
             !
           enddo
           !
         enddo
         !
       enddo
       !enddo cycle_go
       !
     enddo 
     !$omp end parallel do
     !
     if (job%verbose>=5) call TimerStop('PTselect_sample_points')
     !
     if (verbose>=4) write(out,"(' ... PTselect_sample_points - done!')")   

  end subroutine PTselect_sample_points
  !
  !
  ! This routine generates the rotational basis set in the contracted representation. 
  ! Each basis function gets a symmetry label here. 
  !
  subroutine PT_conctracted_rotational_bset(j)

    integer(ik),intent(in) :: j     ! current rotational quantum    
    !type(FLbasissetT),intent(in)  :: bs(0:PT%Nmodes) ! Basis set specifications: range and type

    integer(ik)         :: dimen,nroots,ideg,ndeg,nu(0:PT%Nmodes),alloc,iroot,icount,k0,i
    integer(ik)         :: irepr,tau0,Ncount
    real(rk)            :: zpe
    integer(ik),allocatable   :: count_index(:,:)
    real(rk),allocatable      :: eigenvects(:,:)
    type(PTlevelT),pointer    :: cf

    real(ark)           :: MaxEigenvects

    integer(ik)      :: isym,Ntotal(sym%Nrepresen),ilarge_coeff
    !type(MOrepres_arkT),pointer   :: irr(:)

    !integer(ik)        :: ibstype,Nclasses,imode,i,iclasses,dimen,alloc,npoints,io_slot,pshift
    !integer(ik)        :: v,bs_size,ilevel,k,ipol,ib,i_eq(PT%Nmodes),Nirr(sym%Nrepresen)
    !integer(ik)        :: ipoint_t,iclass,charact(sym%Noper),irepr,iroot,Npar,gamma,info,jlevel
    !character(len=cl)  :: unitfname ,char_,diag_
    !real(ark)          :: f_value,f_prim,f_t
    !integer(ik)        :: nroots,jrot,icount,ideg,kdeg,ndeg,Ncount,tau0,k0,ioper
    !integer(ik)        :: jpoint,jdeg,im1,im2,level_degen,Nelem,ielem,jroot
    !type(PTlevelT),pointer    ::  cf
    !integer(ik),parameter    ::  mpoints = 100
    !logical                  ::  reduced_model

    !
    ! The contracted basis set field has to be allocated before this stage:
    !
    if (.not.allocated(contr)) then 
      !
      write(out,"('PT_conctracted_rotational_bset: field contr(0) is not existing, why?')")
      stop 'PT_conctracted_rotational_bset: where is contr(0)?' 
      !
    endif
    !
    ! In order to finish the initialization of the contracted basis set
    ! we need to add the rotational part
    !
    !contr(0)%dimen = bs(imode)%range(2)
    dimen = 2*j+1 ! bs(0)%range(2)+1
    nroots = dimen
    nu = 0 
    zpe = huge(1.0_rk) ! FLenergy_zero(nu)
    !
    ideg = 1
    Ndeg = min(sym%Maxdegen,2)
    !
    allocate (contr(0)%ilevel(nroots),contr(0)%ideg(nroots),stat=alloc)
    !
    ! choose between the default k-based scenario or the euler-based genertation of the rotational contr. basis
    !
    if (.not.job%rotsym_do) then 
      !
      allocate (count_index(nroots,Ndeg),stat=alloc)
      !
      count_index = 0
      count_index(1,1) = 1
      contr(0)%ilevel(1) = 1
      contr(0)%ideg(1) = 1

      iroot  = 1
      icount = 1
      contr(0)%max_degen = 1
      do k0 = 1,j
        !
        do tau0 = 0,1 
          !
          iroot = iroot + 1
          icount = icount + 1
          !
          call MLrotsymmetry_func(j,k0,tau0,irepr,ideg)
          Ndeg = sym%degen(irepr)
          contr(0)%max_degen = max(contr(0)%max_degen,Ndeg)
          !
          if ( Ndeg==2 ) then 
            !
            count_index(icount,ideg) = iroot
            !
            contr(0)%ilevel(iroot  ) = icount
            contr(0)%ideg(iroot  ) = ideg
            !
            if ( tau0==0 ) icount = icount - 1
            !
          elseif (Ndeg==1) then
            !
            contr(0)%ilevel(iroot  ) = icount
            contr(0)%ideg(iroot  ) = 1
            !
            count_index(icount,1) = iroot
            !
          else 
            !
            write(out,"('PTcontracted_prediag: rotational degen>2: ',i7)") Ndeg
            stop 'PTcontracted_prediag: rotational degen>2'
            !
          endif 
          !
        enddo 
        !
      enddo
      !
      Ncount = icount
      !
      allocate (PT%rot_index(Ncount,contr(0)%max_degen),stat=alloc)
      if (associated(PT%rot_primindex)) deallocate(PT%rot_primindex)
      allocate (PT%rot_primindex(0:dimen-1),stat=alloc)
      !
      icount = 1 
      iroot = 0
      PT%rot_index(1,1)%j = j
      PT%rot_index(1,1)%k = 0
      PT%rot_index(1,1)%tau = mod(j,2)
      !
      PT%rot_primindex(0)%j = j
      PT%rot_primindex(0)%k = 0
      PT%rot_primindex(0)%tau = mod(j,2)
      !
      do k0 = 1,j
        !
        do tau0 = 0,1
          !
          icount = icount + 1
          iroot = iroot + 1
          !
          call MLrotsymmetry_func(j,k0,tau0,irepr,ideg)
          Ndeg = sym%degen(irepr)
          PT%rot_index(icount,ideg)%j = j
          PT%rot_index(icount,ideg)%k = k0
          PT%rot_index(icount,ideg)%tau = tau0
          !
          PT%rot_primindex(iroot)%j = j
          PT%rot_primindex(iroot)%k = k0
          PT%rot_primindex(iroot)%tau = tau0
          !
          if ( Ndeg==2.and.tau0==0 ) icount = icount - 1
          !
        enddo 
        !
      enddo
      !
      contr(0)%dimen  = dimen
      contr(0)%nlevels = Ncount
      contr(0)%nroots  = dimen
      !dimen = Ncount
      !
      allocate (contr(0)%eigen(Ncount),contr(0)%prim_bs%icoeffs(0:PT%Nmodes,dimen),stat=alloc)
      if (alloc/=0) then
         write (out,"(' Error ',i9,' trying to allocate rot-contr-eigen-field')") alloc
         stop 'PTcontracted_prediagonalization, rot-contr-eigen -  out of memory'
      end if
      !
      if (job%verbose>=2) then 
        !
        write(out,"(//'Symmetry of the contracted solution, class:',i4)") 0
        write(out,"('      i       ener         deg  symmetry  j   k  tau  quanta:')")
        !
      end if
      !
      do icount = 1,Ncount
        !
        k0   = PT%rot_index(icount,1)%k
        tau0 = PT%rot_index(icount,1)%tau
        !
        call MLrotsymmetry_func(j,k0,tau0,irepr,ideg)
        Ndeg = sym%degen(irepr)
        !
        allocate (contr(0)%eigen(icount)%vect(dimen,Ndeg),&
                  contr(0)%eigen(icount)%nu(0:PT%Nmodes),&
                  contr(0)%eigen(icount)%normal(0:PT%Nmodes),stat=alloc)
        call ArrayStart('contr%eigen%vect',alloc,size(contr(0)%eigen(icount)%vect),kind(contr(0)%eigen(0)%vect))
        !
        cf => contr(0)%eigen(icount)
        !
        cf%vect(:,:) = 0
        cf%nu(:) = 0
        cf%nu(0) = count_index(icount,1)-1 !  k0+(j*(j+1) )/2
        cf%normal(:) = 0
        cf%normal(0) = k0
        cf%degeneracy = Ndeg
        nu = 0 ;  nu(0) = k0+(j*(j+1) )/2
        cf%value = FLenergy_zero(nu)
        zpe = 0 ! min(zpe,cf%value)
        !
        !contr(0)%max_degen = max(contr(0)%max_degen,cf%degeneracy)
        !
        do ideg = 1,Ndeg
          !
          !k0   = PT%rot_index(icount,ideg)%k
          !tau0 = PT%rot_index(icount,ideg)%tau
          !
          iroot = count_index(icount,ideg)
          !
          contr(0)%prim_bs%icoeffs(:,iroot)   = 0
          contr(0)%prim_bs%icoeffs(0,iroot)   = iroot-1 ! cf%nu(0)
          !
          ! rigid rotor energy value 
          !
          !tau0 = mod(iroot,2) ; if (iroot==0) tau0 = mod(J,2)
          !k0   = ( iroot+tau0 )/2
          !nu = 0 ;  nu(0) = 1+k0+(j*(j+1) )/2
          !
          !call MLrotsymmetry_func(j,k0,tau0,irepr,jdeg)
          !
          cf%vect(iroot,ideg) = 1.0_rk
          !
        enddo 
        !
        cf%isym = irepr
        cf%gamma = trim(sym%label(cf%isym))
        !
        !
        if (job%verbose>=2) then 
          !
          write(out,"(i7,f18.8,2i4,2x,a4,3i4,30i4)") icount,cf%value,&
                                                     cf%degeneracy,cf%isym,cf%gamma,j,k0,tau0,&
                                                    (cf%nu(i),i=1,min(30,PT%Nmodes))
          !
        end if 
        !
      enddo
      !
      deallocate (count_index)
      !
    else
      !
      nroots = 2*j+1
      !
      dimen = nroots
      !
      allocate(count_index(nroots,nroots),eigenvects(nroots,nroots),stat=alloc)
      ! 
      call MLrotsymmetry_generate(j,job%verbose,count_index,eigenvects,Ncount,Ntotal)
      !
      contr(0)%ilevel(1) = 1
      contr(0)%ideg(1)   = 1
      contr(0)%max_degen = 1
      !
      allocate (PT%rot_index(Ncount,sym%maxdegen),stat=alloc)
      if (associated(PT%rot_primindex)) deallocate(PT%rot_primindex)
      allocate (PT%rot_primindex(0:dimen-1),stat=alloc)
      !
      !
      ! finding the rotational assignement for the contracted basis functions
      !
      icount = 0
      !
      do isym = 1,sym%Nrepresen
        !
        Ndeg = sym%degen(isym)
        !
        do i = 1,Ntotal(isym)
          !
          icount = icount + 1
          !
          do ideg = 1,Ndeg
            !
            iroot = count_index(icount,ideg)
            !
            MaxEigenvects = maxval(eigenvects(:,iroot)**2,dim=1)-small_
            !
            ilarge_coeff = maxloc(eigenvects(:,iroot)**2,dim=1,mask=eigenvects(:,iroot)**2.ge.MaxEigenvects)
            !
            k0 = (ilarge_coeff)/2
            tau0 = mod(ilarge_coeff,2)
            if (k0==0) tau0 = mod(j,2)
            !
            PT%rot_index(icount,ideg)%j = j
            PT%rot_index(icount,ideg)%k = k0
            PT%rot_index(icount,ideg)%tau = tau0
            !
            !PT%rot_index(icount,ideg)%j = j
            !PT%rot_index(icount,ideg)%k = icount
            !PT%rot_index(icount,ideg)%tau = ideg
            !
          enddo
          !
        enddo
        !
      enddo
      !
      ! assignmenet for the primitive rotational functions
      !
      icount = 1 
      iroot = 0
      !
      PT%rot_primindex(0)%j = j
      PT%rot_primindex(0)%k = 0
      PT%rot_primindex(0)%tau = mod(j,2)
      !
      do k0 = 1,j
        !
        do tau0 = 0,1
          !
          iroot = iroot + 1
          !
          PT%rot_primindex(iroot)%j = j
          PT%rot_primindex(iroot)%k = k0
          PT%rot_primindex(iroot)%tau = tau0
          !
        enddo 
        !
      enddo
      !
      contr(0)%dimen   = dimen
      contr(0)%nlevels = Ncount
      contr(0)%nroots  = dimen
      !
      allocate (contr(0)%eigen(Ncount),contr(0)%prim_bs%icoeffs(0:PT%Nmodes,dimen),stat=alloc)
      call ArrayStart('contr%prim_bs',alloc,size(contr(0)%prim_bs%icoeffs),kind(contr(0)%prim_bs%icoeffs))
      !
      if (job%verbose>=2) then 
        !
        write(out,"(//'Symmetry of the contracted solution, class:',i4)") 0
        write(out,"('      i       ener         deg  symmetry  j   k')")
        !
      end if
      !
      icount = 0
      !
      do isym = 1,sym%Nrepresen
        !
        Ndeg = sym%degen(isym)
        contr(0)%max_degen = max(contr(0)%max_degen,Ndeg)
        !
        do i = 1,Ntotal(isym)
          !
          icount = icount + 1
          !
          Ndeg = sym%degen(isym)
          !
          allocate (contr(0)%eigen(icount)%vect(dimen,Ndeg),&
                    contr(0)%eigen(icount)%nu(0:PT%Nmodes),&
                    contr(0)%eigen(icount)%normal(0:PT%Nmodes),stat=alloc)
          call ArrayStart('contr%eigen%vect',alloc,size(contr(0)%eigen(icount)%vect),kind(contr(0)%eigen(0)%vect))
          !
          cf => contr(0)%eigen(icount)
          !
          k0   = PT%rot_index(icount,1)%k
          tau0 = PT%rot_index(icount,1)%tau
          !
          cf%vect(:,:) = 0
          cf%nu(:) = 0
          !
          !f%nu(0) = count_index(icount,1)-1
          !
          cf%degeneracy = Ndeg
          !
          nu = 0 ;  nu(0) = k0+(j*(j+1) )/2
          cf%nu(0) = k0
          !
          cf%normal(:) = 0
          cf%normal(0) = k0
          !
          cf%value = FLenergy_zero(nu)
          zpe = 0 
          !
          cf%isym = isym
          cf%gamma = trim(sym%label(cf%isym))
          !
          do ideg = 1,sym%degen(isym)
            !
            iroot = count_index(icount,ideg)
            !
            contr(0)%prim_bs%icoeffs(:,iroot)   = 0
            contr(0)%prim_bs%icoeffs(0,iroot)   = iroot-1
            !
            cf%vect(:,ideg) = eigenvects(:,iroot)
            !
            contr(0)%ilevel(iroot) = icount
            contr(0)%ideg(iroot)   = sym%degen(isym)
            !
          enddo 
          !
          if (job%verbose>=2) then 
            !
            write(out,"(i7,f18.8,2i4,2x,a4,i4,i4)") icount,cf%value,cf%degeneracy,cf%isym,cf%gamma,j,cf%nu(0)
            !
          end if 
          !
        enddo
        !
      enddo
      !
      deallocate(eigenvects)
      deallocate (count_index)
      !
    endif 
    !
    PT%zpe_contr = PT%zpe_contr + zpe
    !
    contr_bset_initialized = .true.
    !
  end subroutine PT_conctracted_rotational_bset
  !
  !
  subroutine reconstruct_transf_matrix(Ndeg,mpoints,phi_src,tmat,tol,info)

    integer(ik),intent(in)  ::Ndeg,mpoints
    integer(ik),intent(out) ::info

    real(ark),intent(in)    :: phi_src(sym%Noper,Ndeg,mpoints)
    real(ark),intent(inout) :: tmat(sym%Noper,Ndeg,Ndeg)
    real(rk),intent(in)     :: tol
    real(ark)               :: t_vect(Ndeg)

    integer(ik) :: alloc_p,ideg,ig,jg,ioper,ieq,ipoint,keq,jdeg,ndeg2,info_t,rank,iw,m,n,nthreads,tid,nsize,alloc
    double precision,allocatable  :: a(:,:),b(:,:),s(:),work(:)
    real(ark),allocatable  :: am(:,:),bm(:),xm(:)
    integer(ik) :: OMP_GET_THREAD_NUM,OMP_GET_NUM_THREADS
    character(len=cl) :: my_fmt !format for I/O specification
    !
    if (job%verbose>=6) call TimerStart('reconstruct_transf_matrix')
    !
    if (verbose>=4) write(out,"('reconstruct_transf_matrix...')") 
    !
    tmat = 0
    info = 0 
    !
    m = Ndeg*mpoints ; n = Ndeg**2 ;  iw = 20*max(m,n)
    !
    if (Ndeg>mpoints) then 
      write(out,"('reconstruct_transf_matrix: sample_points < ndeg: ',2i0)") mpoints,ndeg
      stop 'sample_points is too small?'
    endif
    !
    nthreads = 1
    !
    ! collect number of threads
    !
    !     Start parallel region
    !omp parallel private(nthreads,tid)
    !!
    !!  Obtain thread number
    !tid = OMP_GET_THREAD_NUM()
    !!
    !!     Only master thread does this
    !if (tid==0) then
    !    !
    !    nthreads = OMP_GET_NUM_THREADS()
    !    if (job%verbose>=6) PRINT *, 'Number of threads = ', NTHREADS
    !    !
    !endif 
    !omp end parallel
    !
    !alloc = 0
    !
    !nsize = Ndeg*mpoints*Ndeg**2*nthreads
    !call ArrayStart('reconstruct_transf:a',alloc,nsize,rk)
    !nsize = Ndeg*mpoints*nthreads
    !call ArrayStart('reconstruct_transf:b',alloc,nsize,rk)
    !nsize = iw*nthreads
    !call ArrayStart('reconstruct_transf:w',alloc,nsize,rk)
    !
    !omp parallel private(a,b,s,work,alloc_p) shared(tmat)
    !
    allocate(a(Ndeg*mpoints,Ndeg**2),stat=alloc_p)
    call ArrayStart('reconstruct_transf:a',alloc_p,1_ik,rk,size(a,kind=hik))
    allocate(b(Ndeg*mpoints,1),stat=alloc_p)
    call ArrayStart('reconstruct_transf:b',alloc_p,1_ik,rk,size(b,kind=hik))
    allocate(s(min(m,n)),stat=alloc_p)
    call ArrayStart('reconstruct_transf:s',alloc_p,1_ik,rk,size(s,kind=hik))
    allocate(work(iw),stat=alloc_p)
    call ArrayStart('reconstruct_transf:w',alloc_p,1_ik,rk,size(work,kind=hik))

    allocate(am(m,n),stat=alloc_p)
    call ArrayStart('reconstruct_transf',alloc_p,1_ik,rk,size(am,kind=hik))
    allocate(bm(m),stat=alloc_p)
    call ArrayStart('reconstruct_transf',alloc_p,1_ik,rk,size(bm,kind=hik))
    allocate(xm(n),stat=alloc_p)
    call ArrayStart('reconstruct_transf',alloc_p,1_ik,rk,size(xm,kind=hik))

    !
    !if (alloc_p/=0) then
    !    write (out,"(' reconstruct_transf_matrix: ',i9,' trying to allocate array for a and b')") alloc_p
    !    stop 'reconstruct_transf_matrix, a and b  - out of memory'
    !end if
    !
    !omp do private(ioper,ieq,ipoint,ideg,keq,ig,jg,ndeg2,info_t,t_vect,rank) reduction(max:info) schedule(static) 
    do ioper=1,sym%Noper
      !
      info_t = 0
      !
      am = 0
      bm = 0
      !
      !$omp parallel do private(ipoint,ideg,ieq,ig,jg,keq) shared(bm,am)
      do ipoint = 1,mpoints
        do ideg = 1,Ndeg
          !
          ieq = ideg + (ipoint-1)*Ndeg
          !
          bm(ieq) = phi_src(ioper,ideg,ipoint)
          !
          do ig = 1,Ndeg
            do jg = 1,Ndeg
              !
              keq = jg + Ndeg*(ig-1)
              !
              if (ig==ideg) then 
                am(ieq,keq) = phi_src(1,jg,ipoint)
              endif    
            enddo
          enddo
        enddo 
        !
      enddo
      !$omp end parallel do
      !
      if (verbose>=6) then
        !
        write(out,"('ioper,b(ielem):')")
        !
        ndeg2 = Ndeg**2
        !
        write(my_fmt,'(a,i0,a)') "(i8,8x,",ndeg2,"f18.10)"
        !
        write(out,my_fmt) ioper,bm(1:Ndeg**2)
        !
        write(out,"('ioper,ipoint,ideg,a(ieq,:):')")
        !
        ieq = 0 
        !
        do ipoint = 1,mpoints
          do ideg = 1,Ndeg
            !
            ieq = ieq + 1
            !
            write(out,"(3i8,40f18.10)") ioper,ipoint,ideg,am(ieq,1:min(40,Ndeg**2))
            !
          enddo
        enddo
        !
      endif
      !
      if (verbose>=5) write(out,"('reconst_tr_m: dgelss')")
      !
      b(1:m,1) = bm(1:m)
      a = am
      !
      call dgelss(m,n,1,a(1:m,1:n),m,b(1:m,1:1),m,s,-1.0d-12, rank, work, iw, info_t)
      !
      if (verbose>=5) write(out,"('reconst_tr_m: dgelss...done!')")
      !
      if (info_t<0) then 
        write(out,"('reconstruct_transf_matrix: (',i9,') probably not sufficient sample_points: ',i8)") info_t,mpoints
        stop 'sample_points is too small?'
      endif 
      !
      if (rank/=n) then 
        !
        info = max(info,2)
        !
      endif
      !
      !omp parallel do private(ideg,jdeg,ieq) shared(tmat)
      !do ideg = 1,Ndeg
      !  do jdeg = 1,Ndeg
      !    !
      !    ieq = jdeg + Ndeg*(ideg-1)
      !    !
      !    tmat(ioper,ideg,jdeg) = real(b(ieq,1),ark)
      !    !
      !  enddo 
      !enddo
      !omp end parallel do
      !
      ! for higher accuracy try to refine the solution using ark
      !
      xm(1:n) = b(1:n,1)    
      !
      if (tol<1.0e-11) then 
        !
        call ML_rjacobi_fit_ark(m,n,am,bm,xm,tol)
        !
      endif
      !
      !bm(1:n) = xm(1:n)
      !
      !$omp parallel do private(ideg,jdeg,ieq) shared(tmat)
      do ideg = 1,Ndeg
        do jdeg = 1,Ndeg
          !
          ieq = jdeg + Ndeg*(ideg-1)
          !
          tmat(ioper,ideg,jdeg) = xm(ieq)
          !
        enddo 
      enddo
      !$omp end parallel do
      !
      ! check
      !
      !$omp parallel do private(ipoint,t_vect,ideg) reduction(max:info) schedule(static) 
      do ipoint = 1,mpoints
         !
         t_vect(:) = matmul(tmat(ioper,:,:),phi_src(1,:,ipoint))
         !
         do ideg=1,ndeg
           !
           if (abs(t_vect(ideg)-phi_src(ioper,ideg,ipoint))>tol) then 
             if (job%verbose>=6) then 
               write(out,"('reconstruct_transf_mat: Cannot define presentation, ioper,ipoint,k =  ',3i8)") ioper,ipoint,ideg
               print *, t_vect(ideg),phi_src(ioper,ideg,ipoint)
             endif 
             info = max(info,2)
             !return 
           endif 
           !
         enddo
         !
      enddo
      !$omp end parallel do
      !
    enddo 
    !omp enddo
    !
    deallocate(a,b,work,s)    
    !omp end parallel
    !
    if (job%verbose>=6) call MemoryReport
    !
    call ArrayStop('reconstruct_transf:a')
    call ArrayStop('reconstruct_transf:b')
    call ArrayStop('reconstruct_transf:s')
    call ArrayStop('reconstruct_transf:w')
    !
    deallocate(am,bm,xm)    
    call ArrayStop('reconstruct_transf')
    !
    if (info==2) then 
      !
      if (job%verbose>=6) then 
        write(out,"('reconst_tr_m: the effect. rank is too small, the points have to be reselected: ')") 
      endif
      !
    endif 
    !
    if (verbose>=4) write(out,"('...reconstruct_transf_matrix ')") 
    if (job%verbose>=6) call TimerStop('reconstruct_transf_matrix')
    !
   end subroutine reconstruct_transf_matrix




  !
  subroutine degenerate_symmetrization(Nelem,mpoints,phi_src,transform,tol,Nirr,Nirr_rk,chi,info)

    integer(ik),intent(in)  ::Nelem,mpoints
    integer(ik),intent(out) ::info

    real(ark),intent(inout)  :: phi_src(sym%Noper,Nelem,1:mpoints)
    real(ark),intent(out)    :: transform(Nelem,sym%maxdegen,Nelem),chi(sym%Nclasses)
    integer(ik),intent(out)  :: Nirr(sym%Nrepresen)
    real(ark),intent(out)    :: Nirr_rk(sym%Nrepresen)
    real(rk),intent(in)      :: tol

    real(ark)                :: t_vect(Nelem,Nelem),tmat_t(sym%Noper,Nelem,Nelem)
    real(ark)                :: tmat(sym%Noper,Nelem,Nelem),fnormal,f_t,g_t
    real(ark)                :: vect(Nelem,Nelem)
    integer(ik) :: ideg,jdeg,ioper,kdeg,iclass,isym
    integer(ik) :: try_elem,felem,gamma,Ndeg,Nirr_elem,ielem,jelem,ielem_t
    !
    real(ark)                :: Numireps_inf,Numireps_
    integer(ik)              :: ielem_,ielem_inf
    character(len=cl)        :: my_fmt !format for I/O specification
    !
    if (verbose>=4) write(out,"('degenerate_symmetrization...')") 
    !
    if (job%sym_C) then
      !
      Nirr(1) = Nelem
      !
      transform = 0
      do ielem = 1,Nelem
         transform(ielem,1,ielem) = 1.0_ark
      enddo
      !
      return
      !
    endif 
    !
    if (job%verbose>=5) call TimerStart('Degenerate symmetrization')
    !
    transform = 0 
    info = 0 
    Nirr_rk = 0
    !
    if (job%verbose>=7) then  
      !
      write(my_fmt,'(a,i0,a)') "(2i8,",mpoints,"f18.10)"
      !
      write(out,"('phi_src(ioper,ielem,ipoint):')")
        do ioper = 1,sym%Noper
          do ideg = 1,Nelem
            !
             write(out,my_fmt) ioper,ideg,phi_src(ioper,ideg,1:mpoints)
            !
          enddo
        enddo
       !
    endif 
    !
    call reconstruct_transf_matrix(Nelem,mpoints,phi_src,tmat_t,tol,info)
    !
    if (info/=0) then 
      if (job%verbose>=5) call TimerStop('Degenerate symmetrization')
      return
    endif 
    !
    if (job%verbose>=7) then  
      !
      write(my_fmt,'(a,i0,a)') "(2i8,",Nelem,"g18.10)"
      !
      write(out,"('phi_src(ioper,ielem,jelem)-after:')")
        do ioper = 1,sym%Noper
          do ideg = 1,Nelem
            !
            write(out,my_fmt) ioper,ideg,tmat_t(ioper,ideg,1:Nelem)
            !
          enddo
        enddo
       !
    endif
    !
    tmat = tmat_t
    !
    ! calculate the characters 
    !
    chi = 0
    ioper = 1
    !
    do iclass =1,sym%Nclasses
      !
      do ideg = 1,Nelem
        !
        chi(iclass) = chi(iclass) + tmat(ioper,ideg,ideg)
        !
      enddo 
      !
      if (job%verbose>=6) then 
        write(out,"('iclass = ',i5,'; character: ',f20.8)") iclass,chi(iclass)
      endif 
      !
      ioper = ioper+sym%Nelements(iclass)
      !
    enddo 
    !
    ! estimate the number of the irreducible representasions 
    !
    gamma = 0
    !
    do isym =1,sym%Nrepresen
       !
       Nirr_rk(isym) = sum(real(sym%Nelements(:)*sym%characters(isym,:),ark)*chi(:))/real(sym%Noper,ark)
       !
       Nirr(isym) = nint(Nirr_rk(isym))
       !
       if (abs(Nirr_rk(isym)-real(Nirr(isym)))>0.01) then
         Nirr_rk(isym) = 0
         Nirr(isym)    = 0 
       endif
       !
       ! special case of the infinite group DinfH(M) where the infinite classes are processed separatelly 
       !
       if (job%sym_group(1:7)=='DINFTYH') then
         !
         Numireps_inf = 0
         Numireps_    = 0
         ielem_inf = 0 
         ielem_    = 0
         !
         do iclass =1,sym%Nclasses
           !
           if (sym%Nelements(iclass)>sym%class_size_max) then
              !
              ielem_inf = ielem_inf + sym%Nelements(iclass)
              Numireps_inf = Numireps_inf + real(sym%Nelements(iclass),ark)*sym%characters(isym,iclass)*chi(iclass)
              !
           else
              !
              ielem_ = ielem_ + sym%Nelements(iclass)
              Numireps_ = Numireps_ + real(sym%Nelements(iclass),ark)*sym%characters(isym,iclass)*chi(iclass)
              ! 
           endif  
         enddo
         !
         ! in the case the large classes have non zero contribution -> ignore the rest
         if (Numireps_inf>sqrt(small_)) then 
           !
           Nirr_rk(isym) = Numireps_inf/real(ielem_inf,ark)
           !
         else
           !
           Nirr_rk(isym) = Numireps_/real(ielem_,ark)
           Nirr_rk(isym) = 0
           !
         endif
         !
         Nirr(isym) = nint(Nirr_rk(isym)) 
         !
         if (abs(Nirr_rk(isym)-real(Nirr(isym)))>0.01) then
           Nirr_rk(isym) = 0
           Nirr(isym)    = 0 
         endif
         !
       endif 
       !
       if (Nirr(isym)<0.or.Nirr(isym)>Nelem.or.abs(Nirr_rk(isym)-real(Nirr(isym)))>0.01) then 
         !
         write(my_fmt,'(a,i0,a)') "(a,",sym%Nclasses,"f18.6)"
         write(out,"('degenerate_symmetrization: Found characters and Nirr are illegal: ')") 
         write(out,my_fmt) '              characters : ',chi
         write(my_fmt,'(a,i0,a)') "(a,",sym%Nrepresen,"i9)"
         write(out,my_fmt) '                    Nirr : ',Nirr(1:isym)
         info = 1
         !
         if (job%verbose>=5) call TimerStop('Degenerate symmetrization')
         !
         !return
         !
       endif
       !
       if (verbose>=6.and.Nirr(isym)>0) then 
         !
         ! transformatio vector to irr. repres. 
         !
         do ideg = 1,sym%degen(isym)
           do ioper = 1,sym%Noper
           !
             write(out,"('ideg,ioper,tmat ',2i8,20f18.10)") ideg,ioper,&
                                      tmat(ioper,ideg,1:min(Nelem,20))
           !
           enddo
         enddo
         !
       endif 
    enddo
    !
    if (all(Nirr==0)) then 
      info = 1
      if (job%verbose>=5) call TimerStop('Degenerate symmetrization')
      if (job%verbose>=6) then 
        write(out,"('no irreps found')")
      endif 
      return
    endif
    !
    if (verbose>=5) then 
      write(out,"('Nirr = ',40i8)") Nirr(:)
    endif 
    !
    if (job%verbose>=6) call TimerStart('degenerate_symm: construct irreps')
    !
    Nirr_elem = 0 
    !
    gamma_loop : do gamma = 1,sym%Nrepresen
      !
      if (Nirr(gamma)==0) cycle gamma_loop
      !
      try_elem = 0 
      felem = 0 
      t_vect = 0 
      !
      ! Degeneracy of the term
      !
      Ndeg = sym%degen(gamma)
      !
      elem_loop2: do while (try_elem<Nelem.and.felem<Nirr(gamma))
        !
        try_elem = try_elem + 1
        !
        ielem_t=0 
        !
        elem_loop: do while (ielem_t<Ndeg.and.felem<Nirr(gamma))
          !
          info = 0 
          !
          ! transformation of vector to irr. repres. 
          !
          vect = 0 
          !
          ielem_t = ielem_t + 1
          !
          do ioper = 1,sym%Noper

            vect(1:Nelem,1:Nelem) =  vect(1:Nelem,1:Nelem) + &
                                         sym%irr(gamma,ioper)%repres(ielem_t,ielem_t)*&
                                         real(sym%degen(gamma),ark)/real(sym%Noper,ark)*&
                                         tmat(ioper,1:Nelem,1:Nelem)
            !
            if (verbose>=6) then 
              write(out,"('try_elem,ioper,tmat,repres,degen ',2i8,40f18.10)") try_elem,ioper,&
                                       tmat(ioper,ielem_t,1:min(Nelem,40)),&
                                       sym%irr(gamma,ioper)%repres(ielem_t,1),&
                                       real(sym%degen(gamma),rk)/real(sym%Noper,rk)
            endif 
            !
          enddo
          !
          t_vect(1,:) = vect(try_elem,:)
          !
          !
          if (verbose>=6) then 
            do kdeg = 1,Nelem
               write(out,"('1,kdeg,t_vect: ',i8,f18.10)") kdeg,t_vect(1,kdeg)
            enddo
          endif 
          !
          ! Now we normalize these vectors 
          !
          fnormal = dot_product(t_vect(1,:),t_vect(1,:))

          if (fnormal>small_) then 
            !
            t_vect(1,:) = t_vect(1,:)/sqrt(fnormal)
            !
            else
             !
             if (verbose>=6) write(out,"('try_elem,Nelem,felem,Nirr: ',4i8)") try_elem,Nelem,felem,Nirr(gamma)
             !
             cycle elem_loop
             !
          endif
          !
          ! Schmidt orthogonalization
          !
          do ielem = 1,Nirr_elem
            do  ideg= 1,sym%maxdegen
              !
              f_t = sum(transform(ielem,ideg,1:Nelem)*t_vect(1,1:Nelem))
              !
              t_vect(1,1:Nelem) = t_vect(1,1:Nelem)- transform(ielem,ideg,1:Nelem)*f_t

              if (abs(f_t)>0.9) then 
                 if (verbose>=5) &
                   write(out,"('non-orthgon: i,gamma,ielem,ideg: ',4i6,f20.8)") Nirr_elem+1,gamma,ielem,ideg,f_t
                 info = 1
                 cycle elem_loop 
              endif
              !
              fnormal = dot_product(t_vect(1,1:Nelem),t_vect(1,1:Nelem))
              t_vect(1,1:Nelem) = t_vect(1,1:Nelem)/sqrt(fnormal)
              f_t = sum(transform(ielem,ideg,1:Nelem)*t_vect(1,1:Nelem))
              !
              if (abs(f_t)>sqrt(small_)) then 
                 if (verbose>=5) &
                   write(out,"('non-orthgon: i,gamma,ielem,ideg: ',4i6,f20.8)") Nirr_elem+1,gamma,ielem,ideg,f_t
                 info = 1
                 cycle elem_loop 
              endif
              !
            enddo
            !
          enddo
          !
          ! Now we normalize these vectors again 
          !
          fnormal = dot_product(t_vect(1,:),t_vect(1,:))
          !
          if (fnormal>small_) then 
            !
            t_vect(1,:) = t_vect(1,:)/sqrt(fnormal)
            !
            else
             !
             cycle elem_loop
             !
          endif
          !
          ! Re-constructing other degenerate components from the first one
          !
          if (Ndeg>1) then 
            !
            !do  ideg= 1,Nelem
            !  !
            !  do  jdeg= 1,Ndeg-1
            !    !
            !    ioper = jdeg+1
            !    !
            !    if (ioper>sym%Noper) then
            !       write(out,"('degenerate_symmetrization: ioper>Noper: ',2i7)") ioper,sym%Noper
            !       stop 'degenerate_symmetrization: ioper>Noper'
            !    endif
            !    !
            !    do  kdeg= 1,Ndeg-1
            !      !
            !      a(jdeg,kdeg) = sym%irr(gamma,ioper)%repres(1,kdeg+1) 
            !      !
            !    enddo
            !    !
            !    b(jdeg) = sum(t_vect(1,1:Nelem)*tmat(ioper,1:Nelem,ideg)) &
            !              -  sym%irr(gamma,ioper)%repres(1,1)*t_vect(1,ideg) 
            !    ! 
            !  enddo
            !  !
            !  call MLlinurark(Ndeg-1,a(1:Ndeg-1,1:Ndeg-1),b(1:Ndeg-1),t_vect(2:Ndeg,ideg),ierror)
            !  !
            !  if (ierror/=0) then
            !    !
            !    if (verbose>=6) write(out,"('switch from MLlinurark to lapack_gelss, Ndeg = ',i8 )") Ndeg
            !    !
            !    !allocate(da(Ndeg-1,Ndeg-1),db(Ndeg-1,1),stat=alloc)
            !    !if (alloc/=0) then
            !    !    write (out,"(' degenerate_symmetrization: ',i9,' trying to allocate array for da and db')") alloc
            !    !    stop 'degenerate_symmetrization, da and db  - out of memory'
            !    !end if
            !      !
            !      !write (out,"('degenerate_symmet: Error ',i9,' in MLlinurark ')") ierror
            !      !stop 'degenerate_symmet: error in MLlinurark'
            !    !end if
            !    !
            !    da(1:Ndeg-1,1:Ndeg-1) = a(1:Ndeg-1,1:Ndeg-1)
            !    db(1:Ndeg-1,1) = b(1:Ndeg-1)
            !    !
            !    call lapack_gelss(da(1:Ndeg-1,1:Ndeg-1),db(1:Ndeg-1,1:1))
            !    !
            !    t_vect(2:Ndeg,ideg) = real(db(1:Ndeg-1,1),ark)
            !    !
            !  endif
            !  ! 
            !enddo
            !
            do jdeg= 2,Ndeg
              !
              t_vect(jdeg,1:Nelem) = 0
              !
              do ioper = 1,sym%Noper
                !
                do jelem = 1,Nelem
                  !
                  t_vect(jdeg,1:Nelem) =  t_vect(jdeg,1:Nelem) + &
                                          sym%irr(gamma,ioper)%repres(1,jdeg)*&  !!!!!  check !!!!!  ielem_t <- 1
                                          real(sym%degen(gamma),ark)/real(sym%Noper,ark)*& 
                                          tmat(ioper,jelem,1:Nelem)*t_vect(1,jelem)
                  !
                enddo
                !
              enddo
              !
            enddo
            !
          endif 
          !
          ! Now we normalize these vectors 
          !
          do jdeg= 2,Ndeg
            !
            fnormal = dot_product(t_vect(jdeg,:),t_vect(jdeg,:))
            !
            if (fnormal>small_) then 
              !
              t_vect(jdeg,:) = t_vect(jdeg,:)/sqrt(fnormal)
              !
            endif
            !
          enddo
          !
          ! Check orthogonality and apply the Schmidt orthogonalization
          !
          do  jdeg= 1,Ndeg
            do ielem = 1,Nirr_elem
              do  ideg= 1,sym%maxdegen
                !
                f_t = sum(transform(ielem,ideg,1:Nelem)*t_vect(jdeg,1:Nelem))
                !
                if (abs(f_t)>0.9) then 
                   if (verbose>=5) &
                     write(out,"('non-orthgon: i,gamma,jdeg,ielem,kdeg: ',5i6,f20.8)") Nirr_elem+1,gamma,jdeg,ielem,ideg,f_t
                   info = 1
                   cycle elem_loop 
                endif
                !
                t_vect(jdeg,1:Nelem) = t_vect(jdeg,1:Nelem)- transform(ielem,ideg,1:Nelem)*f_t
                fnormal = dot_product(t_vect(jdeg,1:Nelem),t_vect(jdeg,1:Nelem))
                t_vect(jdeg,1:Nelem) = t_vect(jdeg,1:Nelem)/sqrt(fnormal)
                f_t = sum(transform(ielem,ideg,1:Nelem)*t_vect(jdeg,1:Nelem))
                !
                if (abs(f_t)>sqrt(small_)) then 
                   if (verbose>=5) &
                   write(out,"('non-orthgon: i,gamma,jdeg,ielem,ideg: ',5i6,f20.8)") Nirr_elem+1,gamma,jdeg,ielem,ideg,f_t
                    info = 1
                    cycle elem_loop 
                endif
                
              enddo
            enddo
          enddo
          !
          ! check if the found vector does transorm correctly with the group
          !
          do jdeg = 1,Ndeg
            do kdeg = 1,Nelem
              !
              if (verbose>=6) then 
                !
                write(out,"('jdeg,kdeg,t_vect: ',2i8,f18.10)") jdeg,kdeg,t_vect(jdeg,kdeg)
                !
              endif 
              !         
              do ioper = 1,sym%Noper
                !
                f_t = sum( t_vect(jdeg,1:Nelem)*tmat(ioper,1:Nelem,kdeg))
                !
                g_t = sum( sym%irr(gamma,ioper)%repres(jdeg,1:Ndeg)*t_vect(1:Ndeg,kdeg) )
                !
                ! Continue if these two quantaties are the same 
                !
                if (abs(f_t-g_t)>0.01) then 
                   info = 1
                   if (verbose>=5) then 
                     write(out,"('jdeg,kdeg,ioper,f,g',3i6,2f20.8)") jdeg,kdeg,ioper,f_t,g_t
                   else
                     cycle elem_loop 
                   endif 
                endif
                !
              enddo
              !
            enddo
            !
          enddo
          !
          if (info==1) cycle elem_loop 
          !
          ! if we are through all obstacles, we are finally there
          !
          felem = felem + 1
          !
          if (info==0) then  
            !
            Nirr_elem = Nirr_elem + 1
            transform(Nirr_elem,1:Ndeg,1:Nelem) = t_vect(1:Ndeg,1:Nelem) 
            !try_elem = 0 
            t_vect = 0 
            !
          else 
            !
            Nirr(gamma) = -info 
            !
          endif 
          !
        enddo elem_loop
        !
      enddo elem_loop2
      !
    enddo  gamma_loop
    !
    !
    if (job%verbose>=6) call TimerStop('degenerate_symm: construct irreps')
    !
    ! Check orthogonality and apply the Schmidt orthogonalization
    !
    do ielem = 1,Nirr_elem
      do ideg= 1,sym%maxdegen
        !
        fnormal = dot_product(transform(ielem,ideg,1:Nelem),transform(ielem,ideg,1:Nelem))
        !
        if (fnormal<sqrt(small_)) cycle 
        !
        do jelem = 1,ielem
          do  jdeg= 1,sym%maxdegen
            !
            if (jelem<ielem.or.jdeg<ideg) then 
              !
              fnormal = dot_product(transform(jelem,jdeg,1:Nelem),transform(jelem,jdeg,1:Nelem))
              !
              if (fnormal<(small_)) cycle 
              !
              f_t = sum(transform(ielem,ideg,1:Nelem)*transform(jelem,jdeg,1:Nelem))
              !
              transform(ielem,ideg,1:Nelem) = transform(ielem,ideg,1:Nelem)-transform(jelem,jdeg,1:Nelem)*f_t
              fnormal = dot_product(transform(ielem,ideg,1:Nelem),transform(ielem,ideg,1:Nelem))
              transform(ielem,ideg,1:Nelem) = transform(ielem,ideg,1:Nelem)/sqrt(fnormal)
              !
              f_t = sum(transform(ielem,ideg,1:Nelem)*transform(jelem,jdeg,1:Nelem))
              !
              if (abs(f_t)>sqrt(small_)) then 
                 !
                 write(out,"('non-orthgon: ielem,jelem,ideg,jdeg : ',4i6,f20.8)") ielem,jelem,ideg,jdeg,f_t
                 !info = 1
                 !
                 transform(ielem,ideg,1:Nelem) = transform(ielem,ideg,1:Nelem)-transform(jelem,jdeg,1:Nelem)*f_t
                 fnormal = dot_product(transform(ielem,ideg,1:Nelem),transform(ielem,ideg,1:Nelem))
                 transform(ielem,ideg,1:Nelem) = transform(ielem,ideg,1:Nelem)/sqrt(fnormal)
                 !
                 f_t = sum(transform(ielem,ideg,1:Nelem)*transform(jelem,jdeg,1:Nelem))
                 if (abs(f_t)>sqrt(small_)) then 
                    write(out,"('non-orthgon: ielem,jelem,ideg,jdeg : ',4i6,f20.8)") ielem,jelem,ideg,jdeg,f_t
                 endif 
                 !
              endif
            endif 
          enddo
        enddo
      enddo
    enddo
    !
    if (any(Nirr(:)<0)) info = 1
    !
    ! Check if all representations have been found 
    !
    if (Nirr_elem/=sum(Nirr)) then 
       write(out,"('degenerate_symmetrization: the irr. representations has not been found')")
       write(out,"('Nirr_elem = ',i8,' Nirr =  ',30i8)") Nirr_elem,Nirr
       info = 1
    endif 

    !deallocate(a,b)

    if (job%verbose>=5) call TimerStop('Degenerate symmetrization')
    !
    if (verbose>=4) write(out,"('...degenerate_symmetrization - done!')") 

 end subroutine degenerate_symmetrization
 !
 !
 !
 subroutine PTsymmetrization(j)

  integer(ik),intent(in) :: j     ! current rotational quantum    
  !type(FLbasissetT),intent(in)  :: bs(0:PT%Nmodes)          ! Basis set specifications: range and type
  integer(ik) :: isym,ioper,iclasses,i0,icoeff,cnu_max(0:PT%Nclasses)
  integer(ik) :: alloc,Nclasses,Npolyads,ib,mat_size,Nmodes,imode,ilevel,Nclasses1
  real(ark)    :: ener0,prod_t,chi(sym%Nclasses)
  integer(ik) :: PTPolyad_active,mat_size_t,ideg,jdeg,it,jt,gamma,cnu(0:PT%Nclasses),Nirr(sym%Nrepresen)
  integer(ik) :: Maxsymcoeffs,Ntotal(1:sym%Nrepresen),Ndeg
  integer(ik) :: max_deg_size,sum_Ntotal,Nrepresen,sizeprint
  integer(hik) :: max_global,dimen,actual_nlevels
  type(PTcoeffs_arkT),allocatable  ::  r_represent(:),projector(:,:)
  type(PTrepres_arkT),allocatable  ::  irr_t(:)
  character(len=cl) :: my_fmt !format for I/O specification
  !
  real(ark) :: Nirr_rk(sym%Nrepresen)


   if (job%verbose>=4) write(out,"(/'PTsymmetrization/start')") 
   !
   if (job%verbose>=3) write(out,"(//'Symmetrization...')") 
   !
   call TimerStart('PTsymmetrization')
   !
   Nclasses = PT%Nclasses ;  Nclasses1 = Nclasses + 1
   Nmodes = PT%Nmodes
   Nrepresen = sym%Nrepresen
   ! First we astimate the active space at the zero PT order, defined by NPolyad:
   ! 
   PT%Polyad_max = PT%Npolyads
   !
   Npolyads = PT%Polyad_max
   !
   ! Allocation of range, overlap of the quanta, and num_max
   !
   allocate (PT%Index_nu(0:PT%Polyad_max),PT%range(2,0:Nmodes),&
             PT%overlap(0:Nmodes),PT%MaxIndex_nu(0:PT%Polyad_max),&
             stat=alloc)

   call ArrayStart('PT%overlap',alloc,size(PT%overlap),kind(PT%overlap))
   call ArrayStart('PT%MaxIndex_nu',alloc,size(PT%MaxIndex_nu),kind(PT%MaxIndex_nu))
   !
   !
   ! define  range
   !
   ! vibrational modes 
   !
   do imode = 1,Nmodes
     PT%range(:,imode) = job%bset(imode)%range(:)
     PT%overlap(imode) = job%bset(imode)%dvrpoints
     PT%res_coeffs(imode) = job%bset(imode)%res_coeffs
   enddo
   !
   ! Here we adjust the rotational range and overlaps 
   ! as we use just one quantum number ktau=2*k+tau 
   !
   PT%range(1,0) =  0
   PT%range(2,0) =  job%bset(0)%range(2)
   PT%overlap(0) =  job%bset(0)%dvrpoints*2
   !
   PT%maxoverlap =  maxval(PT%overlap(1:Nmodes))
   !
   !
   ! max quantum numbers for each mode 
   !
   do iclasses = 0,PT%Nclasses
     !
     cnu_max(iclasses) = contr(iclasses)%nlevels 
     !
   enddo
   !
   !if (trove%lincoord/=0) cnu_max(0) = 1
   !
   PTPolyad_active = PT%Polyad_max
   !
   ! Check whether reduced model has been employed for the contracted basis set construction
   !
   PTreduced_model = .false.
   !
   do imode = 1,PT%Nmodes
     !
     if (job%bset(imode)%model /= 1000) then 
       !
       PTreduced_model = .true.
       !
     endif 
     !
   enddo
   !
   !
   if (job%verbose>=3) write(out,"(/'Generating the contracted active space...')") 
   !
   ! We can now combine and fill the contracted active_space with the quntum numbers 
   !
   icoeff = PTcontr_index(j,cnu_max)
   !
   Maxsymcoeffs = icoeff
   !
   ! We are ready to allocate PT%contractive_space, where we collect information on the nu(i) vs number of 1D index 
   ! 
   allocate (PT%contractive_space(0:Nclasses,Maxsymcoeffs),stat=alloc)
   call ArrayStart('PT%contractive_space',alloc,size(PT%contractive_space),kind(PT%contractive_space))
   !
   if (job%verbose>=5) then 
        write(out,"(/'Contracted active space :')") 
        write(out,"('     ib     ener0       cnu: ')") 
   endif 
   !
   icoeff = PTcontr_index(j,cnu_max,PT%contractive_space(:,:))
   !
   if (job%verbose>=5) then 
     do ib = 1,icoeff
         ener0 = PTcontrenergy_zero(PT%contractive_space(:,ib))

         write(out,'(i7,f12.4,'//fmt%Nclasses//')')  ib,ener0,PT%contractive_space(:,ib)

        !
     enddo 
   endif 
   !
   ! esimate the size if the primitive basis set (total)
   !
   dimen = 1 
   do iclasses = 0,PT%Nclasses
      dimen = dimen*contr(iclasses)%dimen
      !
   enddo 
   !
   PT%Maxcoeffs = dimen
   PT%Maxprimitive = dimen
   !
   ! The quanta are stored in the globaly defined field p_active_space
   !
   ! The product of the degenerated contracted represnetaions will generate
   ! representation in the product. The field PT%Index_deg will 
   ! store the bookeeping of all indeces 
   !
   !
   if (job%verbose>=3) write(out,"(/'Distributing the degenerate components...')") 
   !
   allocate (PT%Index_deg(Maxsymcoeffs),stat=alloc)
   !
   ! maximal total size of the degenerate matrix: the product of the individual maximal degeneracies
   !
   mat_size = 1
   !
   do iclasses = 0,Nclasses
     !
     mat_size = mat_size*contr(iclasses)%max_degen
     !
   enddo

   if (job%verbose>=5) then 
     write(out,"(//'Indexes of products of the degenerate representations  for each level:',30i8)")
     write(out,"('    ilevel   ib    deg_nu :')")
   endif
   !
   max_deg_size = 1 
   !
   actual_nlevels  = 0
   !
   do icoeff = 1,Maxsymcoeffs
     !
     allocate (PT%Index_deg(icoeff)%icoeffs(0:Nclasses,mat_size),stat=alloc)
     call ArrayStart('PT%Index_deg(icoeff)%icoeffs',alloc,size(PT%Index_deg(icoeff)%icoeffs),ik)
     !
     PT%Index_deg(icoeff)%icoeffs(:,:) = 1
     !
     call PTdegener_index(PT%contractive_space(:,icoeff),PT%Index_deg(icoeff)%icoeffs(:,:),mat_size_t)
     PT%Index_deg(icoeff)%size1 = mat_size_t
     !
     actual_nlevels = actual_nlevels + mat_size_t
     !
     max_deg_size = max(mat_size_t,max_deg_size)
     !
     if (job%verbose>=5) then 
       do ib = 1,mat_size_t
         write(out,'(2i7, '//fmt%Nclasses//')') icoeff,ib,PT%Index_deg(icoeff)%icoeffs(:,ib)
         !
       enddo 
     endif 
   enddo 
   !
   PT%max_deg_size = max_deg_size
   PT%Maxsymcoeffs = Maxsymcoeffs
   !
   ! We define the following objects only foj J=0 case. 
   ! Once computed it can be then stored and used later for J/=0
   !
   PT%Maxcontracts = actual_nlevels
   !
   !PTMaxcontracts = PT%Maxcontracts
   !
   if (job%verbose>=3) then 
       write(out,"('Size of contracted active space is ',i8)") PT%Maxcontracts
   endif 
   !
   if (j==0) then 
     !
     allocate (PT%icontr_cnu(0:Nclasses,PT%Maxcontracts),PT%icontr_ideg(0:Nclasses,PT%Maxcontracts),stat=alloc)
     call ArrayStart('PT%contractive_space',alloc,size(PT%icontr_cnu),kind(PT%icontr_cnu))
     call ArrayStart('PT%contractive_space',alloc,size(PT%icontr_ideg),kind(PT%icontr_ideg))
     !
   endif 
   !
   allocate (PT%icontr2icase(PT%Maxcontracts,2),PT%icase2icontr(Maxsymcoeffs,max_deg_size),stat=alloc)
   call ArrayStart('PT%contractive_space',alloc,size(PT%icontr2icase),kind(PT%icontr2icase))
   call ArrayStart('PT%contractive_space',alloc,size(PT%icase2icontr),kind(PT%icase2icontr))
   !
   ilevel = 0 
   !
   do icoeff = 1,Maxsymcoeffs
     !
     do ib = 1,PT%Index_deg(icoeff)%size1
       !
       ilevel = ilevel + 1
       PT%icontr2icase(ilevel,1) = icoeff
       PT%icontr2icase(ilevel,2) = ib
       PT%icase2icontr(icoeff,ib) = ilevel
       !
       if (j==0) then
         !
         !if (job%verbose>=5) then 
         !   write(out,"('icoeff,ib,ilevel,contr_spase,index_ideg ',40i8)") icoeff,ib,ilevel,PT%contractive_space(:,ilevel),PT%Index_deg(ilevel)%icoeffs(:,ib)
         !endif 
         !
         PT%icontr_cnu(0:Nclasses,ilevel)  = PT%contractive_space(0:Nclasses,icoeff)
         PT%icontr_ideg(0:Nclasses,ilevel) = PT%Index_deg(icoeff)%icoeffs(0:Nclasses,ib)
         !
       endif 
       !
     enddo 
     !
   enddo
   !
   actual_nlevels = PT%Maxprimitive
   ! 
   if (job%verbose>=3) write(out,"(/'Counting the total number of primitive components...')") 
   !
   ! This part is for the global basis set representation.
   !
   if (job%verbose>=3) write(out,"(/'symmetrization...')") 
   !
   !
   !                               Symmetrization.  
   !
   !
   ! The projectors for each irreducible representation - to project the contracted 
   ! basis set into the symmetrized basis set 
   !
   allocate (projector(sym%Nrepresen,sym%Noper),stat=alloc)
   !
   do isym =1,sym%Nrepresen
     !
     do ioper =1,sym%Noper
       allocate (projector(isym,ioper)%coeffs(sym%degen(isym),1),stat=alloc)
       call ArrayStart('projector(isym,ioper)%coeffs',alloc,size(projector(isym,ioper)%coeffs),kind(projector(isym,ioper)%coeffs))
       !
       projector(isym,ioper)%coeffs(:,1) = sym%irr(isym,ioper)%repres(1,:)*real(sym%degen(isym),ark)/real(sym%Noper,ark)
       !
     enddo 
   enddo 
   !
   ! We symmetrized the contracted basis set 
   ! by calculating irreducible represntations of the product of Nclasses the symmetrized components 
   ! Here the field 'represent' defines how the product of the contracted functions 
   ! transform with the group operations, i.e. the representation of basis set in the 
   ! contracted basis. 
   ! The field 'transform' will define the transformation from the contracted basis set 
   ! to the symmetrized basis set. 
   !
   allocate (r_represent(sym%Noper),PT%irr(sym%Nrepresen),irr_t(sym%Nrepresen),stat=alloc)
   if (alloc/=0) then
       write (out,"(' Error ',i9,' r_represent ')") alloc
       stop 'PTsymmetrization, r_represent - out of memory'
   end if
   !
   do ioper = 1,sym%Noper
     !
     allocate (r_represent(ioper)%coeffs(mat_size,mat_size),stat=alloc)
     call ArrayStart('r_represent(ioper)%coeffs',alloc,size(r_represent(ioper)%coeffs),kind(r_represent(ioper)%coeffs))
     !
     r_represent(ioper)%coeffs = 0 
     !
   enddo
   !
   ! Srart here the loop over all symm. independent quantum numbers
   ! first time only to estimate the total numbers (Ntotal) of irred. representations 
   !
   if (job%verbose>=3) write(out,"('Counting the total number of irr. representations...')") 
   !
   Ntotal = 0 
   !
   if (job%verbose>=5) then 
      write(out,"(//'Construct irreducible representations for each level')")
      write(out,"('Find numbers of irr. representations')")
   endif 
   !
   do icoeff = 1,Maxsymcoeffs
     !
     ! Construct the total representation matrices as a product of each classes matrix
     !
     ! PT%contractive_space(:,icoeff)
     !
     cnu(:) =  PT%contractive_space(:,icoeff)

     !if (job%verbose>=5) then 
     !   write(out,"(i7,'' : ' ',<Nclasses1>i3,' isym= (',<Nclasses1>i3,')')") icoeff,cnu(:),(contr(iclasses)%eigen(cnu(iclasses))%isym,iclasses=0,PT%Nclasses)
     !endif 

     !PT%contractive_space(:,icoeff) = cnu(:)
     !
     do ioper = 1,sym%Noper
       !
       do ideg = 1,PT%Index_deg(icoeff)%size1 
         do jdeg = 1,PT%Index_deg(icoeff)%size1 
           prod_t = 1.0_ark
           do iclasses = 0,PT%Nclasses
             !
             gamma = contr(iclasses)%eigen(cnu(iclasses))%isym
             !
             it = PT%Index_deg(icoeff)%icoeffs(iclasses,ideg)
             jt = PT%Index_deg(icoeff)%icoeffs(iclasses,jdeg)
             !
             ! transposed matrices (?) repres(:,:) - because the functions are transformed 
             ! through an inverce matrix
             !
             prod_t = prod_t*sym%irr(gamma,ioper)%repres(it,jt)
             !
           enddo
           !
           r_represent(ioper)%coeffs(ideg,jdeg) = prod_t
           !
         enddo
       enddo
       !
       if (job%verbose>=6) then 
         !
         sizeprint = PT%Index_deg(icoeff)%size1
         write(my_fmt,'(a,i0,a)') "(t1,i5,t8,",sizeprint,"(f18.8))"
         !
         do ideg = 1,PT%Index_deg(icoeff)%size1 
           !
           write(out,my_fmt) ioper,r_represent(ioper)%coeffs(ideg,1:PT%Index_deg(icoeff)%size1)
           !
         enddo
         !
       endif 
       !
     enddo
     !
     ! calculate the characters 
     !
     chi = 0
     ioper = 1
     !
     do iclasses =1,sym%Nclasses
       !
       do ideg = 1,PT%Index_deg(icoeff)%size1 
         !
         chi(iclasses) = chi(iclasses) + r_represent(ioper)%coeffs(ideg,ideg)
         !
       enddo 
       !
       if (job%verbose>=6) then 
         write(out,"('ioper = ',i5,'; character: ',f12.8)") ioper,chi(iclasses)
       endif 
       !
       ioper = ioper+sym%Nelements(iclasses)
       !
     enddo 
     !
     ! estimate the number of the irreducible representasions 
     !
     do isym =1,sym%Nrepresen
        !
        Nirr_rk(isym) = sum(real(sym%Nelements(:)*sym%characters(isym,:),ark)*chi(:))/real(sym%Noper,ark)
        Nirr(isym) = nint(Nirr_rk(isym),ik)
        !
        if (trove%lincoord/=0.and.j/=0.and.sym%lquant(isym)>0) Nirr(isym) = 0 
        !
     enddo 
     !
     if (all(Nirr(:)==0)) then 
       write(out,"('No symmetry defined, Nirr = 0, icoeff = ',i8)") icoeff
       stop 'No symmetry defined, Nirr = 0'
     endif 
     !
     if (job%verbose>=5) then 
        write(my_fmt,'(a,i0,a,i0,a,i0,a)') "(i7,a,",Nclasses+1,"i4,a8,",Nclasses+1,"i4,a1,2x,",Nrepresen,"(f12.4))"
        write(out,my_fmt) icoeff,' : ',cnu(:),' isym= (',&
                         (contr(iclasses)%eigen(cnu(iclasses))%isym,iclasses=0,PT%Nclasses),')',Nirr_rk(1:Nrepresen)
     endif
     !
     !if (job%verbose>=5) then 
     !  write(out,"('Number of irr. rep-s = ',30f12.4)") Nirr_rk(1:min(30,size(Nirr_rk)))
     !endif 
     !
     Ntotal(:) = Ntotal(:) + Nirr(:)
     !
     sum_Ntotal = sum(Ntotal(:)*sym%degen(:))
     !
     if (sum_Ntotal>actual_nlevels) then 
        Ntotal(:) = Ntotal(:) - Nirr(:)
        Maxsymcoeffs = icoeff-1
        exit
     endif 
     !
   enddo  
   !
   do isym = 1,sym%Nrepresen
     !
     allocate (PT%irr(isym)%repres(Ntotal(isym),sym%degen(isym),mat_size),stat=alloc)
     call ArrayStart('PT%irr(isym)%coeffs',alloc,size(PT%irr(isym)%repres),kind(PT%irr(isym)%repres))
     allocate (irr_t(isym)%repres(Ntotal(isym),sym%degen(isym),mat_size),stat=alloc)
     call ArrayStart('irr_t',alloc,size(irr_t(isym)%repres),kind(irr_t(isym)%repres))
     !
     PT%irr(isym)%repres = 0
     irr_t(isym)%repres = 0
     !
     allocate(PT%irr(isym)%N(Maxsymcoeffs),stat=alloc)
     call ArrayStart('PT%irr(isym)%N',alloc,size(PT%irr(isym)%N),kind(PT%irr(isym)%N))
     !
   enddo
   !
   ! Now when we now the sizes we can allocate the matrices with all information 
   ! about the symmetry 
   !
   if (job%verbose>=3) write(out,"('Generating the irr. representations...')") 
   !
   ! We are ready to allocate PT%contractive_space, where we collect information on the nu(i) vs number of 1D index 
   ! 
   allocate (PT%symactive_space(1:sym%Nrepresen),PT%globactive_space,&
             PT%Max_sym_levels(1:sym%Nrepresen),stat=alloc)
   if (alloc/=0) then
      write (out,"(' Error ',i9,' symactive_space ')") alloc
      stop 'PTsymmetrization, symactive_space - out of memory'
   end if
   !
   PT%Max_sym_levels(:) = Ntotal(:)
   !
   if (job%verbose>=3) then 
      write(out,"(/'Total number of irr. representations: ',40i10/)") Ntotal
   endif 
   if (job%verbose>=5)  write(out,"('icoef  isym  ideg  irr. repres. ')")
   !
   do isym =1,sym%Nrepresen
     !
     allocate (PT%symactive_space(isym)%sym_N(Ntotal(isym),2),stat=alloc)
     call ArrayStart('PT%symactive_space(isym)%sym_N',alloc,size(PT%symactive_space(isym)%sym_N),&
          kind(PT%symactive_space(isym)%sym_N))
     !
   enddo 

   if (job%verbose>=6) then 
      write(out,"(//'Construct IRREPS for each level')")
   endif 
   !
   ! We run the big loop again and construct the symmetrical transformations
   !
   Ntotal = 0 
   symind_loop : do icoeff = 1,Maxsymcoeffs
     !
     ! Construct the total representation matrices as a product of each classes matrix
     !
     cnu(:) =  PT%contractive_space(:,icoeff)
     !
     do ioper = 1,sym%Noper
       !
       do ideg = 1,PT%Index_deg(icoeff)%size1 
         do jdeg = 1,PT%Index_deg(icoeff)%size1 
           prod_t = 1.0_ark
           do iclasses = 0,PT%Nclasses
             !
             gamma = contr(iclasses)%eigen(cnu(iclasses))%isym
             !
             it = PT%Index_deg(icoeff)%icoeffs(iclasses,ideg)
             jt = PT%Index_deg(icoeff)%icoeffs(iclasses,jdeg)
             !
             prod_t = prod_t*sym%irr(gamma,ioper)%repres(it,jt)
             !
           enddo
           !
           r_represent(ioper)%coeffs(ideg,jdeg) = prod_t
           !
         enddo
       enddo
       !
     enddo
     !
     ! calculate the characters - again 
     !
     chi = 0
     ioper = 1
     do iclasses =1,sym%Nclasses
       do ideg = 1,PT%Index_deg(icoeff)%size1 
         chi(iclasses) = chi(iclasses) + r_represent(ioper)%coeffs(ideg,ideg)
       enddo 
       ioper = ioper+sym%Nelements(iclasses)
     enddo 
     !
     ! estimate the number of the irreducible representasions - again
     !
     do isym =1,sym%Nrepresen
        !Nirr(isym) = sum(sym%Nelements(:)*chi(:)*sym%characters(isym,:))/sym%Noper
        Nirr_rk(isym) = sum(real(sym%Nelements(:)*sym%characters(isym,:),ark)*chi(:))/real(sym%Noper,ark)
        Nirr(isym) = nint(Nirr_rk(isym))
        if (trove%lincoord/=0.and.j/=0.and.sym%lquant(isym)>0) Nirr(isym) = 0 
        !
     enddo 
     !
     ! Transformation matrix to the irreducible representation
     ! This is final for the nondegenerate cases elements, 
     ! but is gonna have to be orthogonalaized for the degenerate ones. 
     !
     ! Combining all transformation into one by mltiplying them. 
     ! This is final for the nondegenerate cases elements, 
     ! but is gonna have to be orthogonalaized for the degenerate ones. 
     !
     Ndeg = PT%Index_deg(icoeff)%size1 
     !
     call degenerate_projectors(icoeff,Nirr,Ntotal)
     !
     write(my_fmt,'(a,i0,a)') "(i7,i4,i4,",Ndeg,"f18.8)"
     !
     do isym =1,sym%Nrepresen
       !
       do i0 = 1,Nirr(isym)
         !
         PT%symactive_space(isym)%sym_N(Ntotal(isym)+i0,1) = icoeff
         PT%symactive_space(isym)%sym_N(Ntotal(isym)+i0,2) = i0
         !
         if (job%verbose>=5) then 
           do ideg = 1,sym%degen(isym)
             write(out,my_fmt) icoeff,isym,ideg,irr_t(isym)%repres(Ntotal(isym)+i0,ideg,1:Ndeg)
           enddo 
         endif
         !
       enddo
       !
       PT%irr(isym)%N(icoeff) = Nirr(isym)
       !
       Ntotal(isym) = Ntotal(isym) + Nirr(isym)
       !
     enddo
     !
   enddo symind_loop
   !
   if (job%verbose>=3) write(out,"(/'Correspondence between primitive and symmetrized (global) quantum numbers ...')") 
   !
   ! maximal number of combinations in the global active space
   !
   max_global = 1
   !
   do icoeff =1,Maxsymcoeffs
     max_global = max(max_global,PT%Index_deg(icoeff)%size1 )
   enddo
   !
   do iclasses = 0,Nclasses
     !
     max_global = max_global*int(contr(iclasses)%dimen,hik)
     !
   enddo
   !
   if (job%verbose>=6) then 
     write(out,"('max_global = ',i7)") max_global
   endif 
   !
   !
   Ntotal = PT%Max_sym_levels

   if (job%verbose>=5) then 
      write(out,"(//'Index_global: transformation of the quanta from the symm.  to the prim. basis sets',30i8)")
   endif
   !
   ! The transformation from the symmetrized basis to the primitive basis 
   ! consits of three steps: 
   ! 1) the contracted basis transformation;
   ! 2) transformation to the product of the contracted basis functions 
   ! 3) the symmetrization, i.e. transformation to the irred. representaion.
   ! This makes up a product of several summation.
   ! To make it simple for the later use in the diagonalization 
   ! we want to have just one summation, i.e. only one expansion. 
   ! Forward this we create a primitive active space in  a way to simplify it. 
   ! We analyze each irr. vector, i.e. how it is constructed from primit. basis functions, 
   ! and create a single summation array from it. 
   ! We build this summation in the way that different sumamtion can be distinguished  
   ! only by the size of transformtion for each case. All cases of the the same size 
   ! are treated alike. Thus we need to describe N different ways of summations, 
   ! where N = max(PT%Index_deg(:)%size1 ) = max_deg_size
   !
   !
   write(out,"(/'Size of the primitive basis set : ',i12)") dimen
   write(out,"( 'Total number of irr. representations: ',40i10)") PT%Max_sym_levels
   !
   do ioper =1,sym%Noper
     deallocate (r_represent(ioper)%coeffs)
     do isym =1,sym%Nrepresen
       deallocate (projector(isym,ioper)%coeffs)
     enddo 
   enddo 
   call ArrayStop('projector(isym,ioper)%coeffs')
   call ArrayStop('r_represent(ioper)%coeffs')
   call ArrayStop('irr_t')
   !
   do isym = 1,sym%Nrepresen
     !
     deallocate (irr_t(isym)%repres,stat=alloc)
     !
   enddo
   !
   deallocate(irr_t)
   deallocate(projector)
   deallocate(r_represent)
   if (job%verbose>=3) call MemoryReport

   !if (job%verbose>=4) write(out,"('PTsymmetrization/end')") 
   !
   call TimerStop('PTsymmetrization')
   !
   contains 

   !
   ! This procedure constructs the irreducible transformations for the degenerate representations  
   ! The starting transformation is given by the trans_vect operator, which has to be orthogonalized 
   ! by the Schmidt method. 
   !
   subroutine degenerate_projectors(icoeff,Nirr,Ntotal)

     integer(ik),intent(in) :: icoeff,Nirr(sym%Nrepresen),Ntotal(sym%Nrepresen)
     integer(ik) :: Ndeg,ideg,jdeg,Nelem,N_indep,ielem,jelem,kelem,felem,alloc,Nfound,nroots,kdeg,istart,try_elem,jsym,ierror
     !
     type(PTcoeffs_arkT),allocatable  :: t_vect(:)
     real(ark),allocatable  :: mat_t(:),a(:,:),b(:),vect(:,:)
     !
     real(rk),allocatable   :: da(:,:),db(:,:)
     !
     real(ark) :: f_t,g_t
     !
     Nelem = PT%Index_deg(icoeff)%size1
     !
     allocate(a(Nelem,Nelem),b(Nelem),da(Nelem,Nelem),db(Nelem,1),vect(Nelem,Nelem),stat=alloc)
     if (alloc/=0) then
         write (out,"(' degenerate_projectors: ',i9,' trying to allocate array for a and b')") alloc
         stop 'degenerate_projectors, a and b  - out of memory'
     end if
     !
     allocate (t_vect(Nelem),mat_t(Nelem),stat=alloc)
     if (alloc/=0) then
        write (out,"(' Error ',i9,' t_vect ',i9)") alloc
        stop 'degenerate_projectors, t_vect - out of memory'
     end if
     !
     do ielem = 1,Nelem
        allocate(t_vect(ielem)%coeffs(Nelem,Nelem),stat=alloc)
     enddo
     !
     do isym = 1,sym%Nrepresen
       !
       istart = Ntotal(isym)
       !
       Ndeg = sym%degen(isym)
       
       do ielem = 1,Nelem
         t_vect(ielem)%coeffs = 0 
         do ioper = 1,sym%Noper
           !
           t_vect(ielem)%coeffs(1,1:Nelem) =  t_vect(ielem)%coeffs(1,1:Nelem) + &
                                              projector(isym,ioper)%coeffs(1,1)*r_represent(ioper)%coeffs(ielem,1:Nelem)
           !
         enddo
       enddo
       !
       ! Now we orthogonalize these vectors among themself, removing repeated ones
       !
       felem = 0
       try_elem = 0 
       !
       elem_loop: do while (felem<Nirr(isym).and.try_elem<Nelem)
         !
         try_elem = try_elem + 1
         !
         vect(1,1:Nelem) = t_vect(try_elem)%coeffs(1,1:Nelem)
         !
         ! initial check for non-vanish 
         !
         !
         f_t = sum(vect(1,:)**2)
         ! Continue for non-zero vectors
         !
         if (f_t>small_) then 
           !
           vect(1,:) = vect(1,:)/sqrt(f_t)
           !
           else
           !
           cycle elem_loop
           !
         endif
         !
         ! Schmidt orthogonalization
         !
         do ielem = 1,felem
           !
           f_t = sum(irr_t(isym)%repres(istart+ielem,1,1:Nelem)*vect(1,1:Nelem))
           !
           vect(1,1:Nelem) = vect(1,1:Nelem)- irr_t(isym)%repres(istart+ielem,1,1:Nelem)*f_t
           !
         enddo
         !
         ! normalization 
         !
         f_t = sum(vect(1,:)**2)
         !
         ! Continue for non-zero vectors
         !
         if (f_t>small_) then 
           !
           vect(1,:) = vect(1,:)/sqrt(f_t)
           !
           else
           !
           cycle elem_loop
           !
         endif
         !
         ! Reconstructing other degenerate components
         !
         !
         do jdeg= 2,Ndeg
           !
           vect(jdeg,1:Nelem) = 0
           !
           do ioper = 1,sym%Noper
            !
            do jelem = 1,Nelem
             !
             vect(jdeg,1:Nelem) =  vect(jdeg,1:Nelem) + &
                                   sym%irr(isym,ioper)%repres(1,jdeg)*&
                                   real(sym%degen(isym),ark)/real(sym%Noper,ark)*&
                                   r_represent(ioper)%coeffs(jelem,1:Nelem)*vect(1,jelem)
              !
            enddo

           enddo
           !
         enddo
         !
         !do jelem= 1,Nelem
         !  !
         !  do  jdeg= 1,Ndeg-1
         !    !
         !    ioper = jdeg+1
         !    !
         !    if (ioper>sym%Noper) then
         !       write(out,"('degenerate_projectors: ioper>Noper: ',2i7)") ioper,sym%Noper
         !       stop 'degenerate_projectors: ioper>Noper'
         !    endif
         !    !
         !    do  kdeg= 1,Ndeg-1
         !      !
         !      a(jdeg,kdeg) = sym%irr(isym,ioper)%repres(1,kdeg+1)
         !      !
         !    enddo
         !    !
         !    b(jdeg) = sum(vect(1,1:Nelem)*r_represent(ioper)%coeffs(1:Nelem,jelem)) &
         !                 -  sym%irr(isym,ioper)%repres(1,1)*vect(1,jelem)
         !    ! 
         !  enddo
         !  !
         !  call MLlinurark(Ndeg-1,a(1:Ndeg-1,1:Ndeg-1),b(1:Ndeg-1),vect(2:Ndeg,jelem),ierror)
         !  !
         !  if (ierror/=0) then
         !    !
         !    !  lapack_gelss 
         !    !
         !    da(1:Ndeg-1,1:Ndeg-1) = a(1:Ndeg-1,1:Ndeg-1)
         !    db(1:Ndeg-1,1) = b(1:Ndeg-1)
         !    !
         !    call lapack_gelss(da(1:Ndeg-1,1:Ndeg-1),db(1:Ndeg-1,1:1))
         !    !
         !    vect(2:Ndeg,jelem) = real(db(1:Ndeg-1,1),ark)
         !    !
         !  end if
         !  !
         !enddo
         !
         ! normalize 
         !
         do jdeg =2,Ndeg
           !
           f_t = sum(vect(jdeg,:)**2)
           !
           ! Continue for non-zero vectors
           !
           if (f_t>small_) then 
             !
             vect(jdeg,:) = vect(jdeg,:)/sqrt(f_t)
             !
             else
             !
             cycle elem_loop
             !
           endif
           !
           ! Orthogonalization with each other 
           !
           do kdeg = 1,jdeg-1
             !
             f_t = sum(vect(kdeg,:)*vect(jdeg,:))
             !
             vect(jdeg,:) = vect(jdeg,:)-vect(kdeg,:)*f_t
             !
           enddo
           !
         enddo
         !
         ! check if the found vector does transorm correctly with the group
         !
         do jdeg = 1,Ndeg
           !         
           do ioper = 1,sym%Noper
             !
             do jelem = 1,Nelem
               !
               f_t = sum( vect(jdeg,1:Nelem)*r_represent(ioper)%coeffs(1:Nelem,jelem) )
               !
               g_t = sum( sym%irr(isym,ioper)%repres(jdeg,1:Ndeg)*vect(1:Ndeg,jelem) )
               !
               ! Continue if this two quanttaties are the same 
               !
               if (abs(f_t-g_t)>sqrt(small_)) cycle elem_loop
               !
             enddo
             !
           enddo
           !
         enddo
         !
         ! check if the found vector is really unique, by comparing also with other symmetries 
         !
         do jsym = 1,isym
           !
           do ielem = 1,min(Nirr(jsym),felem)
             !
             do kdeg =1,Ndeg
               !
               do jdeg =1,sym%degen(jsym)
                 !
                 if (all(abs(vect(kdeg,1:Nelem) - &
                             irr_t(jsym)%repres(Ntotal(jsym)+ielem,jdeg,1:Nelem))<sqrt(small_))) cycle elem_loop
                 !
               enddo 
               !
             enddo 
             !
           enddo
           !
         enddo
         !
         !
         ! if we are through all obstacles, we are finally there
         !
         felem = felem + 1
         !
         irr_t(isym)%repres(istart+felem,1:Ndeg,1:Nelem) = vect(1:Ndeg,1:Nelem)
         PT%irr(isym)%repres(istart+felem,1:Ndeg,1:Nelem) = vect(1:Ndeg,1:Nelem)
         !
         !t_vect(felem)%coeffs(1,:) = t_vect(ielem)%coeffs(1,:)
         !
       enddo elem_loop
       !
       ! Check if all representations have been found 
       !
       if (felem/=Nirr(isym)) then 
          write(out,"('degenerate_projectors: Not all irr. representations have been found for')")
          write(out,"('icoeff = ',i7,' isym = ',i4,' : only ',i7,' out of ',i7)") icoeff,isym,felem,Nirr(isym)
          stop 'degenerate_projectors: Not all irr!. representations have been found'
       endif 
       !

     enddo 
 

     deallocate (t_vect,mat_t,vect)
     deallocate(a,b,da,db)


   end subroutine degenerate_projectors
   !
 end subroutine PTsymmetrization
!
!
! Here we construct the Hamiltonian matrix in the contracted basis set  representation
!
  subroutine PThamiltonian_contract(jrot)

    integer(ik),intent(in) :: jrot ! rotational quantum number
    !
    integer(ik)  :: alloc,alloc_p,dimen,dimen_row,dimen_maxrow
    integer(hik) :: matsize
    integer(ik) :: irow,isym,rlevel,k_i,k_t,istart,jstart,iend,jelem,k_j
    type(PTcoeffsT) :: smat(sym%Nrepresen)
    integer(ik) :: kblock(sym%Nrepresen,0:jrot,2)
    !
    real(rk),allocatable :: mat_t(:,:,:),a(:,:)
    integer(ik) :: ielem,icase,Nterms(sym%Nrepresen),i_irr(sym%Nrepresen),nroots
    integer(ik),allocatable :: ijterm(:,:),k_row(:,:),bterm(:,:)
    !
    real(rk) :: zpe
    integer  :: slevel,dimen_s,max_dim,iterm,jterm,total_roots,icontr
    !
    integer(ik) :: iunit,unitO,unitC,rec_len,irec_len,chkptIO
    integer(ik) :: ncontr,maxcontr,maxcontr0
    character(len=cl)   :: task
    character(len=4)   :: jchar
    character(len=cl)  :: unitfname,filename,statusf,symchar
    logical :: only_store = .false.
    logical :: no_diagonalization = .false.
    !
    ! A special case when the diagonlization is to be skipped 
    !
    if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE'.or.&
           trim(job%IOeigen_action)=='READ').and.&
           (job%IOmatelem_split.and.(job%iswap(1)/=0.or.fitting%iparam(1)/=1) )) then
       !
       write(out,"('For MATELEM SAVE DIVIDE the eigenvalue problem is skipped ')")
       write(out,"('Please run again with matelem READ or NONE')")
       !
       return 
       !
    endif 

    !
    ! check if we only need to store matrices, not diagonalize them
    !
    select case (trim(job%mat_readwrite))
      !
    case ('SAVE-LOWER','STORE-LOWER','STORE_CHEAP')
      only_store = .true.
    end select
    !
    select case (trim(job%diagonalizer))
      !
    case ('ENERGY=DIAGONAL','NO-DIAGONALIZATION')
       no_diagonalization = .true.
    end select
    !
    call TimerStart('Contracted Hamiltonian')
    !
    if (job%verbose>=5) write(out,"(/'PThamiltonian_contract/start: variational solution ')") 
    !
    !
    ! Prepare the storing information if necessary:
    !
    if ( trim(job%IOeigen_action)=='SAVE'.or.trim(job%IOeigen_action)=='APPEND' ) then
      call check_point_active_space(job%IOeigen_action)
    endif 
    !
    ! obtain zpe 
    !
    if (jrot>0.or..not.job%select_gamma(1)) call FLread_ZPE
    !
    ! prepare the vectors to store also in the symmetrized representaion
    !
    if (job%IOeigen_compress) then
      !
      ! use the predefined file to store the compacted vectors
      !
      dimen = max(min(int(PT%Maxcontracts*job%compress),PT%Maxcontracts),1)
      !
      inquire(iolength=rec_len) zpe
      rec_len = rec_len*dimen
      !
      inquire(iolength=irec_len) iterm
      irec_len = irec_len*(dimen+1)
      !
      write(unitfname, '(a, i4)') 'compacted eigenfuncs for ', jrot
      call iostart(trim(unitfname), unitO)
      !
      write(unitfname, '(a, i4)') 'compacted coeffs for ', jrot
      call iostart(trim(unitfname), unitC)
      !
      write(jchar, '(i4)') jrot
      !
      select case (trim(job%IOeigen_action))
        !
      case ('APPEND')
        !
        statusf = 'old'
        !
      case default 
        !
        statusf = 'replace'
        !
      end select 
      !
      filename = trim(job%compress_file)//'_vect'//trim(adjustl(jchar))//'.tmp'
      open(unitO,access='direct',action = 'write',status=statusf,file=filename,recl=rec_len) 
      !
      filename = trim(job%compress_file)//'_coef'//trim(adjustl(jchar))//'.tmp'
      open(unitC,access='direct',action = 'write',status=statusf,file=filename,recl=irec_len)
      !
      if (job%verbose>=2) write(out,"('The vectors will be compressed before saving using threshold = ',g15.7)") job%coeff_thresh
      !
    endif
    !
    !Determine the size of Htotal:
    !
    dimen = PT%Maxsymcoeffs ! PT%Maxcontrcoeffs
    !
    if (job%verbose>=2) then 
        write (out,"(/'Size of the contracted matrix  = ',i7)") dimen
    endif
    !
    if (trim(job%diagonalizer(1:10))=='READ-EIGEN'.or.trim(job%mat_readwrite)=='READ'.or.&
        trim(job%mat_readwrite)=='READ-LOWER'.or.trim(job%diagonalizer(1:13))=='READ-ENERGIES') then 
      !
      if (job%verbose>=3) write(out,"('Diagonalization...')")
      !
      rlevel = PTNlevels
      total_roots = PTNroots
      zpe = 0
      max_dim = 1
      !
      do isym = 1,sym%Nrepresen
        !
        ! This how we exclude symmeitres from the calculations
        !
        if (.not.job%select_gamma(isym)) cycle
        !
        dimen_s = PT%Max_sym_levels(isym)
        !
        max_dim = max(dimen_s,max_dim)
        !
      enddo
      !
      allocate (k_row(sym%Nrepresen,max_dim),stat=alloc)
      !
      k_row = 0 
      !
      do isym = 1,sym%Nrepresen
        !
        if (.not.job%select_gamma(isym)) cycle
        !
        dimen_s = PT%Max_sym_levels(isym)
        !
        !----------Only allocate if we are putting vectors into memory---------------!
        if(trim(job%diagonalizer(1:13))/='READ-ENERGIES') then 
		matsize = int(dimen_s,hik)*int(job%nroots(isym),hik)
		if (job%verbose>=4) write(out,"('Allocate array b',i7,'x',i7,' = ',i8)") dimen_s,job%nroots(isym),matsize
		allocate (a(dimen_s,job%nroots(isym)),bterm(job%nroots(isym),2),stat=alloc)
		!
		a = 0
		!
		call ArrayStart('PThamiltonian_contract:b',alloc,1,kind(a),matsize)
		!
		bterm = 1
		!
		if (job%verbose>=4) call MemoryReport
		!
		if (job%verbose>=1) then 
		   write (out,"(//'Size of the symmetrized hamiltonian = ',i7,' Symmetry = ',a4)") dimen_s,sym%label(isym)
		endif
	endif
        !
        call diagonalization_contract(jrot,isym,dimen_s,a,zpe,rlevel,total_roots,bterm,k_row(isym,1:dimen_s)) 
        !
        !Only deallocate if we arent Reading the energy checkpoint files.
        if(trim(job%diagonalizer(1:13))/='READ-ENERGIES') then !Only deallocate if we allocated
        	deallocate (bterm)
        !
        	deallocate (a)
        	call ArrayStop('PThamiltonian_contract:b')
        endif
        !
      enddo
      !
      deallocate(k_row)
      !
      if ( trim(job%IOeigen_action)=='SAVE'.or.trim(job%IOeigen_action)=='APPEND' ) then
        !
        call check_point_active_space('CLOSE')
        !
      endif 
      !
      if (job%verbose>=5) write(out,"(/'PThamiltonian_contract/end ')") 
      !
      call TimerStop('Contracted Hamiltonian')
      !
      return
      !
    endif 
    !
    if (job%verbose>=7) then 
       write(out,"(/'contracted matrix - start')")
       write(out,"('       ib     jb        matrix       quanta_i - guanta_j')") 
    endif 
    !
    allocate (ijterm(dimen,sym%Nrepresen),stat=alloc)
    call ArrayStart('PThamiltonian_contract:a',alloc,size(ijterm),kind(ijterm))
    !
    ! Count and distribute the rows in the symmetrized representaion: 
    !
    Nterms = 0 
    !
    do irow = 1,dimen
      !
      do isym = 1,sym%Nrepresen
        i_irr(isym) = PT%irr(isym)%N(irow) 
      enddo 
      !
      !jterm = 0 
      !
      ijterm(irow,:) = Nterms(:)
      !
      Nterms(:) = Nterms(:) + i_irr(:)
      !
    enddo
    !
    if (job%verbose>=3) write(out,"(/'Calculating the symmetrized mat. elements...'/)")
    !
    k_t = 0 
    kblock(:,:,1) = 1 ; kblock(:,:,2) = 0
    do irow = 1,dimen
      !
      iterm = PT%contractive_space(0,irow)
      k_i = PT%rot_index(iterm,1)%k
      !
      if (k_i==k_t) then 
        !
        do isym = 1,sym%Nrepresen
           !
           kblock(isym,k_i,2) = ijterm(irow,isym)+PT%irr(isym)%N(irow)
           !
        enddo
        !
      else
        !
        do isym = 1,sym%Nrepresen
           !
           k_t = k_i
           kblock(isym,k_i,1) = ijterm(irow,isym) + 1
           kblock(isym,k_i,2) = ijterm(irow,isym)+PT%irr(isym)%N(irow)
           !
        enddo
        !
      endif 
      !
    enddo
    !
    !
    ! forget about the kblock structure in case of the TD symmetry or if the rot. symmetry is based on the euler angles transformation properties
    !
    if (job%vib_rot_contr.or.job%rotsym_do ) then
      !
      if (job%rotsym_do ) then
        !
        select case (trim( trove%symmetry ))
        case('TD','TD(M)','C2V(M)','C2V','C3V(M)',&
             'C3V','D3H(M)','D3H','C2H(M)','C2H','G4(M)','G4','G4(EM)','D2H(M)','D2H')
        case default
            write(out,"('Error PThamiltonian_contract: rotsym_do is not implemented for ',a)") trim( trove%symmetry )
            stop 'Error PThamiltonian_contract: illegal symmetry for rotsym_do'
        end select 
        !
      endif
      !
      do isym = 1,sym%Nrepresen
        !
        dimen_s = PT%Max_sym_levels(isym)
        !
        kblock(isym,:,1) = 1
        kblock(isym,:,2) = dimen_s
        !
      enddo
      !
    endif
    !
    ! Counting different krot for each symmetry of each block
    !
    max_dim = 1
    !
    do isym = 1,sym%Nrepresen
      !
      ! This how we exclude symmeitres from the calculations
      !
      if (.not.job%select_gamma(isym)) cycle
      !
      dimen_maxrow = 1
      !
      if (job%verbose>=6) write(out,"('isym k_i kblock:')")
      !
      do k_i = 0,jrot
        !
        dimen_row = kblock(isym,k_i,2)-kblock(isym,max(k_i-2,0),1)+1
        dimen_maxrow = max(dimen_maxrow,dimen_row)
        !
        if (job%verbose>=6) write(out,"('isym,k_i,kblock  = ',4i0)") isym,k_i,kblock(isym,k_i,1),kblock(isym,k_i,2)
        ! 
      enddo
      !
      dimen_s = PT%Max_sym_levels(isym)
      !
      max_dim = max(dimen_s,max_dim)
      !
      matsize = int(dimen_s,hik)*int(dimen_maxrow,hik)
      !
      if (job%verbose>=4) write(out,"('Allocate array ',i7,'x',i7,' = ',i8)") dimen_s,dimen_maxrow,matsize
      allocate (smat(isym)%coeffs(dimen_s,dimen_maxrow),stat=alloc)
      call ArrayStart('PThamiltonian_contract:smat'//sym%label(isym),alloc,1,kind(smat(isym)%coeffs),matsize)
      !
      smat(isym)%coeffs = 0 
      !
    enddo
    !
    allocate (k_row(sym%Nrepresen,max_dim),stat=alloc)
    !
    k_row = 0 
    !
    do isym = 1,sym%Nrepresen
      !
      if (.not.job%select_gamma(isym)) cycle
      !
      do k_i = 0,jrot
        k_row(isym,kblock(isym,k_i,1):kblock(isym,k_i,2)) = k_i
      enddo
      !
    enddo
    !
    if (job%verbose>=4) call MemoryReport
    !
    call TimerStart('Calculating the Hamiltonian matrix')
    !
    task = 'top'
    call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
    !
    ! We have two calculation options: fast and cheap and slow but expensive.  
    !
    if (job%verbose>=4) write(out,"(/'Calculate the Hamiltonian matrix...')")
    !
    if (job%fast.and..not.job%vib_rot_contr) then 
      !
      if (job%verbose>=4) write(out,"(/'Fast and more expensive approach...')")
      !
      if (FLrotation.and.jrot/=0) then
        !
        if (job%verbose>=5) write(out,"(/' Restore matelements for the Coriolis part ...')")
        !
        call TimerStart('Restoring KE matrix')
        !
        task = 'rot'
        call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
        task = 'cor'
        call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
        !
        call TimerStop('Restoring KE matrix')
        !
        if (job%verbose>=5) write(out,"(/' ...done!')")
        !
      endif
      !
      if ( PTvibrational_me_calc ) then
        !
        if (job%verbose>=5) write(out,"(/' Restore matelements for the Vibrational part ...')")
        !
        call TimerStart('Restoring KE matrix')
        !
        task = 'vib'
        call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
        !
        call TimerStop('Restoring KE matrix')
        !
        if (job%verbose>=5) write(out,"(/' ...done!')")
        !
      endif
      !
      if (job%verbose>=4) write(out,"(/' Construct the Hamiltonian matrix...')") 
      !
      if (job%verbose>=5) write(out,"(' N Arrays of ',f12.5,'Gb each will be allocated (N is the number of processors)')")&
                          real(sym%Nrepresen,rk)*real(PT%max_deg_size,rk)*real(max_dim,rk)*real(rk,rk)/1024.0_rk**3
      !
      !$omp parallel private(mat_t,alloc_p) 
      allocate (mat_t(sym%Nrepresen,PT%max_deg_size,max_dim),stat=alloc_p)
      if (alloc_p/=0)  then 
      write(out,"('PThamiltonian_contract: mat_t - out of memory')") 
         stop 'PThamiltonian_contract - mat_t out of memory'
      endif 
      !
      !$omp do private(irow,isym,dimen_s,iterm,ielem,k_i,dimen_row,istart,iend) schedule(static) 
      do irow = 1,dimen
        !
        ! ithread = omp_get_thread_num()
        !
        if (job%rotsym_do) then 
          !
          call symm_mat_element_vector(jrot,irow,ijterm,PTmatrixelements_contr_gamma,mat_t)
          !
        else
          !
          call symm_mat_element_vector_k(jrot,irow,ijterm,PTmatrixelements_contr,mat_t,no_diagonalization)
          !
        endif
        !
        do isym = 1,sym%Nrepresen
            !
            if (.not.job%select_gamma(isym)) cycle
            !
            dimen_s = PT%Max_sym_levels(isym)
            !
            iterm = ijterm(irow,isym)
            !
            do ielem = 1,PT%irr(isym)%N(irow) 
              !
              k_i = k_row(isym,iterm+ielem)
              !
              istart = kblock(isym,max(k_i-2,0),1)
              iend   = kblock(isym,k_i,2)
              dimen_row = iend-istart+1
              !
              smat(isym)%coeffs(iterm+ielem,1:dimen_row) = mat_t(isym,ielem,istart:iend)
              !
            enddo
        enddo
        !
      enddo
      !$omp enddo
      !
      deallocate (mat_t)
      !$omp end parallel
      !
      if (associated(grot)) deallocate(grot)
      if (associated(gcor)) deallocate(gcor)
      if (associated(hvib%me)) deallocate(hvib%me)
      !
      call ArrayStart('hvib-matrix',0,1,4)
      call ArrayStart('grot-matrix',0,1,4)
      call ArrayStart('gcor-matrix',0,1,4)
      call ArrayStop('hvib-matrix')
      call ArrayStop('grot-matrix')
      call ArrayStop('gcor-matrix')
      !
      if (job%verbose>=4) write(out,"(/' ...done!)')") 
      !
    elseif (job%vib_rot_contr) then
      !
      if (job%verbose>=4) write(out,"(/'vib-rot contraction...')")
      !
      if (job%verbose>=4) write(out,"(/' Construct the Hamiltonian matrix...')") 
      !
      task = 'top-icontr'
      call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
      !
      if (job%verbose>=5) write(out,"(' N Arrays of ',f12.5,'Gb each will be allocated (N is the number of processors)')") &
                          real(sym%Nrepresen,rk)*real(PT%max_deg_size,rk)*real(max_dim,rk)*real(rk,rk)/1024.0_rk**3
      !
      !omp parallel private(mat_t,alloc_p) 
      allocate (mat_t(sym%Nrepresen,PT%max_deg_size,max_dim),stat=alloc_p)
      if (alloc_p/=0)  then 
      write(out,"('PThamiltonian_contract: mat_t - out of memory')") 
         stop 'PThamiltonian_contract - mat_t out of memory'
      endif
      !
      maxcontr0 = size(PT%Ncontr02icase0,dim=1)
      !
      !omp do private(icontr,task,irow,isym,dimen_s,iterm,ielem,k_i,dimen_row,istart,iend) schedule(static)
      do icontr=1,maxcontr0
         !
         if (FLrotation.and.jrot/=0) then
           !
           task = 'rot-icontr'
           call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr,icontr)
           task = 'cor-icontr'
           call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr,icontr)
           !
         endif
         !
         if ( PTvibrational_me_calc ) then
           !
           task = 'vib-icontr'
           call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr,icontr)
           !
         endif
         !
         do irow = PT%Ncontr0icase(icontr,1),PT%Ncontr0icase(icontr,2)
           !
           if (job%rotsym_do) then 
             !
             call calc_symm_mat_element_vector_contr(jrot,irow,ijterm,PTmatrixelements_contr_gamma,mat_t)
             !
           else
             !
             call calc_symm_mat_element_vector_contr_k(jrot,irow,ijterm,PTmatrixelements_contr,mat_t)
             !
           endif
           !
           do isym = 1,sym%Nrepresen
               !
               if (.not.job%select_gamma(isym)) cycle
               !
               dimen_s = PT%Max_sym_levels(isym)
               !
               iterm = ijterm(irow,isym)
               !
               do ielem = 1,PT%irr(isym)%N(irow) 
                 !
                 k_i = k_row(isym,iterm+ielem)
                 !
                 istart = kblock(isym,max(k_i-2,0),1)
                 iend   = kblock(isym,k_i,2)
                 dimen_row = iend-istart+1
                 !
                 smat(isym)%coeffs(iterm+ielem,1:dimen_row) = mat_t(isym,ielem,istart:iend)
                 !
               enddo
           enddo
           !
        enddo
      enddo
      !omp enddo
      !
      deallocate (mat_t)
      !omp end parallel
      !enddo
      !
      if (associated(grot)) deallocate(grot)
      if (associated(gcor)) deallocate(gcor)
      if (associated(hvib%me)) deallocate(hvib%me)
      !
      call ArrayStart('hvib-matrix',0,1,4)
      call ArrayStart('grot-matrix',0,1,4)
      call ArrayStart('gcor-matrix',0,1,4)
      call ArrayStop('hvib-matrix')
      call ArrayStop('grot-matrix')
      call ArrayStop('gcor-matrix')
      !
      if (job%verbose>=4) write(out,"(/' ...done!)')")       !
    else ! slow and cheap calculations
      !
      if (job%verbose>=4) write(out,"(/'Slow and less expensive approach...')")
      !
      if (.not.job%vib_contract) then 
        !
        write(out,"('PThamiltonian_contract: -slow- is only for J0mat representaion')") 
        stop 'PThamiltonian_contract: slow is only for J0mat'
        !
      endif 
      !
      if (FLrotation.and.jrot/=0.and..not.job%vib_rot_contr) then 
        !
        if (job%verbose>=4) write(out,"('   Rotational part...')")
        !
        task = 'rot'
        !
        call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
        !
        !$omp parallel private(mat_t,alloc_p) 
        allocate (mat_t(sym%Nrepresen,PT%max_deg_size,max_dim),stat=alloc_p)
        if (alloc_p/=0)  then 
        write(out,"('PThamiltonian_contract: mat_t - out of memory')") 
           stop 'PThamiltonian_contract - mat_t out of memory'
        endif
        !
        !$omp do private(irow,isym,dimen_s,iterm,ielem,k_i,dimen_row,istart,iend) schedule(static) 
        do irow = 1,dimen
          !
          ! ithread = omp_get_thread_num()
          !
          !call symm_mat_element_vector_k(jrot,irow,ijterm,PTmatrixelements_contr_grot,mat_t)
          !
          if (job%rotsym_do) then 
            !
            call symm_mat_element_vector(jrot,irow,ijterm,PTmatrixelements_symrot_contr_grot,mat_t)
            !
          else
            !
            call symm_mat_element_vector_k(jrot,irow,ijterm,PTmatrixelements_contr_grot,mat_t,no_diagonalization)
            !
          endif
          !
          do isym = 1,sym%Nrepresen
              !
              if (.not.job%select_gamma(isym)) cycle
              !
              dimen_s = PT%Max_sym_levels(isym)
              !
              iterm = ijterm(irow,isym)
              !
              do ielem = 1,PT%irr(isym)%N(irow) 
                !
                k_i = k_row(isym,iterm+ielem)
                !
                istart = kblock(isym,max(k_i-2,0),1)
                iend   = kblock(isym,k_i,2)
                dimen_row = iend-istart+1
                !
                smat(isym)%coeffs(iterm+ielem,1:dimen_row) = mat_t(isym,ielem,istart:iend)
                !
              enddo
          enddo
          !
        enddo
        !$omp enddo
        !
        deallocate (mat_t)
        !$omp end parallel
        !
        do k_i = 1,3
          do k_j = 1,3
            deallocate(grot(k_i,k_j)%me)
          enddo
        enddo
        !
        deallocate(grot)
        call Arraystop('grot-matrix')
        !
        if (job%verbose>=4) write(out,"('   Coriolis part...')")
        !
        task = 'cor'
        !
        call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
        !
        !$omp parallel private(mat_t,alloc_p) 
        allocate (mat_t(sym%Nrepresen,PT%max_deg_size,max_dim),stat=alloc_p)
        if (alloc_p/=0)  then 
        write(out,"('PThamiltonian_contract: mat_t - out of memory')") 
           stop 'PThamiltonian_contract - mat_t out of memory'
        endif 
        !
        !$omp do private(irow,isym,dimen_s,iterm,ielem,k_i,dimen_row,istart,iend) schedule(static) 
        do irow = 1,dimen
          !
          ! ithread = 1
          ! ithread = omp_get_thread_num()
          !
          !call symm_mat_element_vector_k(jrot,irow,ijterm,PTmatrixelements_contr_gcor,mat_t)
          !
          if (job%rotsym_do) then 
            !
            call symm_mat_element_vector(jrot,irow,ijterm,PTmatrixelements_symrot_contr_gcor,mat_t)
            !
          else
            !
            call symm_mat_element_vector_k(jrot,irow,ijterm,PTmatrixelements_contr_gcor,mat_t)
            !
          endif
          !
          do isym = 1,sym%Nrepresen
              !
              if (.not.job%select_gamma(isym)) cycle
              !
              dimen_s = PT%Max_sym_levels(isym)
              !
              iterm = ijterm(irow,isym)
              !
              do ielem = 1,PT%irr(isym)%N(irow) 
                !
                k_i = k_row(isym,iterm+ielem)
                !
                istart = kblock(isym,max(k_i-2,0),1)
                iend   = kblock(isym,k_i,2)
                dimen_row = iend-istart+1
                !
                smat(isym)%coeffs(iterm+ielem,1:dimen_row) = smat(isym)%coeffs(iterm+ielem,1:dimen_row) + &
                                                             mat_t(isym,ielem,istart:iend)
                !
              enddo
          enddo
          !
        enddo
        !$omp enddo
        !
        deallocate (mat_t)
        !$omp end parallel
        !
        do k_i = 1,3
          deallocate(gcor(k_i)%me)
        enddo
        !
        deallocate(gcor)
        call Arraystop('gcor-matrix')
        !
      endif
      ! 
      ! It's time to get of the gvib-grot-gcor fields, which are usually large.
      !
      if ( PTvibrational_me_calc ) then
        !
        if (job%verbose>=4) write(out,"('   Vibrational part...')")
        !
        task = 'vib'
        !
        call PTrestore_rot_kinetic_matrix_elements(jrot,task,iunit,dimen,ncontr,maxcontr)
        !
        !$omp parallel private(mat_t,alloc_p) 
        allocate (mat_t(sym%Nrepresen,PT%max_deg_size,max_dim),stat=alloc_p)
        if (alloc_p/=0)  then 
        write(out,"('PThamiltonian_contract: mat_t - out of memory')") 
           stop 'PThamiltonian_contract - mat_t out of memory'
        endif 
        !
        !$omp do private(irow,isym,dimen_s,iterm,ielem,k_i,dimen_row,istart,iend) schedule(static) 
        do irow = 1,dimen
          !
          ! ithread = 1
          ! ithread = omp_get_thread_num()
          !
          !call symm_mat_element_vector_k(jrot,irow,ijterm,PTmatrixelements_contr_hvib,mat_t)
          !
          if (job%rotsym_do) then 
            !
            call symm_mat_element_vector(jrot,irow,ijterm,PTmatrixelements_symrot_contr_hvib,mat_t)
            !
          else
            !
            call symm_mat_element_vector_k(jrot,irow,ijterm,PTmatrixelements_contr_hvib,mat_t)
            !
          endif
          !
          do isym = 1,sym%Nrepresen
              !
              if (.not.job%select_gamma(isym)) cycle
              !
              dimen_s = PT%Max_sym_levels(isym)
              !
              iterm = ijterm(irow,isym)
              !
              do ielem = 1,PT%irr(isym)%N(irow) 
                !
                k_i = k_row(isym,iterm+ielem)
                !
                istart = kblock(isym,max(k_i-2,0),1)
                iend   = kblock(isym,k_i,2)
                dimen_row = iend-istart+1
                !
                smat(isym)%coeffs(iterm+ielem,1:dimen_row) = smat(isym)%coeffs(iterm+ielem,1:dimen_row) + &
                                                             mat_t(isym,ielem,istart:iend)
                !
              enddo
          enddo
          !
        enddo
        !$omp enddo
        !
        deallocate (mat_t)
        !$omp end parallel
        !
        deallocate(hvib%me)
        !
        call ArrayStart('hvib-matrix',0,1,4)
        call ArrayStart('grot-matrix',0,1,4)
        call ArrayStart('gcor-matrix',0,1,4)
        call ArrayStop('hvib-matrix')
        call ArrayStop('grot-matrix')
        call ArrayStop('gcor-matrix')
        !
      endif 
      !
    endif
    !
    call TimerStop('Calculating the Hamiltonian matrix')
    !
    if (job%verbose>=4) write(out,"('...done!')")
    ! Correction for the case we do not compute the vibrational part of the 
    ! Hamiltonian:
    !
    if (.not.PTvibrational_me_calc) then 
      !
      if (job%verbose>=3) write(out,"('Diagonal correction...')")
      !
      do isym = 1,sym%Nrepresen
        !
        if (.not.job%select_gamma(isym)) cycle
        !
        !$omp parallel do private(ielem,icase,slevel,k_i,iterm) 
        do ielem = 1,Nterms(isym)
           !
           icase    = PT%symactive_space(isym)%sym_N(ielem,1)
           slevel   = PT%contractive_space(1,icase)
           !
           k_i = k_row(isym,ielem)
           !
           iterm = ielem - kblock(isym,max(k_i-2,0),1) + 1
           !
           smat(isym)%coeffs(ielem,iterm) = smat(isym)%coeffs(ielem,iterm) + &
                                            contr(1)%eigen(slevel)%value
        enddo
        !$omp end parallel do
        !
      enddo
      !
    endif 
    !
    ! Loop over all symmetries and diagonalize or save to disk the Hamiltonian matrices. 
    ! For diagonalization, the smat-object is copied to the real matrix a. 
    ! For storing only the lower part is saved. 
    !
    rlevel = PTNlevels
    total_roots = PTNroots
    zpe = 0 
    !
    do isym = 1,sym%Nrepresen
      !
      if (.not.job%select_gamma(isym)) cycle
      !
      dimen_s = PT%Max_sym_levels(isym)
      !
      allocate (bterm(dimen_s,2),stat=alloc)
      call ArrayStart('PThamiltonian_contract:bterm',alloc,size(bterm),kind(bterm))
      !
      if (job%sparse) then 
        !
        dimen_maxrow = 1
        do k_i = 0,jrot
          dimen_row = kblock(isym,min(k_i+2,jrot),2)-kblock(isym,max(k_i-2,0),1)+1
          dimen_maxrow = max(dimen_maxrow,dimen_row)
          if (job%verbose>=6) write(out,"('k_i = ',i9,'; dimen_row = ',i9)") k_i,dimen_row
        enddo
        !
        !if (job%nroots(isym)/=1000000) nroots = min(job%nroots(isym),dimen_s)
        !
        nroots = min(job%nroots(isym),dimen_s)
        if (job%nroots(isym)==0.or.job%nroots(isym)==1000000) nroots=dimen_maxrow
        !        
        dimen_maxrow = max(dimen_maxrow,nroots)
        !
        if (only_store.or.no_diagonalization) then 
          !
          allocate (a(dimen_s,1),stat=alloc)
          call ArrayStart('PThamiltonian_contract:a',alloc,size(a),kind(a))
          !
        else 
          !
          matsize = int(dimen_s,hik)*int(dimen_maxrow,hik)
          if (job%verbose>=4) write(out,"('Allocate array a (sparse)',i8,'x',i8,' = ',i9)") dimen_s,dimen_maxrow,matsize
          allocate (a(dimen_s,dimen_maxrow),stat=alloc)
          !
          call ArrayStart('PThamiltonian_contract:a',alloc,1,kind(a),matsize)
          !
        endif
        !
      else 
        !
        matsize = 1
        !
        if (only_store.or.no_diagonalization) then 
          !
          allocate (a(dimen_s,1),stat=alloc)
          call ArrayStart('PThamiltonian_contract:a',alloc,size(a),kind(a))
          !
        elseif (.not.only_store) then 
          !
          matsize = int(dimen_s,hik)*int(dimen_s,hik)
          if (job%verbose>=4) write(out,"('Allocate array a',i8,'x',i8,' = ',i9)") dimen_s,dimen_s,matsize
          allocate (a(dimen_s,dimen_s),stat=alloc)
          !
          call ArrayStart('PThamiltonian_contract:a',alloc,1,kind(a),matsize)
          !
        endif
        !
      endif
      !
      if (job%verbose>=4) call MemoryReport
      !
      if (job%verbose>=4) write(out,"(/'   Prepare the sparse representation address-array...')")
      !
      !$omp parallel do private(ielem,icase,slevel,k_i,dimen_row,istart,iend) shared(bterm)
      do ielem = 1,Nterms(isym)
         !
         icase    = PT%symactive_space(isym)%sym_N(ielem,1)
         slevel   = PT%contractive_space(1,icase)
         !
         k_i = k_row(isym,ielem)
         !
         dimen_row = kblock(isym,k_i,2)-kblock(isym,max(k_i-2,0),1)+1
         !
         bterm(ielem,1) = kblock(isym,max(k_i-2,   0),1)
         bterm(ielem,2) = kblock(isym,min(k_i+2,jrot),2)
         !
      enddo
      !$omp end parallel do
      !
      if (job%verbose>=4) write(out,"(/'   ...done!')")
      !
      !
      ! prepare a unit for saving the matrix to the disk, if required 
      !
      if (only_store) then 
        !
        write(unitfname,"('matrix for j = ',i6,' sym = ',i4)") jrot,isym
        !
        call IOStart(trim(unitfname),chkptIO)
        !
        write(jchar, '(i4)') jrot
        write(symchar, '(i4)') isym
        filename = trim(job%matrix_file)//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))//'.chk'
        !
        open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
        !
        write(chkptIO) dimen_s
        !
        write(chkptIO) 'Lower'
        if (job%sparse) then 
          write(chkptIO) 'spar'
          write(chkptIO) 'Start bterm'
          write(chkptIO) bterm
        else
          write(chkptIO) 'full'
        endif
        !
        write(chkptIO) 'Start matrix'
        !
        do ielem = 1,dimen_s
           !
           if (job%sparse) then
             !
             dimen_row = ielem-bterm(ielem,1)+1
             !
             a(1:dimen_row,1) = smat(isym)%coeffs(ielem,1:dimen_row)
             !
             do jelem = ielem+1,bterm(ielem,2)
               !
               k_j = jelem - bterm(ielem,1) + 1
               k_i = ielem - bterm(jelem,1) + 1
               !
               a(k_j,1) = smat(isym)%coeffs(jelem,k_i)
               !
             enddo
             !
             dimen_row = bterm(ielem,2)-bterm(ielem,1)+1
             !
             write(chkptIO) a(1:dimen_row,1)
             !
           else
             !
             a = 0
             !
             icase    = PT%symactive_space(isym)%sym_N(ielem,1)
             slevel   = PT%contractive_space(1,icase)
             !
             k_i = k_row(isym,ielem)
             !
             dimen_row = kblock(isym,k_i,2)-kblock(isym,max(k_i-2,0),1)+1
             !
             istart = kblock(isym,max(k_i-2,0),1)
             iend   = kblock(isym,k_i,2)
             !
             a(istart:iend,1) = smat(isym)%coeffs(ielem,1:dimen_row)
             !
             write(chkptIO) a
             !
           endif
           !
        enddo
        !
        nroots = 0
        !
        write(chkptIO) 'End matrix'
        close(chkptIO,status='keep')
        !
        deallocate (smat(isym)%coeffs)
        call Arraystop('PThamiltonian_contract:smat'//sym%label(isym))
        !
      elseif (no_diagonalization) then 
        !
        do ielem = 1,Nterms(isym)
           !
           icase    = PT%symactive_space(isym)%sym_N(ielem,1)
           slevel   = PT%contractive_space(1,icase)
           !
           k_i = k_row(isym,ielem)
           !
           dimen_row = kblock(isym,k_i,2)-kblock(isym,max(k_i-2,0),1)+1
           !
           if (job%sparse) then 
             !
             dimen_row = ielem-bterm(ielem,1)+1
             !
             a(ielem,1) = smat(isym)%coeffs(ielem,dimen_row)
             !
           else
             !
             istart = kblock(isym,max(k_i-2,0),1)
             iend   = ielem-istart+1
             !
             a(ielem,1) = smat(isym)%coeffs(ielem,iend)
             !
           endif 
           !
        enddo
        !
        !do ielem = 1,dimen_s
        !   !
        !   if (job%sparse) then
        !     !
        !     dimen_row = ielem-bterm(ielem,1)+1
        !     !
        !     a(ielem,1) = smat(isym)%coeffs(ielem,dimen_row)
        !     !
        !   else
        !     !
        !     a(ielem,1) = smat(isym)%coeffs(ielem,ielem)
        !     !
        !   endif
        !   !
        !enddo
        !
        call diagonalization_contract(jrot,isym,dimen_s,a,zpe,rlevel,total_roots,bterm,k_row(isym,1:dimen_s)) 
        !
      else ! diagonalize
        !
        a = 0 
        !
        if (job%verbose>=3) write(out,"(/'Prepare the lower part of the matrix...')")
        !
        !$omp parallel do private(ielem,icase,slevel,k_i,dimen_row,istart,iend) shared(bterm)
        do ielem = 1,Nterms(isym)
           !
           icase    = PT%symactive_space(isym)%sym_N(ielem,1)
           slevel   = PT%contractive_space(1,icase)
           !
           k_i = k_row(isym,ielem)
           !
           dimen_row = kblock(isym,k_i,2)-kblock(isym,max(k_i-2,0),1)+1
           !
           if (job%sparse) then 
             !
             a(ielem,1:dimen_row) = smat(isym)%coeffs(ielem,1:dimen_row)
             !
           else
             !
             istart = kblock(isym,max(k_i-2,0),1)
             iend   = kblock(isym,k_i,2)
             !
             a(ielem,istart:iend) = smat(isym)%coeffs(ielem,1:dimen_row)
             !
           endif 
           !
        enddo
        !$omp end parallel do
        !
        if (job%verbose>=3) write(out,"('...and the upper part...')")
        !
        !$omp parallel do private(ielem,k_i,istart,jelem,k_j,jstart,iterm,jterm) shared(a) schedule(dynamic)
        do ielem = 1,Nterms(isym)
           !
           if (job%sparse) then 
             !
             k_i = k_row(isym,ielem)
             istart = kblock(isym,max(k_i-2,0),1)
             !
             do jelem = ielem+1,kblock(isym,min(k_i+2,jrot),2)
               k_j = k_row(isym,jelem)
               jstart  = kblock(isym,max(k_j-2,0),1)
               !
               iterm = ielem-jstart+1
               jterm = jelem-istart+1
               !
               a(ielem,jterm) = a(jelem,iterm)
               !
             enddo
             !
           else
             !
             a(1:ielem-1,ielem) = a(ielem,1:ielem-1)
             !
           endif 
           !
        enddo
        !$omp end parallel do
        !
        ! Diagonalization
        !
        deallocate (smat(isym)%coeffs)
        call Arraystop('PThamiltonian_contract:smat'//sym%label(isym))
        !
        if (job%verbose>=3) write(out,"('Diagonalization...')")
        !
        if (job%verbose>=1) then 
           write (out,"(//'Size of the symmetrized hamiltonian = ',i7,' Symmetry = ',a4)") dimen_s,sym%label(isym)
           ! write (out,"(/'Variation solution (symmetrized):',/'  Gamma    i       value            j  k  t   quanta')") 
        endif
        !
        call diagonalization_contract(jrot,isym,dimen_s,a,zpe,rlevel,total_roots,bterm,k_row(isym,1:dimen_s)) 
        !
      endif ! store vs diagonalize
      !
      deallocate (bterm)
      call ArrayStop('PThamiltonian_contract:bterm')
      !
      !deallocate (smat(isym)%coeffs)
      !
      !if (.not.only_store.and..not.sparse) then 
      if (allocated(a)) then 
        call ArrayStop('PThamiltonian_contract:a')
        deallocate (a)
      endif
      !
    enddo
    !
    if ( trim(job%IOeigen_action)=='SAVE'.or.trim(job%IOeigen_action)=='APPEND' ) then
      !
      call check_point_active_space('CLOSE')
      !
    endif 
    !
    ! close and keep files with the compacted vectors
    !
    if (job%IOeigen_compress) then
      !
      close(unit = unitO,status='keep')
      close(unit = unitC,status='keep')
      !
    endif
    !
    ! free more memory 
    do ielem =1,size(contr(0)%rot(:))
      if (associated(contr(0)%rot(ielem)%coeff3d)) deallocate(contr(0)%rot(ielem)%coeff3d)
    enddo 
    call ArrayStart('contr(0)-rot-coeff3d',0,1,4)
    call ArrayStop('contr(0)-rot-coeff3d')
    !
    deallocate(ijterm,k_row)
    !
    !if (job%verbose>=1) write (out,"('Constraction of the contracted matrix ..... done!  ')") 
    !
    if (job%verbose>=5) write(out,"(/'PThamiltonian_contract/end ')") 
    !
    call TimerStop('Contracted Hamiltonian')
    !
  end subroutine PThamiltonian_contract
  !
  !
  ! Here we restore the vibrational (J=0) matrix elements of the rotational kinetic part G_rot and G_cor
  !
  subroutine PTrestore_rot_kinetic_matrix_elements(jrot,task,chkptIO,dimen,ncontr,maxcontr,icontr)
    !
    integer(ik),intent(in)  :: jrot
    character(len=cl),intent(in)  :: task
    integer(ik),intent(inout)    :: chkptIO
    integer(ik),intent(in)       :: dimen
    integer(ik),intent(inout),optional :: ncontr
    integer(ik),intent(inout),optional  :: maxcontr
    integer(ik),intent(in),optional     :: icontr
    !
    integer(ik)   :: alloc
    character(len=cl)  :: job_is,filename
    character(len=18)  :: buf18
    integer(ik)        :: k1,k2,j,ib0,islice,chkptIO_,ideg,icontr0,istart,iend,maxcontr0
    integer(ik),allocatable :: imat_t(:,:)
    integer(hik)         :: rootsize,rootsize_,rootsize2,rootsize2_,nprocs,tid,icontr1,icontr2
    integer              :: OMP_GET_NUM_THREADS,omp_get_thread_num
    real(rk),allocatable :: mat_t(:,:),mat_(:,:)
    real(rk)             :: f_t
    !
    ! Return if there is nothing to read
    !
    if ( trim(job%IOkinet_action)/='VIB_READ'.and.trim(job%IOkinet_action)/='READ'.and..not.job%contrci_me_fast) return
    !
    if ( trim(job%IOswap_matelem)/='NONE') return
    !
    rootsize = int(ncontr*(ncontr+1)/2,hik)
    rootsize_ = int(maxcontr*(maxcontr+1)/2,hik)
    !
    rootsize2  = int(ncontr*ncontr,hik)
    rootsize2_ = int(maxcontr*maxcontr,hik)
    !
    !dimen = max(min(int(PT%Maxcontracts*job%compress),PT%Maxcontracts),1)
    if (job%verbose>=6.and.present(icontr)) write(out,"('icontr = ',i9)") icontr
    !
    select case (trim(task))
    !
    case('top')
      !
      job_is ='Vib. matrix elements of the rot. kinetic'
      call IOStart(trim(job_is),chkptIO)
      !
      !open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=job%kinetmat_file,recordtype='variable')
      !
      open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=job%kinetmat_file)
      !
      read(chkptIO) buf18
      if (buf18/='Start Kinetic part') then
        write (out,"(' Vib. kinetic checkpoint file ',a,' has bogus header: ',a)") job%kinetmat_file,buf18
        stop 'PTrestore_rot_kinetic_matrix_elements - bogus file format'
      end if
      !
      read(chkptIO) ncontr
      !
      if (jrot==0.and.PT%Maxcontracts/=ncontr.and.(.not.trove%triatom_sing_resolve ) ) then
        write (out,"(' Vib. kinetic checkpoint file ',a)") job%kinetmat_file
        write (out,"(' Actual and stored basis sizes at J=0 do not agree  ',2i0)") PT%Maxcontracts,ncontr
        stop 'PTrestore_rot_kinetic_matrix_elements - in file - illegal nroots '
      end if
      !
      rootsize = int(ncontr*(ncontr+1)/2,hik)
      rootsize2 = int(ncontr*ncontr,hik)
      !
      if (job%verbose>=6) write(out,"(/'Restore_rot_kin...: Number of elements: ',i8)") PT%Maxcontracts
      !
      ! Read the indexes of the J=0 contracted basis set. 
      !
      if (.not.FLrotation.or.jrot==0) then
        !
        allocate (imat_t(0:PT%Nclasses,ncontr),stat=alloc)
        call ArrayStart('mat_t',alloc,size(imat_t),kind(imat_t))
        !
        read(chkptIO) buf18(1:10)
        if (buf18(1:10)/='icontr_cnu') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': icontr_cnu is missing ',a)") job%kinetmat_file,buf18(1:10)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  icontr_cnu missing'
        end if
        !
        read(chkptIO) imat_t(0:PT%Nclasses,1:ncontr)
        !
        read(chkptIO) buf18(1:11)
        if (buf18(1:11)/='icontr_ideg') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': icontr_ideg is missing ',a)") job%kinetmat_file,buf18(1:11)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  icontr_ideg missing'
        end if
        !
        read(chkptIO) imat_t(0:PT%Nclasses,1:ncontr)
        !
        deallocate(imat_t)
        !
      else
        !
        allocate (PT%icontr_cnu(0:PT%Nclasses,ncontr),PT%icontr_ideg(0:PT%Nclasses,ncontr),stat=alloc)
        call ArrayStart('PT%contractive_space',alloc,size(PT%icontr_cnu),kind(PT%icontr_cnu))
        call ArrayStart('PT%contractive_space',alloc,size(PT%icontr_ideg),kind(PT%icontr_ideg))
        !
        deallocate(PT%icontr2icase)
        call Arraystop('PT%contractive_space')
        !
        allocate (PT%icontr2icase(ncontr,2),stat=alloc)
        call ArrayStart('PT%contractive_space',alloc,size(PT%icontr2icase),kind(PT%icontr2icase))
        !
        read(chkptIO) buf18(1:10)
        if (buf18(1:10)/='icontr_cnu') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': icontr_cnu is missing ',a)") job%kinetmat_file,buf18(1:10)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  icontr_cnu missing'
        end if
        !
        read(chkptIO) PT%icontr_cnu(0:PT%Nclasses,1:ncontr)
        !
        read(chkptIO) buf18(1:11)
        if (buf18(1:11)/='icontr_ideg') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': icontr_ideg is missing ',a)") job%kinetmat_file,buf18(1:11)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  icontr_ideg missing'
        end if
        !
        read(chkptIO) PT%icontr_ideg(0:PT%Nclasses,1:ncontr)
        !
      endif
      !
      if (job%vib_rot_contr.and.PTvibrational_me_calc) then
        !
        read(chkptIO) buf18(1:7)
        if (buf18(1:7)/='vib-rot') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': label vib-rot is missing ',a)") job%kinetmat_file,buf18(1:7)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  vib-rot missing'
        end if
        !
        close(chkptIO)
        !
        write(job_is,"('single swap_matrix')")
        !
        call IOStart(trim(job_is),chkptIO)
        !
        filename = trim(job%matelem_suffix)//"0"//'.chk'
        !
        open(chkptIO,form='unformatted',action='read',status='old',file=filename)
        !
      endif
      !
      ! reconstruct the correlation between the vib. indices for J=0 and current J
      !
      call Find_groundstate_icontr(maxcontr)
      !
      if (job%verbose>=4) write(out,"('   ...done!')")
      !
      if (job%verbose>=4.and.maxcontr/=ncontr) then
        write (out,"('   The contracted basis set is reduced: ',i8,' -> ',i8)") ncontr,maxcontr
      end if
      !
      if (maxcontr>ncontr) then
        write (out,"(' Actual and stored basis sizes at J=0 do not agree (maxcontr,ncontr)  ',2i8)") maxcontr,ncontr
        stop 'PTrestore_rot_kinetic_matrix_elements - in file - illegal ncontr '
      end if
      !
    case('rot')
      !
      if (job%verbose>=4) write(out,"('   Read and process rotational part...')")
      !
      ! Read the rotational part only 
      !
      allocate(mat_(maxcontr,maxcontr),stat=alloc)
      call ArrayStart('PThamiltonian_contract: mat_',alloc,1,kind(mat_),rootsize2_)
      !
      if (.not.job%IOmatelem_split) then
        !
        read(chkptIO) buf18(1:5)
        if (buf18(1:5)/='g_rot') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': g_rot is missing ',a)") job%kinetmat_file,buf18(1:5)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  g_rot missing'
        end if
        !
      endif
      !
      allocate(grot(3,3),stat=alloc)
      !
      islice = 0
      chkptIO_ = chkptIO
      !
      do k1 = 1,3
        !
        do k2 = 1,3
          !
          islice = islice + 1
          !
          call divided_slice_open(islice,chkptIO_,'g_rot',job%matelem_suffix)
          !
          allocate(grot(k1,k2)%me(maxcontr,maxcontr),stat=alloc)
          call ArrayStart('grot-matrix',alloc,1,kind(f_t),rootsize2_)
          !
          read(chkptIO_) mat_
          !
          grot(k1,k2)%me(1:ncontr,1:ncontr) = mat_(1:ncontr,1:ncontr)
          !
          call divided_slice_close(islice,chkptIO_,'g_rot')
          !
        enddo
      enddo
      !
      deallocate(mat_)
      call ArrayStop('PThamiltonian_contract: mat_')
      !
      if (job%verbose>=4) write(out,"('   ...done!')")
      !
    case('cor')
      !
      if (job%verbose>=4) write(out,"('   Read and process Coriolis part...')")
      !
      allocate(mat_(maxcontr,maxcontr),stat=alloc)
      call ArrayStart('PThamiltonian_contract: mat_',alloc,1,kind(mat_),rootsize2_)
      !
      if (.not.job%IOmatelem_split) then
        !
        read(chkptIO) buf18(1:5)
        if (buf18(1:5)/='g_cor') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': g_cor is missing ',a)") job%kinetmat_file,buf18(1:5)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  g_cor missing'
        end if
        !
      endif
      !
      allocate(gcor(3),stat=alloc)
      !
      islice  = 9
      chkptIO_ = chkptIO
      !
      do k1 = 1,3
        !
        islice = islice + 1
        !
        allocate(gcor(k1)%me(maxcontr,maxcontr),stat=alloc)
        call ArrayStart('gcor-matrix',alloc,1,kind(f_t),rootsize2_)
        !
        call divided_slice_open(islice,chkptIO_,'g_cor',job%matelem_suffix)
        !
        read(chkptIO_) mat_
        !
        gcor(k1)%me(1:ncontr,1:ncontr) = mat_(1:ncontr,1:ncontr)
        !
        call divided_slice_close(islice,chkptIO_,'g_cor')
        !
      enddo
      !
      deallocate(mat_)
      call ArrayStop('PThamiltonian_contract: mat_')
      !
      if (job%verbose>=4) write(out,"('   ...done!')")
      !
    case('vib')
      !
      if (job%verbose>=4) write(out,"('   Read and process vibrational part...')")
      !
      if (.not.job%IOmatelem_split.and.( (.not.FLrotation.or.jrot==0).and.trim(job%IOkinet_action)/='VIB_READ' ) ) then
        !
        allocate(mat_t(maxcontr,maxcontr),stat=alloc)
        call ArrayStart('PThamiltonian_contract: mat_t',alloc,1,kind(mat_t),rootsize2_)
        !
        read(chkptIO) buf18(1:5)
        if (buf18(1:5)/='g_rot') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': g_rot is missing ',a)") job%kinetmat_file,buf18(1:5)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  g_rot missing'
        end if
        !
        do k1 = 1,3
          do k2 = 1,3
            !
            read(chkptIO) mat_t
            !
          enddo
        enddo
        !
        read(chkptIO) buf18(1:5)
        if (buf18(1:5)/='g_cor') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': g_cor is missing ',a)") job%kinetmat_file,buf18(1:5)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  g_cor missing'
        end if
        !
        !do k1 = 1,PT%Nmodes
        do k2 = 1,3
          !
          read(chkptIO) mat_t
          !
        enddo
        !enddo
        !
        deallocate(mat_t)
        call ArrayStop('mat_t')
        !
      endif
      !
      if (job%verbose>=6) write(out,"('   rootsize_,rootsize = ',2i0)") rootsize_,rootsize
      !
      read(chkptIO) buf18(1:4)
      if (buf18(1:4)/='hvib') then
        write (out,"(' Vib. kinetic checkpoint file ',a,': hvib is missing ',a)") job%kinetmat_file,buf18(1:4)
        if (buf18(1:4)=='g_ro') then 
          write (out,"(' Most likely non-divided chk-points used with MATELEM READ SPLIT')") 
          write (out,"(' Re-do MATELEM SAVE SPLIT or use MATELEM SPLIT READ')") 
        endif
        stop 'PTrestore_rot_kinetic_matrix_elements - in file -  hvib or End missing'
      end if
      !
      allocate(mat_(maxcontr,maxcontr),stat=alloc)
      call ArrayStart('PThamiltonian_contract: mat_',alloc,1,kind(mat_),rootsize2_)
      !
      allocate(hvib%me(maxcontr,maxcontr),stat=alloc)
      call ArrayStart('hvib-matrix',alloc,1,kind(f_t),rootsize2_)
      !
      read(chkptIO) mat_
      !
      hvib%me(1:ncontr,1:ncontr) = mat_(1:ncontr,1:ncontr)
      !
      deallocate(mat_)
      call ArrayStop('PThamiltonian_contract: mat_')
      !
      read(chkptIO) buf18(1:16)
      if (buf18(1:16)/='End Kinetic part') then
        write (out,"(' Vib. kinetic checkpoint file ',a,' has bogus footer: ',a)") job%kinetmat_file,buf18(1:16)
        stop 'PTrestore_rot_kinetic_matrix_elements - bogus file format'
      end if
      !
      close(chkptIO,status='keep')
      !
      if (job%verbose>=4) write(out,"('   ...done!')")
      !
    case('top-icontr')
      !  
      nprocs = 1
      tid = 0
      !$omp parallel private(tid)
        tid = omp_get_thread_num()
        if (tid==0) then
           nprocs = omp_get_num_threads()
        endif
      !$omp end parallel
      !
      if (FLrotation.and.jrot/=0) then
        !
        allocate(grot(3,3),stat=alloc)
        !
        rootsize2_ = int(maxcontr,hik)*int(PT%max_deg_size,hik)*9_hik*int(nprocs,hik)
        call ArrayStart('PThamiltonian_contract: grot',alloc,1,rk,rootsize2_)
        !
        allocate(gcor(3),stat=alloc)
        rootsize2_ = int(maxcontr,hik)*int(PT%max_deg_size,hik)*int(PT%Nmodes,hik)*3_hik*int(nprocs,hik)
        call ArrayStart('PThamiltonian_contract: grot',alloc,1,rk,rootsize2_)
        !
        if (job%vib_rot_contr) then
          !
          do islice = 1,9+3*PT%Nmodes
              call divided_slice_open_vib_rot(islice,job%matelem_suffix)
          enddo
          !
        endif
        !
      endif
      !
    case('rot-icontr') ! rotational part for the vib-rot contraction scheme
      !
      ! Read the rotational part only
      !
      if (.not.job%IOmatelem_split ) then
        !
        write (out,"('PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with MATELEM SAVE SPLIT only ')")
        stop 'PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with SPLIT only'
        !
      endif
      !
      if (.not.job%vib_rot_contr) return
      !
      icontr1 = PT%Ncontr02icase0(icontr,1)
      icontr2 = PT%Ncontr02icase0(icontr,2)
      !
      islice = 0
      !
      do k1 = 1,3
        do k2 = 1,3
          !
          islice = islice + 1
          !
          nullify(grot(k1,k2)%me)
          !
          if (associated(grot(k1,k2)%me)) deallocate(grot(k1,k2)%me)
          !
          allocate(grot(k1,k2)%me(maxcontr,icontr1:icontr2),stat=alloc)
          !
          write(job_is,"('single swap_matrix #',i8)") islice
          call IOStart(trim(job_is),chkptIO_)
          !
          read(chkptIO_) grot(k1,k2)%me
          !
        enddo
      enddo
      !
    case('cor-icontr') ! corriolis part for the vib-rot contraction scheme
      !
      ! Read the Corriolis part only
      !
      !
      if (.not.job%IOmatelem_split ) then
        !
        write (out,"('PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with MATELEM SAVE SPLIT only ')")
        stop 'PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with SPLIT only'
        !
      endif
      !
      if (.not.job%vib_rot_contr) then
        !
        write (out,"('PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with cor-icontr only ')")
        stop 'PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with cor-icontr only'
        !
      endif
      !
      icontr1 = PT%Ncontr02icase0(icontr,1)
      icontr2 = PT%Ncontr02icase0(icontr,2)
      !
      islice  = 9
      !
      do k1 = 1,3
        !
        islice = islice + 1
        !
        nullify(gcor(k1)%me)
        !
        if (associated(gcor(k1)%me)) deallocate(gcor(k1)%me)
        !
        allocate(gcor(k1)%me(maxcontr,icontr1:icontr2),stat=alloc)
        !
        write(job_is,"('single swap_matrix #',i8)") islice
        call IOStart(trim(job_is),chkptIO_)
        !
        read(chkptIO_) gcor(k1)%me
        !
      enddo
      !
    case('vib-icontr') ! vibrational part for the vib-rot contraction scheme
      !
      !
      !if (job%verbose>=4.and.irow==0) write(out,"('   Read and process vibrational part...')")
      !
      if (.not.job%IOmatelem_split.and.( (.not.FLrotation.or.jrot==0).and.trim(job%IOkinet_action)/='VIB_READ' ) ) then
        !
        if (job%vib_rot_contr) then
          write (out,"('PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with MATELEM SAVE SPLIT only ')")
          stop 'PTrestore_rot_kinetic_matrix_elements: vib-rot can be used with SPLIT  only'
        endif
        !
      endif
      !
      if (icontr==1) then 
        !
        read(chkptIO) buf18(1:4)
        if (buf18(1:4)/='hvib') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': hvib is missing ',a)") job%kinetmat_file,buf18(1:4)
          if (buf18(1:4)=='g_ro') write (out,"(' Most likely non-divided chk-points used with MATELEM READ DIVIDED')") 
          write (out,"(' Re-do MATELEM SAVE DIVIDE or use MATELEM READ!')") 
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  hvib or End missing'
        end if
        !
      endif
      !
      if (associated(hvib%me)) deallocate(hvib%me)
      !
      call ArrayStart('hvib-matrix',0,1,4)
      call ArrayStart('grot-matrix',0,1,4)
      call ArrayStart('gcor-matrix',0,1,4)
      call ArrayStop('hvib-matrix')
      call ArrayStop('grot-matrix')
      call ArrayStop('gcor-matrix')
      !
      icontr1 = PT%Ncontr02icase0(icontr,1)
      icontr2 = PT%Ncontr02icase0(icontr,2)
      !
      if (job%verbose>=6) write(out,"('allocate hvib for ',i9,' x ',i8,' -> ',i8)") maxcontr,icontr1,icontr2
      !
      allocate(hvib%me(maxcontr,icontr1:icontr2),stat=alloc)
      call ArrayStart('hvib-matrix',alloc,1,kind(f_t),rootsize2_)
      !
      read(chkptIO) hvib%me
      !
      maxcontr0 = size(PT%Ncontr02icase0,dim=1)
      !
      if (icontr==maxcontr0) then 
        !
        read(chkptIO) buf18(1:4)
        if (buf18(1:4)/='hvib') then
          write (out,"(' Vib. kinetic checkpoint file ',a,' has bogus footer: ',a)") job%kinetmat_file,buf18(1:16)
          stop 'PTrestore_rot_kinetic_matrix_elements - bogus file format'
        end if
        !
        close(chkptIO,status='keep')
        !
        if (job%verbose>=4) write(out,"('   ...done!')")
        !
      endif
      !
    end select
    !
  contains 

    !
    subroutine divided_slice_open(islice,chkptIO,name,suffix)
      !
      implicit none
      integer(ik),intent(in)      :: islice
      integer(ik),intent(inout)   :: chkptIO
      character(len=*),intent(in) :: name,suffix
      character(len=4)            :: jchar
      character(len=cl)           :: buf,filename,job_is
      integer(ik)                 :: ilen
      logical                     :: ifopened
      !
      if (.not.job%IOmatelem_split) return
      !
      write(job_is,"('single swap_matrix')")
      !
      call IOStart(trim(job_is),chkptIO)
      !
      write(jchar, '(i4)') islice
      !
      filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
      !
      open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=filename)
      !
      ilen = LEN_TRIM(name)
      !
      read(chkptIO) buf(1:ilen)
      if ( trim(buf(1:ilen))/=trim(name) ) then
        write (out,"(' kinetic checkpoint slice ',a20,': header is missing or wrong',a)") filename,buf(1:ilen)
        stop 'PTrestore_rot_kinetic_matrix_elements - in slice -  header missing or wrong'
      end if
      !
    end subroutine divided_slice_open
    !
    subroutine divided_slice_close(islice,chkptIO,name)
      !
      integer(ik),intent(in) :: islice
      integer(ik),intent(inout) :: chkptIO
      character(len=*),intent(in) :: name
      character(len=4) :: jchar
      character(len=cl) :: buf,filename
      integer(ik)      :: ilen
      logical          :: ifopened
      !
      if (.not.job%IOmatelem_split) return
      !
      ilen = LEN_TRIM(name)
      !
      read(chkptIO) buf(1:ilen)
      if ( trim(buf(1:ilen))/=trim(name) ) then
        write (out,"(' divided_slice_close, kinetic checkpoint slice ',a,': footer is missing or wrong',a)") &
              filename,buf(1:ilen)
        stop 'divided_slice_close - in slice -  footer missing or wrong'
      end if
      !
      close(chkptIO)
      !
    end subroutine divided_slice_close
    !
    subroutine divided_slice_open_vib_rot(islice,suffix)
      !
      implicit none
      integer(ik),intent(in)      :: islice
      character(len=*),intent(in) :: suffix
      integer(ik)                 :: chkptIO
      character(len=4)            :: jchar
      character(len=cl)           :: buf,filename,job_is
      integer(ik)                 :: ilen
      logical                     :: ifopened
      !
      if (.not.job%IOmatelem_split) return
      !
      write(jchar, '(i4)') islice
      !
      filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
      !
      write(job_is,"('single swap_matrix #',i8)") islice
      !
      call IOStart(trim(job_is),chkptIO)
      !
      open(chkptIO,form='unformatted',action='read',status='old',file=filename)
      !
      ilen = 4
      !
      read(chkptIO) buf(1:ilen)
      if ( trim(buf(1:ilen))/='grot'.and.trim(buf(1:ilen))/='gcor' ) then
        write (out,"(' kinetic checkpoint slice ',a20,': header is missing or wrong',a)") filename,buf(1:ilen)
        stop 'PTrestore_rot_kinetic_matrix_elements - in slice -  header missing or wrong'
      end if
      !
    end subroutine divided_slice_open_vib_rot
    !
    subroutine divided_slice_close_vib_rot(islice,name,chkptIO)
      !
      integer(ik),intent(in)  :: islice
      character(len=*),intent(in) :: name
      integer(ik),intent(in)  :: chkptIO
      character(len=4) :: jchar
      character(len=cl) :: buf,filename,job_is
      integer(ik)      :: ilen
      logical          :: ifopened
      !
      if (.not.job%IOmatelem_split) return
      !
      ilen = LEN_TRIM(name)
      !
      !write(job_is,"(a,' single swap_matrix',i5)") trim(name),islice
      !call IOStart(trim(job_is),chkptIO)
      !
      read(chkptIO) buf(1:ilen)
      if ( trim(buf(1:ilen))/=trim(name) ) then
        write (out,"(' divided_slice_close_vib_rot, kinetic checkpoint slice ',a,': footer is missing or wrong',a)")&
               filename,buf(1:ilen)
        stop 'divided_slice_close - in slice -  footer missing or wrong'
      end if
      !
      close(chkptIO)
      !
    end subroutine divided_slice_close_vib_rot

  end subroutine PTrestore_rot_kinetic_matrix_elements
  !
  !
  !
  ! We construct the Hamiltonian matrix in symm. adapted representaion 
  ! for the K-factorized rotational basis 
  !
  recursive subroutine symm_mat_element_vector_k(jrot,irow,ijterm,func,mat_t,no_diagonalization)

    integer(ik),intent(in)   :: jrot,irow,ijterm(:,:)
    real(rk),external      :: func
    real(rk),intent(out)   :: mat_t(:,:,:)
    logical,optional,intent(in) :: no_diagonalization 
    !
    integer(ik) :: cnu_i(0:PT%Nclasses),cnu_j(0:PT%Nclasses)
    integer(ik) :: deg_i(0:PT%Nclasses),deg_j(0:PT%Nclasses)
    real(rk)    :: mat_elem
    integer(ik) :: isize,jsize,ielem,jelem,k_i,k_j,tau_i,tau_j
    integer(ik) :: jrow,ideg,jdeg,isym,jsym,iL,iR,iterm,jterm,icontr,jcontr
    real(rk)    :: hcontr(PT%max_deg_size,PT%max_deg_size)
    real(rk)    :: vec_i(PT%max_deg_size),vec_j(PT%max_deg_size)
      !
      !call TimerStart('Symmetrized Hamiltonian - one column')
      !
      mat_t = 0 
      !
      cnu_i(:) = PT%contractive_space(:,irow)
      !
      isize = PT%Index_deg(irow)%size1
      !
      do jrow = 1,irow
         !
         if ( present(no_diagonalization).and.no_diagonalization.and.jrow/=irow ) cycle
         !
         cnu_j(:) = PT%contractive_space(:,jrow)
         !
         jsize = PT%Index_deg(jrow)%size1 
         !
         do ideg = 1,isize
            !
            deg_i(:) = PT%Index_deg(irow)%icoeffs(:,ideg)
            !
            do jdeg = 1,jsize
               !
               deg_j(:) = PT%Index_deg(jrow)%icoeffs(:,jdeg)
               !
               !iroot = contr(iclass)%iroot(cnu_i(iclass),deg_i(iclass))
               !jroot = contr(iclass)%iroot(cnu_j(iclass),deg_j(iclass))
               !
               icontr = PT%icase2icontr(irow,ideg)
               jcontr = PT%icase2icontr(jrow,jdeg)
               k_i = PT%rot_index(cnu_i(0),deg_i(0))%k
               k_j = PT%rot_index(cnu_j(0),deg_j(0))%k
               tau_i = PT%rot_index(cnu_i(0),deg_i(0))%tau
               tau_j = PT%rot_index(cnu_j(0),deg_j(0))%tau
               !
               ! Matrix elements 
               !
               hcontr(ideg,jdeg) = func(icontr,jcontr,jrot,k_i,k_j,tau_i,tau_j)
               !
            enddo
            !
         enddo
         !
         do isym = 1,sym%Nrepresen
           !
           iterm = ijterm(irow,isym) 
           !
           do jsym = 1,isym
             !
             jterm = ijterm(jrow,jsym) 
             !
             do ielem = 1,PT%irr(isym)%N(irow) 
               !
               vec_i(1:isize) = PT%irr(isym)%repres(iterm+ielem,1,1:isize) 
               !
               do jelem = 1,PT%irr(jsym)%N(jrow) 
                 !
                 vec_j(1:jsize) = PT%irr(jsym)%repres(jterm+jelem,1,1:jsize)
                 !
                 vec_j(1:isize) = matmul(hcontr(1:isize,1:jsize),vec_j(1:jsize))  
                 !
                 mat_elem = dot_product(vec_i(1:isize),vec_j(1:isize))
                 !
                 if (isym==jsym) then
                    !
                    iL = ielem
                    iR = jterm+jelem
                    !
                    if (iterm+ielem<jterm+jelem) then
                      !
                      iL = jelem
                      iR = iterm+ielem
                      !
                    endif 
                    !
                    if (debug_check_symmetries) then
                      if (PT%symactive_space(isym)%sym_N(iterm+ielem,1)/=irow.or.&
                          PT%symactive_space(isym)%sym_N(iterm+ielem,2)/=ielem) then 
                          write(out,"('PThamiltonian_contract: something wrong with counting for isym,ielem,iterm,jterm = ',4i8)") &
                                      isym,ielem,iterm,jterm
                          write(out,"(' either PT%symactive_space(isym)%sym_N(1)/=irow  ',2i8)") & 
                             PT%symactive_space(isym)%sym_N(iterm+ielem,1),irow
                          write(out,"('     or PT%symactive_space(isym)%sym_N(2)/=ielem ',2i8)") & 
                             PT%symactive_space(isym)%sym_N(iterm+ielem,2),ielem
                          stop 'something wrong with sym-counting'
                      endif 
                    endif
                    !
                    if (job%select_gamma(isym)) then 
                      !
                      mat_t(isym,iL,iR)  = mat_elem
                      !
                    endif
                    !
                 elseif (debug_check_symmetries) then
                   if (abs(mat_elem)>(10.0_rk)**(-(rk-3))) then 
                      !
                      ! We print out non-zero mat. elements between different symmetries, which have to be zero.
                      !
                      if (job%verbose>=6) &
                        write(out,"('<',a4,2i6,'|H|',a4,2i6,'> = ',g18.10)") & 
                                      sym%label(isym),irow,iterm+ielem,sym%label(jsym),jrow,jterm+jelem,mat_elem
                   
                      !
                      ! if this error is too big - we stop
                      !
                      if(abs(mat_elem)>1.0_rk) then 
                        !write(out,"(/'Non-diagonal element between different symmetries:')")
                           write(out,"(/'<',a4,2i6,'|H|',a4,2i6,'> = ',g18.10,a)") & 
                                      sym%label(isym),irow,iterm+ielem,sym%label(jsym),jrow,jterm+jelem,mat_elem,&
                                      ' Non-diagonal element between different symmetries is too large!'
                        !
                        !
                        ! special case for linear molecules and E-symmetries. Not an ideal solution!
                        if (trove%lincoord==0.or.all( (/isym,jsym/)<=4 ) ) then 
                           stop 'non-zero element between two symmetries'
                        endif 
                      endif
                   endif
                 endif
                 ! 
               enddo
             enddo
           enddo
           !
         enddo
         !
      enddo
      !
      !call TimerStop('Symmetrized Hamiltonian - one column')
      !
  end subroutine symm_mat_element_vector_k



  !
  ! In this version of the routine we construct the Hamiltonian matrix in symm. adapted representaion 
  ! for rotational basis which is not factorized with "K". 
  !
  recursive subroutine symm_mat_element_vector(jrot,irow,ijterm,func,mat_t)

    integer(ik),intent(in)   :: jrot,irow,ijterm(:,:)
    real(rk),external      :: func
    real(rk),intent(out)   :: mat_t(:,:,:)
    !
    integer(ik) :: cnu_i(0:PT%Nclasses),cnu_j(0:PT%Nclasses)
    integer(ik) :: deg_i(0:PT%Nclasses),deg_j(0:PT%Nclasses)
    real(rk)    :: mat_elem
    integer(ik) :: isize,jsize,ielem,jelem
    integer(ik) :: jrow,ideg,jdeg,isym,jsym,iL,iR,iterm,jterm,icontr,jcontr
    real(rk)    :: hcontr(PT%max_deg_size,PT%max_deg_size)
    real(rk)    :: vec_i(PT%max_deg_size),vec_j(PT%max_deg_size)
      !
      !call TimerStart('Symmetrized Hamiltonian - one column')
      !
      mat_t = 0 
      !
      cnu_i(:) = PT%contractive_space(:,irow)
      !
      isize = PT%Index_deg(irow)%size1
      !
      do jrow = 1,irow
         !
         cnu_j(:) = PT%contractive_space(:,jrow)
         !
         jsize = PT%Index_deg(jrow)%size1 
         !
         do ideg = 1,isize
            !
            deg_i(:) = PT%Index_deg(irow)%icoeffs(:,ideg)
            !
            do jdeg = 1,jsize
               !
               deg_j(:) = PT%Index_deg(jrow)%icoeffs(:,jdeg)
               !
               !iroot = contr(iclass)%iroot(cnu_i(0),deg_i(0))
               !jroot = contr(iclass)%iroot(cnu_j(0),deg_j(0))
               !
               icontr = PT%icase2icontr(irow,ideg)
               jcontr = PT%icase2icontr(jrow,jdeg)
               !k_i = PT%rot_index(cnu_i(0),deg_i(0))%k
               !k_j = PT%rot_index(cnu_j(0),deg_j(0))%k
               !tau_i = PT%rot_index(cnu_i(0),deg_i(0))%tau
               !tau_j = PT%rot_index(cnu_j(0),deg_j(0))%tau
               !
               ! Matrix elements 
               !
               hcontr(ideg,jdeg) = func(icontr,jcontr,jrot,cnu_i(0),cnu_j(0),deg_i(0),deg_j(0))
               !
            enddo
            !
         enddo
         !
         do isym = 1,sym%Nrepresen
           !
           iterm = ijterm(irow,isym) 
           !
           do jsym = 1,isym
             !
             jterm = ijterm(jrow,jsym) 
             !
             do ielem = 1,PT%irr(isym)%N(irow) 
               !
               vec_i(1:isize) = PT%irr(isym)%repres(iterm+ielem,1,1:isize) 
               !
               do jelem = 1,PT%irr(jsym)%N(jrow) 
                 !
                 vec_j(1:jsize) = PT%irr(jsym)%repres(jterm+jelem,1,1:jsize)
                 !
                 vec_j(1:isize) = matmul(hcontr(1:isize,1:jsize),vec_j(1:jsize))  
                 !
                 mat_elem = dot_product(vec_i(1:isize),vec_j(1:isize))
                 !
                 if (isym==jsym) then
                    !
                    iL = ielem
                    iR = jterm+jelem
                    !
                    if (iterm+ielem<jterm+jelem) then
                      !
                      iL = jelem
                      iR = iterm+ielem
                      !
                    endif 
                    !
                    if (debug_check_symmetries) then
                      if (PT%symactive_space(isym)%sym_N(iterm+ielem,1)/=irow.or.&
                          PT%symactive_space(isym)%sym_N(iterm+ielem,2)/=ielem) then 
                          write(out,"('PThamiltonian_contract: something wrong with counting for isym,ielem,iterm,jterm = ',4i8)") &
                                      isym,ielem,iterm,jterm
                          write(out,"(' either PT%symactive_space(isym)%sym_N(1)/=irow  ',2i8)") & 
                             PT%symactive_space(isym)%sym_N(iterm+ielem,1),irow
                          write(out,"('     or PT%symactive_space(isym)%sym_N(2)/=ielem ',2i8)") & 
                             PT%symactive_space(isym)%sym_N(iterm+ielem,2),ielem
                          stop 'something wrong with sym-counting'
                      endif 
                    endif
                    !
                    if (job%select_gamma(isym)) then 
                      !
                      mat_t(isym,iL,iR)  = mat_elem
                      !
                    endif
                    !
                 elseif (debug_check_symmetries) then
                   if (abs(mat_elem)>(10.0_rk)**(-(rk-3))) then 
                      !
                      ! We print out non-zero mat. elements between different symmetries, which have to be zero.
                      !
                      if (job%verbose>=6) &
                        write(out,"('<',a4,2i6,'|H|',a4,2i6,'> = ',g18.10)") & 
                                      sym%label(isym),irow,iterm+ielem,sym%label(jsym),jrow,jterm+jelem,mat_elem
                      !
                      ! if this error is too big - we stop
                      !
                      if(abs(mat_elem)>1.0_rk) then 
                        !write(out,"(/'A non-diagonal mat. element between different symmetries:')")  
                        write(out,"(/'<',a4,3i6,'|H|',a4,3i6,'> = ',g18.10,a)") & 
                                      sym%label(isym),irow,ielem,iterm+ielem,sym%label(jsym),jrow,jelem,jterm+jelem,mat_elem,&
                                      ' Non-diagonal element (euler) between different symmetries is too large!'
                        stop 'non-zero element between two symmetries'
                      endif
                      !
                   endif
                 endif
                 ! 
               enddo
             enddo
           enddo
           !
         enddo
         !
      enddo
      !
      !
      !call TimerStop('Symmetrized Hamiltonian - one column')
      !
      !
  end subroutine symm_mat_element_vector


  !
  ! In this version of the routine we construct the Hamiltonian matrix in symm. adapted representaion 
  ! for rotational basis which is not factorized with "K" and using the icontr-based sorting 
  !
  recursive subroutine calc_symm_mat_element_vector_contr(jrot,irow,ijterm,func,hsym)

    integer(ik),intent(in)   :: jrot,irow,ijterm(:,:)
    real(rk),external      :: func
    real(rk),intent(out)   :: hsym(:,:,:)
    !
    integer(ik) :: cnu_i(0:PT%Nclasses),cnu_j(0:PT%Nclasses)
    integer(ik) :: deg_i(0:PT%Nclasses),deg_j(0:PT%Nclasses)
    real(rk)    :: mat_elem
    integer(ik) :: isize,jsize
    integer(ik) :: jrow,ideg,jdeg,icontr,jcontr
    real(rk)    :: hcontr(PT%max_deg_size,PT%max_deg_size)
    real(rk)    :: vec_i(PT%max_deg_size),vec_j(PT%max_deg_size)
      !
      !call TimerStart('Symmetrized Hamiltonian - one column')
      !
      hsym = 0 
      !
      cnu_i(:) = PT%contractive_space(:,irow)
      !
      isize = PT%Index_deg(irow)%size1
      !
      !$omp  parallel do private(jrow,cnu_j,jsize,ideg,deg_i,jdeg,deg_j,icontr,jcontr,hcontr) shared(hsym) &
      !$omp& schedule(dynamic)
      do jrow = 1,irow
         !
         cnu_j(:) = PT%contractive_space(:,jrow)
         !
         jsize = PT%Index_deg(jrow)%size1 
         !
         do ideg = 1,isize
            !
            deg_i(:) = PT%Index_deg(irow)%icoeffs(:,ideg)
            !
            do jdeg = 1,jsize
               !
               deg_j(:) = PT%Index_deg(jrow)%icoeffs(:,jdeg)
               !
               icontr = PT%icase2icontr(irow,ideg)
               jcontr = PT%icase2icontr(jrow,jdeg)
               ! Matrix elements 
               !
               hcontr(ideg,jdeg) = func(jcontr,icontr,jrot,cnu_j(0),cnu_i(0),deg_j(0),deg_i(0))
               !
            enddo
            !
         enddo
         !
         call transfer_to_symmetric_representatoin(irow,jrow,ijterm,hcontr,hsym)
         !
      enddo
      !$omp end parallel do
      !
      !
      !call TimerStop('Symmetrized Hamiltonian - one column')
      !
      !
  end subroutine calc_symm_mat_element_vector_contr


  !
  ! In this version of the routine we construct the Hamiltonian matrix in symm. adapted representaion 
  ! for rotational basis which is factorized with "K" and using the icontr-based sorting 
  !
  recursive subroutine calc_symm_mat_element_vector_contr_k(jrot,irow,ijterm,func,hsym)

    integer(ik),intent(in)   :: jrot,irow,ijterm(:,:)
    real(rk),external      :: func
    real(rk),intent(out)   :: hsym(:,:,:)
    !
    integer(ik) :: cnu_i(0:PT%Nclasses),cnu_j(0:PT%Nclasses)
    integer(ik) :: deg_i(0:PT%Nclasses),deg_j(0:PT%Nclasses)
    real(rk)    :: mat_elem
    integer(ik) :: isize,jsize
    integer(ik) :: jrow,ideg,jdeg,icontr,jcontr,k_i,k_j,tau_i,tau_j
    real(rk)    :: hcontr(PT%max_deg_size,PT%max_deg_size)
    real(rk)    :: vec_i(PT%max_deg_size),vec_j(PT%max_deg_size)
      !
      !call TimerStart('Symmetrized Hamiltonian - one column')
      !
      hsym = 0 
      !
      cnu_i(:) = PT%contractive_space(:,irow)
      !
      isize = PT%Index_deg(irow)%size1
      !
      !$omp parallel do private(jrow,cnu_j,jsize,ideg,deg_i,jdeg,deg_j,icontr,jcontr,k_i,k_j,tau_i,tau_j,hcontr) &
      !$omp& shared(hsym) schedule(dynamic)
      do jrow = 1,irow
         !
         cnu_j(:) = PT%contractive_space(:,jrow)
         !
         jsize = PT%Index_deg(jrow)%size1 
         !
         do ideg = 1,isize
            !
            deg_i(:) = PT%Index_deg(irow)%icoeffs(:,ideg)
            !
            do jdeg = 1,jsize
               !
               deg_j(:) = PT%Index_deg(jrow)%icoeffs(:,jdeg)
               !
               !iroot = contr(iclass)%iroot(cnu_i(iclass),deg_i(iclass))
               !jroot = contr(iclass)%iroot(cnu_j(iclass),deg_j(iclass))
               !
               icontr = PT%icase2icontr(irow,ideg)
               jcontr = PT%icase2icontr(jrow,jdeg)
               k_i = PT%rot_index(cnu_i(0),deg_i(0))%k
               k_j = PT%rot_index(cnu_j(0),deg_j(0))%k
               tau_i = PT%rot_index(cnu_i(0),deg_i(0))%tau
               tau_j = PT%rot_index(cnu_j(0),deg_j(0))%tau
               !
               ! Matrix elements 
               !
               hcontr(ideg,jdeg) = func(jcontr,icontr,jrot,k_j,k_i,tau_j,tau_i)
               !
            enddo
            !
         enddo
         !
         call transfer_to_symmetric_representatoin(irow,jrow,ijterm,hcontr,hsym)
         !
      enddo
      !$omp end parallel do
      !
      !
      !call TimerStop('Symmetrized Hamiltonian - one column')
      !
      !
  end subroutine calc_symm_mat_element_vector_contr_k


  !
  ! Transform the degenerate submatrix from the primitive or contracted primitive, non-symmetrized representation 
  ! to the symemtrized representaion and check the symmetry non-diagonal matrix elements 
  !
  recursive subroutine transfer_to_symmetric_representatoin(irow,jrow,ijterm,hcontr,hsym)
     !
     integer(ik),intent(in) :: irow,jrow
     integer(ik),intent(in) :: ijterm(:,:)
     real(rk),intent(out)   :: hsym(:,:,:)
     !
     integer(ik) :: isym,iterm,jsym,jterm,isize,jsize,ielem,jelem,iL,iR
     !
     real(rk)    :: hcontr(PT%max_deg_size,PT%max_deg_size)
     real(rk)    :: vec_i(PT%max_deg_size),vec_j(PT%max_deg_size)
     real(rk)    :: mat_elem
         !
         isize = PT%Index_deg(irow)%size1
         !
         jsize = PT%Index_deg(jrow)%size1
         !
         do isym = 1,sym%Nrepresen
           !
           iterm = ijterm(irow,isym) 
           !
           do jsym = 1,isym
             !
             jterm = ijterm(jrow,jsym) 
             !
             do ielem = 1,PT%irr(isym)%N(irow) 
               !
               vec_i(1:isize) = PT%irr(isym)%repres(iterm+ielem,1,1:isize) 
               !
               do jelem = 1,PT%irr(jsym)%N(jrow) 
                 !
                 vec_j(1:jsize) = PT%irr(jsym)%repres(jterm+jelem,1,1:jsize)
                 !
                 vec_j(1:isize) = matmul(hcontr(1:isize,1:jsize),vec_j(1:jsize))  
                 !
                 mat_elem = dot_product(vec_i(1:isize),vec_j(1:isize))
                 !
                 if (isym==jsym) then
                    !
                    iL = ielem
                    iR = jterm+jelem
                    !
                    if (iterm+ielem<jterm+jelem) then
                      !
                      iL = jelem
                      iR = iterm+ielem
                      !
                    endif 
                    !
                    if (PT%symactive_space(isym)%sym_N(iterm+ielem,1)/=irow.or.&
                        PT%symactive_space(isym)%sym_N(iterm+ielem,2)/=ielem) then 
                        write(out,"('PThamiltonian_contract: something wrong with counting for isym,ielem,iterm,jterm = ',4i8)") &
                                    isym,ielem,iterm,jterm
                        write(out,"(' either PT%symactive_space(isym)%sym_N(1)/=irow  ',2i8)") & 
                           PT%symactive_space(isym)%sym_N(iterm+ielem,1),irow
                        write(out,"('     or PT%symactive_space(isym)%sym_N(2)/=ielem ',2i8)") & 
                           PT%symactive_space(isym)%sym_N(iterm+ielem,2),ielem
                        stop 'something wrong with sym-counting'
                    endif 
                    !
                    if (job%select_gamma(isym)) then 
                      !
                      hsym(isym,iL,iR)  = mat_elem
                      !
                    endif
                    !
                 elseif(abs(mat_elem)>(10.0_rk)**(-(rk-3))) then 
                    !
                    ! We print out non-zero mat. elements between different symmetries, which have to be zero.
                    !
                    if (job%verbose>=6) &
                      write(out,"('<',a4,2i6,'|H|',a4,2i6,'> = ',g18.10)") & 
                                    sym%label(isym),irow,iterm+ielem,sym%label(jsym),jrow,jterm+jelem,mat_elem

                    !
                    ! if this error is too big - we stop
                    !
                    if(abs(mat_elem)>1.0_rk) then 
                      !write(out,"(/'Non-diagonal element between different symmetries:')")
                         write(out,"(/'<',a4,2i6,'|H|',a4,2i6,'> = ',g18.10,a)") & 
                                    sym%label(isym),irow,iterm+ielem,sym%label(jsym),jrow,jterm+jelem,mat_elem,&
                                    ' Non-diagonal element between different symmetries is too large!'
                      !
                      !
                      ! special case for linear molecules and E-symmetries. Not an ideal solution!
                      if (trove%lincoord==0.or.all( (/isym,jsym/)<=4 ) ) then 
                         stop 'non-zero element between two symmetries'
                      endif 
                    endif
                    !
                 endif
                 ! 
               enddo
             enddo
           enddo
         enddo

  end subroutine transfer_to_symmetric_representatoin


  subroutine  diagonalization_contract(jrot,gamma,dimen_s,mat,zpe,rlevel,total_roots,bterm,k_row) 

   integer(ik),intent(in)    :: jrot,gamma,dimen_s
   real(rk),intent(inout)    :: zpe
   integer(ik),intent(inout) :: rlevel,total_roots
   real(rk),intent(inout)    :: mat(:,:)
   integer(ik),intent(inout) :: k_row(dimen_s)
   integer(ik),intent(inout) :: bterm(dimen_s,2)

   integer(ik)  :: nu(0:PT%Nmodes),k,tau,IOunit_quanta,IOunit_vector,alloc,cnu_0,normal(0:PT%Nmodes)
   integer(ik)  :: nroots,nroots_,irange(2),iroot,jroot,icase,iclasses,dimen_p,ideg,kdeg,nroots_max,dimen_s_
   integer(ik)  :: level_degen,icoeff,irecord,ilevel,dimen,irow,iterm,ielem,jelem,n1,n2,icol
   integer(ik)  :: Nterms,ib,ilarge_coef_t,Nmodes,Nclasses,Nclasses1,isym(0:PT%Nclasses),cdimen,cdimenmax,unitO,unitC,vector_size
   integer(ik)  :: cnu(0:PT%Nclasses)
   real(rk)     :: beta, upper_ener_max
   real(rk)     :: vrange(2),MaxEigenvects,termvalue,largest_coeff
   real(rk),allocatable :: energy(:),mat_t(:,:),vec_t(:),dvrvector(:),dvrvector_(:),vec_compress(:),maxcontrib(:)
   real,allocatable     :: mat4(:,:),energy4(:)
   real                 :: vrange4(2),coef4
   integer(ik),allocatable :: eignu(:,:),icoeff_compress(:),eignormal(:,:)
   integer(ik),allocatable :: maxterm(:) ,ijterm(:),ivec(:)
   !
   double precision,external :: ddot
   !
   ! variables for job%mat_readwrite='READ-EIGEN-GRID'
   integer(ik)   :: nprow, npcol, info, idimen, jdimen, j, loc_r, loc_c
   real(rk)      :: coef
   character(cl) :: irowchar, icolchar
   logical :: no_diagonalization = .false.
   !
   real(rk)                           :: spur,mat1,mat2,mat0
   !real(rk), dimension(:, :), pointer :: mexp

   character(len=3)     :: cgamma(0:PT%Nclasses)
   character(len=cl)    :: unitfname
   character(len=cl)    :: filename,symchar,jchar,buff,buff4
   !
   character(len=1)     :: rng,jobz
   integer(hik)         :: ndvr_ktau,matsize
   integer(ik)          :: nelem,chkptIO
   integer(ik)          :: dimen_maxrow,m_,i_,j_,kmax,jb
   character(len=cl)    :: my_fmt   !format for I/O specification
   character(len=wl)    :: my_fmt_l !format for long I/O specification
     !
     ! Check for the trivial solution 
     if (dimen_s<=0) return 
     !
     Nmodes = PT%Nmodes
     Nclasses = PT%Nclasses
     Nclasses1 = Nclasses+1

     nroots_max = job%nroots(gamma)
     if (nroots_max==0) nroots_max = huge(1_ik)/2
     !
     upper_ener_max = job%upper_ener
     if (upper_ener_max==1e9) upper_ener_max = safe_max
     !
     allocate (energy(dimen_s),stat=alloc)
     call ArrayStart('diagonalization_contract:energy',alloc,size(energy),kind(energy))
     !
     ! prepare the diagonalization ranges and options 
     !
     if (job%verbose>=3) then
       !
       if (job%sparse) then 
           write(out,"('Sparse diagonalization...')")
       else 
           write(out,"('Full diagonalization...')")
       endif
       !
     endif
     !
     if (job%verbose>=4) call TimerStart('Full diagonalization') 
     !
     jobz = 'V'
     !if (trim(job%IOeigen_action)=='SAVE') jobz = 'V'
     !
     vrange(1) = -0.0_rk ; vrange(2) = job%upper_ener+job%partfunc%ZPE
     irange(1) = 1 ; irange(2) = min(job%nroots(gamma),dimen_s)
     !
     if (irange(2)==dimen_s) then
        !
        rng = 'A'
        !
     elseif (irange(2)<dimen_s) then
        !
        rng = 'I'
        !
     elseif (job%upper_ener<=1e9) then 
        !
        rng = 'V'
        !
        !   find the smallest absolute diagonal value of mat
        !
        if (job%partfunc%ZPE<sqrt(small_)) then 
          !
          MaxEigenvects  = huge(1.0_rk)
          k  = 1
          do iroot=1,dimen_s
             !
             if (job%sparse) then
                !
                jroot = iroot-bterm(iroot,1)+1
                !
                mat0 = abs(mat(iroot,jroot))
                !
             else
                mat0 = abs(mat(iroot,iroot))
             endif 
             !
             if (mat0<=MaxEigenvects) then 
                 MaxEigenvects = mat0
                 k = iroot
             endif
          enddo
          !
          vrange(2) = job%upper_ener+MaxEigenvects
          !
        endif 
     else
        rng = 'A'
     endif 
     !
     ! Read/write from/to the disk a precomputed Hamiltonian matrix matrix
     !
     select case (trim(job%mat_readwrite)) 
     !
     case ('READ')
       !
       write(unitfname,"('matrix for j = ',i6,' sym = ',i4)") jrot,gamma
       !
       call IOStart(trim(unitfname),chkptIO)
       !
       write(jchar, '(i4)') jrot
       write(symchar, '(i4)') gamma
       filename = trim(job%matrix_file)//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))//'.chk'
       !
       open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=filename)
       !
       if (job%sparse) then 
         !
         read(chkptIO) buff(1:11)
         !
         if (buff(1:11)/='Start bterm') then
           write (out,"(' matrix ',a,' has bogus header: ',a,' should be _Start bterm_')") filename,buff(1:11)
           stop 'bogus file format'
         end if
         !
         read(chkptIO) dimen_s_
         read(chkptIO) bterm
         !
       else
         !
         read(chkptIO) dimen_s_
         !
       endif 
       !
       read(chkptIO) buff(1:12)
       !
       if (buff(1:12)/='Start matrix') then
         write (out,"(' matrix ',a,' has bogus header: ',a,' should be _Start matrix_')") filename,buff(1:12)
         stop 'bogus file format'
       end if
       !
       do ielem = 1,dimen_s
          !
          if (job%sparse) then
            !
            nelem = bterm(ielem,2)-bterm(ielem,1)+1
            !
            read(chkptIO) mat(ielem,1:nelem)
            !
          else
            !
            read(chkptIO) mat(ielem,1:dimen_s)
            !
          endif
          !
       enddo
       !
       read(chkptIO) buff(1:10)
       !
       if (buff(1:10)/='End matrix') then
         write (out,"(' matrix ',a,' has bogus header: ',a)") filename,buff(1:10)
         stop 'bogus file format'
       end if
       !
       close(chkptIO,status='keep')
       !
     case ('READ-LOWER')
       !
       ! this format is designed to replace 'READ'. HERE ONLY THE LOWER PART OF THE MATRIX IS STORED
       !
       write(unitfname,"('matrix for j = ',i6,' sym = ',i4)") jrot,gamma
       !
       call IOStart(trim(unitfname),chkptIO)
       !
       write(jchar, '(i4)') jrot
       write(symchar, '(i4)') gamma
       filename = trim(job%matrix_file)//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))//'.chk'
       !
       open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=filename)
       !
       read(chkptIO) dimen_s_
       !
       read(chkptIO) buff(1:5)
       !
       if (buff(1:5)/='Lower') then
         write (out,"(' matrix ',a,' has bogus header: ',a,' should be _Lower_')") filename,buff(1:5)
         stop 'bogus header, should be Lower'
       end if
       !
       read(chkptIO) buff4(1:4)
       !
       if (buff4(1:4)/='spar'.and.buff4(1:4)/='full') then
         write (out,"(' matrix ',a,' has bogus header: ',a,' should be _spar_ or _full_')") filename,buff(1:4)
         stop 'bogus header, should be spar or full'
       end if
       !
       if (job%sparse.and.buff4(1:4)/='spar') then
           write (out,"(' matrix ',a,' has header: ',a,' should be _spar_ for the sparse representation used here')") &
                  filename,buff(1:4)
           stop 'bogus header, should be spar'
       end if
       !
       if (buff4(1:4)=='spar') then 
         !
         read(chkptIO) buff(1:11)
         !
         if (buff(1:11)/='Start bterm') then
           write (out,"(' matrix ',a,' has bogus header: ',a,' should be _Start bterm_')") filename,buff(1:11)
           stop 'bogus file format'
         end if
         read(chkptIO) bterm
         !
       endif 
       !
       read(chkptIO) buff(1:12)
       !
       if (buff(1:12)/='Start matrix') then
         write (out,"(' matrix ',a,' has bogus header: ',a,' should be _Start matrix_')") filename,buff(1:12)
         stop 'bogus header, should be Start matrix'
       end if
       !
       do ielem = 1,dimen_s
          !
          if (buff4(1:4)=='spar'.and.job%sparse) then 
            !
            nelem = bterm(ielem,2)-bterm(ielem,1)+1
            !
            read(chkptIO) mat(ielem,1:nelem)
            !
          elseif (buff4(1:4)=='spar'.and..not.job%sparse) then
            !
            read(chkptIO) mat(ielem,bterm(ielem,1):bterm(ielem,2))
            !
          elseif (buff4(1:4)=='full'.and..not.job%sparse) then
            !
            read(chkptIO) mat(ielem,1:ielem)
            !
          else
            !
            write (out,"(' combination  matrix-sparse and stored-full is not allowed')") 
            stop 'combination  matrix-sparse and stored-full is not allowed'
            !
          endif
          !
       enddo
       !
       read(chkptIO) buff(1:10)
       !
       if (buff(1:10)/='End matrix') then
         write (out,"(' matrix ',a,' has bogus header: ',a)") filename,buff(1:10)
         stop 'bogus file format'
       end if
       !
       close(chkptIO,status='keep')
       !
     case('SAVE','STORE') 
       !
       write(unitfname,"('matrix for j = ',i6,' sym = ',i4)") jrot,gamma
       !
       call IOStart(trim(unitfname),chkptIO)
       !
       write(jchar, '(i4)') jrot
       write(symchar, '(i4)') gamma
       filename = trim(job%matrix_file)//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))//'.chk'
       !
       open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
       !
       if (job%sparse) write(chkptIO) 'Start bterm'
       write(chkptIO) dimen_s
       if (job%sparse) write(chkptIO) bterm
       !
       write(chkptIO) 'Start matrix'
       !
       do ielem = 1,dimen_s
          !
          if (job%sparse) then
            !
            nelem = bterm(ielem,2)-bterm(ielem,1)+1
            !
            write(chkptIO) mat(ielem,1:nelem)
            !
          else
            !
            write(chkptIO) mat(ielem,1:dimen_s)
            !
          endif
          !
       enddo
       !
       nroots = 0
       !
       write(chkptIO) 'End matrix'
       close(chkptIO,status='keep')
       !
       if (job%verbose>=4) call TimerStop('Full diagonalization') 
       !
       return
       !
     end select 
     !
     ! diagonalization schemes 
     !
     select case (trim(job%diagonalizer)) 
     !
     case default
       !
       write (out,"('PTDiagonalize_hamiltonian_symm: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
       stop 'PTDiagonalize_hamiltonian_symm - wrong diagonalizer '
       !
     case('DSTEVX','DSTEVR','DSTEVD','DSTEV') 
       !
       call diag_tridiag(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),job%diagonalizer,rng=rng,jobz=jobz,iroots=nroots,&
                         vrange=vrange,irange=irange,tol=job%tolerance)
       !
     case('PLASMA_DSYTRDX') 
       !
       call plasma_sytrdx(dimen_s,mat,energy,nroots,vrange(2))
       !
     case('DSYEV-ILP','DSYEVR-ILP','DSYEVD-ILP','DSYEVX-ILP') 
       !
       call diag_syev_ilp(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),job%diagonalizer,rng=rng,jobz=jobz,iroots=nroots,&
                          vrange=vrange,irange=irange,tol=job%tolerance)
       !
     case('DSTEVX-P','DSTEVR-P','DSTEVD-P','DSTEV-P') 
       !
       call diag_tridiag_pack(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),job%diagonalizer,rng=rng,jobz=jobz,iroots=nroots,&
                              vrange=vrange,irange=irange,tol=job%tolerance)
       !
     case('PROPACK')
       !
       nroots = min(job%nroots(gamma),int(dimen_s*9/10))
       !
       call diag_propack(dimen_s,bterm,nroots,job%factor,job%maxiter,job%verbose,job%tolerance,mat,energy)
       !
     case('ULEN')
       !
       if (job%sparse) stop 'sparse is not compatible with ULEN'
       !
       call diag_ulen(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s))
       nroots = dimen_s
       !
     case('READ-ENERGIES') !New Read Energy checkpoint files
       !
       energy(:) = 0.0_rk
       !
       write(out, '(/a,1x,i4,1x,a,1x,i4)') 'read eigenvectors for j=', jrot, 'and symmetry=', gamma
       !
       write(unitfname,"('solution for j = ',i6,' sym = ',i4)") jrot,gamma
       call IOStart(trim(unitfname),chkptIO)
       !
       write(jchar, '(i4)') jrot
       write(symchar, '(i4)') gamma
       
       !---Read energy file nroots and dimen_s
       filename = 'energies'//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))//'.chk'
       open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=trim(filename),iostat=info)
       read(chkptIO) buff(1:14)
       if(buff(1:14)/='Start energies') then
       	stop 'Invalid energies checkpoint file-energy'
       endif
       
       read(chkptIO) dimen, nroots
       
       write(out, '(/a,1x,i8,1x,a,1x,i8)') 'read eigenvectors for dimen=', dimen, 'and nroots=', nroots
       
       !Allocate maxcontrib and maxterm
       allocate (maxTerm(nroots),maxcontrib(nroots))
       call ArrayStart('maxcontrib',alloc,size(maxcontrib),kind(maxcontrib))
       
       read(chkptIO) energy(1:nroots)
       read(chkptIO) buff(1:13)
       if(buff(1:13)/='Start contrib') then
       	stop 'Invalid energies checkpoint file-contrib'
       endif

       !---read contribs
       do ielem=1,nroots
       		read(chkptIO,iostat=info) maxTerm(ielem),maxcontrib(ielem)
       		if(info<0) exit
       		 if (job%verbose>=6) write(out, '(/a,1x,i8,1x,a,1x,es11.4)') 'maxterm=', maxTerm(ielem), 'and maxcontrib=',&
       		                      maxcontrib(ielem)
    
       enddo
       
       write(out,"('Done reading energy file!!!')")
       close(chkptIO)
     case('READ-EIGEN') 
       !
       write(unitfname,"('solution for j = ',i6,' sym = ',i4)") jrot,gamma
       !
       call IOStart(trim(unitfname),chkptIO)
       !
       write(jchar, '(i4)') jrot
       write(symchar, '(i4)') gamma
       filename = trim(job%solution_file)//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))//'.chk'
       !
       open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=filename)
       !
       read(chkptIO) buff(1:14)
       !
       if (buff(1:14)/='Start energies') then
         write (out,"(' matrix ',a,' has bogus header: ',a)") filename,buff(1:14)
         stop 'bogus file format'
       end if
       !
       read(chkptIO) dimen_p,nroots
       !
       if (dimen_s/=dimen_p) then
         write (out,"(' solution matrix ',a,' has a wrong size',i9)") filename,dimen_p
         stop 'bogus matrix size'
       end if
       !
       read(chkptIO) energy(1:nroots)
       !
       read(chkptIO) buff(1:13)
       !
       if (buff(1:13)/='Start vectors') then
         write (out,"(' matrix ',a,' has bogus header (Start vectors): ',a)") filename,buff(1:13)
         stop 'bogus file format'
       end if
       !
       jelem = 0
       !
       do while (jelem < dimen_s)
         !
         read(chkptIO) n1,n2,dimen
         !
         jelem = jelem + dimen
         !
         if (job%verbose>=4) write(out,"('read eigen-solutions: n1,n2,dimen = ',2i8,2x,i8)") n1,n2,dimen
         !
         do ielem = 1,nroots
            !
            read(chkptIO) mat(n1:n2,ielem)
            !
         enddo
         !
       enddo
       !
       if (dimen_s/=jelem) then
         write (out,"(' solution matrix  has a wrong total size',i9,' /= dimen_s = ',i8)") jelem,dimen_s
         stop 'bogus total matrix size'
       end if
       !
       read(chkptIO) buff(1:11)
       !
       if (buff(1:11)/='End vectors') then
         write (out,"(' matrix ',a,' has bogus header: ',a)") filename,buff(1:11)
         stop 'bogus file format'
       end if
       !
       close(chkptIO,status='keep')
       !
     case('READ-EIGEN-GRID')
       !
       mat(:,:) = 0.0_rk
       energy(:) = 0.0_rk
       !
       if (job%verbose>=4) write(out, '(/a,1x,i4,1x,a,1x,i4)') '  read eigenvectors for j=', jrot, 'and symmetry=', gamma
       !
       write(unitfname,"('solution for j = ',i6,' sym = ',i4)") jrot,gamma
       call IOStart(trim(unitfname),chkptIO)
       !
       write(jchar, '(i4)') jrot
       write(symchar, '(i4)') gamma
       !
       nprow = 1
       npcol = 1
       !
       irow = -1
       !
       do while(.true.)
         !
         irow = irow + 1
         if (irow>(nprow-1)) exit
         write(irowchar,*) irow
         !
         icol = -1
         !
         do while(.true.)
           !
           icol = icol + 1
           if (icol>(npcol-1)) exit
           write(icolchar,*) icol
           !
           filename = trim(job%solution_file)//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))&
           &//'_'//trim(adjustl(irowchar))//'_'//trim(adjustl(icolchar))//'.chk'
           !
           if (job%verbose>=4) write(out, '(/a,1x,i3,1x,i3,1x,a,1x,a)') '  read block (', irow, icol, ') from file', trim(filename)
           !
           open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=trim(filename),iostat=info)
           if (info/=0) then
             write(out, '(/a,1x,a,1x,a)') 'error: file=', trim(filename), 'not found'
             stop
           endif
           !
           read(chkptIO) nprow, npcol
           !
           ! read energies
           !
           read(chkptIO) buff(1:14)
           !
           if (buff(1:14)/='Start energies') then
             write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:14)
             stop
           endif
           !
           read(chkptIO) dimen, nroots
           !
           if (dimen/=dimen_s) then
             write(out, '(1x,a,1x,i6,1x,a,1x,i6)') &
             'error: dimen=', dimen, '  /=  dimen_s=', dimen_s
             stop
           endif
           !
           read(chkptIO) energy(1:nroots)
           !
           read(chkptIO) buff(1:12)
           !
           if (buff(1:12)/='End energies') then
             write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:12)
             stop
           endif
           !
           ! read eigenvectors
           !
           read(chkptIO) loc_r, loc_c
           !
           read(chkptIO) buff(1:13)
           !
           if (buff(1:13)/='Start vectors') then
             write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:13)
             stop
           endif
           !
           do
             read(chkptIO,iostat=info) idimen, jdimen, coef
             if (info/=0) then
               backspace(chkptIO)
               read(chkptIO) buff(1:11)
               if (buff(1:11)/='End vectors') then
                 write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:11)
                 stop
               endif
               exit
             else
               mat(idimen,jdimen) = coef
             endif
           enddo
           !
           close(chkptIO,status='keep')
           !
         enddo
       enddo
       !
     case('READ-EIGEN-GRID4')
       !
       !mat(:,:) = 0.0_rk
       !energy(:) = 0.0_rk
       !
       if (job%verbose>=4) write(out, '(/a,1x,i4,1x,a,1x,i4)') '  read eigenvectors for j=', jrot, 'and symmetry=', gamma
       !
       write(unitfname,"('solution for j = ',i6,' sym = ',i4)") jrot,gamma
       call IOStart(trim(unitfname),chkptIO)
       !
       write(jchar, '(i4)') jrot
       write(symchar, '(i4)') gamma
       !
       nprow = 1
       npcol = 1
       !
       irow = -1
       !
       if (job%verbose>=4) call TimerStart('read real-4 vectors') 
       !
       do while(.true.)
         !
         irow = irow + 1
         if (irow>(nprow-1)) exit
         write(irowchar,*) irow
         !
         icol = -1
         !
         do while(.true.)
           !
           icol = icol + 1
           if (icol>(npcol-1)) exit
           write(icolchar,*) icol
           !
           filename = trim(job%solution_file)//trim(adjustl(jchar))//'_'//trim(adjustl(symchar))&
           &//'_'//trim(adjustl(irowchar))//'_'//trim(adjustl(icolchar))//'.chk'
           !
           if (job%verbose>=4) write(out, '(a,1x,i3,1x,i3,1x,a,1x,a)') '  read block (', irow, icol, ') from file', trim(filename)
           !
           open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=trim(filename),iostat=info)
           if (info/=0) then
             write(out, '(/a,1x,a,1x,a)') 'error: file=', trim(filename), 'not found'
             stop
           endif
           !
           read(chkptIO) nprow, npcol
           !
           ! read energies
           !
           read(chkptIO) buff(1:14)
           !
           if (buff(1:14)/='Start energies') then
             write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:14)
             stop
           endif
           !
           read(chkptIO) dimen, nroots
           !
           if (dimen/=dimen_s) then
             write(out, '(1x,a,1x,i6,1x,a,1x,i6)') &
             'error: dimen=', dimen, '  /=  dimen_s=', dimen_s
             stop
           endif
           !
           if (irow==0.and.icol==0) then
             !
             if (job%verbose>=4) write(out,"('Reading ',i8,' real4 vectors...')") nroots
             !
             allocate (mat4(dimen_s,nroots),energy4(nroots),stat=alloc)
             matsize = int(dimen_s*nroots,hik)
             call ArrayStart('mat_4',alloc,1_ik,kind(mat4),matsize)
             call ArrayStart('mat_4',alloc,size(energy4),kind(energy4))
             mat4 = 0
             !
           endif
           !
           read(chkptIO) energy4(1:nroots)
           !
           read(chkptIO) buff(1:12)
           !
           if (buff(1:12)/='End energies') then
             write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:12)
             stop
           endif
           !
           ! read eigenvectors
           !
           read(chkptIO) loc_r, loc_c
           !
           read(chkptIO) buff(1:13)
           !
           if (buff(1:13)/='Start vectors') then
             write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:13)
             stop
           endif
           !
           do
             read(chkptIO,iostat=info) idimen, jdimen, coef4
             if (info/=0) then
               backspace(chkptIO)
               read(chkptIO) buff(1:11)
               if (buff(1:11)/='End vectors') then
                 write(out, '(/a,1x,a)') 'error: file has bogus header=', buff(1:11)
                 stop
               endif
               exit
             else
               mat4(idimen,jdimen) = coef4
             endif
           enddo
           !
           close(chkptIO,status='keep')
           !
         enddo
       enddo
       !
       energy(1:nroots) = energy4(1:nroots)
       deallocate (energy4)
       !
       allocate (mat_t(dimen_s,nroots),stat=alloc)
       matsize = int(dimen_s*nroots,hik)
       call ArrayStart('mat_t',alloc,1_ik,kind(mat_t),matsize)
       !
       mat_t = mat4
       !
       deallocate (mat4)
       call ArrayStop('mat_4')
       !
       if (job%verbose>=4) call TimerStop('read real-4 vectors') 
       !
       call diagonalization_single_double(jrot,gamma,bterm,dimen_s,irange,vrange,jobz,rng,mat,mat_t,energy,nroots)
       !
       deallocate (mat_t)
       call ArrayStop('mat_t')
       !
     case('SYEV','SYEV0') 
       !
       if (job%sparse) stop 'sparse is not compatible with syev'
       !
       if (trim(job%diagonalizer)=='SYEV0') jobz = 'N'
       !
       !call diag_dsyev(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),jobz=jobz)
       !
       call lapack_syev(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),jobz=jobz)
       nroots = dimen_s
       !
     case('SYEVD') 
       !
       if (job%sparse) stop 'sparse is not compatible with syevd'
       !
       call lapack_syevd(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s))
       nroots = dimen_s
       !
     case('SYEVR')
       !
       if (job%sparse) stop 'sparse is not compatible with syevr'
       !
       call lapack_syevr(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),rng=rng,jobz=jobz,iroots=nroots,vrange=vrange,irange=irange) 
       !
     case('SYEVR4','SYEV4')
       !
       if (job%sparse) stop 'sparse is not compatible with syev'
       !
       vrange4 = vrange
       !
       allocate (mat4(dimen_s,dimen_s),energy4(dimen_s),stat=alloc)
       if (alloc/=0) then
          write (out,"(' diagonalization_contract/Error  ',i9,' trying to allocate array for mat4')") alloc
          stop 'diagonalization_contract, mat4  - out of memory'
       end if
       !
       !$omp parallel do private(ielem) shared(mat4) schedule(dynamic)
       do ielem = 1,dimen_s
          mat4(ielem,:) = mat(ielem,:)
       enddo
       !$omp end parallel do
       !
       if (trim(job%diagonalizer)=='SYEVR4') then
         !
         call lapack_syevr(mat4(1:dimen_s,1:dimen_s),energy4(1:dimen_s),rng=rng,jobz=jobz,iroots=nroots,vrange=vrange4,&
                           irange=irange) 
         !
       else 
         !
         call lapack_syev(mat4(1:dimen_s,1:dimen_s),energy4(1:dimen_s),jobz=jobz)
         !
         nroots = dimen_s
         !
       endif
       !
       energy(1:nroots) = energy4(1:nroots)
       deallocate(energy4)
       !
       if (jobz=='V') then 
         !
         ! orthogonalization of the real*8 eigenvectors
         !
         !$omp parallel do private(ielem) shared(mat) schedule(dynamic)
         do ielem = 1,nroots
            mat(:,ielem) = mat4(:,ielem)
         enddo
         !$omp end parallel do
         !
         deallocate(mat4)
         !
         select case (trim(job%orthogonalizer))
           !
         case default
           !
           write (out,"('PTDiagonalize_hamiltonian_symm: type of the orthogonalizer  ',a,' unknown')") trim(job%orthogonalizer)
           stop 'PTDiagonalize_hamiltonian_symm - wrong orthogonalizer'
           !
         case ('GRAM-SCHMIDT','SCHMIDT')
           !
           call schmidt_orthogonalization(dimen_s,nroots,mat)
           !
         case ('SVD')
           !
           call lapack_gesvd(mat(1:dimen_s,1:nroots))
           !
         end select
         !
       endif 
       !
       if (allocated(mat4)) deallocate(mat4)
       !
     case('SYEV-4TO8','SYEVR-4TO8')
       !
       if (job%sparse) stop 'sparse is not compatible with syev'
       !
       call prediagonalization_single_double(jrot,gamma,bterm,dimen_s,irange,vrange,jobz,rng,mat,energy,nroots)
       !
     case('SYEV-E-PT','SYEVR-E-PT')
       !
       call PT_energy_truncated_diagonalization(dimen_s,irange,vrange,jobz,rng,mat,energy,nroots)
       !
     case('SYEV-BS-PT','SYEVR-BS-PT')
       !
       call PT_bset_truncated_diagonalization(gamma,dimen_s,irange,vrange,jobz,rng,mat,energy,nroots)
       !
     case('ENERGY=DIAGONAL','NO-DIAGONALIZATION')
       !
       no_diagonalization = .true.
       !
       allocate (ivec(dimen_s),stat=alloc)
       call ArrayStart('PT_diagonal_no_diagonalization',alloc,size(ivec),kind(ivec))
       !
       call PT_diagonal_no_diagonalization(dimen_s,bterm,mat,energy,nroots,ivec)
       !
       !
     case('SYEV-KROT-BS-PT','SYEVR-KROT-BS-PT')
       !
       call krot_contracted_diagonalization_BS_PT(jrot,gamma,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)
       !
     case('SYEV-KROT-EN-PT','SYEVR-KROT-EN-PT')
       !
       call krot_contracted_diagonalization_en_PT(jrot,gamma,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)
       !
     case('SYEV-KROT-EN','SYEVR-KROT-EN')
       !
       call krot_contracted_diagonalization_en(jrot,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)
       !
     case('SYEV-KROT','SYEVR-KROT') 
       !
       call krot_contracted_diagonalization_II(jrot,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)
       !
     case('SYEVX')
       !
       if (job%sparse) stop 'sparse is not compatible with syev'
       !
       if (job%nroots(gamma)/=1e6) then 
          !
          irange(1) = 1 ; irange(2) = min(job%nroots(gamma),dimen_s)
          !
          call lapack_syevx(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),iroots=nroots,irange=irange,tol=job%tolerance) 
          !
       elseif (job%upper_ener/=1e9) then 
          !
          vrange(1) = -0.0_rk ; vrange(2) = job%upper_ener+job%partfunc%ZPE
          !
          !   find the smallest absolute diagonal value of mat
          if (job%partfunc%ZPE<sqrt(small_)) then 
            !
            MaxEigenvects  = huge(1.0_rk)
            k  = 1
            do iroot=1,dimen_s
               if (abs(mat(iroot,iroot))<=MaxEigenvects) then 
                   MaxEigenvects = abs( mat(iroot,iroot) )
                   k = iroot
               endif
            enddo
            vrange(2) = job%upper_ener+mat(k,k)
          endif 
          !
          call lapack_syevx(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),iroots=nroots,vrange=vrange,tol=job%tolerance) 
          !
       else
          !
          call lapack_syevx(mat(1:dimen_s,1:dimen_s),energy(1:dimen_s),iroots=nroots,tol=job%tolerance) 
          !
       endif 
       !
     case('MATEXP') 
       !
       write(out, '(/a)') 'Compute partition function'
       !

       !allocate(mexp(dimen_s, dimen_s), stat = info)
       !if (info /= 0) stop 'PThamiltonian_contract: mexp - out of memory'
       !
       !m => a
       !
       beta = planck * vellgt/(boltz*job%partfunc%temperature)
       !
       if (job%sparse) then
         !
         mat1 = mat(1,1-bterm(1,1)+1)
         mat2 = mat(dimen_s,dimen_s-bterm(dimen_s,1)+1)
         !
       else
         !
         mat1 = mat(1,1) ; mat2 = mat(dimen_s,dimen_s)
         !
       endif 
       !
       mat0 = (mat2-mat1)*0.5_rk
       !
       !if (job%partfunc%ZPE>small_) mat0 = job%partfunc%ZPE
       !
       if (job%verbose>=2) then 
          write (out,"(/'matrix: min = ',f18.4,' max = ',f18.4,' norm = ',f18.4)") mat1,mat2,mat0
       endif
       !
       ! compute H-mat0
       !
       do ielem = 1, dimen_s
          !
          jelem=ielem
          !
          if (job%sparse) jelem=ielem-bterm(ielem,1)+1
          !
          mat(ielem, jelem) = mat(ielem, jelem) - mat0 - job%partfunc%ZPE
          !
       end do
       !
       ! compute -(H-ZPE)/KT
       !
       mat = mat * (-beta)
       !
       ! compute spur of matrix exponential
       !
       if (job%sparse) then
         !
         ! change to the band representaion
         !
         dimen_maxrow = size(mat,dim=2)
         !
         kmax = 0
         !
         do j_ = 1,dimen_s
           !
           kmax = max(bterm(j_,2)-j_,kmax)
           !
         enddo
         !
         allocate (mat_t(kmax+1,dimen_s),stat=alloc)
         !
         matsize = int(kmax+1,hik)*int(dimen_s,hik)
         call ArrayStart('mat_t',alloc,1_ik,kind(mat_t),matsize)
         !
         do j_ = 1,dimen_s
           !
           m_ = 1-j_
           !
           do i_ = j_,min(j_+kmax,dimen_s)
             !
             jb = j_-bterm(i_,1)+1
             !
             if (jb<1.or.j_>bterm(i_,2)) cycle
             !
             mat_t(m_+i_,j_) = mat(i_,jb)
             !
           enddo
           !
         enddo
         !
         call partfunc_matexp_taylor(dimen_s,mat_t,0.1_rk,20,job%tolerance,job%maxiter,spur)
         !
         deallocate(mat_t)
         call ArrayStop('mat_t')
         !
       else
         !
         call partfunc_matexp_taylor(dimen_s,mat,0.1_rk,20,job%tolerance,job%maxiter,spur)
         !
       endif 
       !
       ! compute partition function
       !
       spur = spur * job%partfunc%gns(gamma) * real(2*trove%jmax+1, kind = rk)
       !
       ! restore H: -(H-ZPE)/KT -> H
       !
       spur = spur*exp(-beta*mat0)
       !
       write(out, '(/1x, a, 1x, es16.8)') 'qpart = ', spur
       !
       !mat = mat / (-planck * vellgt) * (boltz * intensity%temperature)
       !do ielem = 1, dimen_s
       !   mat(ielem, ielem) = mat(ielem, ielem) + intensity%ZPE
       !end do
       !!
       !nullify(m)
       !
       job%partfunc%value = job%partfunc%value + spur
       !
       if (gamma==sym%Nrepresen) then
          !
          write(out, '(/1x, a, 1x, es16.8)') 'partition function value is', job%partfunc%value
          !
       endif 
       !
       write(out, '(/1(4hdone))')
       !
       if (job%verbose>=4) call TimerStop('Full diagonalization') 
       !
       return
       !
     case('PSEUPD') 
       !
       nroots = min(job%nroots(gamma),int(dimen_s*9/10))
       !
       ! nroots is mandatory here, besides it has to be less than dimen_s. 
       ! if it if zero and was not given at the input we can estimate it.
       !
       if (nroots==0.and.job%upper_ener/=1e9) then 
          !
          nroots = dimen_s*job%upper_ener/maxval(mat(:,:))
          !
       endif 
       !
       if (size(mat,dim=2)<nroots) then 
         write (out,"(' diagonalization_contract: size of mat(SEUPD) < nroots  = ',2i9)") size(mat,dim=2)<nroots
         stop 'diagonalization_contract, mat  - too small'
       endif
       !
       !call dseupd_p_arpack(dimen_s,bterm,nroots,job%factor,job%maxiter,job%tolerance,mat,energy)
       !
       !call diag_dseupd_p(dimen_s,bterm,nroots,job%factor,job%maxiter,job%tolerance,mat,energy)
       !
       call dseupd_omp_arpack(dimen_s,bterm,nroots,job%factor,job%maxiter,job%tolerance,mat,energy)
       !
     case('SEUPD')
       !
       nroots = min(job%nroots(gamma),int(dimen_s*9/10))
       !
       ! nroots is mandatory here, besides it has to be less than dimen_s. 
       ! if it if zero and was not given at the input we can estimate it.
       !
       if (nroots==0.and.job%upper_ener/=1e9) then 
          !
          nroots = dimen_s*job%upper_ener/maxval(mat(:,:))
          !
       endif 
       !
       if (size(mat,dim=2)<nroots) then 
         write (out,"(' diagonalization_contract: size of mat(SEUPD) < nroots  = ',2i9)") size(mat,dim=2)<nroots
         stop 'diagonalization_contract, mat  - too small'
       endif
       !
       if (job%IOvector_symm) then
         !
         !call dseupd_arpack(dimen_s,bterm,nroots,job%factor,job%maxiter,job%tolerance,mat,energy,job%IOvector_symm)
         !
       else
         !
         !call dseupd_arpack(dimen_s,bterm,nroots,job%factor,job%maxiter,job%tolerance,mat,energy)
         !
         dimen_maxrow = size(mat,dim=2)
         !
         kmax = 0
         !
         do j_ = 1,dimen_s
           !
           kmax = max(bterm(j_,2)-j_,kmax)
           !
         enddo
         !
         allocate (mat_t(kmax+1,dimen_s),stat=alloc)
         !
         do j_ = 1,dimen_s
           !
           m_ = 1-j_
           !
           do i_ = j_,min(j_+kmax,dimen_s)
             !
             jb = j_-bterm(i_,1)+1
             !
             if (jb<1.or.j_>bterm(i_,2)) cycle
             !
             mat_t(m_+i_,j_) = mat(i_,jb)
             !
           enddo
           !
         enddo
         !
         call diag_dseupd(dimen_s,bterm,nroots,job%factor,job%maxiter,job%tolerance,mat_t,energy)
         !
         !$omp parallel do private(j_) shared(mat) schedule(static)
         do j_=1,dimen_s
            !
            call dcopy(nroots,mat_t(1:nroots,j_),1,mat(j_,1:nroots),1)
            !
            !h(j,1:nroots) = v(j,1:nroots)
            !
         enddo
         !$omp end parallel do
         !
         deallocate(mat_t)
         !
       endif
       !
     end select
     !
     if (job%verbose>=4) call TimerStop('Full diagonalization') 
     !
     if (job%verbose>=4) write(out,"('...done!')")
     !
     ZPE = job%partfunc%ZPE
     !
     if (gamma==1.and.jrot==0) then
       !
       ZPE  = safe_max
       !
       do iroot=1,nroots
          if (energy(iroot)<=ZPE) then ! .and.abs(energy(iroot))>1e-4) then 
              ZPE = energy(iroot)
              !write(out,"(/'Zero-point-energy is ',f18.6)") ZPE
          endif
       enddo
       !
       job%partfunc%ZPE = ZPE
       !
     endif
     !
     if (gamma==1) write(out,"(/'Zero-point-energy is ',f18.6)") ZPE
     !
     if (trim(job%IOeigen_action)=='SAVE'.or.trim(job%IOeigen_action)=='APPEND') then
       !
       write(unitfname,"('Quantum numbers of solution gamma = ',i2)") gamma
       !
       !unitfname ='Quantum numbers of the eigensolution'
       call IOStart(trim(unitfname),IOunit_quanta)
       !
       write(unitfname,"('Eigenvectors for ',i2)") gamma
       !
       !unitfname ='Eigenvectors in the primitive basis set'
       !
       call IOStart(trim(unitfname),IOunit_vector)
       !
       !Prepare the i/o-file for the fbr/dvr-representaion of the eigenvectors
       !
       !if (trove%FBR) then
          ! 

          !
       !else ! DVR
       !   ! 
       !   unitfname ='Eigenvectors in DVR representaion'
       !   call IOStart(trim(unitfname),IOunit_vector)
       !   !
       !endif
       !
     endif 
     !
     ! Determine the assignment of the eigenvectors using the largest coefficient principle 
     ! 
     ! and Reporting the final results 
     !
     if (job%verbose>=1) then 
       !write (out,"(//'Size of the symmetrized hamiltonian = ',i7)") dimen_s
       !write (out,"(/'Symmetrized solution:',/'  Gamma    i       value            j  k  t   quanta')") 
       write (out,"(/a,/a)") &
             'Variational solution - irreducible representation','  Gamma     i       value             j  k  t   quanta'
     endif
     !
     
     ! Find the largest coefficients only if not provided from external diagonalization.
     if(trim(job%diagonalizer)/='READ-ENERGIES') then
     
     	allocate (maxTerm(nroots),maxcontrib(nroots))
     	call ArrayStart('maxcontrib',alloc,size(maxcontrib),kind(maxcontrib))
    	maxTerm  = 1
     
     
        !$omp parallel do private(iroot,MaxEigenvects,jroot) shared(maxTerm) schedule(dynamic)
        do iroot=1,nroots
          !
          MaxEigenvects  = small_
          !
          if (.not.no_diagonalization) then 
            !
            do jroot=1,dimen_s
                 if (abs(mat(jroot,iroot))>=MaxEigenvects) then 
                     MaxEigenvects = abs( mat(jroot,iroot) )
                     maxTerm(iroot) = jroot
                 endif
            enddo
              !
            maxcontrib(iroot)  = mat(maxTerm(iroot),iroot)
            !
          else
            ! 
            maxTerm(iroot) = ivec(iroot)
            maxcontrib(iroot)  = 1.0_rk
            !
          endif
       !
        enddo
     !$omp end parallel do
     !
     
     endif
     
     if (no_diagonalization) then 
       !
       deallocate(ivec)
       call ArrayStop('PT_diagonal_no_diagonalization')
       !
     endif
     !
     allocate(eignu(nroots,0:PT%Nmodes),eignormal(nroots,0:PT%Nmodes),stat=alloc)
     call ArrayStart('diagonalization_contract:eignu',alloc,size(eignu),kind(eignu))
     call ArrayStart('diagonalization_contract:eignu',alloc,size(eignormal),kind(eignormal))
     !
     nroots_ = 0
     cdimenmax = 1
     !
     write(my_fmt_l,'(a,i0,a,i0,a,i0,a,i0,a)') "(2x,a,i7,f14.6,3x,a1,a4,a1,3i3,a2,1x,a1,",Nclasses,"(1x,a3),a1,",&
                     Nmodes,"i4,a2,1x,f9.2,1x,a1,",Nmodes+1,"i4,a2,1x,a1,",Nclasses,"i4,a2)"
     
     !write(out,'(2x,a,i7,f14.6,3x,a1,a4,a1,3i3,a2,1x,a1'//fmt%Aclasses//',a1,'//fmt%Nmodes0//',a2,1x,f9.2,1x,a1,'//fmt%Nmodes//'," )",1x,"(",'//fmt%Nclasses0//',a2)') & 
     !                  sym%label(gamma),iroot,termvalue,&
     !                  "(",cgamma(0),";",jrot,k,tau," )", &
     !                  "(",cgamma(1:PT%Nclasses),";",nu(1:PT%Nmodes)," )",maxcontrib(iroot)**2,"(",normal(1:PT%Nmodes),normal(0),cnu(1:PT%Nclasses)," )"
     !
     do iroot=1,nroots
       !
       termvalue = energy(iroot)-ZPE
       !
       ! count rooots to be stored 
       !
       if (energy(iroot)-ZPE<=upper_ener_max.and.iroot<=nroots_max) nroots_ = nroots_ + 1
       !
       icase    = PT%symactive_space(gamma)%sym_N(maxTerm(iroot),1)
       ideg     = PT%symactive_space(gamma)%sym_N(maxTerm(iroot),2)
       cnu(:) = PT%contractive_space(:,icase)  
       nu = 0
       normal = 0
       do iclasses = 0,PT%Nclasses
         if (cnu(iclasses)<=contr(iclasses)%nlevels) then
            nu(:) = nu(:) + contr(iclasses)%eigen(cnu(iclasses))%nu(:)
         endif 
         cgamma(iclasses) = contr(iclasses)%eigen(cnu(iclasses))%gamma
         !
       enddo 
       !
       largest_coeff = maxcontrib(iroot)
       do iclasses = 1,PT%Nclasses
         if (cnu(iclasses)<=contr(iclasses)%nlevels) then
            normal(:) = normal(:) + contr(iclasses)%eigen(cnu(iclasses))%normal(:)
         endif
         !
         ! the total coeff is the product of the J=0 and contracted  
         !!!!!largest_coeff = largest_coeff*contr(iclasses)%eigen(cnu(iclasses))%largest_coeff
         !
       enddo
       !
       maxcontrib(iroot) = largest_coeff
       !
       !normal(0) = nu(0)
       !
       eignu(iroot,:) = nu(:)
       eignormal(iroot,:) = normal(:)
       !
       ! recostruct the rotational quanta from the 1D record
       !
       kdeg = PT%Index_deg(icase)%icoeffs(0,ideg)
       !
       k   = PT%rot_index(cnu(0),kdeg)%k
       tau = PT%rot_index(cnu(0),kdeg)%tau
       !
       !if (termvalue>-1e1) then
         !
         if (all(nu==normal).and..false.) then 
           !
           write(out,'(2x,a,i7,f14.6,3x,a1,a4,a1,3i3,a2,1x,a1,'//fmt%Aclasses//',a1,'//fmt%Nmodes0//',a2,f9.2)') & 
                      sym%label(gamma),iroot,termvalue,"(",&
                      cgamma(0),";",jrot,k,tau," )", &
                      "(",cgamma(1:PT%Nclasses),";", &
                      nu(1:PT%Nmodes)," )",maxcontrib(iroot)**2
           !
         else
            !write(out,'(2x,a,i7,f14.6,3x,"(",a4,";",3i3," )",1x,"("'//fmt%Aclasses//',";",'//fmt%Nmodes0//'," )",1x,f9.2,1x,"(",'//fmt%Nmodes//'," )",1x,"(",'//fmt%Nclasses0//'," )")') & 
            !           sym%label(gamma),iroot,termvalue,&
            !           cgamma(0),jrot,k,tau, &
            !           cgamma(1:PT%Nclasses), &
            !           nu(1:PT%Nmodes),maxcontrib(iroot)**2,normal(1:PT%Nmodes),normal(0),cnu(1:PT%Nclasses)

            write(out,my_fmt_l)&
            !write(out,'(2x,a,i7,f14.6,3x,a1,a4,a1,3i3,a2,1x,a1'//fmt%Aclasses//',a1,'//fmt%Nmodes0//',a2,1x,f9.2,1x,a1,'//fmt%Nmodes//',a2,1x,a1,'//fmt%Nclasses0//',a2)') & 
                       sym%label(gamma),iroot,termvalue,&
                       "(",cgamma(0),";",jrot,k,tau," )", &
                       "(",cgamma(1:PT%Nclasses),";",nu(1:PT%Nmodes)," )",maxcontrib(iroot)**2,&
                       "(",normal(1:PT%Nmodes),normal(0)," )","(",cnu(1:PT%Nclasses)," )"


            !
         endif
         !
       !endif
       !
     enddo 
     !
     ! storing the eigenfunctions to the hard disk
     !
     if (trim(job%IOeigen_action)=='SAVE') then ! .or.trim(job%IOeigen_action)=='APPEND') then
       !
       level_degen = sym%degen(gamma)
       dimen_p =  PT%Maxprimitive
       !
       dimen = PT%Maxsymcoeffs
       !
       if (job%IOvector_symm) then 
          vector_size = dimen_s
       else
          vector_size = PT%Maxcontracts
       endif 
       !
       allocate (vec_t(vector_size),ijterm(dimen),stat=alloc)
       call ArrayStart('diagonalization_contract:vector',alloc,size(vec_t),kind(vec_t))
       call ArrayStart('diagonalization_contract:ijterm',alloc,size(ijterm),kind(ijterm))
       !
       if (trove%DVR) then
          !
          ! The total size of the vector is 
          ! 
          ndvr_ktau = dvr%total_size*(2*Jrot+1)
          !
          allocate (dvrvector(ndvr_ktau),dvrvector_(dvr%total_size),stat=alloc)
          call ArrayStart('diagonalization_contract:dvrvector',alloc,1,kind(dvrvector),ndvr_ktau)
          call ArrayStart('diagonalization_contract:dvrvector',alloc,1,kind(dvrvector_),dvr%total_size)
          !
       endif
       !
       if (job%IOeigen_compress) then
         !
         ! use the predefined file to store the compacted vectors
         !
         write(unitfname, '(a, i4)') 'compacted eigenfuncs for ', jrot
         call iostart(trim(unitfname), unitO)
         !
         write(unitfname, '(a, i4)') 'compacted coeffs for ', jrot
         call iostart(trim(unitfname), unitC)
         !
         allocate (vec_compress(PT%Maxcontracts),icoeff_compress(PT%Maxcontracts),stat=alloc)
         call ArrayStart('diagonalization_contr:vec_compress',alloc,size(vec_compress),kind(vec_compress))
         call ArrayStart('diagonalization_contr:vec_compress',alloc,size(icoeff_compress),kind(icoeff_compress))
         !
       endif
       !
       Nterms = 0 
       !
       do irow = 1,dimen
         !
         ijterm(irow) = Nterms
         !
         Nterms = Nterms + PT%irr(gamma)%N(irow) 
         !
       enddo
       !
       ! transforming the vectors from symm. to contracted representaion...
       !
       do kdeg = 1,level_degen
         !
         if (job%IOvector_symm.and.kdeg>1) exit
         !
         do iroot=1,nroots_
         !
         if (.not.job%IOvector_symm) then 
             !
             !$omp parallel do private(icoeff,irow,ib,iterm,ielem) shared(vec_t) schedule(dynamic)
             do icoeff = 1,PT%Maxcontracts
                !
                vec_t(icoeff) = 0 
                !
                irow = PT%icontr2icase(icoeff,1)
                ib   = PT%icontr2icase(icoeff,2)
                !
                iterm = ijterm(irow) 
                !
                do ielem = 1,PT%irr(gamma)%N(irow) 
                   !
                   vec_t(icoeff) = vec_t(icoeff) + mat(iterm+ielem,iroot)*PT%irr(gamma)%repres(iterm+ielem,kdeg,ib)
                   !
                enddo
                !
             enddo 
             !$omp end parallel do
             !
           else 
             !
             !
             if (.not.no_diagonalization.and..not.job%ignore_vectors) vec_t(:) = mat(:,iroot) 
             !
           endif
           !
           total_roots = total_roots + 1
           !
           irecord = total_roots
           !
           if (job%IOvector_symm) irecord = iroot
           !
           ! Find the largest coefficient maxTerm in the contracted representaion:
           !
           if (.not.no_diagonalization.and..not.job%ignore_vectors) then 
             !
             MaxEigenvects = maxval(vec_t(:)**2,dim=1)-small_
             ilarge_coef_t = maxloc(vec_t(:)**2,dim=1,mask=vec_t(:)**2.ge.MaxEigenvects)
             !
           else
             !
             if (.not.no_diagonalization) MaxEigenvects = 1.0_rk
             if (.not.job%ignore_vectors) MaxEigenvects = maxcontrib(iroot)
             ilarge_coef_t = maxTerm(iroot)
             !
           endif
           !
           icase    = PT%symactive_space(gamma)%sym_N(maxTerm(iroot),1)
           ideg     = PT%symactive_space(gamma)%sym_N(maxTerm(iroot),2)
           cnu(:) = PT%contractive_space(:,icase)  
           nu = 0
           do iclasses = 0,PT%Nclasses
             if (cnu(iclasses)<=contr(iclasses)%nlevels) then
                nu(:) = nu(:) + contr(iclasses)%eigen(cnu(iclasses))%nu(:)
             endif 
             !
             isym(iclasses) = contr(iclasses)%eigen(cnu(iclasses))%isym
             !
           enddo 
           ! 
           ! the degenerate solutions are assigned to the same quantum total number
           !
           ilevel = rlevel + iroot
           !
           if (job%IOvector_symm) ilevel = iroot 
           !
           write(my_fmt,'(a,i0,a,i0,a,i0,a,i0,a)') "(i8,3i8,f20.12,i8,",nmodes,"i4,i8,",&
                        Nclasses1,"i4,i8,",Nmodes,"i4,2x,f17.8,",Nclasses,"i7)"
           !
           !write(IOunit_quanta,'(i8,3i8,f20.12,i8,<Nmodes>i4,i8,<Nclasses1>i4,i8,<Nmodes>i4,2x,f17.8,<Nclasses>i7)')  irecord,&
           write(IOunit_quanta,my_fmt)  irecord,gamma,ilevel,kdeg,energy(iroot),eignu(iroot,0:PT%Nmodes),ilarge_coef_t,&
                                        isym(0:Nclasses),eignormal(iroot,0:PT%Nmodes),maxcontrib(iroot),cnu(1:Nclasses)
           !
           !
           ! in case of DVR storing the eigenfunctions in the DVR representaion too.
           !
           call TimerStart('Storing eigenvectors')
           !
           if (.not.no_diagonalization.and..not.job%IOeigen_compress.and..not.job%ignore_vectors) then
             !
             write(IOunit_vector,rec=irecord) vec_t
             !
           endif
           !
             !
           !else ! DVR
           !  !
           !  dvrvector = 0
           !  !
           !  do icoeff = 1,PT%Maxcontracts
           !     !
           !     call PTDVR_contracted_bases_onthefly(jrot,icoeff,0,dvrvector_)
           !     !
           !     icase = PT%icontr2icase(icoeff,1)
           !     !
           !     cnu_0   = PT%contractive_space(0,icase)  
           !     !
           !     !$omp parallel do private(idvrpoint,idvr_ktau) shared(dvrvector) schedule(dynamic)
           !     do idvrpoint = 1,dvr%total_size
           !       !
           !       idvr_ktau = idvrpoint+(cnu_0-1)*dvr%total_size
           !       !
           !       dvrvector(idvr_ktau) = dvrvector(idvr_ktau) + dvrvector_(idvrpoint)*vec_t(icoeff)
           !       !
           !     enddo
           !     !$omp end parallel do
           !     !
           !     deallocate(dvr%contr_func(icoeff,0)%coeff1d)
           !     !
           !  enddo
           !  !
           !  !call dgemv('T',PT%Maxcontracts,dvr%total_size,alpha,dvr%contr_func(icoeff,idvrpoint,0),PT%Maxcontracts,vec_t,1,beta,dvrvector,1)
           !  !
           !  write(IOunit_vector,rec=irecord) dvrvector(1:ndvr_ktau)
           !  !
           !endif
           !
           call TimerStop('Storing eigenvectors')
           !
           if (job%IOeigen_compress) then
             !
             call TimerStart('Compressing eigenvectors')
             !
             ! compress the eigenvectors 
             !
             cdimen = 0 
             icoeff_compress(:) = 0
             !
             do iterm = 1,PT%Maxcontracts
                if (abs(vec_t(iterm)) > job%coeff_thresh) then
                   cdimen = cdimen + 1
                   icoeff_compress(cdimen) = iterm
                   !
                   vec_compress(cdimen) = vec_t(iterm)
                   !
                end if
             end do
             !
             cdimenmax = max(cdimen,cdimenmax)
             !
             call TimerStop('Compressing eigenvectors')
             !
             if (job%verbose>=6) write(out,"('iroot = ',i8,' dimen = ',i9,'  compressed size = ',i8)") iroot,PT%Maxcontracts,cdimen
             if (cdimen>PT%Maxcontracts*job%compress) then 
               write(out,"('Error: the compression factor ',f9.2,' is too low, must be at leas  ',f9.2)") &
               job%compress,real(cdimen/PT%Maxcontracts)
               stop 'the compression factor is too low'
             endif
             !
             call TimerStart('Storing Compressed eigenvectors')
             !
             write(unitO,rec=irecord) vec_compress(1:cdimen)
             write(unitC,rec=irecord) cdimen,icoeff_compress(1:cdimen)
             !
             call TimerStop('Storing Compressed eigenvectors')
             !
           endif 
           !
         enddo
         !
       enddo
       !
       rlevel = rlevel + nroots_
       !
       if (allocated(dvrvector)) then  
          deallocate(dvrvector,dvrvector_)
          call ArrayStop('diagonalization_contract:dvrvector')
       endif
       !
       if (allocated(vec_t)) then  
          deallocate(vec_t)
          call ArrayStop('diagonalization_contract:vector')
       endif
       !
       if (allocated(ijterm)) then  
          deallocate(ijterm)
          call ArrayStop('diagonalization_contract:ijterm')
       endif
       !
       if (job%IOeigen_compress) then
         !
         !close(unitO,status='keep')
         !close(unitC,status='keep')
         !
         deallocate(vec_compress,icoeff_compress)
         call ArrayStop('diagonalization_contr:vec_compress')
         !
         if (job%verbose>=4) write(out,"(/a,i9,' out of ',i9,' suggested compression  = ',f12.5/)") &
                             'Maximal number of non-zero values after vector compression  = ',&
                             cdimenmax,PT%Maxcontracts,real(cdimenmax)/real(PT%Maxcontracts)
         !
       endif
       !
     endif
     !
     if (allocated(maxterm)) deallocate(maxterm)
     if (allocated(maxcontrib)) deallocate(maxcontrib)
     call ArrayStop('maxcontrib')
     !
     if (allocated(eignu)) then 
       deallocate(eignu)
       deallocate(eignormal)
       call ArrayStop('diagonalization_contract:eignu')
     endif 
     deallocate (energy)
     call ArrayStop('diagonalization_contract:energy')
     !
     contains 
     !
     ! ------------------------------- contains -------------------------------------
     ! 
     !
     subroutine real4_real8_matrix_transformation(dimen_a,dimen_b,amat,trasform)
       !
       integer(ik),intent(in) :: dimen_a,dimen_b
       real(rk),intent(inout) :: amat(dimen_a,dimen_a)
       real(rk),intent(in)    :: trasform(dimen_a,dimen_b)
       real(rk),allocatable  :: diag(:),gmat(:,:)
       integer(ik) ::ielem,jelem,iterm,alloc
       integer(hik) :: matsize
       !
       if (job%verbose>=5) write (out,"('     hamiltonian: real4->real8...')")
       if (job%verbose>=4) call TimerStart('hamiltonian: real4->real8') 
       !
       allocate (diag(dimen_a),gmat(dimen_a,dimen_b),stat=alloc)
       !
       matsize = int(dimen_a,hik)*int(dimen_b,hik)
       !
       call ArrayStart('real4_real8_matrix_transf',alloc,size(diag),kind(diag))
       call ArrayStart('real4_real8_matrix_transf',alloc,1,kind(gmat),matsize)
       !
       !$omp parallel do private(ielem,iterm) shared(diag,gmat) schedule(dynamic)
       do ielem = 1,dimen_a
         !
         diag(ielem) = amat(ielem,ielem)
         !
         do iterm = 1,dimen_b
          !
          gmat(ielem,iterm)=ddot(ielem-1,amat(ielem,1:ielem-1),1,trasform(1:ielem-1,iterm),1)
          !
         enddo
         !
       end do
       !$omp end parallel do
       !
       !$omp parallel do private(ielem,jelem) shared(amat) schedule(dynamic)
       do ielem=1,dimen_b
          do jelem=1,dimen_b
            !
            amat(ielem,jelem) = ddot(dimen_a,trasform(:,jelem),1,gmat(:,ielem),1)
            !
           enddo 
       enddo
       !$omp end parallel do
       !
       deallocate(gmat)
       !
       !$omp parallel do private(ielem,jelem) shared(amat) schedule(dynamic)
       do ielem=1,dimen_b
         do jelem=ielem,dimen_b
            ! 
            amat(ielem,jelem) = amat(ielem,jelem) + amat(jelem,ielem)
            amat(ielem,jelem) = amat(ielem,jelem) + &
                                sum(trasform(:,ielem)*diag(:)*trasform(:,jelem))
            amat(jelem,ielem) = amat(ielem,jelem) 
            !
        enddo 
       enddo 
       !$omp end parallel do
       !
       deallocate(diag)
       !
       call ArrayStop('real4_real8_matrix_transf')
       !
       if (job%verbose>=4) call TimerStop('hamiltonian: real4->real8') 
       if (job%verbose>=5) write (out,"('     ...done!')")
       !
     end subroutine real4_real8_matrix_transformation
     !
  end subroutine diagonalization_contract


  subroutine schmidt_orthogonalization(dimen_s,nroots,mat)
      !
      integer(ik),intent(in) :: dimen_s,nroots
      real(rk),intent(inout) :: mat(:,:)
      integer(ik) :: ielem,jelem
      double precision :: cross_prod,ddot,factor
      !
      if (job%verbose>=4) write (out,"(/'     real4 orthogonalization (Gram-Schmidt)...')")
      if (job%verbose>=4) call TimerStart('Real4 orthogonalization') 
      !
      do ielem =  1,nroots
        !
        cross_prod = ddot(dimen_s,mat(:,ielem),1,mat(:,ielem),1)
        !
        factor = 1.0_rk/sqrt(cross_prod)
        !
        !mat(:,ielem) = mat(:,ielem)*factor
        !
        call dscal(dimen_s,factor,mat(:,ielem),1)
        !
        !$omp parallel do private(jelem,cross_prod) shared(mat) schedule(dynamic)
        do jelem = ielem+1,nroots
          !
          cross_prod = ddot(dimen_s,mat(:,ielem),1,mat(:,jelem),1)
          !
          cross_prod = -cross_prod
          !
          !mat(:,jelem) = mat(:,jelem)-cross_prod*mat(:,ielem)
          !
          call daxpy(dimen_s,cross_prod,mat(:,ielem),1,mat(:,jelem),1)
          ! 
        enddo 
        !$omp end parallel do
        !
      enddo 
      !
      !
      if (job%verbose>=4) call TimerStop('Real4 orthogonalization') 
      if (job%verbose>=4) write (out,"('     ...done!')") 
      !
  end subroutine schmidt_orthogonalization



  subroutine prediagonalization_single_double(jrot,gamma,bterm,dimen_s,irange,vrange,jobz,rng,mat,energy,nroots)

     integer(ik),intent(in)      :: jrot,gamma,dimen_s
     integer(ik),intent(in)      :: irange(2)
     integer(ik),intent(in)      :: bterm(dimen_s,2)
     real(rk),intent(in)         :: vrange(2)
     character(len=1),intent(in) :: rng,jobz
     real(rk),intent(inout)      :: mat(:,:),energy(:)
     integer(ik),intent(out)     :: nroots
     !
     character(len=1)            :: jobz_,rng_
     real,allocatable     :: mat4(:,:),energy4(:)
     real(rk),allocatable :: mat_t(:,:),transform(:,:)
     real                 :: vrange4(2)
     integer(ik)          :: ielem,alloc,irange_(2),dimen4,iroot,k,kdeg,tau,icase,ideg,cnu(0:PT%Nclasses)
     integer(ik)          :: istart,iend,nelem,i,j,l,lelem
     integer(ik)          :: iclasses,jroot,maxTerm,nu(0:PT%nmodes)
     character(len=3)     :: cgamma(0:PT%Nclasses)
     real(rk)             :: termvalue,MaxEigenvects,temp
     double precision     :: alpha = 1.0d0,beta=0.0d0
     integer(hik) :: matsize
     !
     !
     if (job%verbose>=4) write (out,"(/'     real4->real8-diagonalization...')")
     if (job%verbose>=4) call TimerStart('prediag: real4->real8')
     !
     jobz_ ='V'
     rng_ = rng
     !
     allocate (mat4(dimen_s,dimen_s),energy4(dimen_s),stat=alloc)
     matsize = int(dimen_s,hik)*int(dimen_s,hik)
     !
     call ArrayStart('diag_contract: 4-8',alloc,1,kind(mat4),matsize)
     call ArrayStart('diag_contract: 4-8',alloc,size(energy4),kind(energy4))
     !
     if (job%sparse) then
       !
       if (job%verbose>=4) write (out,"('       sparse matrix processing...')")
       !
       !$omp parallel do private(ielem,istart,iend,nelem) shared(mat4) schedule(dynamic)
       do ielem = 1,dimen_s
          !
          istart = bterm(ielem,1) ; iend   = bterm(ielem,2)
          !
          nelem = iend-istart+1
          !
          mat4(ielem,istart:iend) = mat(ielem,1:nelem)
          !
       enddo
       !$omp end parallel do
       !
     else
       !
       !$omp parallel do private(ielem) shared(mat4) schedule(dynamic)
       do ielem = 1,dimen_s
          mat4(ielem,:) = mat(ielem,:)
       enddo
       !$omp end parallel do
       !
     endif
     !
     if (job%verbose>=4) write (out,"('       SSYEV (real4)...')") 
     !
     select case (trim(job%diagonalizer)) 

     case default
       !
       write (out,"('PTDiagonalize_hamiltonian_symm: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
       stop 'PTDiagonalize_hamiltonian_symm - wrong diagonalizer '
       !
     case('SYEV-4TO8') 
       !
       !call lapack_syev(mat4(1:dimen_s,1:dimen_s),energy4(1:dimen_s),jobz=jobz_) 
       !
       call diag_syev_i8(mat4(1:dimen_s,1:dimen_s),energy4(1:dimen_s),jobz=jobz_)
       !
       dimen4 = dimen_s
       if (rng=='I') then 
          dimen4 = min(int(irange(2)*job%factor),dimen_s)
       elseif(rng=='V') then 
          !
          k  = 0
          do iroot=1,dimen_s
             if (energy4(iroot)-job%partfunc%ZPE<=vrange(2)*job%factor) then 
                k = k+1
             endif
          enddo
          !
          dimen4 = k
          !
       endif 
       !
     case('SYEVR-4TO8') 
       !
       irange_(1) = 1 ; irange_(2) = min(int(irange(2)*job%factor),dimen_s)
       vrange4(1) = vrange(1) ; vrange4(2) = (vrange(2)-job%partfunc%ZPE)*job%factor+job%partfunc%ZPE
       !
       call lapack_syevr(mat4(1:dimen_s,1:dimen_s),energy4(1:dimen_s),rng=rng_,jobz=jobz_,iroots=dimen4,&
                        vrange=vrange4,irange=irange_)
       !
     end select
     !
     if (job%verbose>=4) write (out,"('       ...done!')") 
     !
     if (job%verbose>=5) then 

        do iroot=1,dimen4
          !
          termvalue = energy4(iroot)-job%partfunc%ZPE
          !
          MaxEigenvects  = small_
          !
          do jroot=1,dimen_s
             if (abs(mat4(jroot,iroot))>=MaxEigenvects) then 
                 MaxEigenvects = abs( mat4(jroot,iroot) )
                 maxTerm = jroot
             endif
          enddo
          !
          icase    = PT%symactive_space(gamma)%sym_N(maxTerm,1)
          ideg     = PT%symactive_space(gamma)%sym_N(maxTerm,2)
          cnu(:) = PT%contractive_space(:,icase)  
          nu = 0
          do iclasses = 0,PT%Nclasses
            if (cnu(iclasses)<=contr(iclasses)%nlevels) then
               nu(:) = nu(:) + contr(iclasses)%eigen(cnu(iclasses))%nu(:)
            endif 
            !
            cgamma(iclasses) = contr(iclasses)%eigen(cnu(iclasses))%gamma
            !
          enddo 
          !
          ! recostruct the rotational quanta from the 1D record
          !
          kdeg = PT%Index_deg(icase)%icoeffs(0,ideg)
          !
          k   = PT%rot_index(cnu(0),kdeg)%k
          tau = PT%rot_index(cnu(0),kdeg)%tau
          !
          write(out,'("4 ",a,i7,f14.6,3x,"[",a4,";",3i3,"]",1x,"["'//fmt%Aclasses//',";",'//fmt%Nmodes0//',"]")') & 
                     sym%label(gamma),iroot,termvalue,&
                     cgamma(0),jrot,k,tau, &
                     cgamma(1:PT%Nclasses), &
                     nu(1:PT%Nmodes)
          !
        enddo 
        !
     endif
     !
     if (job%sparse) dimen4 = min(dimen4,size(mat,dim=2))
     !
     if (job%verbose>=5) write (out,"('       syev4->syev8: dimen_s = ',i8,' dimen4 = ',i8)") dimen_s,dimen4
     !
     allocate (transform(dimen_s,dimen4),stat=alloc)
     !
     matsize = int(dimen_s,hik)*int(dimen4,hik)
     !
     call ArrayStart('diag_contract: 4-8',alloc,1,kind(transform),matsize)
     !
     !$omp parallel do private(ielem) shared(transform) schedule(dynamic)
     do ielem = 1,dimen4
        transform(:,ielem) = mat4(:,ielem)
     enddo
     !$omp end parallel do
     !
     deallocate(mat4,energy4)
     !
     select case (trim(job%orthogonalizer))
       !
     case default
       !
       write (out,"('PTDiagonalize_hamiltonian_symm: type of the orthogonalizer  ',a,' unknown')") trim(job%orthogonalizer)
       stop 'PTDiagonalize_hamiltonian_symm - wrong orthogonalizer'
       !
     case ('GRAM-SCHMIDT','SCHMIDT')
       !
       call schmidt_orthogonalization(dimen_s,dimen4,transform)
       !
     case ('SVD')
       !
       call lapack_gesvd(transform(1:dimen_s,1:dimen4))
       !
     end select
     !
     allocate (mat_t(dimen4,dimen_s),stat=alloc)
     !
     ! transformation to the real*4 basis
     !
     !call real4_real8_matrix_transformation(dimen_s,dimen4,mat,transform)
     !
     if (job%verbose>=5) write (out,"('     Transformation to the R4 basis...')")
     if (job%verbose>=4) call TimerStart('Real4to8-new-basis') 
     !
     if (job%sparse) then
        !  
        !$omp parallel do private(j,istart,iend,nelem,i,temp,l,lelem) shared(mat_t) schedule(dynamic)
        do i = 1,dimen4
           !
           if (job%verbose>=5) write (out,"('     i = ',i8)") i 
           !
           do j = 1,dimen_s
              !
              istart = bterm(j,1) ; iend   = bterm(j,2)
              !
              nelem = iend-istart+1
              !
              temp = 0
              !
              do l = 1,nelem
                 !
                 lelem = istart + l - 1
                 !
                 temp = temp +transform(lelem,i)*mat(j,l)
                 !
              enddo
              !
              mat_t(i,j) = temp
              !
          enddo
        enddo
        !$omp end parallel do
        !
        if (job%verbose>=4) call TimerStart('Real4to8-new-basis2')
        !
        if (job%verbose>=5) write (out,"('     Transformation to the R4 basis.........')")
        !
        !$omp parallel do private(j,i,l,temp) shared(mat) schedule(dynamic)
        do j = 1,dimen4
           !
           if (job%verbose>=5) write (out,"('     j = ',i8)") j
           !
           do i = j,dimen4
              !
              mat(j,i) = 0
              !
           enddo
           !
           do l = 1,dimen_s
              !
              if (transform(l,j).ne.0) then
                 !
                 temp = transform(l,j)
                 do i = 1,dimen4
                    !
                    mat(j,i) = mat(j,i) + temp*mat_t(i,l)
                    !
                 enddo
              endif

           enddo
        enddo
        !$omp end parallel do
        if (job%verbose>=4) call TimerStop('Real4to8-new-basis2')
        !
     else
        !
        call dgemm('T','N',dimen4,dimen_s,dimen_s,alpha,& 
                      transform(1:dimen_s,1:dimen4),dimen_s,&
                            mat(1:dimen_s,1:dimen_s),dimen_s,&
                     beta,mat_t(1:dimen4,1:dimen_s),dimen4)
        !
        call dgemm('N','N',dimen4,dimen4,dimen_s,alpha,&
                           mat_t(1:dimen4,1:dimen_s),dimen4,&
                        transform(1:dimen_s,1:dimen4),dimen_s,&
                       beta, mat(1:dimen4,1:dimen4),dimen4)
        !
     endif
     !
     if (job%verbose>=4) call TimerStop('Real4to8-new-basis') 
     if (job%verbose>=5) write (out,"('     ...done!')") 
     !
     deallocate(mat_t)
     !
     ! diagonalization
     !
     if (job%verbose>=5) write (out,"('     Diagonalization...')") 
     ! 
     select case (trim(job%diagonalizer)) 
     !
     case default
       !
       write (out,"('prediagonalization_single_double: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
       stop 'prediagonalization_single_double - wrong diagonalizer '
       !
     case('SYEV-4TO8') 
       !
       call lapack_syev(mat(1:dimen4,1:dimen4),energy(1:dimen4),jobz=jobz)
       nroots = dimen4
       !
     case('SYEVR-4TO8') 
       !
       call lapack_syevr(mat(1:dimen4,1:dimen4),energy(1:dimen4),rng=rng,jobz=jobz,iroots=nroots,vrange=vrange,irange=irange) 
       !
     end select
     !
     if (job%verbose>=5) write (out,"('     ...done!')") 
     !
     ! Reconstruct the eigenfunctions in the original representation 
     !
     if (job%verbose>=5) write (out,"('     Transformation to the original basis...')")
     !
     if (job%verbose>=4) call TimerStart('Real4to8-original-basis') 
     !
     allocate (mat_t(dimen_s,dimen4),stat=alloc)
     !
     matsize = int(dimen_s,hik)*int(dimen4,hik)
     !
     call ArrayStart('diag_contract: 4-8',alloc,1,kind(mat_t),matsize)
     !
     if (jobz=='V') then 
       call dgemm('N','N',dimen_s,dimen4,dimen4,alpha,transform(1:dimen_s,1:dimen4),dimen_s,& 
                          mat(1:dimen4,1:dimen4),dimen4,beta,mat_t(1:dimen_s,1:dimen4),dimen_s)
       !
       !$omp parallel do private(ielem) shared(mat) schedule(dynamic)
       do ielem=1,dimen_s
          !
          !omp parallel do private(jelem) shared(mat) schedule(dynamic)
          !do jelem=1,dimen4
          !  !
          !  mat(ielem,jelem) = mat_t(ielem,jelem)
          !  !
          !enddo 
          !omp end parallel do
          !
          call dcopy(dimen4,mat_t(ielem,1:dimen4),1,mat(ielem,1:dimen4),1)
          !
       enddo
       !$omp end parallel do
       !
     endif
     !
     if (job%verbose>=4) call TimerStop('Real4to8-original-basis') 
     !
     if (job%verbose>=5) write (out,"('     ...done!')") 
      !
     deallocate(mat_t,transform)
     !
     call ArrayStop('diag_contract: 4-8')
     !
     if (job%verbose>=4) call TimerStop('prediag: real4->real8')
     if (job%verbose>=4) write (out,"('     ...done!')")
     ! 
  end subroutine prediagonalization_single_double

  subroutine diagonalization_single_double(jrot,gamma,bterm,dimen_s,irange,vrange,jobz,rng,mat,transform,energy,nroots)

     integer(ik),intent(in)      :: jrot,gamma,dimen_s
     integer(ik),intent(in)      :: irange(2)
     integer(ik),intent(in)      :: bterm(dimen_s,2)
     real(rk),intent(in)         :: vrange(2)
     character(len=1),intent(in) :: rng,jobz
     real(rk),intent(inout)             :: transform(:,:)
     real(rk),intent(inout)      :: mat(:,:),energy(:)
     integer(ik),intent(out)     :: nroots
     !
     character(len=1)            :: jobz_,rng_
     real(rk),allocatable :: mat_t(:,:)
     integer(ik)          :: ielem,alloc,dimen4,iroot,k,kdeg,tau,icase,ideg,cnu(0:PT%Nclasses)
     integer(ik)          :: istart,iend,nelem,i,j
     integer(ik)          :: iclasses,jroot,maxTerm,nu(0:PT%nmodes)
     character(len=3)     :: cgamma(0:PT%Nclasses)
     real(rk)             :: termvalue,MaxEigenvects
     double precision     :: alpha = 1.0d0,beta=0.0d0, ddot
     integer(hik) :: matsize
     !
     !
     if (job%verbose>=4) write (out,"('     real4->real8-diagonalization...')")
     if (job%verbose>=4) call TimerStart('prediag: real4->real8')
     !
     dimen4 = nroots
     !
     jobz_ ='V'
     rng_ = rng
     !
     if (job%verbose>=4) write (out,"('     real4-energies...')") 
     !
     if (job%verbose>=4) then 

        do iroot=1,dimen4
          !
          termvalue = energy(iroot)-job%partfunc%ZPE
          !
          MaxEigenvects  = small_
          !
          do jroot=1,dimen_s
             if (abs(transform(jroot,iroot))>=MaxEigenvects) then 
                 MaxEigenvects = abs( transform(jroot,iroot) )
                 maxTerm = jroot
             endif
          enddo
          !
          icase    = PT%symactive_space(gamma)%sym_N(maxTerm,1)
          ideg     = PT%symactive_space(gamma)%sym_N(maxTerm,2)
          cnu(:) = PT%contractive_space(:,icase)  
          nu = 0
          do iclasses = 0,PT%Nclasses
            if (cnu(iclasses)<=contr(iclasses)%nlevels) then
               nu(:) = nu(:) + contr(iclasses)%eigen(cnu(iclasses))%nu(:)
            endif 
            !
            cgamma(iclasses) = contr(iclasses)%eigen(cnu(iclasses))%gamma
            !
          enddo 
          !
          ! recostruct the rotational quanta from the 1D record
          !
          kdeg = PT%Index_deg(icase)%icoeffs(0,ideg)
          !
          k   = PT%rot_index(cnu(0),kdeg)%k
          tau = PT%rot_index(cnu(0),kdeg)%tau
          !
          write(out,'("4 ",a,i7,f14.6,3x,"[",a4,";",3i3,"]",1x,"["'//fmt%Aclasses//',";",'//fmt%Nmodes0//',"]")') & 
                     sym%label(gamma),iroot,termvalue,&
                     cgamma(0),jrot,k,tau, &
                     cgamma(1:PT%Nclasses), &
                     nu(1:PT%Nmodes)
          !
        enddo 
        !
     endif
     !
     if (job%sparse) dimen4 = min(dimen4,size(mat,dim=2))
     !
     !deallocate(mat4,energy4)
     !call ArrayStop('mat_4')
     !
     select case (trim(job%orthogonalizer))
       !
     case default
       !
       write (out,"('PTDiagonalize_hamiltonian_symm: type of the orthogonalizer  ',a,' unknown')") trim(job%orthogonalizer)
       stop 'PTDiagonalize_hamiltonian_symm - wrong orthogonalizer'
       !
     case ('GRAM-SCHMIDT','SCHMIDT')
       !
       call schmidt_orthogonalization(dimen_s,dimen4,transform)
       !
     case ('SVD')
       !
       call lapack_gesvd(transform(1:dimen_s,1:dimen4))
       !
     end select
     !
     ! transformation to the real*4 basis
     !
     !call real4_real8_matrix_transformation(dimen_s,dimen4,mat,transform)
     !
     if (job%verbose>=4) write (out,"('     Transformation to the R4 basis...')")
     if (job%verbose>=4) call TimerStart('Real4to8-new-basis') 
     !
     if (job%sparse) then
        !
        allocate (mat_t(dimen_s,dimen4),stat=alloc)
        !  
        !$omp parallel do private(j,istart,iend,nelem) shared(mat_t) schedule(dynamic)
        do i = 1,dimen_s
           !
           istart = bterm(i,1) ; iend   = bterm(i,2)
           !
           nelem = iend-istart+1
           !
           if (job%verbose>=5) write (out,"('     i = ',i8)") i 
           !
           do j = 1,dimen4
              !
              mat_t(i,j) = ddot(nelem,mat(i,:),1,transform(istart:iend,j),1)
              !
          enddo
        enddo
        !$omp end parallel do
        !
        if (job%verbose>=4) call TimerStart('Real4to8-new-basis2')
        !
        if (job%verbose>=4) write (out,"('     Transformation to the R4 basis-2........')")
        !
        !$omp parallel do private(j,i) shared(mat) schedule(dynamic)
        do i = 1,dimen4
           !
           if (job%verbose>=5) write (out,"('     j = ',i8)") j
           !
           do j = i,dimen4
              !
              mat(i,j) = ddot(dimen_s,transform(1:dimen_s,i),1,mat_t(1:dimen_s,j),1)

           enddo
        enddo
        !$omp end parallel do
        if (job%verbose>=4) call TimerStop('Real4to8-new-basis2')
        !
     else
        !
        allocate (mat_t(dimen4,dimen_s),stat=alloc)
        !
        call dgemm('T','N',dimen4,dimen_s,dimen_s,alpha,& 
                      transform(1:dimen_s,1:dimen4),dimen_s,&
                            mat(1:dimen_s,1:dimen_s),dimen_s,&
                     beta,mat_t(1:dimen4,1:dimen_s),dimen4)
        !
        call dgemm('N','N',dimen4,dimen4,dimen_s,alpha,&
                           mat_t(1:dimen4,1:dimen_s),dimen4,&
                        transform(1:dimen_s,1:dimen4),dimen_s,&
                       beta, mat(1:dimen4,1:dimen4),dimen4)
        !
     endif
     !
     if (job%verbose>=4) call TimerStop('Real4to8-new-basis') 
     if (job%verbose>=4) write (out,"('     ...done!')") 
     !
     deallocate(mat_t)
     !
     ! diagonalization
     !
     if (job%verbose>=4) write (out,"('     Diagonalization...')") 
     ! 
     !select case (trim(job%diagonalizer)) 
     !
     !case default
     !  !
     !  write (out,"('prediagonalization_single_double: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
     !  stop 'prediagonalization_single_double - wrong diagonalizer '
     !  !
     !case('SYEV-4TO8') 
       !
       call lapack_syev(mat(1:dimen4,1:dimen4),energy(1:dimen4),jobz=jobz)
       nroots = dimen4
       !
     !case('SYEVR-4TO8') 
     !  !
     !  call lapack_syevr(mat(1:dimen4,1:dimen4),energy(1:dimen4),rng=rng,jobz=jobz,iroots=nroots,vrange=vrange,irange=irange) 
     !  !
     !end select
     !
     if (job%verbose>=4) write (out,"('     ...done!')") 
     !
     ! Reconstruct the eigenfunctions in the original representation 
     !
     if (job%verbose>=4) write (out,"('     Transformation to the original basis...')")
     !
     if (job%verbose>=4) call TimerStart('Real4to8-original-basis') 
     !
     allocate (mat_t(dimen_s,dimen4),stat=alloc)
     !
     matsize = int(dimen_s,hik)*int(dimen4,hik)
     !
     call ArrayStart('diag_contract: 4-8',alloc,1,kind(mat_t),matsize)
     !
     if (jobz=='V') then 
       call dgemm('N','N',dimen_s,dimen4,dimen4,alpha,transform(1:dimen_s,1:dimen4),dimen_s,& 
                          mat(1:dimen4,1:dimen4),dimen4,beta,mat_t(1:dimen_s,1:dimen4),dimen_s)
       !
       !$omp parallel do private(ielem) shared(mat) schedule(dynamic)
       do ielem=1,dimen_s
          !
          !omp parallel do private(jelem) shared(mat) schedule(dynamic)
          !do jelem=1,dimen4
          !  !
          !  mat(ielem,jelem) = mat_t(ielem,jelem)
          !  !
          !enddo 
          !omp end parallel do
          !
          call dcopy(dimen4,mat_t(ielem,1:dimen4),1,mat(ielem,1:dimen4),1)
          !
       enddo
       !$omp end parallel do
       !
     endif
     !
     if (job%verbose>=4) call TimerStop('Real4to8-original-basis') 
     !
     if (job%verbose>=4) write (out,"('     ...done!')") 
      !
     deallocate(mat_t)
     !
     call ArrayStop('diag_contract: 4-8')
     !
     if (job%verbose>=4) call TimerStop('prediag: real4->real8')
     if (job%verbose>=4) write (out,"('     ...done!')")
     ! 
  end subroutine diagonalization_single_double


  subroutine PT_energy_truncated_diagonalization(dimen_s,irange,vrange,jobz,rng,mat,energy,nroots)

    integer(ik),intent(in)      :: dimen_s
    integer(ik),intent(in)      :: irange(2)
    real(rk),intent(in)         :: vrange(2)
    character(len=1),intent(in) :: rng,jobz
    real(rk),intent(inout)      :: mat(:,:),energy(:)
    integer(ik),intent(out)     :: nroots
    !
    character(len=1)            :: jobz_
    real(rk),allocatable :: mat_t(:,:),mat_k(:,:),mat_g(:,:),energy_(:)
    integer(ik)          :: ielem,jelem,kelem,nelem,alloc
    real(rk)             :: pt_thresh,factor,df,energy_thresh,energy_t,eps,eps_
    double precision     :: alpha = 1.0d0,beta=0.0d0
    integer(hik)         :: matsize
    integer(ik)          :: iter,max_elems,dimen_g,dimen_n
    integer(ik)           :: iaddress(dimen_s),naddress(dimen_s),kaddress(dimen_s)
    !

    jobz_ = 'N'

    pt_thresh = job%pt_ener_thresh

    factor = 0 ! ????
    !
    df = (job%factor-1.0_rk)/job%maxiter
    !
    do ielem=1,dimen_s
        !
        energy(ielem) = mat(ielem,ielem)
        !
    enddo
    !
    energy_thresh = (vrange(2)-job%partfunc%ZPE)*(factor+1.0_rk)+job%partfunc%ZPE
    max_elems = min(int(irange(2)*(factor+1.0_rk)),dimen_s)
    !
    ! obtain the energy threshold for a given max_elems(nroots)
    !
    if (max_elems<dimen_s) then 
      !
      allocate (energy_(dimen_s),stat=alloc)
      !
      do ielem=1,dimen_s
        !
        energy_(ielem) = mat(ielem,ielem)
        !
      enddo
      !
      do ielem=1,max_elems
        !
        energy_t = energy_(ielem)
        !
        do jelem=ielem+1,dimen_s
          !
          if ( energy_t>energy_(jelem) ) then
            !
            energy_t=energy_(jelem)
            energy_(jelem) = energy_(ielem)
            energy_(ielem) = energy_t
            !
          endif 
          !
        enddo
        !
      enddo
      !
      energy_thresh = min(energy_(max_elems),energy_thresh)
      !
      deallocate(energy_)
      !
    endif
    !
    eps = safe_max  ; eps_ = safe_max
    !
    iter = 0
    !
    do while(iter<=job%maxiter.and.eps>job%tolerance)
       !
       iter = iter + 1
       !
       factor = factor + df 
       !
       eps = eps_
       !
       if (eps<job%tolerance.or.iter==job%maxiter) then 
         !
         jobz_ = jobz
         !
       endif
       !
       ! count the elements taken into account for the given thresholds
       !
       kaddress = 0
       iaddress = 1
       naddress = 1
       !
       do ielem=1,dimen_s
          !
          if (mat(ielem,ielem)<=energy_thresh) then
            !
            kelem = kelem + 1
            !
            kaddress(ielem) = kelem
            iaddress(kelem) = ielem
            !
           elseif(mat(ielem,ielem)-energy_thresh<=pt_thresh) then 
            !
            nelem = nelem + 1
            naddress(nelem) = ielem
            !
          endif
          !
       enddo
       !
       dimen_g = kelem
       dimen_n = nelem
       !
       if (job%verbose>=5) write (out,"('     Size of the contr. matrix = ',i8)") dimen_g
       if (job%verbose>=5) write (out,"('     Number of elements taken for PT = ',i8)") dimen_n
       !
       if (dimen_g==0) then  
         nroots =0
         return
       endif
       !
       if (job%verbose>=5) write (out,"('     Shrinking the matrix...')")
       if (job%verbose>=4) call TimerStart('Shrinking e-matrix')
       !
       if (job%verbose>=5) write (out,"('       restoring the lower part from the upper...')")
       !
       !$omp parallel do private(ielem,jelem) shared(mat) schedule(dynamic)
       do ielem=1,dimen_s
          !
          do jelem=1,ielem-1
             !
             mat(jelem,ielem) = mat(ielem,jelem)
             !
          enddo
          !
       enddo
       !$omp end parallel do
       !
       if (job%verbose>=5) write (out,"('       initializating the reduced matrix G...')")
       !
       allocate (mat_g(0:dimen_g,dimen_g),stat=alloc)
       matsize = int(dimen_g,hik)*int(dimen_g,hik)
       !
       call ArrayStart('bset_contr_diago_g',alloc,1,kind(mat_g),matsize)
       !$omp parallel do private(ielem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          !
          mat_g(0:dimen_g,ielem) = 0
          !
       enddo
       !$omp end parallel do
       !
       if (dimen_n>0) then 
         !
         if (job%verbose>=5) write (out,"('       a) computing the perturbation theory correction ...')")
         !
         allocate (mat_k(1:dimen_g,1:dimen_n),mat_t(1:dimen_g,1:dimen_n),stat=alloc)
         !
         matsize = int(dimen_g,hik)*int(dimen_n,hik)*2_hik
         !
         call ArrayStart('bset_contr_diago_pt',alloc,1,kind(mat_k),matsize)
         !
         !$omp parallel do private(ielem,nelem) shared(mat_k,mat_t) schedule(dynamic)
         do ielem=1,dimen_g
            !
            do nelem=1,dimen_n
              !
              mat_t(ielem,nelem) = mat(iaddress(ielem),naddress(nelem))
              mat_k(ielem,nelem) = mat_t(ielem,nelem)/( energy(iaddress(ielem))-energy(naddress(nelem)) )
              !
            enddo
            !
         enddo
         !$omp end parallel do
         !
         if (job%verbose>=5) write (out,"('       b) computing the perturbation theory correction ...')")
         !
         alpha = 0.5d0
         !
         call dgemm('N','T',dimen_g,dimen_g,dimen_n,alpha,&
                            mat_k(1:dimen_g,1:dimen_n),dimen_g,&
                            mat_t(1:dimen_g,1:dimen_n),dimen_g,&
                       beta,mat_g(1:dimen_g,1:dimen_g),dimen_g)
         !
         alpha = 1.0d0
         !
         deallocate(mat_k,mat_t)
         call ArrayStop('bset_contr_diago_pt')
         !
       endif
       !
       if (job%verbose>=5) write (out,"('       shrinking the matrix and  adding the PT correction...')")
       !
       !$omp parallel do private(ielem,jelem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          !
          do jelem=1,ielem
             !
             mat_g(ielem,jelem) = mat_g(ielem,jelem) + mat_g(jelem,ielem) + mat(iaddress(ielem),iaddress(jelem))
             !
             mat_g(jelem,ielem) = mat_g(ielem,jelem)
             !
          enddo
          !
       enddo
       !$omp end parallel do
       !
       if (job%verbose>=4) call TimerStop('Shrinking e-matrix')
       if (job%verbose>=5) write (out,"('     ...done!')")
       !
       ! diagonalization
       !
       if (job%verbose>=5) write (out,"('     Diagonalization...')")
       if (job%verbose>=4) call TimerStart('Diagonalization matrix')
       !
       allocate(energy_(dimen_g),stat=alloc)
       !
       select case (trim(job%diagonalizer)) 
       !
       case default
         !
         write (out,"('krot_contracted_diagonalization_II: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
         stop 'krot_contracted_diagonalization_II - wrong diagonalizer '
         !
       case('SYEV-E-PT') 
         !
         call lapack_syev(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),jobz=jobz_)
         nroots = min(dimen_g,size(mat_g,dim=2))
         !
       case('SYEVR-E-PT') 
         !
         call lapack_syevr(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),rng=rng,jobz=jobz_,iroots=nroots,&
                           vrange=vrange,irange=irange)
         nroots = min(nroots,size(mat_g,dim=2))
         !
       end select
       !
       if (nroots<0) cycle
       !
       if (job%verbose>=4) call TimerStop('Diagonalization matrix')
       !
       if (job%verbose>=5) write (out,"('       nroots = ',2i5)") nroots
       !
       if (job%verbose>=5) write (out,"('     ...done!')") 
       !
       ! Reconstruct the eigenfunctions in the original representation 
       !
       if (job%verbose>=5) write (out,"('     transformation to the original basis...')")
       if (job%verbose>=4) call TimerStart('transform to original k-basis')
       !
       if (jobz_=='V') then
          !
          !$omp parallel do private(ielem,kelem) shared(mat) schedule(dynamic)
          do ielem=1,dimen_s
             !
             kelem = kaddress(ielem)
             !
             if (kelem/=0) call dcopy(nroots,mat_g(kelem,1:nroots),1,mat(ielem,1:nroots),1)
             !
          enddo
          !$omp end parallel do
          !
       endif
       !
       call ArrayStop('PT_contr_diago_g')
       !
       eps_ = sqrt(sum( (energy_(1:nroots)-energy(1:nroots))**2/nroots ))
       !
       energy(1:nroots) = energy_(1:nroots)
       !
       ! update the energy threshold
       !
       if (max_elems<dimen_s.and.max_elems>0) then 
         !
         energy_thresh = energy_(max_elems)
         !
       endif
       !
    enddo
    !
  end subroutine PT_energy_truncated_diagonalization


  subroutine PT_bset_truncated_diagonalization(gamma,dimen_s,irange,vrange,jobz,rng,mat,energy,nroots)

    integer(ik),intent(in)      :: gamma,dimen_s
    integer(ik),intent(in)      :: irange(2)
    real(rk),intent(in)         :: vrange(2)
    character(len=1),intent(in) :: rng,jobz
    real(rk),intent(inout)      :: mat(:,:),energy(:)
    integer(ik),intent(out)     :: nroots
    !
    character(len=1)     :: jobz_
    real(rk),allocatable :: mat_t(:,:),mat_k(:,:),mat_g(:,:),energy_(:),vector(:),energy0(:)
    integer(ik)          :: ielem,jelem,kelem,nelem,alloc,iroot
    real(rk)             :: termvalue,pt_thresh,df,energy_thresh,energy_t,eps,eps_,f_t,tol_thresh
    double precision     :: alpha = 1.0d0,beta=0.0d0
    double precision     :: ddot
    integer(hik)         :: matsize
    integer(ik)          :: iter,max_elems,dimen_g,dimen_n,dimen_x,dimen_e
    integer(ik)          :: iaddress(dimen_s),kaddress_(dimen_s),naddress(dimen_s),kaddress(dimen_s),naddress_(dimen_s)
    logical              :: last_iter
    !
    if (job%verbose>=4) write (out,"('     bset-contracted diagonalization...')")
    if (job%verbose>=4) call TimerStart('bset_contr_diago')
    !
    jobz_ = 'N'
    !
    pt_thresh = job%pt_ener_thresh
    tol_thresh = job%thresh
    !
    df = job%factor
    !
    do ielem=1,dimen_s
        !
        energy(ielem) = mat(ielem,ielem)
        !
    enddo
    !
    energy_thresh = vrange(2)
    max_elems = min(irange(2),dimen_s)
    !
    ! obtain the energy threshold for a given max_elems(nroots)
    !
    allocate (energy0(dimen_s),stat=alloc)
    !
    call dcopy(dimen_s,energy(:),1,energy0(:),1)
    !
    do ielem=1,dimen_s
      !
      energy_t = energy0(ielem)
      !
      do jelem=ielem+1,dimen_s
        !
        if ( energy_t>energy0(jelem) ) then
          !
          energy_t=energy0(jelem)
          energy0(jelem) = energy0(ielem)
          energy0(ielem) = energy_t
          !
        endif 
        !
      enddo
      !
    enddo
    !
    if (max_elems<dimen_s)  energy_thresh = min(energy0(max_elems),energy_thresh)
    !
    ! count the elements taken into account for the given thresholds
    !
    iaddress = 1
    naddress_= 1
    kaddress_= 0
    dimen_g  = 0
    dimen_n  = dimen_s
    !
    kelem = 0 ; nelem = 0
    !
    do ielem=1,dimen_s
       !
       if (energy(ielem)<=energy_thresh) then
         !
         kelem = kelem + 1
         !
         kaddress_(ielem) = kelem
         iaddress(kelem)  = ielem
         !
       else
         !
         nelem = nelem + 1
         naddress_(nelem) = ielem
         !
       endif
       !
    enddo
    !
    dimen_e = kelem
    dimen_x = nelem
    !
    if (job%verbose>=4) write (out,"('     Number of roots to converge     = ',i9)") dimen_e
    if (job%verbose>=4) write (out,"('     Lowest diagonal mat. element    = ',f18.8)") energy(1)
    !
    eps = safe_max  ; eps_ = safe_max
    !
    nroots =0
    !
    if (dimen_e==0) return
    !
    if (dimen_x>0) then 
      !
      if (job%verbose>=4) write (out,"('     analyzing all basis set contributions ...')")
      !
      allocate (mat_k(1:dimen_e,1:dimen_x),vector(1:dimen_x),stat=alloc)
      !
      matsize = int(dimen_e,hik)*int(dimen_x,hik)+int(dimen_x,hik)
      !
      call ArrayStart('bset_contr_diago_pt',alloc,1,kind(mat_k),matsize)
      !
      !$omp parallel do private(ielem,nelem) shared(mat_k) schedule(dynamic)
      do ielem=1,dimen_e
         !
         do nelem=1,dimen_x
           !
           mat_k(ielem,nelem) = mat(iaddress(ielem),naddress_(nelem))/( energy(iaddress(ielem))-energy(naddress_(nelem)) )
           !
         enddo
         !
      enddo
      !$omp end parallel do
      !
      !$omp parallel do private(nelem,f_t) shared(vector) schedule(dynamic)
      do nelem=1,dimen_x
         !
         f_t = ddot(dimen_e,mat_k(:,nelem),1,mat_k(:,nelem),1)
         !
         vector(nelem) = sqrt(f_t/real(dimen_e,ark) )
         !
      enddo
      !$omp end parallel do
      !
      if (job%verbose>=5) then 
        !
        write (out,"(/'     Contributions from the basis functions beyond the selected region...')")
        !
        do nelem=1,dimen_x
           !
           write (out,"(i6,f16.8)") nelem,vector(nelem)
           !
        enddo
        !
        write (out,"('')")
        !
      endif
      !
      deallocate(mat_k)
      !        
      call ArrayStop('bset_contr_diago_pt')
      !
    endif
    !
    iter = 0
    !
    last_iter = .false.
    !
    do while(.not.last_iter)
       !
       iter = iter + 1
       !
       if (job%verbose>=4) write (out,"(/'     iter = ',i8,'  tol_thresh = ',g18.8)") iter,tol_thresh
       if (job%verbose>=4) write (out,"('     Prepare the matrix...')")
       !
       eps = eps_
       !
       if (eps<=job%tolerance.or.iter==job%maxiter) last_iter = .true.
       !
       if (job%verbose>=4) write (out,"('     Shrinking the matrix...')")
       if (job%verbose>=4) call TimerStart('Shrinking b-matrix')
       !
       ! count the elements taken into account for the given thresholds
       !
       naddress = 1
       kaddress = kaddress_
       !
       kelem = dimen_e ; nelem = 0
       !
       do jelem=1,dimen_x
          !
          ielem = naddress_(jelem)
          !
          if(vector(jelem)>=tol_thresh*pt_thresh) then 
            !
            nelem = nelem + 1
            naddress(nelem) = ielem
            !
          elseif (vector(jelem)>=tol_thresh) then
            !
            kelem = kelem + 1
            !
            kaddress(ielem) = kelem
            iaddress(kelem) = ielem
            !
          endif
          !
       enddo
       !
       dimen_g = kelem
       dimen_n = nelem
       !
       if (dimen_g==dimen_s) last_iter = .true.
       !
       if (job%verbose>=4) write (out,"('       Size of the contr. matrix       = ',i9)") dimen_g
       if (job%verbose>=4) write (out,"('       Number of elements taken for PT = ',i9)") dimen_n
       !
       if (dimen_g==0) cycle
       !
       if (job%verbose>=4) write (out,"('       -- initializating the reduced matrix G...')")
       !
       allocate (mat_g(0:dimen_g,dimen_g),stat=alloc)
       matsize = int(dimen_g,hik)*int(dimen_g,hik)
       !
       call ArrayStart('bset_contr_diago_g',alloc,1,kind(mat_g),matsize)
       !$omp parallel do private(ielem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          mat_g(0:dimen_g,ielem) = 0
       enddo
       !$omp end parallel do
       !
       if (dimen_n>0) then 
          !
          if (job%verbose>=4) write (out,"('       -- computing the perturbation theory correction ...')")
          !
          allocate (mat_k(1:dimen_g,1:dimen_n),mat_t(1:dimen_g,1:dimen_n),stat=alloc)
          !
          matsize = int(dimen_g,hik)*int(dimen_n,hik)*2_hik
          !
          call ArrayStart('bset_contr_diago_pt',alloc,1,kind(mat_k),matsize)
          !
          !$omp parallel do private(ielem,nelem,energy_t) shared(mat_k,mat_t) schedule(dynamic)
          do ielem=1,dimen_g
             !
             do nelem=1,dimen_n
               !
               mat_t(ielem,nelem) = 0
               mat_k(ielem,nelem) = 0
               !
               energy_t = energy(iaddress(ielem))-energy(naddress(nelem))
               !
               if (abs(mat(iaddress(ielem),naddress(nelem))/energy_t)<1e2) then
                 !
                 mat_t(ielem,nelem) = mat(iaddress(ielem),naddress(nelem))
                 mat_k(ielem,nelem) = mat_t(ielem,nelem)/energy_t
                 !
              else 
                 !
                 write(out,"('bset_contr_diago_pt-error: mat(iaddress(ielem),naddress(nelem))/energy_t)<1e2 ')")
                 write(out,"(a,i8,a,i8,'; iaddresses = ',2i8,' mat = ',g18.8,' energies = ',2f18.9,' dener = ',g18.8,' ')") &
                 'ielem = ',ielem,'; nelem = ',nelem,iaddress(ielem),naddress(nelem),mat(iaddress(ielem),naddress(nelem)),&
                 energy(iaddress(ielem)),energy(naddress(nelem)),energy_t
                 stop 'bset_contr_diago_pt-error: mat(iaddress(ielem),naddress(nelem))/energy_t)<1e2'
                 !
               endif
               !
             enddo
             !
          enddo
          !$omp end parallel do
          !
          alpha = 0.5d0
          !
          call dgemm('N','T',dimen_g,dimen_g,dimen_n,alpha,&
                             mat_k(1:dimen_g,1:dimen_n),dimen_g,&
                             mat_t(1:dimen_g,1:dimen_n),dimen_g,&
                        beta,mat_g(1:dimen_g,1:dimen_g),dimen_g)
          !
          alpha = 1.0d0
          !
          deallocate(mat_k,mat_t)
          call ArrayStop('bset_contr_diago_pt')
          !
       endif 
       !
       if (job%verbose>=4) write (out,"('       -- shrinking the matrix and  adding the PT correction...')")
       !
       !$omp parallel do private(ielem,jelem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          !
          do jelem=1,ielem
             !
             mat_g(ielem,jelem) = mat_g(ielem,jelem) + mat_g(jelem,ielem) + mat(iaddress(ielem),iaddress(jelem))
             !
             mat_g(jelem,ielem) = mat_g(ielem,jelem)
             !
          enddo
          !
       enddo
       !$omp end parallel do
       !
       if (job%verbose>=4) call TimerStop('Shrinking b-matrix')
       if (job%verbose>=4) write (out,"('     ...done!')")
       !
       !
       ! diagonalization
       !
       if (job%verbose>=4) write (out,"('     Diagonalization...')")
       if (job%verbose>=4) call TimerStart('Diagonalization matrix')
       !
       allocate(energy_(dimen_g),stat=alloc)
       !
       if (last_iter) jobz_=jobz
       !
       select case (job%diagonalizer(1:5)) 
       !
       case default
         !
         write (out,"('PT_bset_truncated_diagonalization: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
         stop 'PT_bset_truncated_diagonalization - wrong diagonalizer '
         !
       case('SYEV-') 
         !
         call lapack_syev(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),jobz=jobz_)
         nroots = dimen_g
         !
       case('SYEVR') 
         !
         call lapack_syevr(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),rng=rng,jobz=jobz_,iroots=nroots,&
                           vrange=vrange,irange=irange)
         !
       end select
       !
       if (nroots<0) cycle
       !
       if (job%verbose>=4) call TimerStop('Diagonalization matrix')
       !
       if (job%verbose>=4) write (out,"('     ...done!')") 
       !
       if (job%verbose>=4) write (out,"('     nroots = ',2i5/)") nroots
       !
       if (job%verbose>=4) then 
           !
           do iroot=1,nroots
             !
             termvalue = energy_(iroot)-job%partfunc%ZPE
             write(out,'("| ",a,i7,f14.6)') sym%label(gamma),iroot,termvalue
             !
           enddo 
           !
        endif
       !
       ! Reconstruct the eigenfunctions in the original representation 
       !
       if (last_iter.and.jobz_=='V') then
          !
          if (job%verbose>=4) write (out,"('     transformation to the original basis...')")
          if (job%verbose>=4) call TimerStart('transform to original basis')
          !
          !$omp parallel do private(ielem,kelem) shared(mat) schedule(dynamic)
          do ielem=1,dimen_s
             !
             kelem = kaddress(ielem)
             !
             call dcopy(nroots,mat_g(kelem,1:nroots),1,mat(ielem,1:nroots),1)
             !
          enddo
          !$omp end parallel do
          !
          if (job%verbose>=4) call TimerStop('transform to original basis')
          if (job%verbose>=4) write (out,"('     ...done!')")
          !
       endif
       !
       eps_ = sqrt(sum( ( energy0(1:dimen_e)-energy_(1:dimen_e) )**2 )/real(dimen_e,ark) )
       !
       energy0(1:nroots) = energy_(1:nroots)
       !
       if (job%verbose>=4) write (out,"('     rms = ',g18.8)") eps_
       !
       ! update the tolerence threshold
       !
       tol_thresh = df*tol_thresh
       !
       deallocate(mat_g,energy_)
       call ArrayStop('bset_contr_diago_g')
       ! 
    enddo
    !
    energy(1:nroots) = energy0(1:nroots)
    !
    deallocate(energy0)
    !
    if (allocated(vector)) deallocate(vector)
    !
    if (job%verbose>=4) call TimerStop('bset_contr_diago') 
    if (job%verbose>=4) write (out,"('     ...done!')")
    !
  end subroutine PT_bset_truncated_diagonalization


  subroutine PT_diagonal_no_diagonalization(dimen_s,bterm,mat,energy,nroots,ivec)

    integer(ik),intent(in)      :: dimen_s
    integer(ik),intent(in)      :: bterm(dimen_s,2)
    real(rk),intent(inout)      :: mat(:,:),energy(:)
    integer(ik),intent(out)     :: nroots
    integer(ik),intent(out)     :: ivec(1:dimen_s)
    real(rk)                    :: energy_t
    !
    integer(ik)          :: ielem,alloc,jelem,istart,nelem,iend,ivec_t,dimen_p
    !
    if (job%verbose>=5) write (out,"('     Eigen-problem: no diagonalization...')")
    !
    !if (job%verbose>=4) call TimerStart('diagonal: no diagonalization')
    !
    energy(:) = mat(:,1)
    !
    do ielem=1,dimen_s
        ivec(ielem) = ielem
    enddo
    !
    do ielem=1,dimen_s
      !
      energy_t = energy(ielem)
      !
      do jelem=ielem+1,dimen_s
        !
        if ( energy_t>energy(jelem) ) then
          !
          energy_t=energy(jelem)
          energy(jelem) = energy(ielem)
          energy(ielem) = energy_t
          !
          ivec_t = ivec(jelem)
          ivec(jelem) = ivec(ielem)
          ivec(ielem) = ivec_t
          !
        endif 
        !
      enddo
      !
    enddo
    !
    mat(:,1) = real(ivec,rk)
    !
    nroots = dimen_s
    !
    !if (job%verbose>=4) call TimerStop('diagonal: no diagonalization') 
    if (job%verbose>=5) write (out,"('     ...done!')")
    !
  end subroutine PT_diagonal_no_diagonalization






  subroutine krot_contracted_diagonalization(jrot,k_row,dimen_s,vrange,irange,rng,jobz,mat,energy,nroots)

    integer(ik),intent(in)    :: jrot,dimen_s,k_row(dimen_s),irange(2)
    real(rk),intent(in)       :: vrange(2)
    real(rk),intent(inout)    :: mat(:,:),energy(:)
    integer(ik),intent(out)   :: nroots
    !
    real(rk),allocatable  :: gmat(:,:),mat_k(:,:),energy_k(:),gmat_t(:)
    real(rk)              :: energy_thresh,energy_t
    integer(ik)           :: iaddress(dimen_s),max_elems,dimen_g,kblock(0:jrot,2),iaddr_t,ielem_t
    integer(ik) ::ielem,jelem,alloc,k_i,k_j,ielem_start,ielem_end,dimen_k,dimenmax
    character(len=1),intent(in)     :: rng,jobz
    character(len=1)     :: jobz_
    double precision     :: alpha = 1.0d0,beta=0.0d0
    integer(hik)         :: matsize
    !
    if (job%verbose>=4) write (out,"('     krot-contracted diagonalization...')")
    if (job%verbose>=4) call TimerStart('krot_contr_diago')
    !
    allocate (gmat(dimen_s,dimen_s),stat=alloc)
    call ArrayStart('krot_contr_diago',alloc,size(gmat),kind(gmat))
    gmat = 0
    !
    ielem_end = 0
    !
    ! organize the k-blocks
    !
    dimenmax = 1
    !
    do k_i = 0,jrot
       !
       k_j = k_i
       ielem_start = ielem_end + 1
       do while (k_j==k_i.and.ielem_end<dimen_s)
          !
          ielem_end = ielem_end + 1
          !
          k_j = k_row(ielem_end)
          !
       enddo
       !
       if (ielem_end<dimen_s) ielem_end = ielem_end - 1
       !
       kblock(k_i,1) = ielem_start
       kblock(k_i,2) = ielem_end
       dimen_k = ielem_end-ielem_start+1
       dimenmax = max(dimenmax,dimen_k)
       !
    enddo
    !
    !omp parallel private(mat_k,energy_k,alloc) shared(gmat,energy)
    allocate (mat_k(dimenmax,dimenmax),energy_k(dimenmax),stat=alloc)
    if (alloc/=0) then
       write (out,"(' Error ',i9,' trying to allocate array energy_k,mat_k')") alloc
       stop 'krot_contr_diago: energy_k,mat_k  - out of memory'
    end if
    !
    !omp do private(k_i,k_j,ielem_start,ielem_end,dimen_k,jobz_) schedule(dynamic)
    do k_i = 0,jrot
       !
       if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
       !
       k_j = k_i
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       if (dimen_k<=0) cycle
       if (dimen_k>size(mat,dim=2)) then 
         write(out,"('krot_contracted_diagon: number of cols in mat is too small:',i9)") size(mat,dim=2),dimen_k
         stop 'krot_contracted_diagon: N of cols in mat is too small'
       endif 
       !
       mat_k(1:dimen_k,1:dimen_k) = mat(ielem_start:ielem_start+dimen_k-1,ielem_start:ielem_start+dimen_k-1)
       !
       jobz_ = 'V'
       !
       call lapack_syev(mat_k(1:dimen_k,1:dimen_k),energy_k(1:dimen_k),jobz=jobz_)
       !
       gmat(ielem_start:ielem_start+dimen_k-1,ielem_start:ielem_start+dimen_k-1) = mat_k(1:dimen_k,1:dimen_k)
       energy(ielem_start:ielem_start+dimen_k-1) = energy_k(1:dimen_k)
       !
    enddo
    !omp end do
    !
    deallocate(mat_k,energy_k)
    !omp end parallel
    !
    ! Transformation to the krot-contracted basis
    !
    ! the new basis is energy truncated 
    !
    energy_thresh = (vrange(2)-job%partfunc%ZPE)*job%factor+job%partfunc%ZPE
    max_elems = min(int(irange(2)*job%factor),dimen_s)
    !
    ! sorting the eigenvectors according the energy 
    !
    dimen_g = 0
    !
    allocate (gmat_t(dimen_s),stat=alloc)
    !
    call ArrayStart('krot_contr_diag-gmat-t',alloc,size(gmat_t),kind(gmat_t))
    !
    if (job%verbose>=5) write (out,"('     Sorting the k-eigenvectors...')") 
    !
    do ielem=1,dimen_s
      !
      iaddress(ielem) = ielem
      !
    enddo
    !
    do ielem=1,dimen_s
      !
      energy_t = energy(ielem)
      !
      do jelem=ielem+1,dimen_s
        !
        if ( energy_t>energy(jelem) ) then
          !
          energy_t=energy(jelem)
          energy(jelem) = energy(ielem)
          energy(ielem) = energy_t
          !
          iaddr_t = iaddress(jelem)
          iaddress(jelem) = iaddress(ielem)
          iaddress(ielem) = iaddr_t
          !
        endif 
        !
      enddo
      !
      if (ielem>max_elems.or.energy(ielem)>energy_thresh) exit
      !
      dimen_g = dimen_g + 1
      !
    enddo
    !
    if (job%verbose>=5) write (out,"('     Size of the k-contr. matrix = ',i9)") dimen_g
    !
    if (dimen_g==0) then  
      nroots =0
      return
    endif
    !
    do ielem=1,dimen_g
      !
      jelem = iaddress(ielem)
      if (jelem==ielem) cycle
      ielem_t = ielem
      !
      !gmat_t(:) = gmat(:,ielem)
      !gmat(:,ielem) = gmat(:,jelem)
      !
      call dcopy(dimen_s,gmat(:,ielem),1,gmat_t(:    ),1)
      call dcopy(dimen_s,gmat(:,jelem),1,gmat(:,ielem),1)
      !
      do while (jelem/=ielem) 
        !
        iaddress(ielem_t) = ielem_t
        !
        !gmat(:,ielem_t) = gmat(:,jelem)
        !
        call dcopy(dimen_s,gmat(:,jelem),1,gmat(:,ielem_t),1)
        !
        ielem_t = jelem
        jelem = iaddress(jelem)
        !
      enddo
      !
      !gmat(:,ielem_t) = gmat_t(:)
      !
      call dcopy(dimen_s,gmat_t(:),1,gmat(:,ielem_t),1)
      !
      iaddress(ielem_t) = ielem_t
      !
    enddo
    !
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    deallocate(gmat_t)
    !
    call ArrayStop('krot_contr_diag-gmat-t')
    !
    !
    !call matrix_transform(dimen_s,dimen_g,mat,gmat)
    !
    if (job%verbose>=5) write (out,"('     transformation to k-contr. basis (dgemm)...')") 
    !
    allocate (mat_k(dimen_g,dimen_s),stat=alloc)
    !
    matsize = int(dimen_g,hik)*int(dimen_s,hik)
    !
    call ArrayStart('krot_contr_diag-gmat-t',alloc,1,kind(mat_k),matsize)
    !
    call dgemm('T','N',dimen_g,dimen_s,dimen_s,alpha,& 
                       gmat(1:dimen_s,1:dimen_g),dimen_s,&
                        mat(1:dimen_s,1:dimen_s),dimen_s,&
                 beta,mat_k(1:dimen_g,1:dimen_s),dimen_g)
    !
    call dgemm('N','N',dimen_g,dimen_g,dimen_s,alpha,&
                       mat_k(1:dimen_g,1:dimen_s),dimen_g,&
                        gmat(1:dimen_s,1:dimen_g),dimen_s,&
                   beta, mat(1:dimen_g,1:dimen_g),dimen_g)
    !
    deallocate(mat_k)
    !
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    !
    ! diagonalization
    !
    if (job%verbose>=5) write (out,"('     Diagonalization...')") 
    ! 
    select case (trim(job%diagonalizer)) 
    !
    case default
      !
      write (out,"('krot_contracted_diagonalization: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
      stop 'krot_contracted_diagonalization - wrong diagonalizer '
      !
    case('SYEV-KROT') 
      !
      call lapack_syev(mat(1:dimen_g,1:dimen_g),energy(1:dimen_g),jobz=jobz)
      nroots = min(dimen_g,size(mat,dim=2))
      !
    case('SYEVR-KROT') 
      !
      call lapack_syevr(mat(1:dimen_g,1:dimen_g),energy(1:dimen_g),rng=rng,jobz=jobz,iroots=nroots,vrange=vrange,irange=irange) 
      !
      nroots = min(nroots,size(mat,dim=2))
      !
    end select
    !
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    ! Reconstruct the eigenfunctions in the original representation 
    !
    if (job%verbose>=5) write (out,"('     transformation to the original basis...')") 
    !
    allocate (mat_k(dimen_s,dimen_g),stat=alloc)
    call ArrayStart('krot_contr_diago',alloc,size(mat_k),kind(mat_k))
    !
    if (jobz=='V') then 
        call dgemm('N','N',dimen_s,dimen_g,dimen_g,alpha,gmat(1:dimen_s,1:dimen_g),dimen_s,& 
                           mat(1:dimen_g,1:dimen_g),dimen_g,beta,mat_k(1:dimen_s,1:dimen_g),dimen_s)
      !
      do ielem=1,dimen_s
         !$omp parallel do private(jelem) shared(mat) schedule(dynamic)
         do jelem=1,dimen_g
           !
           mat(ielem,jelem) = mat_k(ielem,jelem)
           !
         enddo 
         !$omp end parallel do
      enddo
      !
    endif
    !
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    deallocate(gmat,mat_k)
    call ArrayStop('krot_contr_diago')
    ! 
    if (job%verbose>=4) call TimerStop('krot_contr_diago') 
    if (job%verbose>=4) write (out,"('     ...done!')")
    !
    !
  end subroutine krot_contracted_diagonalization



  subroutine krot_contracted_diagonalization_II(jrot,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)
    !
    implicit none
    !
    integer(ik),intent(in)    :: jrot,dimen_s,k_row(dimen_s),irange(2)
    real(rk),intent(in)       :: vrange(2)
    real(rk),intent(inout)    :: mat(:,:),energy(:)
    integer(ik),intent(out)   :: nroots
    !
    real(rk),allocatable  :: mat_k(:,:),energy_k(:),mat_g(:,:),mat_t(:,:),mat_tt(:,:)
    type(PTcoeffsT)       :: smat(0:jrot)
    type(PTintcoeffs1dT)  :: kaddress(0:jrot)
    !
    real(rk)              :: energy_thresh,energy_t,temp,pt_thresh
    integer(ik)           :: iaddress(dimen_s),naddress(dimen_s),max_elems,dimen_g,kblock(0:jrot,2),kelem
    integer(ik)           :: ielem,jelem,alloc,alloc_p,k_i,k_j,ielem_start,ielem_end,jelem_start,jelem_end,dimen_k,dimen_i,&
                             dimen_j,dimenmax,iroot,nelem,dimen_n
    integer(ik)           :: i,j,l
    character(len=1),intent(in)     :: rng,jobz
    character(len=1)     :: jobz_
    double precision     :: alpha = 1.0d0,beta=0.0d0
    integer(hik)         :: matsize
    !
    !real(rk),allocatable  :: mat_t(:,:)
    !
    if (job%verbose>=4) write (out,"('     krot-contracted diagonalization...')")
    if (job%verbose>=4) call TimerStart('krot_contr_diago')
    !
    if (job%verbose>=10) then 
      !
      allocate(mat_tt(dimen_s,dimen_s),stat=alloc)
      matsize = int(dimen_s,hik)*int(dimen_s,hik)
      mat_tt = mat
      !
    endif
    !
    ielem_end = 0
    !
    ! organize the k-blocks
    !
    dimenmax = 1
    !
    do k_i = 0,jrot
       !
       k_j = k_i
       ielem_start = ielem_end + 1
       do while (k_j==k_i.and.ielem_end<dimen_s)
          !
          ielem_end = ielem_end + 1
          !
          k_j = k_row(ielem_end)
          !
       enddo
       !
       if (ielem_end<dimen_s) ielem_end = ielem_end - 1
       !
       kblock(k_i,1) = ielem_start
       kblock(k_i,2) = ielem_end
       dimen_k = ielem_end-ielem_start+1
       dimenmax = max(dimenmax,dimen_k)
       !
    enddo
    !
    energy_thresh = (vrange(2)-job%partfunc%ZPE)*job%factor+job%partfunc%ZPE
    max_elems = min(int(irange(2)*job%factor),dimen_s)
    pt_thresh = job%pt_ener_thresh
    !
    jobz_ = 'V'
    !
    if (job%verbose>=5) write (out,"('     k-prediag (ssyev)...')") 
    if (job%verbose>=4) call TimerStart('k-prediag (ssyev)')
    !
    !$omp parallel do private(k_i,ielem_start,ielem_end,dimen_k,matsize,ielem) shared(energy) schedule(dynamic)
    do k_i = 0,jrot
       !
       if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       if (dimen_k<=0) cycle
       !
       allocate (smat(k_i)%coeffs(dimen_k,dimen_k),stat=alloc)
       !
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate array smat')") alloc
          stop 'krot_contr_diago: smat  - out of memory'
       end if
       !
       do ielem=1,dimen_k
         !
         call dcopy(dimen_k,mat(ielem_start:ielem_start+dimen_k-1,ielem_start+ielem-1),1,smat(k_i)%coeffs(1:dimen_k,ielem),1)
         !
       enddo
       !
       call lapack_syev(smat(k_i)%coeffs(1:dimen_k,1:dimen_k),energy(ielem_start:ielem_start+dimen_k-1),jobz=jobz_)
       !
    enddo
    !$omp end parallel do
    !
    ! obtain the energy threshold for a given max_elems(nroots)
    !
    if (max_elems<dimen_s) then 
      !
      allocate (energy_k(dimen_s),stat=alloc)
      !
      call dcopy(dimen_s,energy(:),1,energy_k(:),1)
      !
      do ielem=1,max_elems
        !
        energy_t = energy_k(ielem)
        !
        do jelem=ielem+1,dimen_s
          !
          if ( energy_t>energy_k(jelem) ) then
            !
            energy_t=energy_k(jelem)
            energy_k(jelem) = energy_k(ielem)
            energy_k(ielem) = energy_t
            !
          endif 
          !
        enddo
        !
      enddo
      !
      energy_thresh = min(energy_k(max_elems),energy_thresh)
      !
      deallocate(energy_k)
      !
    endif
    !
    ! Complete the allocation by counting memory and also count the roots which are below the energy threshold
    !
    iaddress = 1
    !
    kelem = 0  ! number of included elements 
    nelem = 0  ! nunmber of the rest elements
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       allocate (kaddress(k_i)%imat(dimen_k),stat=alloc)
       !
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate array (kaddress(k_i)%imat')") alloc
          stop 'krot_contr_diago: (kaddress(k_i)%imat  - out of memory'
       end if
       !
       kaddress(k_i)%imat = 0 
       !
       do ielem=1,dimen_k
          !
          if (energy(ielem_start+ielem-1)<=energy_thresh) then 
            !
            kelem = kelem + 1
            !
            kaddress(k_i)%imat(ielem) = kelem
            iaddress(kelem) = ielem_start+ielem-1
            !
           elseif( energy(ielem_start+ielem-1)-energy_thresh<=pt_thresh) then 
            !
            nelem = nelem + 1
            naddress(nelem) = ielem_start+ielem-1
            !
          endif
          !
       enddo
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       call ArrayStart('krot_contr_diago',0,1,kind(smat(k_i)%coeffs),matsize)
       !
    enddo
    !
    dimen_g = kelem
    dimen_n = nelem
    !
    if (job%verbose>=5) write (out,"('     Size of the k-contr. matrix = ',i8)") dimen_g
    if (job%verbose>=5) write (out,"('     Number of elements taken for PT = ',i8)") dimen_n
    !
    if (job%verbose>=4) call TimerStop('k-prediag (ssyev)')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    if (dimen_g==0) then  
      nroots =0
      return
    endif
    !
    ! Transformation to the krot-contracted basis
    ! the new basis is energy truncated 
    !
    if (job%verbose>=5) write (out,"('     transformation to k-contr. basis (dgemm)...')") 
    if (job%verbose>=4) call TimerStart('transformation to k-contr')
    !
    !$omp parallel private(mat_k,alloc_p) shared(mat)
    allocate (mat_k(dimenmax,dimenmax),stat=alloc_p)
    if (alloc_p/=0) then
       write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
       stop 'krot_contr_diago: mat_k  - out of memory'
    end if
    !
    !$omp do private(k_i,ielem_start,ielem_end,dimen_i,k_j,jelem_start,jelem_end,dimen_j,i,j,l,ielem,jelem,temp) schedule(dynamic)
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_i = ielem_end-ielem_start+1
       !
       do k_j = 0,jrot
          !
          if (k_i-k_j>2.or.k_j>k_i) cycle
          !
          if (job%verbose>=5) write (out,"('       k_i,k_j = ',2i5)") k_i,k_j
          !
          jelem_start = kblock(k_j,1)
          jelem_end   = kblock(k_j,2)
          dimen_j = jelem_end-jelem_start+1
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                temp = 0
                do l = 1,dimen_i
                   !
                   ielem = ielem_start+l-1
                   !
                   temp = temp + smat(k_i)%coeffs(l,i)*mat(ielem,jelem)
                   !
                enddo
                mat_k(i,j) = temp
                !
            enddo
          enddo 
          !
          !call dgemm('T','N',dimen_i,dimen_j,dimen_i,alpha,&
          !       smat(k_i)%coeffs(1:dimen_i,1:dimen_i),dimen_i,&
          !                    mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1),dimen_i,&
          !             beta,mat_k(1:dimen_i,1:dimen_j),dimen_i)
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                !
                ielem = ielem_start+i-1
                !
                mat(ielem,jelem) = 0
                !
             enddo
             !
             do l = 1,dimen_j
                !
                if (smat(k_j)%coeffs(l,j).ne.0) then
                   temp = smat(k_j)%coeffs(l,j)
                   do i = 1,dimen_i
                      !
                      ielem = ielem_start+i-1
                      !
                      mat(ielem,jelem) = mat(ielem,jelem) + temp*mat_k(i,l)
                      !
                   enddo
                 endif
             enddo
          enddo
          !
          !call dgemm('N','N',dimen_i,dimen_j,dimen_j,alpha,& 
          !                   mat_k(1:dimen_i,1:dimen_j),dimen_i,&
          !        smat(k_j)%coeffs(1:dimen_j,1:dimen_j),dimen_j,&
          !                beta,mat_g(1:dimen_i,1:dimen_j),dimen_i)
          !
          !mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1) = mat_g(1:dimen_i,1:dimen_j)
          !
       enddo
       !
    enddo
    !$omp end do
    !
    deallocate(mat_k)
    !$omp end parallel
    !
    if (job%verbose>=4) call TimerStop('transformation to k-contr')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    if (job%verbose>=5) write (out,"('     Shrinking the matrix...')")
    if (job%verbose>=4) call TimerStart('Shrinking k-matrix')
    !
    if (job%verbose>=5) write (out,"('       restoring the lower part from the upper...')")
    !
    !$omp parallel do private(ielem,jelem) shared(mat) schedule(dynamic)
    do ielem=1,dimen_s
       !
       do jelem=1,ielem-1
          !
          mat(jelem,ielem) = mat(ielem,jelem)
          !
       enddo
       !
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=5) write (out,"('       initializating the reduced matrix G...')")
    !
    allocate (mat_g(0:dimen_g,dimen_g),stat=alloc)
    matsize = int(dimen_g,hik)*int(dimen_g,hik)
    !
    call ArrayStart('krot_contr_diago_g',alloc,1,kind(mat_g),matsize)
    !$omp parallel do private(ielem) shared(mat_g) schedule(dynamic)
    do ielem=1,dimen_g
       !
       mat_g(0:dimen_g,ielem) = 0
       !
    enddo
    !$omp end parallel do
    !
    if (dimen_n>0) then 
      !
      if (job%verbose>=5) write (out,"('       a) computing the perturbation theory correction ...')")
      !
      allocate (mat_k(1:dimen_g,1:dimen_n),mat_t(1:dimen_g,1:dimen_n),stat=alloc)
      !
      matsize = int(dimen_g,hik)*int(dimen_n,hik)*2_hik
      !
      call ArrayStart('krot_contr_diago_pt',alloc,1,kind(mat_k),matsize)
      !
      !$omp parallel do private(ielem,nelem) shared(mat_k,mat_t) schedule(dynamic)
      do ielem=1,dimen_g
         !
         do nelem=1,dimen_n
           !
           mat_t(ielem,nelem) = mat(iaddress(ielem),naddress(nelem))
           mat_k(ielem,nelem) = mat_t(ielem,nelem)/( energy(iaddress(ielem))-energy(naddress(nelem)) )
           !
         enddo
         !
      enddo
      !$omp end parallel do
      !
      if (job%verbose>=5) write (out,"('       b) computing the perturbation theory correction ...')")
      !
      alpha = 0.5d0
      !
      call dgemm('N','T',dimen_g,dimen_g,dimen_n,alpha,&
                         mat_k(1:dimen_g,1:dimen_n),dimen_g,&
                         mat_t(1:dimen_g,1:dimen_n),dimen_g,&
                    beta,mat_g(1:dimen_g,1:dimen_g),dimen_g)
      !
      alpha = 1.0d0
      !
      deallocate(mat_k,mat_t)
      call ArrayStop('krot_contr_diago_pt')
      !
    endif
    !
    if (job%verbose>=5) write (out,"('       shrinking the matrix and  adding the PT correction...')")
    !
    !$omp parallel do private(ielem,jelem) shared(mat_g) schedule(dynamic)
    do ielem=1,dimen_g
       !
       do jelem=1,ielem
          !
          mat_g(ielem,jelem) = mat_g(ielem,jelem) + mat_g(jelem,ielem) + mat(iaddress(ielem),iaddress(jelem))
          !
          mat_g(jelem,ielem) = mat_g(ielem,jelem)
          !
       enddo
       !
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) call TimerStop('Shrinking k-matrix')
    if (job%verbose>=5) write (out,"('     ...done!')")
    !
    ! diagonalization
    !
    if (job%verbose>=5) write (out,"('     Diagonalization...')")
    if (job%verbose>=4) call TimerStart('Diagonalization k-matrix')
    !
    select case (trim(job%diagonalizer)) 
    !
    case default
      !
      write (out,"('krot_contracted_diagonalization_II: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
      stop 'krot_contracted_diagonalization_II - wrong diagonalizer '
      !
    case('SYEV-KROT') 
      !
      call lapack_syev(mat_g(1:dimen_g,1:dimen_g),energy(1:dimen_g),jobz=jobz)
      nroots = min(dimen_g,size(mat_g,dim=2))
      !
    case('SYEVR-KROT') 
      !
      call lapack_syevr(mat_g(1:dimen_g,1:dimen_g),energy(1:dimen_g),rng=rng,jobz=jobz,iroots=nroots,vrange=vrange,irange=irange)
      nroots = min(nroots,size(mat_g,dim=2))
      !
    end select
    !
    if (job%verbose>=4) call TimerStop('Diagonalization k-matrix')
    !
    if (job%verbose>=5) write (out,"('       nroots = ',2i5)") nroots
    !
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    ! Reconstruct the eigenfunctions in the original representation 
    !
    if (job%verbose>=5) write (out,"('     transformation to the original basis...')")
    if (job%verbose>=4) call TimerStart('transform to original k-basis')
    !
    if (jobz=='V') then
       !
       !$omp parallel private(mat_k,alloc_p) shared(mat)
       allocate (mat_k(dimenmax,nroots),stat=alloc_p)
       if (alloc_p/=0) then
          write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
          stop 'krot_contr_diago: mat_k  - out of memory'
       end if
       !
       !$omp do private(k_i,ielem_start,ielem_end,dimen_k,kelem,ielem,iroot) schedule(dynamic)
       do k_i = 0,jrot
          !
          if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
          !
          ielem_start = kblock(k_i,1)
          ielem_end   = kblock(k_i,2)
          dimen_k = ielem_end-ielem_start+1
          !
          if (dimen_k<=0) cycle
          !
          !allocate(mat_k(dimen_k,dimen_g),stat=alloc)
          !call ArrayStart('krot_contr_diago_k',alloc,1,kind(smat(k_i)%coeffs),matsize)
          !
          do kelem=1,dimen_k
             !
             ielem = kaddress(k_i)%imat(kelem)
             !
             call dcopy(nroots,mat_g(ielem,1:nroots),1,mat_k(kelem,1:nroots),1)
             !
             !mat_k(kelem,1:nroots) = mat_g(ielem,1:nroots)
             !
          enddo
          !
          do iroot = 1,nroots
             !
             call dgemv('N',dimen_k,dimen_k,alpha,smat(k_i)%coeffs(1:dimen_k,1:dimen_k),dimen_k,mat_k(1:dimen_k,iroot),&
                        1,beta,mat(ielem_start:ielem_end,iroot),1)
             !
          enddo
          !
      enddo
      !$omp end do
      !
      deallocate(mat_k)
      !$omp end parallel 
      !
    endif
    !
    if (job%verbose>=4) call TimerStop('transform to original k-basis')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    do k_i = 0,jrot
       !
       deallocate (smat(k_i)%coeffs,kaddress(k_i)%imat)
       !
    enddo
    !
    if (job%verbose>=10) then 
       !
       if (job%verbose>=5) write (out,"('     check the eigenvectors against H...')") 
       !
       allocate (mat_k(nroots,dimen_s),stat=alloc)
       !
       matsize = int(nroots,hik)*int(dimen_s,hik)
       !
       call ArrayStart('krot_contr_diago-t',alloc,1,kind(mat_k),matsize)
       !
       call dgemm('T','N',nroots,dimen_s,dimen_s,alpha,&
                          mat(1:dimen_s,1:nroots),dimen_s,&
                        mat_tt(1:dimen_s,1:dimen_s),dimen_s,&
                   beta,mat_k(1:nroots,1:dimen_s),nroots)
       !
       call dgemm('N','N',nroots,nroots,dimen_s,alpha,& 
                          mat_k(1:nroots,1:dimen_s),nroots,&
                            mat(1:dimen_s,1:nroots),dimen_s,&
                     beta,mat_tt(1:nroots,1:nroots),nroots)
       !
       deallocate(mat_k,mat_tt)
       !
       call ArrayStop('krot_contr_diago-t')
       !
       if (job%verbose>=5) write (out,"('     ...done!')") 
       !
    endif
    !
    deallocate(mat_g)
    call ArrayStop('krot_contr_diago')
    ! 
    if (job%verbose>=4) call TimerStop('krot_contr_diago') 
    if (job%verbose>=4) write (out,"('     ...done!')")
    !
    !
  end subroutine krot_contracted_diagonalization_II




  subroutine krot_contracted_diagonalization_BS_PT(jrot,gamma,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)

    integer(ik),intent(in)    :: jrot,gamma,dimen_s,k_row(dimen_s),irange(2)
    real(rk),intent(in)       :: vrange(2)
    real(rk),intent(inout)    :: mat(:,:),energy(:)
    integer(ik),intent(out)   :: nroots
    !
    real(rk),allocatable  :: mat_k(:,:),mat_g(:,:),mat_t(:,:),mat_tt(:,:),vector(:),energy_(:),energies(:,:),energy0(:)
    type(PTcoeffsT)       :: smat(0:jrot)
    !type(PTintcoeffs1dT)  :: kaddress(0:jrot)
    !
    real(rk)              :: energy_thresh,energy_t,temp,f_t,eps_,eps,tol_thresh,df,pt_thresh
    integer(ik)           :: kaddress(dimen_s),iaddress(dimen_s),naddress(dimen_s),naddress_(dimen_s),kaddress_(dimen_s)
    integer(ik)           :: max_elems,dimen_g,kblock(0:jrot,2),kelem
    integer(ik)           :: ielem,jelem,alloc,alloc_p,k_i,k_j,ielem_start,ielem_end,jelem_start,jelem_end,dimen_k,dimen_i,&
                             dimen_j,dimenmax,iroot,nelem,dimen_n
    integer(ik)           :: i,j,l,dimen_e,dimen_x,iter
    character(len=1),intent(in)     :: rng,jobz
    character(len=1)     :: jobz_
    double precision     :: alpha = 1.0d0,beta=0.0d0,ddot
    integer(hik)         :: matsize
    logical              :: last_iter
    character(len=cl)    :: my_fmt !format for I/O specification
    !
    !real(rk),allocatable  :: mat_t(:,:)
    !
    if (job%verbose>=4) write (out,"('     krot-bs-contracted diagonalization...')")
    if (job%verbose>=4) call TimerStart('krot_bs_contr_diago')
    !
    if (job%verbose>=10) then 
      !
      allocate(mat_tt(dimen_s,dimen_s),stat=alloc)
      matsize = int(dimen_s,hik)*int(dimen_s,hik)
      mat_tt = mat
      !
    endif
    !
    ielem_end = 0
    !
    ! organize the k-blocks
    !
    dimenmax = 1
    !
    do k_i = 0,jrot
       !
       k_j = k_i
       ielem_start = ielem_end + 1
       do while (k_j==k_i.and.ielem_end<dimen_s)
          !
          ielem_end = ielem_end + 1
          !
          k_j = k_row(ielem_end)
          !
       enddo
       !
       if (ielem_end<dimen_s) ielem_end = ielem_end - 1
       !
       kblock(k_i,1) = ielem_start
       kblock(k_i,2) = ielem_end
       dimen_k = ielem_end-ielem_start+1
       dimenmax = max(dimenmax,dimen_k)
       !
    enddo
    !
    energy_thresh = vrange(2)
    max_elems = irange(2)
    !
    pt_thresh = job%pt_ener_thresh
    tol_thresh = job%thresh
    !
    df = job%factor
    !
    jobz_ = 'V'
    !
    if (job%verbose>=5) write (out,"('     k-prediag (ssyev)...')") 
    if (job%verbose>=4) call TimerStart('k-prediag (ssyev)')
    !
    !$omp parallel do private(k_i,ielem_start,ielem_end,dimen_k,matsize,ielem) shared(energy) schedule(dynamic)
    do k_i = 0,jrot
       !
       if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       if (dimen_k<=0) cycle
       !
       allocate (smat(k_i)%coeffs(dimen_k,dimen_k),stat=alloc)
       !
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate array smat')") alloc
          stop 'krot_bs_contr_diago: smat  - out of memory'
       end if
       !
       do ielem=1,dimen_k
         !
         call dcopy(dimen_k,mat(ielem_start:ielem_start+dimen_k-1,ielem_start+ielem-1),1,smat(k_i)%coeffs(1:dimen_k,ielem),1)
         !
       enddo
       !
       call lapack_syev(smat(k_i)%coeffs(1:dimen_k,1:dimen_k),energy(ielem_start:ielem_start+dimen_k-1),jobz=jobz_)
       !
    enddo
    !$omp end parallel do
    !
    ! obtain the energy threshold for a given max_elems(nroots)
    !
    !
    allocate (energy0(dimen_s),stat=alloc)
    call ArrayStart('bset_contr_diago_e',alloc,size(energy0),kind(energy0))
    !
    call dcopy(dimen_s,energy(:),1,energy0(:),1)
    !
    do ielem=1,max_elems
      !
      energy_t = energy0(ielem)
      !
      do jelem=ielem+1,dimen_s
        !
        if ( energy_t>energy0(jelem) ) then
          !
          energy_t=energy0(jelem)
          energy0(jelem) = energy0(ielem)
          energy0(ielem) = energy_t
          !
        endif 
        !
      enddo
      !
    enddo
    !
    energy_thresh = min(energy0(max_elems),energy_thresh)
    !
    !
    ! Complete the allocation by counting memory and also count the roots which are below the energy threshold
    !
    iaddress = 1 ; naddress_ = 1 ; kaddress_ = 0
    !
    kelem = 0  ! number of included elements 
    nelem = 0  ! nunmber of the rest elements
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       do ielem=1,dimen_k
          !
          if (energy(ielem_start+ielem-1)<=energy_thresh) then 
            !
            kelem = kelem + 1
            !
            kaddress_(ielem_start+ielem-1) = kelem
            iaddress(kelem) = ielem_start+ielem-1
            !
           else
            !
            nelem = nelem + 1
            naddress_(nelem) = ielem_start+ielem-1
            !
          endif
          !
       enddo
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       call ArrayStart('krot_bs_contr_diago',0,1,kind(smat(k_i)%coeffs),matsize)
       !
    enddo
    !
    dimen_e = kelem
    dimen_x = nelem
    !
    if (job%verbose>=5) write (out,"('     Size of the k-contr. matrix = ',i9)") dimen_e
    !
    if (job%verbose>=4) call TimerStop('k-prediag (ssyev)')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    nroots =0
    !
    if (dimen_e==0) return
    !
    ! Transformation to the krot-contracted basis
    ! the new basis is BS-truncated 
    !
    if (job%verbose>=5) write (out,"('     transformation to k-contr. basis (dgemm)...')") 
    if (job%verbose>=4) call TimerStart('transformation to k-contr')
    !
    !$omp parallel private(mat_k,alloc_p) shared(mat)
    allocate (mat_k(dimenmax,dimenmax),stat=alloc_p)
    if (alloc_p/=0) then
       write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
       stop 'krot_bs_contr_diago: mat_k  - out of memory'
    end if
    !
    !$omp do private(k_i,ielem_start,ielem_end,dimen_i,k_j,jelem_start,jelem_end,dimen_j,i,j,l,ielem,jelem,temp) schedule(dynamic)
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_i = ielem_end-ielem_start+1
       !
       do k_j = 0,jrot
          !
          if (k_i-k_j>2.or.k_j>k_i) cycle
          !
          if (job%verbose>=5) write (out,"('       k_i,k_j = ',2i5)") k_i,k_j
          !
          jelem_start = kblock(k_j,1)
          jelem_end   = kblock(k_j,2)
          dimen_j = jelem_end-jelem_start+1
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                temp = 0
                do l = 1,dimen_i
                   !
                   ielem = ielem_start+l-1
                   !
                   temp = temp + smat(k_i)%coeffs(l,i)*mat(ielem,jelem)
                   !
                enddo
                mat_k(i,j) = temp
                !
            enddo
          enddo 
          !
          !call dgemm('T','N',dimen_i,dimen_j,dimen_i,alpha,&
          !       smat(k_i)%coeffs(1:dimen_i,1:dimen_i),dimen_i,&
          !                    mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1),dimen_i,&
          !             beta,mat_k(1:dimen_i,1:dimen_j),dimen_i)
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                !
                ielem = ielem_start+i-1
                !
                mat(ielem,jelem) = 0
                !
             enddo
             !
             do l = 1,dimen_j
                !
                if (smat(k_j)%coeffs(l,j).ne.0) then
                   temp = smat(k_j)%coeffs(l,j)
                   do i = 1,dimen_i
                      !
                      ielem = ielem_start+i-1
                      !
                      mat(ielem,jelem) = mat(ielem,jelem) + temp*mat_k(i,l)
                      !
                   enddo
                 endif
             enddo
          enddo
          !
          !call dgemm('N','N',dimen_i,dimen_j,dimen_j,alpha,& 
          !                   mat_k(1:dimen_i,1:dimen_j),dimen_i,&
          !        smat(k_j)%coeffs(1:dimen_j,1:dimen_j),dimen_j,&
          !                beta,mat_g(1:dimen_i,1:dimen_j),dimen_i)
          !
          !mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1) = mat_g(1:dimen_i,1:dimen_j)
          !
       enddo
       !
    enddo
    !$omp end do
    !
    deallocate(mat_k)
    !$omp end parallel
    !
    if (job%verbose>=5) write (out,"('       restoring the lower part from the upper...')")
    !
    !$omp parallel do private(ielem,jelem) shared(mat) schedule(dynamic)
    do ielem=1,dimen_s
       !
       do jelem=1,ielem-1
          !
          mat(jelem,ielem) = mat(ielem,jelem)
          !
       enddo
       !
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) call TimerStop('transformation to k-contr')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    if (dimen_x>0) then 
      !
      if (job%verbose>=4) write (out,"('     analyzing all basis set contributions ...')")
      !
      allocate (mat_k(1:dimen_e,1:dimen_x),vector(1:dimen_x),stat=alloc)
      !
      matsize = int(dimen_e,hik)*int(dimen_x,hik)+int(dimen_x,hik)
      !
      call ArrayStart('bset_contr_diago_pt',alloc,1,kind(mat_k),matsize)
      !
      !$omp parallel do private(ielem,nelem) shared(mat_k) schedule(dynamic)
      do ielem=1,dimen_e
         !
         do nelem=1,dimen_x
           !
           mat_k(ielem,nelem) = mat(iaddress(ielem),naddress_(nelem))/( energy(iaddress(ielem))-energy(naddress_(nelem)) )
           !
         enddo
         !
      enddo
      !$omp end parallel do
      !
      !$omp parallel do private(nelem,f_t) shared(vector) schedule(dynamic)
      do nelem=1,dimen_x
         !
         f_t = ddot(dimen_e,mat_k(:,nelem),1,mat_k(:,nelem),1)
         !
         vector(nelem) = sqrt(f_t/real(dimen_e,ark) )
         !
      enddo
      !$omp end parallel do
      !
      if (job%verbose>=5) then 
        !
        write (out,"(/'     Contributions from the basis functions beyond the selected region...')")
        !
        do nelem=1,dimen_x
           !
           write (out,"(i6,f16.8)") nelem,vector(nelem)
           !
        enddo
        !
        write (out,"('')")
        !
      endif
      !
      deallocate(mat_k)
      !        
      call ArrayStop('bset_contr_diago_pt')
      !
    endif
    !
    allocate (energies(1:dimen_e,1:job%maxiter),stat=alloc)
    matsize = int(dimen_e,hik)*int(job%maxiter,hik)
    call ArrayStart('bset_contr_diago_e',alloc,1,kind(energies),matsize)
    
    !
    eps = safe_max  ; eps_ = safe_max
    !
    iter = 0 ; last_iter = .false.
    !
    jobz_ = 'N' ; dimen_g = 0
    !
    do while(.not.last_iter)
       !
       iter = iter + 1
       !
       if (job%verbose>=4) write (out,"(/'     iter = ',i8,'  tol_thresh = ',g18.8)") iter,tol_thresh
       if (job%verbose>=4) write (out,"('     Prepare the matrix...')")
       !
       eps = eps_
       !
       if (eps<=job%tolerance.or.iter==job%maxiter) last_iter = .true.
       !
       if (job%verbose>=4) write (out,"('     Shrinking the matrix...')")
       if (job%verbose>=4) call TimerStart('Shrinking b-matrix')
       !
       ! count the elements taken into account for the given thresholds
       !
       naddress = 1
       kaddress = kaddress_
       !
       kelem = dimen_e ; nelem = 0
       !
       do jelem=1,dimen_x
          !
          ielem = naddress_(jelem)
          !
          if (vector(jelem)>=tol_thresh) then
            !
            kelem = kelem + 1
            !
            kaddress(ielem) = kelem
            iaddress(kelem) = ielem
            !
           elseif(vector(jelem)>=tol_thresh*pt_thresh) then 
            !
            nelem = nelem + 1
            naddress(nelem) = ielem
            !
          endif
          !
       enddo
       !
       dimen_g = kelem
       dimen_n = nelem
       !
       if (dimen_g==dimen_s) last_iter = .true.
       !
       if (job%verbose>=4) write (out,"('       Size of the contr. matrix       = ',i9)") dimen_g
       if (job%verbose>=4) write (out,"('       Number of elements taken for PT = ',i9)") dimen_n
       !
       if (dimen_g==0) cycle
       !
       if (job%verbose>=4) write (out,"('       -- initializating the reduced matrix G...')")
       !
       allocate (mat_g(0:dimen_g,dimen_g),stat=alloc)
       matsize = int(dimen_g,hik)*int(dimen_g,hik)
       !
       call ArrayStart('bset_contr_diago_g',alloc,1,kind(mat_g),matsize)
       !$omp parallel do private(ielem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          mat_g(0:dimen_g,ielem) = 0
       enddo
       !$omp end parallel do
       !
       if (dimen_n>0) then 
          !
          if (job%verbose>=4) write (out,"('       -- computing the perturbation theory correction ...')")
          !
          allocate (mat_k(1:dimen_g,1:dimen_n),mat_t(1:dimen_g,1:dimen_n),stat=alloc)
          !
          matsize = int(dimen_g,hik)*int(dimen_n,hik)*2_hik
          !
          call ArrayStart('bset_contr_diago_pt',alloc,1,kind(mat_k),matsize)
          !
          !$omp parallel do private(ielem,nelem,energy_t) shared(mat_k,mat_t) schedule(dynamic)
          do ielem=1,dimen_g
             !
             do nelem=1,dimen_n
               !
               mat_t(ielem,nelem) = 0
               mat_k(ielem,nelem) = 0
               !
               energy_t = energy(iaddress(ielem))-energy(naddress(nelem))
               !
               if (abs(mat(iaddress(ielem),naddress(nelem))/energy_t)<1e2) then
                 !
                 mat_t(ielem,nelem) = mat(iaddress(ielem),naddress(nelem))
                 mat_k(ielem,nelem) = mat_t(ielem,nelem)/energy_t
                 !
               endif
               !
             enddo
             !
          enddo
          !$omp end parallel do
          !
          alpha = 0.5d0
          !
          call dgemm('N','T',dimen_g,dimen_g,dimen_n,alpha,&
                             mat_k(1:dimen_g,1:dimen_n),dimen_g,&
                             mat_t(1:dimen_g,1:dimen_n),dimen_g,&
                        beta,mat_g(1:dimen_g,1:dimen_g),dimen_g)
          !
          alpha = 1.0d0
          !
          deallocate(mat_k,mat_t)
          call ArrayStop('bset_contr_diago_pt')
          !
       endif 
       !
       if (job%verbose>=4) write (out,"('       -- shrinking the matrix and  adding the PT correction...')")
       !
       !$omp parallel do private(ielem,jelem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          !
          do jelem=1,ielem
             !
             mat_g(ielem,jelem) = mat_g(ielem,jelem) + mat_g(jelem,ielem) + mat(iaddress(ielem),iaddress(jelem))
             !
             mat_g(jelem,ielem) = mat_g(ielem,jelem)
             !
          enddo
          !
       enddo
       !$omp end parallel do
       !
       if (job%verbose>=4) call TimerStop('Shrinking b-matrix')
       if (job%verbose>=4) write (out,"('     ...done!')")
       !
       !
       ! diagonalization
       !
       if (job%verbose>=4) write (out,"('     Diagonalization...')")
       if (job%verbose>=4) call TimerStart('Diagonalization matrix')
       !
       allocate(energy_(dimen_g),stat=alloc)
       !
       if (last_iter) jobz_=jobz
       !
       select case (job%diagonalizer(1:5)) 
       !
       case default
         !
         write (out,"('PT_bset_truncated_diagonalization: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
         stop 'PT_bset_truncated_diagonalization - wrong diagonalizer '
         !
       case('SYEV-') 
         !
         call lapack_syev(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),jobz=jobz_)
         nroots = dimen_g
         !
       case('SYEVR') 
         !
         call lapack_syevr(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),rng=rng,jobz=jobz_,iroots=nroots,&
                           vrange=vrange,irange=irange)
         !
       end select
       !
       if (nroots<0) cycle
       !
       if (job%verbose>=4) call TimerStop('Diagonalization matrix')
       if (job%verbose>=4) write (out,"('     ...done!')") 
       !
       if (job%verbose>=4) write (out,"('     nroots = ',2i5/)") nroots
       !
       if (job%verbose>=4) then
           !
           energies(1:dimen_e,iter) = energy_(1:dimen_e)-job%partfunc%ZPE
           !
           write(my_fmt,'(a,i0,a)') "(a2,a,i7,",iter,"f14.6)"
           !
           do iroot=1,dimen_e
             !
             write(out,my_fmt) "| ",sym%label(gamma),iroot,energies(iroot,1:iter)
             !
           enddo 
           !
       endif
       !
       ! Reconstruct the eigenfunctions in the original representation 
       !
       if (jobz_=='V'.and.last_iter) then
          !
          if (job%verbose>=4) write (out,"('     transformation to the original basis...')")
          if (job%verbose>=4) call TimerStart('transform to original basis')
          !
          !$omp parallel private(mat_k,alloc_p) shared(mat)
          allocate (mat_k(dimenmax,nroots),stat=alloc_p)
          if (alloc_p/=0) then
             write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
             stop 'krot_bs_contr_diago: mat_k  - out of memory'
          end if
          !
          !$omp do private(k_i,ielem_start,ielem_end,dimen_k,kelem,ielem,iroot) schedule(dynamic)
          do k_i = 0,jrot
             !
             if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
             !
             ielem_start = kblock(k_i,1)
             ielem_end   = kblock(k_i,2)
             dimen_k = ielem_end-ielem_start+1
             !
             if (dimen_k<=0) cycle
             !
             !allocate(mat_k(dimen_k,dimen_g),stat=alloc)
             !call ArrayStart('krot_bs_contr_diago_k',alloc,1,kind(smat(k_i)%coeffs),matsize)
             !
             do kelem=1,dimen_k
                !
                ielem = kaddress(ielem_start+kelem-1)
                !
                call dcopy(nroots,mat_g(ielem,1:nroots),1,mat_k(kelem,1:nroots),1)
                !
                !mat_k(kelem,1:nroots) = mat_g(ielem,1:nroots)
                !
             enddo
             !
             do iroot = 1,nroots
                !
                call dgemv('N',dimen_k,dimen_k,alpha,smat(k_i)%coeffs(1:dimen_k,1:dimen_k),dimen_k,&
                           mat_k(1:dimen_k,iroot),1,beta,mat(ielem_start:ielem_end,iroot),1)
                !
             enddo
             !
          enddo
          !$omp end do
          !
          deallocate(mat_k)
          !$omp end parallel 
          !
          if (job%verbose>=4) call TimerStop('transform to original basis')
          if (job%verbose>=4) write (out,"('     ...done!')")
          !
       endif
       !
       eps_ = sqrt(sum( ( energy0(1:dimen_e)-energy_(1:dimen_e) )**2 )/real(dimen_e,ark) )
       !
       energy0(1:nroots) = energy_(1:nroots)
       !
       if (job%verbose>=4) write (out,"('     rms = ',g18.8)") eps_
       !
       ! update the tolerence threshold
       !
       tol_thresh = df*tol_thresh
       !
       deallocate(mat_g,energy_)
       call ArrayStop('bset_contr_diago_g')
        !
    enddo
    !
    energy(1:nroots) = energy0(1:nroots)
    !
    deallocate(energy0)
    !
    do k_i = 0,jrot
       !
       deallocate (smat(k_i)%coeffs)
       !
    enddo
    !
    call ArrayStop('krot_bs_contr_diago')
    !
    if (job%verbose>=10) then 
       !
       if (job%verbose>=5) write (out,"('     check the eigenvectors against H...')") 
       !
       allocate (mat_k(nroots,dimen_s),stat=alloc)
       !
       matsize = int(nroots,hik)*int(dimen_s,hik)
       !
       call ArrayStart('krot_bs_contr_diago-t',alloc,1,kind(mat_k),matsize)
       !
       call dgemm('T','N',nroots,dimen_s,dimen_s,alpha,&
                          mat(1:dimen_s,1:nroots),dimen_s,&
                        mat_tt(1:dimen_s,1:dimen_s),dimen_s,&
                   beta,mat_k(1:nroots,1:dimen_s),nroots)
       !
       call dgemm('N','N',nroots,nroots,dimen_s,alpha,& 
                          mat_k(1:nroots,1:dimen_s),nroots,&
                            mat(1:dimen_s,1:nroots),dimen_s,&
                     beta,mat_tt(1:nroots,1:nroots),nroots)
       !
       deallocate(mat_k,mat_tt)
       !
       call ArrayStop('krot_bs_contr_diago-t')
       !
       if (job%verbose>=5) write (out,"('     ...done!')") 
       !
    endif
    !
    if (allocated(vector)) deallocate(vector)
    !
    deallocate (energies)
    call ArrayStop('bset_contr_diago_e')
    ! 
    if (job%verbose>=4) call TimerStop('krot_bs_contr_diago') 
    if (job%verbose>=4) write (out,"('     ...done!')")
    !
    !
  end subroutine krot_contracted_diagonalization_BS_PT





  subroutine krot_contracted_diagonalization_en_PT(jrot,gamma,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)
    !
    implicit none
    !
    integer(ik),intent(in)    :: jrot,gamma,dimen_s,k_row(dimen_s),irange(2)
    real(rk),intent(in)       :: vrange(2)
    real(rk),intent(inout)    :: mat(:,:),energy(:)
    integer(ik),intent(out)   :: nroots
    !
    real(rk),allocatable  :: mat_k(:,:),mat_g(:,:),mat_t(:,:),mat_tt(:,:),vector(:),energy_(:),energies(:,:),energy0(:)
    type(PTcoeffsT)       :: smat(0:jrot)
    !
    real(rk)              :: energy_thresh,energy_t,temp,eps_,eps,df,pt_thresh
    integer(ik)           :: kaddress(dimen_s),iaddress(dimen_s),naddress(dimen_s),naddress_(dimen_s),kaddress_(dimen_s)
    integer(ik)           :: max_elems,dimen_g,kblock(0:jrot,2),kelem
    integer(ik)           :: ielem,jelem,alloc,alloc_p,k_i,k_j,ielem_start,ielem_end,jelem_start,jelem_end,dimen_k,&
                             dimen_i,dimen_j,dimenmax,iroot,nelem,dimen_n
    integer(ik)           :: i,j,l,dimen_e,dimen_x,iter
    character(len=1),intent(in)  :: rng,jobz
    character(len=1)     :: jobz_
    double precision     :: alpha = 1.0d0,beta=0.0d0
    integer(hik)         :: matsize
    logical              :: last_iter
    character(len=cl)    :: my_fmt !format for I/O specification
    !
    !real(rk),allocatable  :: mat_t(:,:)
    !
    if (job%verbose>=4) write (out,"('     krot-bs-contracted diagonalization...')")
    if (job%verbose>=4) call TimerStart('krot_bs_contr_diago')
    !
    if (job%verbose>=10) then 
      !
      allocate(mat_tt(dimen_s,dimen_s),stat=alloc)
      matsize = int(dimen_s,hik)*int(dimen_s,hik)
      mat_tt = mat
      !
    endif
    !
    ielem_end = 0
    !
    ! organize the k-blocks
    !
    dimenmax = 1
    !
    do k_i = 0,jrot
       !
       k_j = k_i
       ielem_start = ielem_end + 1
       do while (k_j==k_i.and.ielem_end<dimen_s)
          !
          ielem_end = ielem_end + 1
          !
          k_j = k_row(ielem_end)
          !
       enddo
       !
       if (ielem_end<dimen_s) ielem_end = ielem_end - 1
       !
       kblock(k_i,1) = ielem_start
       kblock(k_i,2) = ielem_end
       dimen_k = ielem_end-ielem_start+1
       dimenmax = max(dimenmax,dimen_k)
       !
    enddo
    !
    !
    df = job%factor
    !
    energy_thresh = vrange(2)+job%thresh
    max_elems = irange(2)
    !
    pt_thresh = job%pt_ener_thresh
    !
    jobz_ = 'V'
    !
    if (job%verbose>=5) write (out,"('     k-prediag (ssyev)...')") 
    if (job%verbose>=4) call TimerStart('k-prediag (ssyev)')
    !
    !$omp parallel do private(k_i,ielem_start,ielem_end,dimen_k,matsize,ielem) shared(energy) schedule(dynamic)
    do k_i = 0,jrot
       !
       if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       if (dimen_k<=0) cycle
       !
       allocate (smat(k_i)%coeffs(dimen_k,dimen_k),stat=alloc)
       !
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate array smat')") alloc
          stop 'krot_bs_contr_diago: smat  - out of memory'
       end if
       !
       do ielem=1,dimen_k
         !
         call dcopy(dimen_k,mat(ielem_start:ielem_start+dimen_k-1,ielem_start+ielem-1),1,smat(k_i)%coeffs(1:dimen_k,ielem),1)
         !
       enddo
       !
       call lapack_syev(smat(k_i)%coeffs(1:dimen_k,1:dimen_k),energy(ielem_start:ielem_start+dimen_k-1),jobz=jobz_)
       !
    enddo
    !$omp end parallel do
    !
    ! obtain the energy threshold for a given max_elems(nroots)
    !
    !
    allocate (energy0(dimen_s),stat=alloc)
    call ArrayStart('bset_contr_diago_e',alloc,size(energy0),kind(energy0))
    !
    call dcopy(dimen_s,energy(:),1,energy0(:),1)
    !
    do ielem=1,max_elems
      !
      energy_t = energy0(ielem)
      !
      do jelem=ielem+1,dimen_s
        !
        if ( energy_t>energy0(jelem) ) then
          !
          energy_t=energy0(jelem)
          energy0(jelem) = energy0(ielem)
          energy0(ielem) = energy_t
          !
        endif 
        !
      enddo
      !
    enddo
    !
    energy_thresh = min(energy0(max_elems),energy_thresh)
    !
    !
    ! Complete the allocation by counting memory and also count the roots which are below the energy threshold
    !
    iaddress = 1 ; naddress_ = 1 ; kaddress_ = 0
    !
    kelem = 0  ! number of included elements 
    nelem = 0  ! nunmber of the rest elements
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       do ielem=1,dimen_k
          !
          if (energy(ielem_start+ielem-1)<=energy_thresh) then 
            !
            kelem = kelem + 1
            !
            kaddress_(ielem_start+ielem-1) = kelem
            iaddress(kelem) = ielem_start+ielem-1
            !
           else
            !
            nelem = nelem + 1
            naddress_(nelem) = ielem_start+ielem-1
            !
          endif
          !
       enddo
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       call ArrayStart('krot_bs_contr_diago',0,1,kind(smat(k_i)%coeffs),matsize)
       !
    enddo
    !
    dimen_e = kelem
    dimen_x = nelem
    !
    if (job%verbose>=5) write (out,"('     Size of the k-contr. matrix = ',i9)") dimen_e
    !
    if (job%verbose>=4) call TimerStop('k-prediag (ssyev)')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    nroots =0
    !
    if (dimen_e==0) return
    !
    ! Transformation to the krot-contracted basis
    ! the new basis is BS-truncated 
    !
    if (job%verbose>=5) write (out,"('     transformation to k-contr. basis (dgemm)...')") 
    if (job%verbose>=4) call TimerStart('transformation to k-contr')
    !
    !$omp parallel private(mat_k,alloc_p) shared(mat)
    allocate (mat_k(dimenmax,dimenmax),stat=alloc_p)
    if (alloc_p/=0) then
       write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
       stop 'krot_bs_contr_diago: mat_k  - out of memory'
    end if
    !
    !$omp do private(k_i,ielem_start,ielem_end,dimen_i,k_j,jelem_start,jelem_end,dimen_j,i,j,l,ielem,jelem,temp) schedule(dynamic)
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_i = ielem_end-ielem_start+1
       !
       do k_j = 0,jrot
          !
          if (k_i-k_j>2.or.k_j>k_i) cycle
          !
          if (job%verbose>=5) write (out,"('       k_i,k_j = ',2i5)") k_i,k_j
          !
          jelem_start = kblock(k_j,1)
          jelem_end   = kblock(k_j,2)
          dimen_j = jelem_end-jelem_start+1
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                temp = 0
                do l = 1,dimen_i
                   !
                   ielem = ielem_start+l-1
                   !
                   temp = temp + smat(k_i)%coeffs(l,i)*mat(ielem,jelem)
                   !
                enddo
                mat_k(i,j) = temp
                !
            enddo
          enddo 
          !
          !call dgemm('T','N',dimen_i,dimen_j,dimen_i,alpha,&
          !       smat(k_i)%coeffs(1:dimen_i,1:dimen_i),dimen_i,&
          !                    mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1),dimen_i,&
          !             beta,mat_k(1:dimen_i,1:dimen_j),dimen_i)
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                !
                ielem = ielem_start+i-1
                !
                mat(ielem,jelem) = 0
                !
             enddo
             !
             do l = 1,dimen_j
                !
                if (smat(k_j)%coeffs(l,j).ne.0) then
                   temp = smat(k_j)%coeffs(l,j)
                   do i = 1,dimen_i
                      !
                      ielem = ielem_start+i-1
                      !
                      mat(ielem,jelem) = mat(ielem,jelem) + temp*mat_k(i,l)
                      !
                   enddo
                 endif
             enddo
          enddo
          !
          !call dgemm('N','N',dimen_i,dimen_j,dimen_j,alpha,& 
          !                   mat_k(1:dimen_i,1:dimen_j),dimen_i,&
          !        smat(k_j)%coeffs(1:dimen_j,1:dimen_j),dimen_j,&
          !                beta,mat_g(1:dimen_i,1:dimen_j),dimen_i)
          !
          !mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1) = mat_g(1:dimen_i,1:dimen_j)
          !
       enddo
       !
    enddo
    !$omp end do
    !
    deallocate(mat_k)
    !$omp end parallel
    !
    if (job%verbose>=5) write (out,"('       restoring the lower part from the upper...')")
    !
    !$omp parallel do private(ielem,jelem) shared(mat) schedule(dynamic)
    do ielem=1,dimen_s
       !
       do jelem=1,ielem-1
          !
          mat(jelem,ielem) = mat(ielem,jelem)
          !
       enddo
       !
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) call TimerStop('transformation to k-contr')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    allocate (energies(1:dimen_e,1:job%maxiter),stat=alloc)
    matsize = int(dimen_e,hik)*int(job%maxiter,hik)
    call ArrayStart('bset_contr_diago_e',alloc,1,kind(energies),matsize)
    !
    eps = safe_max  ; eps_ = safe_max
    !
    iter = 0 ; last_iter = .false.
    !
    jobz_ = 'N' ; dimen_g = 0
    !
    do while(.not.last_iter)
       !
       iter = iter + 1
       !
       if (job%verbose>=4) write (out,"(/'     iter = ',i8,'  energy_thresh = ',g18.8)") iter,energy_thresh
       if (job%verbose>=4) write (out,"('     Prepare the matrix...')")
       !
       eps = eps_
       !
       if (eps<=job%tolerance.or.iter==job%maxiter) last_iter = .true.
       !
       if (job%verbose>=4) write (out,"('     Shrinking the matrix...')")
       if (job%verbose>=4) call TimerStart('Shrinking b-matrix')
       !
       ! count the elements taken into account for the given thresholds
       !
       naddress = 1
       kaddress = kaddress_
       !
       kelem = dimen_e ; nelem = 0
       !
       do jelem=1,dimen_x
          !
          ielem = naddress_(jelem)
          !
          if (energy(ielem)<=energy_thresh) then
            !
            kelem = kelem + 1
            !
            kaddress(ielem) = kelem
            iaddress(kelem) = ielem
            !
           elseif(energy(ielem)-energy_thresh>=pt_thresh) then 
            !
            nelem = nelem + 1
            naddress(nelem) = ielem
            !
          endif
          !
       enddo
       !
       dimen_g = kelem
       dimen_n = nelem
       !
       if (job%verbose>=4) write (out,"('       Size of the contr. matrix       = ',i9)") dimen_g
       if (job%verbose>=4) write (out,"('       Number of elements taken for PT = ',i9)") dimen_n
       !
       !outer_loop : do 
         !
         loop_n : do ielem=1,dimen_n
           !
           do jelem=1,dimen_g
              !
              energy_t = energy(iaddress(jelem))-energy(naddress(ielem))
              !
              if (abs(mat(iaddress(jelem),naddress(ielem))/energy_t)>=0.01) then
                !
                kelem = kelem + 1
                !
                kaddress(naddress(ielem)) = kelem
                iaddress(kelem) = naddress(ielem)
                !
                naddress(ielem) = 0
                !
                nelem = nelem - 1
                !
                cycle loop_n
                !
              endif
              !
           enddo
           !
         enddo loop_n
         !
         ielem = 1
         !
         do while(ielem<=nelem)
            !
            if (naddress(ielem)==0) then 
               naddress(ielem:dimen_n) = eoshift(naddress(ielem:dimen_n),shift= 1,boundary=1)
            else
              !
              ielem = ielem + 1
              !
            endif
            !
         enddo 
         !
         !if (dimen_g == kelem)  exit
         !
         dimen_g = kelem
         dimen_n = nelem
         !
         if (job%verbose>=4) write (out,"('       Size of the contr. matrix       = ',i9)") dimen_g
         if (job%verbose>=4) write (out,"('       Number of elements taken for PT = ',i9)") dimen_n
         !
       !enddo outer_loop
       !
       if (dimen_g==dimen_s) last_iter = .true.
       !
       !if (job%verbose>=4) write (out,"('       Size of the contr. matrix       = ',i9)") dimen_g
       !if (job%verbose>=4) write (out,"('       Number of elements taken for PT = ',i9)") dimen_n
       !
       if (dimen_g==0) cycle
       !
       if (job%verbose>=4) write (out,"('       -- initializating the reduced matrix G...')")
       !
       allocate (mat_g(0:dimen_g,dimen_g),stat=alloc)
       matsize = int(dimen_g,hik)*int(dimen_g,hik)
       !
       call ArrayStart('bset_contr_diago_g',alloc,1,kind(mat_g),matsize)
       !$omp parallel do private(ielem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          mat_g(0:dimen_g,ielem) = 0
       enddo
       !$omp end parallel do
       !
       if (dimen_n>0) then 
          !
          if (job%verbose>=4) write (out,"('       -- computing the perturbation theory correction ...')")
          !
          allocate (mat_k(1:dimen_g,1:dimen_n),mat_t(1:dimen_g,1:dimen_n),stat=alloc)
          !
          matsize = int(dimen_g,hik)*int(dimen_n,hik)*2_hik
          !
          call ArrayStart('bset_contr_diago_pt',alloc,1,kind(mat_k),matsize)
          !
          !$omp parallel do private(ielem,nelem,energy_t) shared(mat_k,mat_t) schedule(dynamic)
          do ielem=1,dimen_g
             !
             do nelem=1,dimen_n
               !
               mat_t(ielem,nelem) = 0
               mat_k(ielem,nelem) = 0
               !
               energy_t = energy(iaddress(ielem))-energy(naddress(nelem))
               !
               !if (abs(mat(iaddress(ielem),naddress(nelem))/energy_t)<1e2) then
                 !
                 mat_t(ielem,nelem) = mat(iaddress(ielem),naddress(nelem))
                 mat_k(ielem,nelem) = mat_t(ielem,nelem)/energy_t
                 !
               !endif
               !
             enddo
             !
          enddo
          !$omp end parallel do
          !
          alpha = 0.5d0
          !
          call dgemm('N','T',dimen_g,dimen_g,dimen_n,alpha,&
                             mat_k(1:dimen_g,1:dimen_n),dimen_g,&
                             mat_t(1:dimen_g,1:dimen_n),dimen_g,&
                        beta,mat_g(1:dimen_g,1:dimen_g),dimen_g)
          !
          alpha = 1.0d0
          !
          deallocate(mat_k,mat_t)
          call ArrayStop('bset_contr_diago_pt')
          !
       endif 
       !
       if (job%verbose>=4) write (out,"('       -- shrinking the matrix and  adding the PT correction...')")
       !
       !$omp parallel do private(ielem,jelem) shared(mat_g) schedule(dynamic)
       do ielem=1,dimen_g
          !
          do jelem=1,ielem
             !
             mat_g(ielem,jelem) = mat_g(ielem,jelem) + mat_g(jelem,ielem) + mat(iaddress(ielem),iaddress(jelem))
             !
             mat_g(jelem,ielem) = mat_g(ielem,jelem)
             !
          enddo
          !
       enddo
       !$omp end parallel do
       !
       if (job%verbose>=4) call TimerStop('Shrinking b-matrix')
       if (job%verbose>=4) write (out,"('     ...done!')")
       !
       !
       ! diagonalization
       !
       if (job%verbose>=4) write (out,"('     Diagonalization...')")
       if (job%verbose>=4) call TimerStart('Diagonalization matrix')
       !
       allocate(energy_(dimen_g),stat=alloc)
       !
       if (last_iter) jobz_=jobz
       !
       select case (job%diagonalizer(1:5)) 
       !
       case default
         !
         write (out,"('PT_bset_truncated_diagonalization: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
         stop 'PT_bset_truncated_diagonalization - wrong diagonalizer '
         !
       case('SYEV-') 
         !
         call lapack_syev(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),jobz=jobz_)
         nroots = dimen_g
         !
       case('SYEVR') 
         !
         call lapack_syevr(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),rng=rng,jobz=jobz_,iroots=nroots,&
                           vrange=vrange,irange=irange)
         !
       end select
       !
       if (nroots<0) cycle
       !
       if (job%verbose>=4) call TimerStop('Diagonalization matrix')
       if (job%verbose>=4) write (out,"('     ...done!')") 
       !
       if (job%verbose>=4) write (out,"('     nroots = ',2i5/)") nroots
       !
       if (job%verbose>=4) then
           !
           energies(1:dimen_e,iter) = energy_(1:dimen_e)-job%partfunc%ZPE
           write(my_fmt,'(a,i0,a)') "(a2,a,i7,",iter,"f14.6)"
           !
           do iroot=1,dimen_e
             !
             write(out,my_fmt) sym%label(gamma),iroot,energies(iroot,1:iter)
             !
           enddo 
           !
       endif
       !
       ! Reconstruct the eigenfunctions in the original representation 
       !
       if (jobz_=='V'.and.last_iter) then
          !
          if (job%verbose>=4) write (out,"('     transformation to the original basis...')")
          if (job%verbose>=4) call TimerStart('transform to original basis')
          !
          !$omp parallel private(mat_k,alloc_p) shared(mat)
          allocate (mat_k(dimenmax,nroots),stat=alloc_p)
          if (alloc_p/=0) then
             write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
             stop 'krot_bs_contr_diago: mat_k  - out of memory'
          end if
          !
          !$omp do private(k_i,ielem_start,ielem_end,dimen_k,kelem,ielem,iroot) schedule(dynamic)
          do k_i = 0,jrot
             !
             if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
             !
             ielem_start = kblock(k_i,1)
             ielem_end   = kblock(k_i,2)
             dimen_k = ielem_end-ielem_start+1
             !
             if (dimen_k<=0) cycle
             !
             !allocate(mat_k(dimen_k,dimen_g),stat=alloc)
             !call ArrayStart('krot_bs_contr_diago_k',alloc,1,kind(smat(k_i)%coeffs),matsize)
             !
             do kelem=1,dimen_k
                !
                ielem = kaddress(ielem_start+kelem-1)
                !
                call dcopy(nroots,mat_g(ielem,1:nroots),1,mat_k(kelem,1:nroots),1)
                !
                !mat_k(kelem,1:nroots) = mat_g(ielem,1:nroots)
                !
             enddo
             !
             do iroot = 1,nroots
                !
                call dgemv('N',dimen_k,dimen_k,alpha,smat(k_i)%coeffs(1:dimen_k,1:dimen_k),dimen_k,&
                           mat_k(1:dimen_k,iroot),1,beta,mat(ielem_start:ielem_end,iroot),1)
                !
             enddo
             !
          enddo
          !$omp end do
          !
          deallocate(mat_k)
          !$omp end parallel 
          !
          if (job%verbose>=4) call TimerStop('transform to original basis')
          if (job%verbose>=4) write (out,"('     ...done!')")
          !
       endif
       !
       eps_ = sqrt(sum( ( energy0(1:dimen_e)-energy_(1:dimen_e) )**2 )/real(dimen_e,ark) )
       !
       energy0(1:nroots) = energy_(1:nroots)
       !
       if (job%verbose>=4) write (out,"('     rms = ',g18.8)") eps_
       !
       ! update the energy threshold
       !
       energy_thresh = energy_thresh+df
       !
       deallocate(mat_g,energy_)
       call ArrayStop('bset_contr_diago_g')
       !
    enddo
    !
    energy(1:nroots) = energy0(1:nroots)
    !
    deallocate(energy0)
    !
    do k_i = 0,jrot
       !
       deallocate (smat(k_i)%coeffs)
       !
    enddo
    !
    call ArrayStop('krot_bs_contr_diago')
    !
    if (job%verbose>=10) then 
       !
       if (job%verbose>=5) write (out,"('     check the eigenvectors against H...')") 
       !
       allocate (mat_k(nroots,dimen_s),stat=alloc)
       !
       matsize = int(nroots,hik)*int(dimen_s,hik)
       !
       call ArrayStart('krot_bs_contr_diago-t',alloc,1,kind(mat_k),matsize)
       !
       call dgemm('T','N',nroots,dimen_s,dimen_s,alpha,&
                          mat(1:dimen_s,1:nroots),dimen_s,&
                        mat_tt(1:dimen_s,1:dimen_s),dimen_s,&
                   beta,mat_k(1:nroots,1:dimen_s),nroots)
       !
       call dgemm('N','N',nroots,nroots,dimen_s,alpha,& 
                          mat_k(1:nroots,1:dimen_s),nroots,&
                            mat(1:dimen_s,1:nroots),dimen_s,&
                     beta,mat_tt(1:nroots,1:nroots),nroots)
       !
       deallocate(mat_k,mat_tt)
       !
       call ArrayStop('krot_bs_contr_diago-t')
       !
       if (job%verbose>=5) write (out,"('     ...done!')") 
       !
    endif
    !
    if (allocated(vector)) deallocate(vector)
    !
    deallocate (energies)
    call ArrayStop('bset_contr_diago_e')
    ! 
    if (job%verbose>=4) call TimerStop('krot_bs_contr_diago') 
    if (job%verbose>=4) write (out,"('     ...done!')")
    !
    !
  end subroutine krot_contracted_diagonalization_en_PT



  subroutine krot_contracted_diagonalization_en(jrot,k_row,dimen_s,irange,vrange,rng,jobz,mat,energy,nroots)

    integer(ik),intent(in)    :: jrot,dimen_s,k_row(dimen_s),irange(2)
    real(rk),intent(in)       :: vrange(2)
    real(rk),intent(inout)    :: mat(:,:),energy(:)
    integer(ik),intent(out)   :: nroots
    !
    real(rk),allocatable  :: mat_k(:,:),mat_g(:,:),mat_tt(:,:),energy_(:),energy0(:)
    type(PTcoeffsT)       :: smat(0:jrot)
    !
    real(rk)              :: energy_thresh,energy_t,temp
    integer(ik)           :: kaddress(dimen_s),iaddress(dimen_s),naddress(dimen_s)
    integer(ik)           :: max_elems,dimen_g,kblock(0:jrot,2),kelem
    integer(ik)           :: ielem,jelem,alloc,alloc_p,k_i,k_j,ielem_start,ielem_end,jelem_start,jelem_end,&
                             dimen_k,dimen_i,dimen_j,dimenmax,iroot,nelem,dimen_n
    integer(ik)           :: i,j,l
    character(len=1),intent(in)     :: rng,jobz
    character(len=1)     :: jobz_
    double precision     :: alpha = 1.0d0,beta=0.0d0
    integer(hik)         :: matsize
    !
    !real(rk),allocatable  :: mat_t(:,:)
    !
    if (job%verbose>=4) write (out,"('     krot-bs-contracted diagonalization...')")
    if (job%verbose>=4) call TimerStart('krot_bs_contr_diago')
    !
    if (job%verbose>=10) then 
      !
      allocate(mat_tt(dimen_s,dimen_s),stat=alloc)
      matsize = int(dimen_s,hik)*int(dimen_s,hik)
      mat_tt = mat
      !
    endif
    !
    nroots = 1
    !
    ielem_end = 0
    !
    ! organize the k-blocks
    !
    dimenmax = 1
    !
    do k_i = 0,jrot
       !
       k_j = k_i
       ielem_start = ielem_end + 1
       do while (k_j==k_i.and.ielem_end<dimen_s)
          !
          ielem_end = ielem_end + 1
          !
          k_j = k_row(ielem_end)
          !
       enddo
       !
       if (ielem_end<dimen_s) ielem_end = ielem_end - 1
       !
       kblock(k_i,1) = ielem_start
       kblock(k_i,2) = ielem_end
       dimen_k = ielem_end-ielem_start+1
       dimenmax = max(dimenmax,dimen_k)
       !
    enddo
    !
    max_elems = min(int(job%factor*dimen_s),dimen_s)
    !
    jobz_ = 'V'
    !
    if (job%verbose>=5) write (out,"('     k-prediag (ssyev)...')") 
    if (job%verbose>=4) call TimerStart('k-prediag (ssyev)')
    !
    !$omp parallel do private(k_i,ielem_start,ielem_end,dimen_k,matsize,ielem) shared(energy) schedule(dynamic)
    do k_i = 0,jrot
       !
       if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       if (dimen_k<=0) cycle
       !
       allocate (smat(k_i)%coeffs(dimen_k,dimen_k),stat=alloc)
       !
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate array smat')") alloc
          stop 'krot_bs_contr_diago: smat  - out of memory'
       end if
       !
       do ielem=1,dimen_k
         !
         call dcopy(dimen_k,mat(ielem_start:ielem_start+dimen_k-1,ielem_start+ielem-1),1,smat(k_i)%coeffs(1:dimen_k,ielem),1)
         !
       enddo
       !
       call lapack_syev(smat(k_i)%coeffs(1:dimen_k,1:dimen_k),energy(ielem_start:ielem_start+dimen_k-1),jobz=jobz_)
       !
    enddo
    !$omp end parallel do
    !
    ! obtain the energy threshold for a given max_elems(nroots)
    !
    !
    allocate (energy0(dimen_s),stat=alloc)
    call ArrayStart('bset_contr_diago_e',alloc,size(energy0),kind(energy0))
    !
    call dcopy(dimen_s,energy(:),1,energy0(:),1)
    !
    do ielem=1,dimen_s
      !
      energy_t = energy0(ielem)
      !
      do jelem=ielem+1,dimen_s
        !
        if ( energy_t>energy0(jelem) ) then
          !
          energy_t=energy0(jelem)
          energy0(jelem) = energy0(ielem)
          energy0(ielem) = energy_t
          !
        endif 
        !
      enddo
       !
    enddo
    !
    energy_thresh = energy0(max_elems)
    !
    ! Complete the allocation by counting memory and also count the roots which are below the energy threshold
    !
    iaddress = 1 ; naddress = 1 ; kaddress = 0
    !
    kelem = 0  ! number of included elements 
    nelem = 0  ! nunmber of the rest elements
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_k = ielem_end-ielem_start+1
       !
       do ielem=1,dimen_k
          !
          if (energy(ielem_start+ielem-1)<=energy_thresh) then 
            !
            kelem = kelem + 1
            !
            kaddress(ielem_start+ielem-1) = kelem
            iaddress(kelem) = ielem_start+ielem-1
            !
           else
            !
            nelem = nelem + 1
            naddress(nelem) = ielem_start+ielem-1
            !
          endif
          !
       enddo
       !
       matsize = int(dimen_k,hik)*int(dimen_k,hik)
       !
       call ArrayStart('krot_bs_contr_diago',0,1,kind(smat(k_i)%coeffs),matsize)
       !
    enddo
    !
    dimen_g = kelem
    dimen_n = nelem
    !
    if (job%verbose>=4) call TimerStop('k-prediag (ssyev)')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    dimen_g = kelem
    dimen_n = nelem
    !
    if (job%verbose>=4) write (out,"('       Size of the contr. matrix       = ',i9)") dimen_g
    if (job%verbose>=4) write (out,"('       Number of elements taken for PT = ',i9)") dimen_n
    !
    if (dimen_g==0) then 
      !
      write(out,"('size of the matrix is zero, please check the input parameters')")
      stop 'krot_contracted_diagonalization_en: dimen_g = 0, threshold is too tight'
      !
    endif
    !
    ! Transformation to the krot-contracted basis
    ! the new basis is BS-truncated 
    !
    if (job%verbose>=5) write (out,"('     transformation to k-contr. basis (dgemm)...')") 
    if (job%verbose>=4) call TimerStart('transformation to k-contr')
    !
    !$omp parallel private(mat_k,alloc_p) shared(mat)
    allocate (mat_k(dimenmax,dimenmax),stat=alloc_p)
    if (alloc_p/=0) then
       write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
       stop 'krot_bs_contr_diago: mat_k  - out of memory'
    end if
    !
    !$omp do private(k_i,ielem_start,ielem_end,dimen_i,k_j,jelem_start,jelem_end,dimen_j,i,j,l,ielem,jelem,temp) schedule(dynamic)
    do k_i = 0,jrot
       !
       ielem_start = kblock(k_i,1)
       ielem_end   = kblock(k_i,2)
       dimen_i = ielem_end-ielem_start+1
       !
       do k_j = 0,jrot
          !
          if (k_i-k_j>2.or.k_j>k_i) cycle
          !
          if (job%verbose>=5) write (out,"('       k_i,k_j = ',2i5)") k_i,k_j
          !
          jelem_start = kblock(k_j,1)
          jelem_end   = kblock(k_j,2)
          dimen_j = jelem_end-jelem_start+1
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                temp = 0
                do l = 1,dimen_i
                   !
                   ielem = ielem_start+l-1
                   !
                   temp = temp + smat(k_i)%coeffs(l,i)*mat(ielem,jelem)
                   !
                enddo
                mat_k(i,j) = temp
                !
            enddo
          enddo 
          !
          !call dgemm('T','N',dimen_i,dimen_j,dimen_i,alpha,&
          !       smat(k_i)%coeffs(1:dimen_i,1:dimen_i),dimen_i,&
          !                    mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1),dimen_i,&
          !             beta,mat_k(1:dimen_i,1:dimen_j),dimen_i)
          !
          do j = 1,dimen_j
             !
             jelem = jelem_start+j-1
             !
             do i = 1,dimen_i
                !
                ielem = ielem_start+i-1
                !
                mat(ielem,jelem) = 0
                !
             enddo
             !
             do l = 1,dimen_j
                !
                if (smat(k_j)%coeffs(l,j).ne.0) then
                   temp = smat(k_j)%coeffs(l,j)
                   do i = 1,dimen_i
                      !
                      ielem = ielem_start+i-1
                      !
                      mat(ielem,jelem) = mat(ielem,jelem) + temp*mat_k(i,l)
                      !
                   enddo
                 endif
             enddo
          enddo
          !
          !call dgemm('N','N',dimen_i,dimen_j,dimen_j,alpha,& 
          !                   mat_k(1:dimen_i,1:dimen_j),dimen_i,&
          !        smat(k_j)%coeffs(1:dimen_j,1:dimen_j),dimen_j,&
          !                beta,mat_g(1:dimen_i,1:dimen_j),dimen_i)
          !
          !mat(ielem_start:ielem_start+dimen_i-1,jelem_start:jelem_start+dimen_j-1) = mat_g(1:dimen_i,1:dimen_j)
          !
       enddo
       !
    enddo
    !$omp end do
    !
    deallocate(mat_k)
    !$omp end parallel
    !
    if (job%verbose>=5) write (out,"('       restoring the lower part from the upper...')")
    !
    !$omp parallel do private(ielem,jelem) shared(mat) schedule(dynamic)
    do ielem=1,dimen_s
       !
       do jelem=1,ielem-1
          !
          mat(jelem,ielem) = mat(ielem,jelem)
          !
       enddo
       !
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) call TimerStop('transformation to k-contr')
    if (job%verbose>=5) write (out,"('     ...done!')") 
    !
    if (job%verbose>=4) write (out,"('       -- initializating the reduced matrix G...')")
    !
    allocate (mat_g(0:dimen_g,dimen_g),stat=alloc)
    matsize = int(dimen_g,hik)*int(dimen_g,hik)
    !
    call ArrayStart('bset_contr_diago_g',alloc,1,kind(mat_g),matsize)
    !$omp parallel do private(ielem) shared(mat_g) schedule(dynamic)
    do ielem=1,dimen_g
       mat_g(0:dimen_g,ielem) = 0
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) write (out,"('       -- shrinking the matrix...')")
    !
    if (job%verbose>=4) call TimerStart('Shrinking b-matrix')
    !
    !$omp parallel do private(ielem,jelem) shared(mat_g) schedule(dynamic)
    do ielem=1,dimen_g
       !
       do jelem=1,ielem
          !
          mat_g(ielem,jelem) = mat(iaddress(ielem),iaddress(jelem))
          !
          mat_g(jelem,ielem) = mat_g(ielem,jelem)
          !
       enddo
       !
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) call TimerStop('Shrinking b-matrix')
    if (job%verbose>=4) write (out,"('     ...done!')")
    !
    ! diagonalization
    !
    if (job%verbose>=4) write (out,"('     Diagonalization...')")
    if (job%verbose>=4) call TimerStart('Diagonalization matrix')
    !
    allocate(energy_(dimen_g),stat=alloc)
    !
    select case (job%diagonalizer(1:5)) 
    !
    case default
      !
      write (out,"('PT_bset_truncated_diagonalization: type of the diagonalizer  ',a,' unknown')") trim(job%diagonalizer)
      stop 'PT_bset_truncated_diagonalization - wrong diagonalizer '
      !
    case('SYEV-') 
      !
      call lapack_syev(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),jobz=jobz_)
      nroots = dimen_g
      !
    case('SYEVR') 
      !
      call lapack_syevr(mat_g(1:dimen_g,1:dimen_g),energy_(1:dimen_g),rng=rng,jobz=jobz_,iroots=nroots,vrange=vrange,irange=irange)
      !
    end select
    !
    if (job%verbose>=4) call TimerStop('Diagonalization matrix')
    if (job%verbose>=4) write (out,"('     ...done!')") 
    !
    if (job%verbose>=4) write (out,"('     nroots = ',2i5/)") nroots
    !
    ! Reconstruct the eigenfunctions in the original representation 
    !
    if (jobz_=='V') then
       !
       if (job%verbose>=4) write (out,"('     transformation to the original basis...')")
       if (job%verbose>=4) call TimerStart('transform to original basis')
       !
       !$omp parallel private(mat_k,alloc_p) shared(mat)
       allocate (mat_k(dimenmax,nroots),stat=alloc_p)
       if (alloc_p/=0) then
          write (out,"(' Error ',i9,' trying to allocate array mat_k')") alloc_p
          stop 'krot_bs_contr_diago: mat_k  - out of memory'
       end if
       !
       !$omp do private(k_i,ielem_start,ielem_end,dimen_k,kelem,ielem,iroot) schedule(dynamic)
       do k_i = 0,jrot
          !
          if (job%verbose>=5) write (out,"('       k = ',i5)") k_i
          !
          ielem_start = kblock(k_i,1)
          ielem_end   = kblock(k_i,2)
          dimen_k = ielem_end-ielem_start+1
          !
          if (dimen_k<=0) cycle
          !
          !allocate(mat_k(dimen_k,dimen_g),stat=alloc)
          !call ArrayStart('krot_bs_contr_diago_k',alloc,1,kind(smat(k_i)%coeffs),matsize)
          !
          do kelem=1,dimen_k
             !
             ielem = kaddress(ielem_start+kelem-1)
             !
             call dcopy(nroots,mat_g(ielem,1:nroots),1,mat_k(kelem,1:nroots),1)
             !
             !mat_k(kelem,1:nroots) = mat_g(ielem,1:nroots)
             !
          enddo
          !
          do iroot = 1,nroots
             !
             call dgemv('N',dimen_k,dimen_k,alpha,smat(k_i)%coeffs(1:dimen_k,1:dimen_k),dimen_k,&
                        mat_k(1:dimen_k,iroot),1,beta,mat(ielem_start:ielem_end,iroot),1)
             !
          enddo
          !
       enddo
       !$omp end do
       !
       deallocate(mat_k)
       !$omp end parallel 
       !
       if (job%verbose>=4) call TimerStop('transform to original basis')
       if (job%verbose>=4) write (out,"('     ...done!')")
       !
    endif
    !
    deallocate(mat_g,energy_)
    call ArrayStop('bset_contr_diago_g')
    !
    energy(1:nroots) = energy0(1:nroots)
    !
    deallocate(energy0)
    !
    do k_i = 0,jrot
       !
       deallocate (smat(k_i)%coeffs)
       !
    enddo
    !
    call ArrayStop('krot_bs_contr_diago')
    !
    if (job%verbose>=10) then 
       !
       if (job%verbose>=5) write (out,"('     check the eigenvectors against H...')") 
       !
       allocate (mat_k(nroots,dimen_s),stat=alloc)
       !
       matsize = int(nroots,hik)*int(dimen_s,hik)
       !
       call ArrayStart('krot_bs_contr_diago-t',alloc,1,kind(mat_k),matsize)
       !
       call dgemm('T','N',nroots,dimen_s,dimen_s,alpha,&
                          mat(1:dimen_s,1:nroots),dimen_s,&
                        mat_tt(1:dimen_s,1:dimen_s),dimen_s,&
                   beta,mat_k(1:nroots,1:dimen_s),nroots)
       !
       call dgemm('N','N',nroots,nroots,dimen_s,alpha,& 
                          mat_k(1:nroots,1:dimen_s),nroots,&
                            mat(1:dimen_s,1:nroots),dimen_s,&
                     beta,mat_tt(1:nroots,1:nroots),nroots)
       !
       deallocate(mat_k,mat_tt)
       !
       call ArrayStop('krot_bs_contr_diago-t')
       !
       if (job%verbose>=5) write (out,"('     ...done!')") 
       !
    endif
    ! 
    if (job%verbose>=4) call TimerStop('krot_bs_contr_diago') 
    if (job%verbose>=4) write (out,"('     ...done!')")
    !
    !
  end subroutine krot_contracted_diagonalization_en




  subroutine matrix_transform(dimen_a,dimen_b,amat,trasform)
    !
    integer(ik),intent(in) :: dimen_a,dimen_b
    real(rk),intent(inout) :: amat(:,:)
    real(rk),intent(in)    :: trasform(:,:)
    real(rk),allocatable  :: diag(:),gmat(:,:)
    integer(ik) ::ielem,iterm,jterm,alloc
    double precision,external :: ddot
    integer(hik)  :: matsize
    !
    if (job%verbose>=5) write (out,"('     transformation to k-contr. basis...')") 
    if (job%verbose>=4) call TimerStart('transform-mat') 
    !
    ! count the number of energies below the energy threshold
    !
    !
    allocate (diag(dimen_a),gmat(dimen_a,dimen_b),stat=alloc)
    !
    matsize = int(dimen_a,hik)*int(dimen_b,hik)
    !
    call ArrayStart('transform-efiltered',alloc,size(diag),kind(diag))
    call ArrayStart('transform-efiltered',alloc,1,kind(gmat),matsize)
    !
    !$omp parallel do private(ielem,iterm) shared(diag,gmat) schedule(dynamic)
    do ielem = 1,dimen_a
      !
      diag(ielem) = amat(ielem,ielem)
      !
      do iterm = 1,dimen_b
        !
        gmat(ielem,iterm)=ddot(ielem-1,amat(ielem,1:ielem-1),1,trasform(1:ielem-1,iterm),1)
        !
      enddo
      !
    end do 
    !$omp end parallel do
    !
    !$omp parallel do private(iterm,jterm) shared(amat) schedule(dynamic)
    do iterm=1,dimen_b
       do jterm=1,dimen_b
         !
         amat(iterm,jterm) = ddot(dimen_a,trasform(:,jterm),1,gmat(:,iterm),1)
         !
        enddo 
    enddo
    !$omp end parallel do
    !
    deallocate(gmat)
    !
    !$omp parallel do private(iterm,jterm) shared(amat) schedule(dynamic)
    do iterm=1,dimen_b
      do jterm=iterm,dimen_b
         ! 
         amat(iterm,jterm) = amat(iterm,jterm) + amat(jterm,iterm)
         amat(iterm,jterm) = amat(iterm,jterm) + &
                             sum(trasform(:,iterm)*diag(:)*trasform(:,jterm))
         amat(jterm,iterm) = amat(iterm,jterm) 
         !
     enddo 
    enddo 
    !$omp end parallel do
    !
    deallocate(diag)
    !
    call ArrayStop('transform-efiltered')
    !
    if (job%verbose>=4) call TimerStop('transform-mat') 
    if (job%verbose>=5) write (out,"('     ...done!')")
    !
  end subroutine matrix_transform


  !
  !
  ! Contracted matrix elements
  !
  subroutine PTcontracted_matelem_class(jrot) 
    !
    implicit none
    !
    integer(ik),intent(in)   :: jrot
    integer(ik)        :: PotOrder,KinOrder,extForder
    integer(ik)        :: poten_N,gvib_N,grot_N,gcor_N,Ncoeffs,jmax,L2vib_N,extF_N_
    integer(ik)        :: iclasses,ilevel,ideg,alloc,dimen,iterm,k1,k2,islice
    real(rk),allocatable :: me_t(:,:)
    real(rk),allocatable :: mat_t(:,:), grot_t(:,:),extF_t(:,:),gvib_t(:,:),hvib_t(:,:),fvib_t(:,:),&
                            matclass(:,:,:),hrot_t(:,:),gcor_t(:,:)
    real(rk),allocatable :: gcor_(:,:,:,:),grot_(:,:,:,:),extF_dvr(:,:,:),extF_r(:,:)
    !
    real(rk)           :: f_t
    integer(ik)        :: isize,iroot
    integer(ik)        :: dimen_p,nroots,chkptIO,extF_rank,chkptIO_
    integer(hik)       :: rootsize,rootsize_,matsize
    !
    logical            :: treat_rotation =.false.  ! switch off/on the rotation 
    logical            :: treat_vibration =.true.  ! switch off/on the vibration
    logical            :: treat_exfF=.false.       ! switch off/on the external field 
    !
    double precision,parameter :: alpha = 1.0d0,beta=0.0d0
    character(len=cl)  :: job_is,buf
    !
    integer(ik)        :: dimen_p_max,nroots_max,imu,mdimen,mdimen_
    integer(ik)        :: iterm1=0,iterm2=12
    integer(ik)        :: icoeff,icase,ilambda,jcoeff,idvr
    integer(ik),allocatable  :: extF_N(:),icoeff2iroot(:,:)
    integer(hik),allocatable :: icoefficoeff1(:)
    !
    type(PTcoeffsT)    :: tmat(PT%Nclasses),mat_tt(PT%Nclasses)
    type(PTcoeffT),pointer        :: fl
      !
      !
      call TimerStart('Contracted matelements-class')
      !
      !if (PT%Nclasses/=1) then 
      !  !
      !  write(out,"('PTcontracted_matelem_class/end: This procedure has not been tested for Nclasses = ',i8,' yet')") PT%Nclasses
      !  stop 'PTcontracted_matelem_class: illegal number of classes' 
      !  !
      !endif
      !
      if (verbose>=4) write(out,"('PTcontracted_matelem_class/start: contracted matrix elements for the hamiltonian ')") 
      !
      extF_rank = FLread_extF_rank()
      !
      allocate(extF_N(max(extF_rank,1)))
      !
      call FLread_fields_dimensions(poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,extF_N,L2vib_N)
      !
      PT%Nterms%poten = poten_N
      PT%Nterms%gvib = gvib_N
      PT%Nterms%grot = grot_N
      PT%Nterms%gcor = gcor_N
      PT%Nterms%jmax = jmax
      !
      ! Some parts of the Hamiltonian are not needed if J=0 (neither grot nor gcor).
      ! We adopt treat_rotation to switch it on/off
      !
      if ((FLrotation.and.jrot/=0).or.trim(job%IOkinet_action)=='SAVE') treat_rotation = .true.
      !
      if (jrot/=0.and.trim(job%IOkinet_action)/='READ') then     
         write (out,"(/'PTcontracted_matelem_class: the contracted matrix elements can be calculated only at J = 0')") 
         write (out,"('First run the J=0 case with IOkinet_action=SAVE')") 
         write (out,"('and switch to J/=0 with IOkinet_action=READ')") 
         stop 'PTcontracted_matelem_class - illegal IOkinet_action for J/=0'
      endif 
      !
      Ncoeffs = max(poten_N,gvib_N,grot_N,gcor_N)
      !
      ! Here we decide whether we need to compute the    matrix elements from 
      ! the pure vibrational part of the Hamiltonian. If our contracted basis set 
      ! has been built under all vib. modes combined into one class, 
      ! we can directly use the corresponding eigenvalues. 
      !
      if (job%vib_contract) then 
        !
        PTvibrational_me_calc = .false.
        !
        if (job%verbose>=3) then 
          write(out,"(/'The vibrational (J=0) part of the Hamiltonian is diagonal.')") 
          write(out,"('The corresponding matrix elements are not computed.'/'The vibrational eigenvalues are used instead.')") 
        endif 
        !
        treat_vibration = .false.
        !
      endif 
      !
      ! Turn on the external field
      !
      if (trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT') treat_exfF = .true.
      !
      ! We assume that all matrix elements are simmetric, therefore we can use 
      ! a 1D array for storing only the upper half of the matrix.
      ! And this is the size of such 1D array.
      !
      mdimen = PT%Maxcontracts
      !
      rootsize = int(mdimen*mdimen,hik)
      !
      ! The vibrational (J=0) matrix elements of the rotational and coriolis 
      ! kinetic parts are retrieved now from the storage place (check_point). 
      ! For pure vibrational calculations we provide an option to store and restore 
      ! the matrix elements of the J=0 part of Hamiltonian
      !
      if (trim(job%IOkinet_action)=='READ'.or.trim(job%IOkinet_action)=='VIB_READ') then
        !
        treat_vibration = .false.
        treat_rotation = .false.
        !
      endif 
      !
      if (treat_vibration.or.treat_exfF.or.treat_rotation) then 
        !
        if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and.&
           (.not.job%IOmatelem_split.or.job%iswap(1)==0.or.(job%iswap(1)==1.and.&
                 job%iswap(2)==(PT%Nmodes+3)*3+PT%Nmodes**2+1) )) then
          !
          if (FLrotation.and.jrot/=0) then 
            write (out,"(' IOkinet_action = SAVE is not working for J/=0 ')") 
            stop 'PTcontracted_matelem_class - illegal IOkinet_action for J/=0'
          endif 
          !
          ! Prepare the checkpoint file
          !
          job_is ='Vib. matrix elements of the rot. kinetic part'
          call IOStart(trim(job_is),chkptIO)

          open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=job%kinetmat_file)
          write(chkptIO) 'Start Kinetic part'
          !
          ! store the bookkeeping information about the contr. basis set
          !
          call PTstore_icontr_cnu(PT%Maxcontracts,chkptIO,job%IOkinet_action)
          !
        endif 
        !
        ! maximal size of the primitive matrix in all classes
        !
        dimen_p_max = 0
        nroots_max = 0 
        !
        ! Allocate objects for contracted matrix elements
        !
        do iclasses = 1,PT%Nclasses
          !
          dimen   = contr(iclasses)%nlevels
          nroots  = contr(iclasses)%nroots
          dimen_p = contr(iclasses)%dimen
          !
          dimen_p_max = max(dimen_p_max,dimen_p)
          nroots_max = max(nroots_max,nroots)
          !
          ! Allocate arrays for matrix elements 
          !
          !
          if (job%verbose>=6) write(out,"(/'PTcontracted_matelem_class: Number of roots: ',i8)") nroots

          ! this will provide the number of the maximal expansion:
          !
          if (job%verbose>=4) write(out,"('class  = ',i8,' contr. dimen = ',i8,' prim. dimen = ',i8)") iclasses,dimen,dimen_p
          !
          !
          ! Prepare the transformation matrix T^+ H T (for non-DVR, FBR integration)
          !
          if (trove%FBR) then
             !
             allocate(tmat(iclasses)%coeffs(dimen_p,nroots),stat=alloc)
             call ArrayStart('PTcontracted_matelem_cl: group of temp arrays',alloc,size(tmat(iclasses)%coeffs),kind(f_t))
             allocate(mat_tt(iclasses)%coeffs(nroots,nroots),stat=alloc)
             call ArrayStart('PTcontracted_matelem_cl: group of temp arrays',alloc,size(mat_tt(iclasses)%coeffs),kind(f_t))
             !
             ! Construct the unitary transformation matrix
             !
             do iroot=1,nroots
               ! 
               ilevel = contr(iclasses)%ilevel(iroot)
               ideg = contr(iclasses)%ideg(iroot)
               !
               tmat(iclasses)%coeffs(:,iroot) = contr(iclasses)%eigen(ilevel)%vect(:,ideg)
               !
             enddo
          endif 
          !
        enddo 
        !
        ! Temporar arrays allocation (for non-DVR, FBR integration)
        !
        !
        if (trove%FBR) then
           allocate(me_t(dimen_p_max,dimen_p_max),stat=alloc)
           call ArrayStart('PTcontracted_matelem_cl: me_t',alloc,dimen_p_max**2,kind(me_t))
           allocate(mat_t(nroots_max,dimen_p_max),stat=alloc)
           call ArrayStart('PTcontracted_matelem_cl: mat_t',alloc,nroots_max*dimen_p_max,kind(mat_t))
           !
           matsize = int(PT%Nclasses*nroots_max*nroots_max,hik)
           !
           allocate(matclass(PT%Nclasses,nroots_max,nroots_max),stat=alloc)
           call ArrayStart('PTcontracted_matelem_cl: matclass',alloc,1,kind(matclass),matsize)
           !
           matclass = 0
           !
           matsize = PT%Nclasses*PT%Maxcontracts
           !
           allocate(icoeff2iroot(PT%Nclasses,PT%Maxcontracts),icoefficoeff1(PT%Maxcontracts),stat=alloc)
           call ArrayStart('PTcontracted_matelem_cl: icoeff2iroot',alloc,1,ik,matsize)
           call ArrayStart('PTcontracted_matelem_cl: icoeff2iroot',alloc,size(icoefficoeff1),ik)
           !
           !$omp  parallel do private(icoeff,icase,ilambda,iclasses,ideg,ilevel,iroot) shared(icoeff2iroot,icoefficoeff1) &
           !$omp& schedule(dynamic)
           do icoeff=1,PT%Maxcontracts
             !
             icoefficoeff1(icoeff) = int(icoeff*(icoeff-1),hik)/2
             !
             icase   = PT%icontr2icase(icoeff,1)
             ilambda = PT%icontr2icase(icoeff,2)
             !
             do iclasses = 1,PT%Nclasses
               !
               ideg = PT%Index_deg(icase)%icoeffs(iclasses,ilambda)
               !
               ilevel = PT%contractive_space(iclasses,icase)
               !
               iroot = contr(iclasses)%iroot(ilevel,ideg)
               !
               icoeff2iroot(iclasses,icoeff) = iroot
               !
             enddo
           enddo
           !$omp end parallel do 
           !
           if (job%verbose>=4) call MemoryReport
        endif
        !
        ! Initialize the Hamiltonian fields and basis functions in the DVR representation
        !
        if (trove%DVR) then
          !
          call PTDVR_contracted_basis_generate(jrot)
          !
        endif
        !
        if (treat_vibration.or.(trove%DVR.and.treat_rotation)) then 
          !
          ! The vibrational part of the Hamiltonian
          !
          if (job%verbose>=4) write(out,"('  allocating hvib, ',i9,' elements...')") rootsize
          !
          allocate(hvib%me(mdimen,mdimen),stat=alloc)
          call ArrayStart('gvib-grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          hvib%me = 0
          !
          if (job%verbose>=5) call MemoryReport
          !
        endif
        !
        !---------------------------!
        ! Only when rotation is ON  !
        !---------------------------!
        !
        if (treat_rotation.and.trove%FBR) then
          !
          if (job%verbose>=2) write(out,"(/'Rotational part of the Kinetic energy operator...')")
          !
          if (job%verbose>=4) write(out,"('  allocating grot, ',i9,' elements...')") rootsize
          !
          if (job%IOmatelem_split) then
            !
            iterm1 = max(job%iswap(1),0)
            iterm2 = min(job%iswap(2),12)
            if (job%IOmatelem_divide) then 
              iterm1 = max(job%iswap(1),0)
              iterm2 = min(job%iswap(2),(PT%Nmodes+3)*3+PT%Nmodes**2)
            endif             
            !
          endif
          !
          if (job%IOmatelem_divide ) then
            !
            if (job%verbose>=4) write(out,"('  The matelem.chk will be divided into 3 x 3 + ',i3,'x 3 = ',i5,' chk-slices')") &
                                       PT%Nmodes,9+3*PT%Nmodes+1
            if (job%verbose>=4) write(out,"(a,i3,' (Gcor), ',i3,'-',i3,' (Gvib), and ',i3,' (Poten) ')") &
                                            '  islice = 0 (gvib+poten stitching), 1-9 (Grot), 10-',&
                                            9+3*PT%Nmodes,9+3*PT%Nmodes+1,9+3*PT%Nmodes+PT%Nmodes**2,9+3*PT%Nmodes+PT%Nmodes**2+1
            if (job%verbose>=4) write(out,"('  This run is for the checkpoint slices from ',i4,' to ',i4)") iterm1,iterm2
            if (job%verbose>=4) write(out,"(/'  For a single chk-slice #i use MATELEM SAVE SPLIT i i ')")
            if (job%verbose>=4) write(out,"(a,a)") '  Vibrational chk-s obtained separately must be combined',&
                                                   ' using MATELEM SAVE STITCH or MATELEM SAVE 0 0'
            if (job%verbose>=4) write(out,"('  For all slices run and stitched in one go use MATELEM SAVE SPLIT ')")
            !
          elseif (job%IOmatelem_split) then
            !
            if (job%verbose>=4) write(out,"('  The matelem.chk will be divided into 3 x 3 + 1 chk-slices')")
            if (job%verbose>=4) write(out,"('  islice = 0 (gvib+poten stitching), 1-9 (Grot), 10-12 (Gcor)')") 
            if (job%verbose>=4) write(out,"('  This run is for the checkpoint slices from ',i4,' to ',i4)") iterm1,iterm2
            if (job%verbose>=4) write(out,"(/'  For a single chk-slice #i use MATELEM SAVE SPLIT i i ')")
            if (job%verbose>=4) write(out,"('  For all slices in one go use MATELEM SAVE SPLIT ')")
            !
          endif
          !
          !
          allocate(grot_t(mdimen,mdimen),hrot_t(mdimen,mdimen),gcor_t(mdimen,mdimen),stat=alloc)
          call ArrayStart('grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          call ArrayStart('grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          call ArrayStart('grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          !
          if (job%verbose>=5) call MemoryReport
          !
          if (trim(job%IOkinet_action)=='SAVE'.and..not.job%IOmatelem_split) then
            !
            write(chkptIO) 'g_rot'
            !
          endif 
          !
          ! The vibrational (J=0) matrix elements of the rotational and coriolis 
          ! kinetic parts are being computed here. 
          !
          ! Run the loop over all term of the expansion of the Hamiltonian 
          !
          islice = 0
          job_is = 'grot'
          !
          do k1 = 1,3
            do k2 = 1,3
              !
              islice = islice + 1
              !
              if (job%IOmatelem_split.and.(islice<iterm1.or.iterm2<islice)) cycle
              !
              grot_t = 0
              hrot_t = 0
              !
              if (job%verbose>=4) write(out,"('k1,k2 = ',2i8)") k1,k2
              !
              grot_N = FLread_fields_dimension_field(job_is,k1,k2)
              !
              fl => me%grot(k1,k2)
              !
              do iterm = 1,grot_N
                !
                call calc_contract_matrix_elements_II(iterm,k1,k2,fl,hrot_t,grot_contr_matelem_single_term)
                !
                !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
                do icoeff=1,mdimen
                  do jcoeff=1,icoeff
                    grot_t(jcoeff,icoeff) = grot_t(jcoeff,icoeff) + hrot_t(jcoeff,icoeff)
                  enddo
                enddo
                !$omp end parallel do
                !
              enddo
              !
              !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  grot_t(icoeff,jcoeff) = grot_t(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              if (trim(job%IOkinet_action)=='SAVE') then
                if (job%IOmatelem_split) then 
                  !
                  call write_divided_slice(islice,'g_rot',job%matelem_suffix,mdimen,grot_t)
                  !
                else
                  !
                  ! store the matrix elements 
                  !
                  write(chkptIO) grot_t
                  !
                endif
              endif
              ! 
            enddo
          enddo
          !
          if (job%verbose>=2) write(out,"(/'Coriolis part of the Kinetic energy operator...')")
          !
          if (trim(job%IOkinet_action)=='SAVE'.and..not.job%IOmatelem_split) then
            !
            write(chkptIO) 'g_cor'
            !
          endif
          !
          ! Run the loop over all term of the expansion of the Hamiltonian 
          !
          job_is = 'gcor'
          do k2 = 1,3
            !
            gcor_t = 0
            !
            if (job%IOmatelem_split.and..not.job%IOmatelem_divide) then
              islice = islice + 1
              if (islice<iterm1.or.iterm2<islice) cycle
            endif
            !
            do k1 = 1,PT%Nmodes
              !
              if (job%IOmatelem_divide) then
                islice = islice + 1
                if (islice<iterm1.or.iterm2<islice) cycle
              endif
              !
              if (job%verbose>=4) write(out,"('k1,k2 = ',2i8)") k1,k2
              !
              grot_t = 0
              !
              gcor_N = FLread_fields_dimension_field(job_is,k1,k2)
              !
              fl => me%gcor(k1,k2)
              !
              do iterm = 1,gcor_N
                !
                !hrot_t = 0
                !
                call calc_contract_matrix_elements_II(iterm,k1,k2,fl,hrot_t,gcor_contr_matelem_single_term)
                !
                !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
                do icoeff=1,mdimen
                  do jcoeff=1,icoeff
                    grot_t(jcoeff,icoeff) = grot_t(jcoeff,icoeff) + hrot_t(jcoeff,icoeff)
                  enddo
                enddo
                !$omp end parallel do
                !
              enddo
              !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  grot_t(icoeff,jcoeff) =  grot_t(jcoeff,icoeff)
                  grot_t(jcoeff,icoeff) = -grot_t(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              if (job%IOmatelem_divide) then
                !
                call write_divided_slice(islice,'g_cor',job%matelem_suffix,mdimen,grot_t)
                !
              else
                !
                !$omp parallel do private(icoeff) shared(gcor_t) schedule(dynamic)
                do icoeff=1,mdimen
                    gcor_t(icoeff,:) = gcor_t(icoeff,:)+grot_t(icoeff,:)
                enddo
                !$omp end parallel do
                !
              endif 
              !
            enddo
            !
            if (trim(job%IOkinet_action)=='SAVE') then
              !
              if (job%IOmatelem_split) then 
                !
                call write_divided_slice(islice,'g_cor',job%matelem_suffix,mdimen,gcor_t)
                !
              else
                !
                ! store the matrix elements 
                !
                write(chkptIO) gcor_t
                !
              endif
            endif
            !
          enddo
          !
          !islice = gcor_N+grot_N
          !
          deallocate(grot_t,hrot_t,gcor_t)
          call ArrayStop('grot-gcor-fields')
          !
        endif
        !
        ! Vibrational part 
        !
        if (treat_vibration.or.(trove%DVR.and.treat_rotation)) then 
          !
          ! The vibrational part of the Hamiltonian
          !
          !if (job%verbose>=4) write(out,"('  allocating hvib, ',i9,' elements...')") rootsize
          !
          !allocate(hvib%me(rootsize),stat=alloc)
          !call ArrayStart('gvib-grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          !hvib%me = 0 
          !
          ! Run the loop over all term of the expansion of the Hamiltonian
          !
          ! Decide between the DVR and FBR integration 
          !
          if (trove%DVR) then 
            !
            if (job%verbose>=2) write(out,"(/'DVR integration of the Hamiltonian factors using contracted basis...')")
            !
            ! Allocate the dvr-rotational objects. In case treat_rotation is FALSE allocate only dummy objects of small sizes
            !
            mdimen_ = mdimen
            !
            rootsize_ = rootsize
            if (.not.treat_rotation) then  
              rootsize_ = 1
              mdimen_ = 1
            endif
            !
            allocate(grot_(3,3,mdimen_,mdimen_),gcor_(PT%Nmodes,3,mdimen_,mdimen_),stat=alloc)
            !
            matsize = rootsize_*9_hik+rootsize_*3_hik*int(PT%Nmodes,hik)
            !
            call ArrayStart('grot-gcor-fields',alloc,1,kind(f_t),matsize)
            !
            if (job%verbose>=5) call MemoryReport
            !
            grot_ = 0
            gcor_ = 0 
            !
            if (trim(job%IOswap_matelem)/='JOIN') then
               !
               call PTDVRcontracted_matelem_all_fields(hvib%me,treat_rotation,grot_,gcor_)
               !
               !call PTDVRcontracted_matelem_all_fields_compress(hvib%me,treat_rotation,grot_,gcor_)
               !
            endif 
            !
            if (job%verbose>=2) write(out,"('...end!')")
            !
            if (treat_rotation.and.trim(job%IOkinet_action)=='SAVE') then
               !
               ! store the rotational matrix elements 
               !
               write(chkptIO) 'g_rot'
               !
               do k1 = 1,3
                 do k2 = 1,3
                   !
                   write(chkptIO) grot_(k1,k2,:,:)
                   ! 
                 enddo
               enddo
               !
               write(chkptIO) 'g_cor'
               !
               ! store the Coriolis matrix elements 
               !
               do k1 = 1,PT%Nmodes
                 do k2 = 1,3
                   !
                   write(chkptIO) gcor_(k1,k2,:,:)
                   ! 
                 enddo
               enddo
               !
               deallocate(grot_,gcor_)
               call ArrayStop('grot-gcor-fields')
               !
            endif
            !
          else ! if (.not.job%IOmatelem_split.or.job%iswap(1)==0 ) then
            !
            ! ----------------- FBR ------------------
            !
            if (job%verbose>=2) write(out,"(/'Vibrational kinetic part...')")
            if (job%verbose>=3) write(out,"(/'Number of gvib terms  = ',i8)") gvib_N
            !
            allocate(hvib_t(mdimen,mdimen),gvib_t(mdimen,mdimen),fvib_t(mdimen,mdimen),stat=alloc)
            call ArrayStart('hvib-fields',alloc,1,kind(f_t),rootsize)
            call ArrayStart('hvib-fields',alloc,1,kind(f_t),rootsize)
            call ArrayStart('hvib-fields',alloc,1,kind(f_t),rootsize)
            !
            islice = 0
            !
            if (job%IOmatelem_divide) islice = (PT%Nmodes+3)*3
            !
            hvib_t = 0
            job_is = 'gvib'
            !
            do k1 = 1,PT%Nmodes
              !
              if (job%IOmatelem_split.and.(islice<iterm1.or.iterm2<islice)) cycle
              !
              do k2 = 1,PT%Nmodes
                !
                if (job%IOmatelem_divide) then
                  islice = islice + 1
                  if (islice<iterm1.or.iterm2<islice) cycle
                endif
                !
                if (job%verbose>=4) write(out,"('k1,k2 = ',2i8)") k1,k2
                !
                gvib_N = FLread_fields_dimension_field(job_is,k1,k2)
                !
                gvib_t = 0
                !
                fl => me%gvib(k1,k2)
                !
                do iterm = 1,gvib_N
                  !
                  !fvib_t = 0
                  !
                  call calc_contract_matrix_elements_II(iterm,k1,k2,fl,fvib_t,gvib_contr_matelem_single_term)
                  !
                  !$omp parallel do private(icoeff,jcoeff) shared(gvib_t) schedule(dynamic)
                  do icoeff=1,mdimen
                    do jcoeff=1,icoeff
                      gvib_t(jcoeff,icoeff) = gvib_t(jcoeff,icoeff) + fvib_t(jcoeff,icoeff)
                      !
                    enddo
                  enddo
                  !$omp end parallel do
                  !
                enddo
                !
                if (job%IOmatelem_divide) then
                  !
                  !$omp parallel do private(icoeff,jcoeff) shared(gvib_t) schedule(dynamic)
                  do icoeff=1,mdimen
                    do jcoeff=1,icoeff-1
                      gvib_t(icoeff,jcoeff) = gvib_t(jcoeff,icoeff)
                    enddo
                  enddo
                  !$omp end parallel do
                  !
                  call write_divided_slice(islice,'g_vib',job%matelem_suffix,mdimen,gvib_t)
                  !
                else
                  !
                  !$omp parallel do private(icoeff,jcoeff) shared(hvib_t) schedule(dynamic)
                  do icoeff=1,mdimen
                    do jcoeff=1,icoeff
                      hvib_t(jcoeff,icoeff) = hvib_t(jcoeff,icoeff)-0.5_rk*gvib_t(jcoeff,icoeff)
                    enddo
                  enddo
                  !$omp end parallel do
                  !
                endif 
                !
              enddo
            enddo
            !
            !hvib_t = -0.5_rk*hvib_t
            !
            if (.not.(job%IOmatelem_divide).and.&
               (.not.job%IOmatelem_split.or.(islice>=iterm1.and.iterm2>=islice) ) ) then
              !
              job_is = 'poten'
              poten_N = FLread_fields_dimension_field(job_is,k1,k2)
              !
              if (job%verbose>=2) write(out,"(/'Potential function...')")
              if (job%verbose>=3) write(out,"(/'Number of pot terms  = ',i8)") poten_N
              !
              gvib_t = 0
              !
              fl => me%poten
              !
              do iterm = 1,poten_N
                  !
                  if (job%verbose>=4) write(out,"('iterm = ',i8)") iterm
                  !
                  call calc_contract_matrix_elements_II(iterm,1,1,fl,fvib_t,poten_contr_matelem_single_term)
                  !
                  !$omp parallel do private(icoeff,jcoeff) shared(gvib_t) schedule(dynamic)
                  do icoeff=1,mdimen
                    do jcoeff=1,icoeff
                      gvib_t(jcoeff,icoeff) = gvib_t(jcoeff,icoeff) + fvib_t(jcoeff,icoeff)
                    enddo
                  enddo
                  !$omp end parallel do
                  !
              enddo
              !
            endif
            !
            !
            if (job%IOmatelem_divide.and.job%iswap(2)==(PT%Nmodes+3)*3+PT%Nmodes**2+1) then
              !
              !$omp parallel do private(icoeff,jcoeff) shared(gvib_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  gvib_t(icoeff,jcoeff) = gvib_t(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              islice = (PT%Nmodes+3)*3+PT%Nmodes**2+1
              !
              call write_divided_slice(islice,'g_vib',job%matelem_suffix,mdimen,gvib_t)
              !
              if (job%IOmatelem_split.and.job%iswap(1)==1) job%iswap(1)=0
              !
            endif
            !
            ! Read, stitch and store the vibrational part only 
            !
            if (job%IOmatelem_divide.and.job%iswap(1)==0) then
               !
               hvib_t = 0
               !
               iterm1 = (PT%Nmodes+3)*3+1
               iterm2 = (PT%Nmodes+3)*3+PT%Nmodes**2+1
               if (job%iswap(2)>iterm2) iterm2 = (PT%Nmodes+3)*3+PT%Nmodes**2
               !
               f_t = -0.5_rk
               !
               do  islice = iterm1,iterm2
                 !
                 if (islice==(PT%Nmodes+3)*3+PT%Nmodes**2+1) f_t = 1.0_rk
                 !
                 call divided_slice_open(islice,chkptIO_,'g_vib',job%matelem_suffix)
                 !
                 read(chkptIO_) gvib_t
                 !
                 !$omp parallel do private(icoeff,jcoeff) shared(hvib_t) schedule(dynamic)
                 do icoeff=1,mdimen
                   do jcoeff=1,icoeff
                     hvib_t(jcoeff,icoeff) = hvib_t(jcoeff,icoeff)+f_t*gvib_t(jcoeff,icoeff)
                   enddo
                 enddo
                 !$omp end parallel do
                 !
                 call divided_slice_close(islice,chkptIO_,'g_vib')
                 !
               enddo
               !
               gvib_t = 0
               !
            endif
            !
            ! now we can switch off IOmatelem_split and compute the vibrational energies 
            !
            if (job%IOmatelem_divide.and.job%iswap(1)==0) job%IOmatelem_divide = .false.
            if (job%IOmatelem_split.and.job%iswap(1)==0) job%IOmatelem_split = .false.
            !
            ! combining and symmetrizing 
            !
            if ( .not.job%IOmatelem_divide.and..not.job%IOmatelem_split ) then
              !
              !$omp parallel do private(icoeff,jcoeff) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff
                  hvib%me(jcoeff,icoeff) = hvib_t(jcoeff,icoeff)+gvib_t(jcoeff,icoeff)
                  hvib%me(icoeff,jcoeff) = hvib%me(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
            endif
            !
            deallocate(hvib_t,gvib_t,fvib_t)
            call ArrayStop('hvib-fields')
            !
          endif 
          !
          call TimerReport
          !
          ! store the matrix elements 
          !
          if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and. & 
                  (.not.job%IOmatelem_divide.or.job%iswap(1)==0) .and. &
                  (.not.job%IOmatelem_split.or.job%iswap(1)==0)) then
             !
             write(chkptIO) 'hvib'
             write(chkptIO) hvib%me
             !
          endif
          !
        endif
        !
        !Finish the contracted checkpointing
        !
        if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and.&
           (.not.job%IOmatelem_divide.or.job%iswap(1)==0 ).and. &
           (.not.job%IOmatelem_split.or.job%iswap(1)==0 ) ) then
          !
          write(chkptIO) 'End Kinetic part'
          close(chkptIO,status='keep')
          !
        endif 
        !
        ! External field part 
        !
        if (treat_exfF) then 
          !
          fitting%iparam(2) = min(fitting%iparam(2),extF_rank)
          fitting%iparam(1) = max(fitting%iparam(1),1)
          !
          if (.not.job%IOextF_divide) then
            !
            fitting%iparam = (/1,extF_rank/)
            !
            if (job%verbose>=2) write(out,"(/'External function...')")
            !
            if (jrot/=0) then     
               write (out,"(/'PTcontracted_matelem_class: contr. matrix elements can be calculated only at J = 0')") 
               write (out,"('switch to  EXTERNAL NONE for j/=0')") 
               stop 'PTcontracted_matelem_class - illegal use of EXTERNAL for J/=0'
            endif 
            !
            ! Prepare the checkpoint file
            !
            job_is ='external field contracted matrix elements for J=0'
            call IOStart(trim(job_is),chkptIO)
            !
            open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=job%extFmat_file)
            write(chkptIO) 'Start external field'
            !
            ! store the matrix elements 
            !
            write(chkptIO) PT%Maxcontracts
            !
          endif 
          !
          if (trove%FBR) then 
            !
            allocate(extF_t(mdimen,mdimen),extF_r(mdimen,mdimen),stat=alloc)
            call ArrayStart('extF-fields',alloc,1,kind(f_t),rootsize)
            call ArrayStart('extF-fields',alloc,1,kind(f_t),rootsize)
            !
            job_is = 'externalF'
            !
            do imu = fitting%iparam(1),fitting%iparam(2)
              !
              if (job%verbose>=4) write(out,"('imu = ',i8)",advance='NO') imu
              !
              extF_t = 0 
              extF_r = 0 
              !
              extF_N_ = FLread_fields_dimension_field(job_is,imu,0)
              !
              fl => me%extF(imu)
              !
              do iterm = 1,extF_N_
                !
                call calc_contract_matrix_elements_II(iterm,imu,1,fl,extF_r,extF_contr_matelem_single_term)
                !
                !$omp parallel do private(icoeff,jcoeff) shared(extF_t) schedule(dynamic)
                do icoeff=1,mdimen
                  do jcoeff=1,icoeff
                    extF_t(jcoeff,icoeff) = extF_t(jcoeff,icoeff) + extF_r(jcoeff,icoeff)
                  enddo
                enddo
                !$omp end parallel do
                !
              enddo
              !
              !$omp parallel do private(icoeff,jcoeff) shared(extF_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  extF_t(icoeff,jcoeff) = extF_t(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              if (job%IOextF_divide) then 
                !
                call write_divided_slice(imu,'extF',job%extmat_suffix,mdimen,extF_t)
                !
              else
                !
                ! always store the matrix elements of the extF moment 
                !
                write(chkptIO) imu
                !
                write(chkptIO) extF_t
                !
              endif
              !
              if (job%verbose>=4) write(out,"('...done')",advance='YES') 
              !
            enddo
            !
            deallocate(extF_t,extF_r)
            call ArrayStop('extF-fields')
            !
          else
            !
            allocate(extF_dvr(extF_rank,mdimen,mdimen),stat=alloc)
            call ArrayStart('extF-fields',alloc,1,kind(f_t),rootsize)
            !
            if (job%verbose>=5) call MemoryReport
            !
            idvr = 1
            !
            call PTDVRcontracted_matelem_extF(idvr,extF_rank,extF_dvr)
            !
            if (job%verbose>=4) write(out,"(/'Storing External Field...')",advance='NO')
            !
            do imu = 1,extF_rank
              !
              if (job%verbose>=4) write(out,"(' ',i4)",advance='NO') imu
              !
              ! always store the matrix elements of the extF moment 
              !
              write(chkptIO) imu
              !
              write(chkptIO) extF_dvr(imu,:,:)
              !
            enddo
            !
            deallocate(extF_dvr)
            call ArrayStop('extF-fields')
            !
            if (job%verbose>=4) write(out,"('...done')",advance='YES')
            !
          endif 
          !
          if (.not.job%IOextF_divide) write(chkptIO) 'End external field'
          !
        endif
        !
        if (trove%FBR) then
          !
          deallocate(me_t,mat_t)
          call ArrayStop('PTcontracted_matelem_cl: me_t') 
          call ArrayStop('PTcontracted_matelem_cl: mat_t') 

          deallocate(matclass)
          call ArrayStop('PTcontracted_matelem_cl: matclass') 
          !
          do iclasses = 1,PT%Nclasses
             deallocate(tmat(iclasses)%coeffs,mat_tt(iclasses)%coeffs)
          enddo
          !
          call ArrayStop('PTcontracted_matelem_cl: group of temp arrays') 
          !
          deallocate(icoeff2iroot,icoefficoeff1)
          call ArrayStop('PTcontracted_matelem_cl: icoeff2iroot')
          !
        endif 
        ! 
      endif 
      !
      ! Rotational matrix elements 
      !
      iclasses = 0 
      dimen   = contr(0)%nlevels
      dimen_p = contr(0)%dimen
      !
      if (FLrotation) then
         !
         if (job%rotsym_do) then
           !
           call PTrot_contracted_matelem_class(jrot)
           !
         else
           !
           if (job%verbose>=2) write(out,"(/'Rotational part...')")
           !
           job_is = 'rot'
           !
           allocate(contr(0)%rot(7),stat=alloc)
           !
           isize = (jmax+1)*(jmax+2)/2
           !
           do k1 =1,size(contr(0)%rot(:))
             !
             allocate(contr(0)%rot(k1)%coeff3d(isize,-2:2,0:1),stat=alloc)
             call ArrayStart('gvib-grot-gcor-fields',alloc,size(contr(0)%rot(k1)%coeff3d),kind(f_t))
             !
           enddo 
           !
           do k1 = 1,7
             !
             call FLread_coeff_matelem(job_is,k1,1,contr(0)%rot(k1)%coeff3d(:,:,:))
             !
           enddo
           !
         endif
         !
      endif
      !
      ! We have completed transformation of the matrix elements from the standard primitive 
      ! representation to the contarcted representaion.
      ! We can free some memory by deallocating the primitive objects. 
      !
      call FLfree_primitive_objects 
      !
      ! ... and also some DVR objects (if applicable) 
      !
      call PTDVR_free_all_fields
      !
      deallocate(extF_N)
      !
      if (verbose>=4) call MemoryReport
      !
      if (verbose>=4) write(out,"('PTcontracted_matelem_class/stop: contracted matrix elements for the hamiltonian ')") 
      !
      call TimerStop('Contracted matelements-class')
      !
      !if (any(trim(job%IOextF_action)==(/'DIVIDE','JOIN'/)).and..not.trim(job%IOkinet_action)=='READ') then 
      !   write(out,"('PTcontracted_matelem_class: cannot proceede for extF = divide-join with matelem /= read')")
      !   stop 'cannot proceede for extF = divide-join with matelem /= read'
      !endif 
      !
      contains

      subroutine write_divided_slice(islice,name,suffix,N,field)
        !
        integer(ik),intent(in) :: islice
        character(len=*),intent(in) :: name,suffix
        integer(ik),intent(in)      :: N
        real(rk),intent(in)         :: field(N,N)
        character(len=4) :: jchar
        integer(ik)            :: chkptIO
        character(len=cl)      :: filename
        character(len=cl)      :: job_is
        !
        write(job_is,"('single swap_matrix')")
        !
        call IOStart(trim(job_is),chkptIO)
        !
        write(jchar, '(i4)') islice
        !
        filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
        !
        open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
        !
        write(chkptIO) trim(name)
        !
        write(chkptIO) field
        !
        write(chkptIO) trim(name)
        !
        close(chkptIO)
        !
      end subroutine write_divided_slice


    subroutine divided_slice_open(islice,chkptIO,name,suffix)
      !
      implicit none
      integer(ik),intent(in)      :: islice
      integer(ik),intent(inout)   :: chkptIO
      character(len=*),intent(in) :: name,suffix
      character(len=4)            :: jchar
      character(len=cl)           :: buf,filename,job_is
      integer(ik)                 :: ilen
      logical                     :: ifopened
      !
      if (.not.job%IOmatelem_split) return
      !
      write(job_is,"('single swap_matrix')")
      !
      call IOStart(trim(job_is),chkptIO)
      !
      write(jchar, '(i4)') islice
      !
      filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
      !
      open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=filename,err=10)
      !
      ilen = LEN_TRIM(name)
      !
      read(chkptIO) buf(1:ilen)
      if ( trim(buf(1:ilen))/=trim(name) ) then
        write (out,"(' kinetic checkpoint slice ',a20,': header is missing or wrong',a)") filename,buf(1:ilen)
        stop 'PTrestore_rot_kinetic_matrix_elements - in slice -  header missing or wrong'
      end if
      !
      return
      !
      10 write(out,"('divided_slice_open-error: The split-file ',a,' does not exist')") trim(filename)
      stop 'divided_slice_open-error: The split-file does not exist'
      !
    end subroutine divided_slice_open
    !
    subroutine divided_slice_close(islice,chkptIO,name)
      !
      integer(ik),intent(in) :: islice
      integer(ik),intent(inout) :: chkptIO
      character(len=*),intent(in) :: name
      character(len=4) :: jchar
      character(len=cl) :: buf,filename
      integer(ik)      :: ilen
      logical          :: ifopened
      !
      if (.not.job%IOmatelem_split) return
      !
      ilen = LEN_TRIM(name)
      !
      read(chkptIO) buf(1:ilen)
      if ( trim(buf(1:ilen))/=trim(name) ) then
        write (out,"(' divided_slice_close, kinetic checkpoint slice ',a,': footer is missing or wrong',a)") filename,buf(1:ilen)
        stop 'divided_slice_close - in slice -  footer missing or wrong'
      end if
      !
      close(chkptIO)
      !
    end subroutine divided_slice_close


      !
      ! This procedure is thought to make the calculations of the contracted mat. elements 
      ! of an arbitrary field (e.g. poten, g_vib, g_rot, g_cor, and extF), 
      ! a general way.
      !
      subroutine calc_contract_matrix_elements_II(iterm,k1,k2,fl,field,func)

        integer(ik),intent(in) :: iterm,k1,k2
        type(PTcoeffT),pointer        :: fl
        !real(rk),intent(in)    :: Hobject(0:,0:)
        !integer(ik),intent(in) :: IndexQ(:)
        real(rk),intent(inout) :: field(:,:)
        real(rk),external      :: func
        !
        !real(rk)               :: matclass(1:,1:,1:)
        !integer(ik),intent(in) :: icoeff2iroot(PT%Nclasses,PT%Maxcontracts)
        !
        integer(ik) :: k(PT%Nmodes)  
        integer(ik) :: iclasses,nroots,dimen_p,im1,im2,iprim,jprim,nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
        integer(ik) :: icoeff,icase,ilambda,jcoeff,jcase,jlambda,ideg,jdeg,ilevel,jlevel
        integer(ik) :: iroot,jroot,Maxcontracts,Nclasses
        integer(hik):: ib,ib0
        real(rk)    :: f_t,f_prod(PT%Nclasses)
        !
        Nclasses = PT%Nclasses
        Maxcontracts = PT%Maxcontracts
        !
        k(:) = fl%IndexQ(:,iterm)
        !
        do iclasses = 1,PT%Nclasses
          !
          nroots  = contr(iclasses)%nroots
          dimen_p = contr(iclasses)%dimen
          im1 = PT%mode_class(iclasses,1)
          im2 = PT%mode_class(iclasses,PT%mode_iclass(iclasses))
          !
          im2 = min(PT%Nmodes-1,im2)
          !
          if (job%verbose>=4) call TimerStart('contract_matrix')
          !
          me_t = 0 
          !
          if (iclasses/=PT%Nclasses) then 
            !
            !$omp parallel do private(iprim,jprim,nu_i,nu_j) shared(me_t)
            do jprim=1,contr(iclasses)%dimen
              !
              nu_j(im1:im2) = contr(iclasses)%prim_bs%icoeffs(im1:im2,jprim)
              !
              do iprim=1,contr(iclasses)%dimen
                !
                nu_i(im1:im2) = contr(iclasses)%prim_bs%icoeffs(im1:im2,iprim)
                !
                ! Primitive matrix elements of all Hamiltonian components ....
                !
                me_t(iprim,jprim) = func(iterm,im1,im2,nu_i,nu_j,k,k1,k2)
                !
              enddo
            enddo
            !$omp end parallel do
            !
          else
            !
            !$omp parallel do private(iprim,jprim,nu_i,nu_j) shared(me_t)
            do jprim=1,contr(iclasses)%dimen
              !
              nu_j(im1:im2+1) = contr(iclasses)%prim_bs%icoeffs(im1:im2+1,jprim)
              !
              do iprim=1,contr(iclasses)%dimen
                !
                nu_i(im1:im2+1) = contr(iclasses)%prim_bs%icoeffs(im1:im2+1,iprim)
                !
                ! Primitive matrix elements of all Hamiltonian components ....
                !
                me_t(iprim,jprim) = func(iterm,im1,im2,nu_i,nu_j,k,k1,k2)
                !
                me_t(iprim,jprim) = me_t(iprim,jprim)*fl%coeff(iterm,nu_i(PT%Nmodes),nu_j(PT%Nmodes))
                !
                !me_t(iprim,jprim) = Hobject(nu_i(PT%Nmodes),nu_j(PT%Nmodes))
                !
              enddo
            enddo
            !$omp end parallel do
            !
          endif 
          !
          if (job%verbose>=4) call TimerStop('contract_matrix')
          !
          if (job%verbose>=4) call TimerStart('contract_matrix_dgemm')
          !
          !mat_t(1:nroots,1:dimen_p) = matmul(transpose(tmat(iclasses)%coeffs(1:dimen_p,1:nroots)),me_t(1:dimen_p,1:dimen_p))
          !mat_tt(iclasses)%coeffs(1:nroots,1:nroots) = matmul(mat_t(1:nroots,1:dimen_p),tmat(iclasses)%coeffs(1:dimen_p,1:nroots))
          !
          call dgemm('T','N',nroots,dimen_p,dimen_p,alpha,tmat(iclasses)%coeffs,dimen_p,& 
                      me_t,dimen_p_max,beta,mat_t,nroots_max)
          call dgemm('N','N',nroots,nroots,dimen_p,alpha,mat_t,nroots_max,& 
                      tmat(iclasses)%coeffs,dimen_p,beta,mat_tt(iclasses)%coeffs,nroots)
          !
          matclass(iclasses,1:nroots,1:nroots) = mat_tt(iclasses)%coeffs
          !
          !call dgemm('T','N',nroots,dimen_p,dimen_p,alpha,tmat(iclasses)%coeffs(1:dimen_p,1:nroots),dimen_p,& 
          !            me_t(1:dimen_p,1:dimen_p),dimen_p,beta,mat_t(1:nroots,1:dimen_p),nroots)
          !call dgemm('N','N',nroots,nroots,dimen_p,alpha,mat_t(1:nroots,1:dimen_p),nroots,& 
          !            tmat(iclasses)%coeffs(1:dimen_p,1:nroots),dimen_p,beta,mat_tt(iclasses)%coeffs(1:nroots,1:nroots),nroots)
          !
          if (job%verbose>=4) call TimerStop('contract_matrix_dgemm')
          !
        enddo 
        !
        if (job%verbose>=4) call TimerStart('contract_matrix_sum_field')
        !
        !$omp parallel do private(icoeff,jcoeff,f_t,iclasses,iroot,jroot) shared(field) schedule(dynamic)
        do icoeff=1,Maxcontracts
          !
          !icase   = PT%icontr2icase(icoeff,1)
          !ilambda = PT%icontr2icase(icoeff,2)
          !
          !ib0 = int(icoeff*(icoeff-1),hik)/2
          !
          !ib0 = icoefficoeff1(icoeff)
          !
          do jcoeff=1,icoeff
            !
            iroot = icoeff2iroot(1,icoeff)
            jroot = icoeff2iroot(1,jcoeff)
            !
            f_t = matclass(1,iroot,jroot)
            !
            !f_t = 1.0_rk
            !
            do iclasses = 2,Nclasses
              !
              iroot = icoeff2iroot(iclasses,icoeff)
              jroot = icoeff2iroot(iclasses,jcoeff)
              !
              !f_prod(iclasses) = mat_tt(iclasses)%coeffs(iroot,jroot)
              !
              f_t = f_t*matclass(iclasses,iroot,jroot)
              !
            enddo
            !
            !f_t = product(matclass(1:Nclasses,icoeff2iroot(1:Nclasses,icoeff),icoeff2iroot(1:Nclasses,jcoeff)))
            !
            !field(jcoeff,icoeff) = field(jcoeff,icoeff)+f_t
            !
            field(jcoeff,icoeff) = f_t
            !
          enddo
        enddo
        !$omp end parallel do 
        !
        if (job%verbose>=4) call TimerStop('contract_matrix_sum_field')
        !
      end subroutine calc_contract_matrix_elements_II
      !
  end subroutine PTcontracted_matelem_class 

  !
  !
  ! Contracted matrix elements
  !
  subroutine PTcontracted_matelem_class_fast_II(jrot) 
    !
    integer(ik),intent(in)   :: jrot
    integer(ik)        :: PotOrder,KinOrder,extForder
    integer(ik)        :: poten_N,gvib_N,grot_N,gcor_N,Ncoeffs,jmax,L2vib_N
    integer(ik)        :: iclasses,ilevel,ideg,jdeg,alloc,dimen,iterm,k1,k2,Ndeg,nprim
    real(rk),allocatable :: grot_t(:,:),extF_t(:,:),hvib_t(:,:)
    !
    real(rk)           :: f_t
    integer(ik)        :: isize,iroot
    integer(ik)        :: dimen_p,chkptIO,extF_rank,chkptIO_,dumpIO_
    integer(hik)       :: rootsize,matsize
    !
    logical            :: treat_rotation =.false.  ! switch off/on the rotation 
    logical            :: treat_vibration =.true.  ! switch off/on the vibration
    logical            :: treat_exfF=.false.       ! switch off/on the external field 
    !
    double precision,parameter :: alpha = 1.0d0,beta=0.0d0
    character(len=cl)  :: job_is,buf,jchar1,jchar2,filename
    !
    integer(ik)        :: imu,Ncomb,junit,Nslices,Nswap,mdimen,mdimen_,icontr,jcontr
    integer(ik)        :: icoeff,icase,ilambda,jcoeff,idvr,iterm1,iterm2,islice,isymcoeff
    integer(ik)        :: N1,N2,k1_,k2_
    integer(ik),allocatable  :: extF_N(:)
    character(len=4) :: jchar
    character(len=18):: buf18
    character(len=4) :: buf4
    integer(ik) :: nclasses,nmodes
    !
    integer(ik), allocatable :: dimen_classes(:), nu_classes(:,:), iclass_nmodes(:), iclass_imode(:,:), iclass_ilambda(:,:,:), &
                                icomb_nclasses(:), icomb_iclass(:,:), icomb_nclasses0(:), icomb_iclass0(:,:), &
                                gvib_icomb_nterms(:,:,:), gvib_icomb_iterm(:,:,:,:,:), &
                                grot_icomb_nterms(:,:,:), grot_icomb_iterm(:,:,:,:,:), &
                                gcor_icomb_nterms(:,:,:), gcor_icomb_iterm(:,:,:,:,:), &
                                vpot_icomb_nterms(:,:,:), vpot_icomb_iterm(:,:,:,:,:), &
                                pseudo_icomb_nterms(:,:,:), pseudo_icomb_iterm(:,:,:,:,:), &
                                extF_icomb_nterms(:,:,:), extF_icomb_iterm(:,:,:,:,:)

    real(rk), allocatable :: enermax_classes(:)

    real(rk), allocatable :: gvib_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: grot_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: gcor_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: vpot_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: pseudo_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: extF_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: gme_Nclass(:,:,:)
    !real(rk), allocatable :: gme(:,:,:,:)
    !
    type(me_class) :: gme(PT%Nclasses) 

    !
    real(rk), allocatable :: prim_vect(:,:)
    integer(ik) :: Nsym,isym,Nsymi,Nsymj,jsymcoeff,Ntot
    integer(ik), allocatable :: isymcoeff_vs_isym(:,:)
    double precision,parameter :: a0 = -0.5d0
      !
      call TimerStart('Contracted matelements-class-fast')
      !
      !if (PT%Nclasses/=1) then 
      !  !
      !  write(out,"('PTcontracted_matelem_class_fast_II/end: This procedure has not been tested for Nclasses = ',i8,' yet')") PT%Nclasses
      !  stop 'PTcontracted_matelem_class_fast: illegal number of classes' 
      !  !
      !endif
      !
      if (verbose>=4) write(out,"('PTcontracted_matelem_class_fast_II/start: contracted matrix elements for the hamiltonian ')") 
      !
      Nclasses = PT%Nclasses
      nmodes = PT%nmodes
      extF_rank = FLread_extF_rank()
      !
      allocate(extF_N(max(extF_rank,1)))
      !
      call FLread_fields_dimensions(poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,extF_N,L2vib_N)
      !
      ! Some parts of the Hamiltonian are not needed if J=0 (neither grot nor gcor).
      ! We adopt treat_rotation to switch it on/off
      !
      if ((FLrotation.and.jrot/=0).or.trim(job%IOkinet_action)=='SAVE') treat_rotation = .true.
      !
      if (jrot/=0.and.trim(job%IOkinet_action)/='READ') then     
         write (out,"(/'PTcontracted_matelem_class_fast_II: the contracted matrix elements can be calculated only at J = 0')") 
         write (out,"('First run the J=0 case with IOkinet_action=SAVE')") 
         write (out,"('and switch to J/=0 with IOkinet_action=READ')") 
         stop 'PTcontracted_matelem_class_fast_II - illegal IOkinet_action for J/=0'
      endif 
      !
      !Ncoeffs = max(poten_N,gvib_N,grot_N,gcor_N)
      !
      ! Here we decide whether we need to compute the    matrix elements from 
      ! the pure vibrational part of the Hamiltonian. If our contracted basis set 
      ! has been built under all vib. modes combined into one class, 
      ! we can directly use the corresponding eigenvalues. 
      !
      if (job%vib_contract) then 
        !
        PTvibrational_me_calc = .false.
        !
        if (job%verbose>=3) then 
          write(out,"(/'The vibrational (J=0) part of the Hamiltonian is diagonal.')") 
          write(out,"('The corresponding matrix elements are not computed.'/'The vibrational eigenvalues are used instead.')") 
        endif 
        !
        treat_vibration = .false.
        !
        job%IOmatelem_split = .true.
        !
      endif 
      !
      ! Turn on the external field
      !
      if (trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT') treat_exfF = .true.
      !
      ! We assume that all matrix elements are simmetric, therefore we can use 
      ! a 1D array for storing only the upper half of the matrix.
      ! And this is the size of such 1D array.
      !
      mdimen = PT%Maxcontracts
      dimen_p = PT%max_deg_size
      !
      if (job%vib_rot_contr) then 
        rootsize = int(dimen_p*mdimen,hik)
      else 
        rootsize = int(mdimen*mdimen,hik)
      endif
      !
      ! The vibrational (J=0) matrix elements of the rotational and coriolis 
      ! kinetic parts are retrieved now from the storage place (check_point). 
      ! For pure vibrational calculations we provide an option to store and restore 
      ! the matrix elements of the J=0 part of Hamiltonian
      !
      if (trim(job%IOkinet_action)=='READ'.or.trim(job%IOkinet_action)=='VIB_READ') then
        !
        treat_vibration = .false.
        treat_rotation = .false.
        !
      endif 
      !
      ! we can allow skipping the kinetic part completely if only the external function
      ! is required 
      !
      if (trim(job%IOkinet_action)=='NONE'.and.treat_exfF) then
        !
        treat_vibration = .false.
        treat_rotation = .false.
        !
      endif 
      !
      if (treat_vibration.or.treat_exfF.or.treat_rotation) then 
        !
        if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and.&
           (.not.job%IOmatelem_split.or.job%iswap(1)==0 )) then
          !
          if (FLrotation.and.jrot/=0) then 
            write (out,"(' IOkinet_action = SAVE is not working for J/=0 ')") 
            stop 'PTcontracted_matelem_class_fast_II - illegal IOkinet_action for J/=0'
          endif 
          !
          ! Prepare the checkpoint file
          !
          job_is ='Vib. matrix elements of the rot. kinetic part'
          call IOStart(trim(job_is),chkptIO)

          open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=job%kinetmat_file)
          write(chkptIO) 'Start Kinetic part'
          !
          ! store the bookkeeping information about the contr. basis set
          !
          call PTstore_icontr_cnu(PT%Maxcontracts,chkptIO,job%IOkinet_action)
          !
          if (job%vib_rot_contr) then
            write(chkptIO) 'vib-rot'
          endif
          !
        endif 
        !
        call initialize_class_contr_objects
        !
        ! Temporar arrays allocation (for non-DVR, FBR integration)
        !
        matsize = PT%Nclasses*PT%Maxcontracts
        !
        ! primitive matrix elements are collected in prim_vect and will be used for all fields 
        !
        dimen = contr(PT%Nclasses)%nroots
        nprim = contr(PT%Nclasses)%dimen
        !
        allocate(prim_vect(nprim,dimen),stat=alloc)
        call ArrayStart('prim_vect',alloc,size(prim_vect),kind(prim_vect))
        !
        !$omp parallel do private(iroot,ilevel,ideg) shared(prim_vect) schedule(static)
        do iroot=1, dimen
          ilevel = contr(PT%Nclasses)%ilevel(iroot)
          ideg = contr(PT%Nclasses)%ideg(iroot)
          prim_vect(1:nprim,iroot) = contr(PT%Nclasses)%eigen(ilevel)%vect(1:nprim,ideg)
        enddo
        !$omp end parallel do
        !
        ! check if there are no contributions to the diagonal symmetry blocks 
        !
        if (.not.debug_check_symmetries) then
          !
          allocate(isymcoeff_vs_isym(sym%Nrepresen,PT%Maxsymcoeffs),stat=alloc)
          call ArrayStart('isymcoeff_vs_isym',alloc,1,kind(isymcoeff_vs_isym),size(isymcoeff_vs_isym,kind=hik))
          isymcoeff_vs_isym = 0
          !
          !$omp parallel do private(isymcoeff,isym,Nsymi) shared(isymcoeff_vs_isym) schedule(dynamic)
          do isymcoeff=1,PT%Maxsymcoeffs
             do isym = 1,sym%Nrepresen
               !
               Nsymi = PT%irr(isym)%N(isymcoeff) 
               !
               isymcoeff_vs_isym(isym,isymcoeff) = min(Nsymi,1)
             enddo
          enddo
          !$omp end parallel do 
          !
          !if (job%verbose>=4) write(out,"(' Due to symmetry selection rules, ',i12,' mat-elements (',i16,') are not zero')") Ntot,PT%Maxsymcoeffs*PT%Maxsymcoeffs
        endif
        !
        if (job%verbose>=4) call MemoryReport
        !
        ! Initialize the Hamiltonian fields and basis functions in the DVR representation
        !
        if (trove%DVR) then
          !
          stop 'DVR is not implemented for PTcontracted_matelem_class_fast_II'
          !
        endif
        !
        if (.not.(trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and. & 
                  (job%IOmatelem_split.or.job%iswap(1)==0.and.job%iswap(1)/=(PT%Nmodes+3)*3 ) ) then

          !
          ! The vibrational part of the Hamiltonian
          !
          if (job%verbose>=4) write(out,"('  allocating hvib, ',i9,' elements...')") rootsize
          !
          allocate(hvib%me(mdimen,mdimen),stat=alloc)
          call ArrayStart('gvib-grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          hvib%me = 0
          !
          if (job%verbose>=5) call MemoryReport
          !
        endif
        !
        !---------------------------!
        ! Only when rotation is ON  !
        !---------------------------!
        !
        if (treat_rotation.and.trove%FBR) then
          !
          if (job%verbose>=2) write(out,"(/'Rotational part of the Kinetic energy operator...')")
          !
          if (job%verbose>=4) write(out,"('  allocating grot, ',i9,' elements...')") rootsize
          !
          if (job%IOmatelem_split) then
            !
            iterm1 = max(job%iswap(1),0)
            iterm2 = min(job%iswap(2),(PT%Nmodes+3)*3+1)
            !
            if (job%verbose>=4) write(out,"('  The matelem.chk will be divided into 1 + 3 x 3 + 3  = 1+12 chk-slices')")
            if (job%verbose>=4) write(out,"('  islice = 0 (gvib and poten), 1-9 (Grot), 10-12 (Gcor) ')")
            if (job%verbose>=4) write(out,"('  This run is for the checkpoint slices from ',i4,' to ',i4/)") iterm1,iterm2
            if (job%verbose>=4) write(out,"(/'  For a single chk-slice #i use MATELEM SAVE SPLIT i i ')")
            if (job%verbose>=4) write(out,"(a,' SAVE SPLIT 0 0')") &
                                              '  Vibrational chk-s correspond to slice 0; for vibrational only use MATELEM '
            if (job%verbose>=4) write(out,"('  For all slices run and stitched in one go use MATELEM SAVE SPLIT ')")
            !
          endif
          !
          if (job%vib_rot_contr) then 
            allocate(grot_t(mdimen,dimen_p),stat=alloc)
          else 
            allocate(grot_t(mdimen,mdimen),stat=alloc)
          endif
          !
          call ArrayStart('grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          !
          if (job%verbose>=5) call MemoryReport
          !
          if (trim(job%IOkinet_action)=='SAVE'.and..not.job%IOmatelem_split) then
            !
            write(chkptIO) 'g_rot'
            !
          endif
          !
          ! The vibrational (J=0) matrix elements of the rotational and coriolis 
          ! kinetic parts are being computed here. 
          !
          ! Run the loop over all term of the expansion of the Hamiltonian 
          !
          islice = 0
          !
          if (job%verbose>=2) call TimerStart('calc_grot_contr_matrix')
          !
          do k1 = 1,3
            do k2 = 1,3
              !
              islice = islice + 1
              !
              !if (job%IOmatelem_split.and.(islice<iterm1.or.iterm2<islice)) cycle
              !
              if ( job%IOmatelem_split ) then 
                if (islice<iterm1.or.iterm2<islice) cycle
                !
                call open_divided_slice(islice,'g_rot',job%matelem_suffix,chkptIO_)
                !
              endif
              !
              if (job%verbose>=4) write(out,"('k1,k2 = ',2i8)") k1,k2
              !
              grot_t = 0
              !
              call calc_grot_me_I(k1,k2,gme)
              !
              do isymcoeff =1,PT%Maxsymcoeffs
                !
                if (job%verbose>=5.and.mod(isymcoeff,10000)==0) write(out,"(4x,i9)") isymcoeff
                !
                Ndeg = PT%Index_deg(isymcoeff)%size1
                !
                if (job%vib_rot_contr) grot_t = 0
                !
                call calc_rot_contr_matrix_I(isymcoeff,me%grot(k1,k2),grot_t)
                !
                !call calc_field_contr_matrix(isymcoeff,me%grot(k1,k2),grot_t)
                !
                if (job%vib_rot_contr) then 
                  !
                  !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(grot_t) schedule(dynamic)
                  do ideg=1,Ndeg
                     icontr = PT%icase2icontr(isymcoeff,ideg)
                     do jdeg=1,ideg-1
                        jcontr = PT%icase2icontr(isymcoeff,jdeg)
                        grot_t(icontr,jdeg) = grot_t(jcontr,ideg)
                    enddo
                  enddo
                  !$omp end parallel do
                  !
                  if (trim(job%IOkinet_action)=='SAVE'.and.job%IOmatelem_split) then
                    write(chkptIO_) grot_t(1:mdimen,1:Ndeg)
                  endif
                  !
                endif
                ! 
              enddo
              !
              if (.not.job%vib_rot_contr) then 
                !
                !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
                do icoeff=1,mdimen
                  do jcoeff=1,icoeff-1
                    grot_t(icoeff,jcoeff) = grot_t(jcoeff,icoeff)
                  enddo
                enddo
                !$omp end parallel do
                !
                if (trim(job%IOkinet_action)=='SAVE') then
                  !
                  if (job%IOmatelem_split) then
                     write(chkptIO_) grot_t
                  else
                     write(chkptIO) grot_t
                  endif
                  !
                endif
                !
              endif
              !
              if (job%IOmatelem_split) then 
                write(chkptIO_) 'g_rot'
                close(chkptIO_)
              endif
              !
            enddo
            !
          enddo
          !
          if (job%verbose>=2) call TimerStop('calc_grot_contr_matrix')
          !
          if (job%verbose>=2) write(out,"('...done!')")
          !
          if (job%verbose>=2) write(out,"(/'Coriolis part of the Kinetic energy operator...')")
          !
          if (trim(job%IOkinet_action)=='SAVE'.and..not.job%IOmatelem_split) then
            !
            write(chkptIO) 'g_cor'
            !
          endif
          !
          ! Run the loop over all term of the expansion of the Hamiltonian 
          !
          if (job%verbose>=2) call TimerStart('calc_gcor_contr_matrix')
          !
          N1 = 1; N2 = 1
          !
          if (job%matelem_append.and.iterm1>0) then
            !
            if (job%vib_rot_contr) then
              !
              write(out,"('Appending or dumping is not working with the vib-rot contraction scheme, remove them from input')")
              stop 'Appending or dumping is not working with the vib-rot'
              !
            endif
            !
            call open_dump_slice(islice,'g_cor',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
            !
            ! finished gcor record
            !
            read(dumpIO_) k1_,k2_
            !
            ! we will start from these indeces 
            !
            N1 = k1_+1
            N2 = k2_
            !
            if (N1>PT%Nmodes) then
              N2 = k2_+1
              N1 = 1
            endif
            !
            read(dumpIO_) grot_t
            !
            read(dumpIO_) buf4(1:4)
            !
            if (buf4(1:4)/='gcor') then
              !
              write (out,"('Wrong record in vib dump-chk file, hcor is missing ',a,' k1,k2 = ',2i4)") buf4(1:4),k1,k2
              stop 'Wrong record in the dump-file'
              !
            end if
            !
            close(dumpIO_)
            !
          endif 
          !
          islice = 9+N2-1
          !
          do k2 = N2,3
            !
            islice = islice + 1
            !
            if ( job%IOmatelem_split ) then 
              if (islice<iterm1.or.iterm2<islice) cycle
              !
              call open_divided_slice(islice,'g_cor',job%matelem_suffix,chkptIO_)
              !
            endif
            !
            if (N1==1) grot_t = 0
            !
            do k1 = N1,PT%Nmodes
              !
              if (job%verbose>=4) write(out,"('k1,k2 = ',2i8)") k1,k2
              !
              ! dumping or/and starting from the previously dumped record of the matelem-checkpoints
              !
              !if (job%IOmatelem_dump) then
              !  !
              !  if (job%vib_rot_contr.and..not.job%matelem_append) then
              !    !
              !    write(out,"('Appending or dumping is not working with the vib-rot contraction scheme, remove them from input')")
              !    stop 'Appending or dumping is not working with the vib-rot'
              !    !
              !  endif
              !  !
              !  !call open_dump_slice(islice,'g_cor',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
              !  !
              !endif
              !
              call calc_gcor_me_I(k1,k2,gme) 
              !
              do isymcoeff =1,PT%Maxsymcoeffs
                !
                Ndeg = PT%Index_deg(isymcoeff)%size1
                !
                if (job%vib_rot_contr) grot_t = 0
                !
                !call calc_gcor_contr_matrix(k1,k2,isymcoeff,grot_t)
                !
                call calc_rot_contr_matrix_II(isymcoeff,me%gcor(k1,k2),grot_t)
                !
                !call calc_rot_contr_matrix_II(isymcoeff,me%gcor(k1,k2),grot_t)
                !
                if (job%vib_rot_contr) then 
                    !
                    !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(grot_t) schedule(dynamic)
                    do ideg=1,Ndeg
                       icontr = PT%icase2icontr(isymcoeff,ideg)
                       do jdeg=1,ideg-1
                          jcontr = PT%icase2icontr(isymcoeff,jdeg)
                          grot_t(icontr,jdeg) =-grot_t(jcontr,ideg)
                       enddo
                    enddo
                    !$omp end parallel do
                    !
                    if (trim(job%IOkinet_action)=='SAVE'.and.job%IOmatelem_split) then
                        write(chkptIO_) grot_t(1:mdimen,1:Ndeg)
                    endif
                    !
                endif
                !
              enddo
              !
              if (job%IOmatelem_dump ) then
                  !
                  if (job%verbose>=6.and.mod(isymcoeff,max(int(PT%Maxsymcoeffs/500),10))==0) write(out,"(i12)") isymcoeff 
                  !
                  call open_dump_slice(islice,'g_cor',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
                  write(dumpIO_) k1,k2
                  write(dumpIO_) grot_t
                  write(dumpIO_) 'gcor'
                  close(dumpIO_)
                  !
              endif
              !
            enddo
            !
            N1 = 1
            !
            if (job%IOmatelem_dump) close(dumpIO_)
            !
            if (.not.job%vib_rot_contr) then 
              !
              !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  grot_t(icoeff,jcoeff) = -grot_t(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              if (trim(job%IOkinet_action)=='SAVE') then
                !
                if (job%IOmatelem_split) then
                   write(chkptIO_) grot_t
                else
                   write(chkptIO) grot_t
                endif
                !
              endif
              !
            endif
            !
            if (job%IOmatelem_split) then 
              write(chkptIO_) 'g_cor'
              close(chkptIO_)
            endif
            !
          enddo
          !
          if (job%verbose>=2) call TimerStop('calc_gcor_contr_matrix')
          !
          deallocate(grot_t)
          call ArrayStop('grot-gcor-fields')
          !
          if (job%verbose>=2) write(out,"('...done!')")
          !
        endif
        !
        ! Vibrational part 
        !
        !islice = (PT%Nmodes+3)*3+1
        !
        if ( treat_vibration.and.(.not.job%IOmatelem_split.or.iterm1==0) ) then 
          !
          ! ----------------- FBR ------------------
          !
          if (job%verbose>=2) write(out,"(/'Vibrational kinetic part...')")
          if (job%verbose>=3) write(out,"(/'Dimensions of the contracted matrix  = ',2i0)") mdimen,dimen_p
          !
          if (job%vib_rot_contr) then 
            allocate(hvib_t(mdimen,dimen_p),stat=alloc)
          else 
            allocate(hvib_t(mdimen,mdimen),stat=alloc)
          endif
          !
          call ArrayStart('hvib-fields',alloc,1,kind(f_t),rootsize)
          !
          if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and. & 
                  (.not.job%IOmatelem_split.or.job%iswap(1)==0.or.job%iswap(1)==(PT%Nmodes+3)*3 ) ) then
             !
             write(chkptIO) 'hvib'
             !
          endif
          !
          if ( job%vib_rot_contr ) then
            !
            ! write hvib to the first "slice"
            islice = 0 
            call open_divided_slice(islice,'hvib',job%matelem_suffix,chkptIO_)
            !
          endif
          !
          if (job%matelem_append.or.job%IOmatelem_dump) then
            !
            if (job%vib_rot_contr) then
              !
              write(out,"('Appending or dumping is not working with the vib-rot contraction scheme, remove them from input')")
              stop 'Appending or dumping is not working with the vib-rot'
              !
            endif
            !
          endif
          !
          islice = 0
          !
          hvib_t = 0
          !
          if (job%verbose>=2) call TimerStart('calc_gvib_contr_matrix')
          !
          N1 = 1
          N2 = 1
          !
          ! starting from the previously dumped record of the matelem-checkpoints
          !
          if (job%matelem_append) then
            !
            call open_dump_slice(islice,'h_vib',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
            !
            ! finished gvib record
            !
            read(dumpIO_) k1_,k2_
            !
            if (job%verbose>=4) write(out,"(' Appending to gvib ',2i0)") k1_,k2_
            !
            ! we will start from these indeces 
            N1 = k1_
            N2 = k2_+1
            !
            if (N2>PT%Nmodes) then
              N1 = k1_+1
              N2 = 1
            endif
            !
            read(dumpIO_) hvib_t
            !
            read(dumpIO_) buf4(1:4)
            !
            if (buf4(1:4)/='hvib') then
              !
              write (out,"('Wrong record in vib dump-chk file, hvib is missing ',a,' k1,k2 = ',2i4)") buf4(1:4),k1,k2
              stop 'Wrong record in the dump-file'
              !
            end if
            !
            close(dumpIO_)
            !
          endif 
          !
          if (job%verbose>=4) write(out,"(' hvib...',i12)") PT%Maxsymcoeffs
          !if (job%verbose>=4) write(out,"('  |',i8)",advance='NO')
          !
          do k1 = N1,PT%Nmodes
            do k2 = N2,PT%Nmodes
              !
              if (job%verbose>=4) write(out,"(' k1,k2 = ',2i4)") k1,k2
              !
              ! computed contracted matrix elements for class Nclasses 
              !
              call calc_gvib_me_I(k1,k2,gme)
              !
              do isymcoeff =1,PT%Maxsymcoeffs
                !
                if (job%verbose>=6.and.mod(isymcoeff,max(int(PT%Maxsymcoeffs/100),10))==0) write(out,"(i12)") isymcoeff
                !
                Ndeg = PT%Index_deg(isymcoeff)%size1
                !
                if (job%vib_rot_contr) hvib_t = 0
                !
                call calc_vib_contr_matrix_I(isymcoeff,me%gvib(k1,k2),hvib_t)
                !
                !call calc_field_contr_matrix(isymcoeff,me%gvib(k1,k2),hvib_t)
                !
              enddo
              !
              ! store temp the matrix elements (dump)
              !
              if (job%IOmatelem_dump) then 
                 !
                 call open_dump_slice(islice,'h_vib',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
                 write(dumpIO_) k1,k2
                 write(dumpIO_) hvib_t
                 write(dumpIO_) 'hvib'
                 close(dumpIO_)
                 !
              endif
              !
            enddo
            !
            N2 = 1
            !
          enddo
          !
          hvib_t = -0.5_rk*hvib_t
          !
          !call daxpy(mdimen,alpha,hvib_t,1,hvib_t,1)
          !
          if (job%verbose>=4) write(out,"(/' Potential energy ',2i4)")
          !
          ! computed contracted matrix elements for class Nclasses 
          !
          call calc_Vpot_me_I(gme)
          !
          do isymcoeff =1,PT%Maxsymcoeffs
            !
            if (job%verbose>=5.and.mod(isymcoeff,max(int(PT%Maxsymcoeffs/100),10))==0) write(out,"(i12)") isymcoeff
            !
            Ndeg = PT%Index_deg(isymcoeff)%size1
            !
            if (job%vib_rot_contr) hvib_t = 0
            !
            !call calc_vpot_contr_matrix(isymcoeff,hvib_t)
            !
            call calc_vib_contr_matrix_I(isymcoeff,me%poten,hvib_t)
            !
            !call calc_vib_contr_matrix_II(isymcoeff,me%poten,hvib_t)
            !
            ! store temp the matrix elements (dump)
            !
            !if (job%IOmatelem_dump) then 
            !   !
            !   call open_dump_slice(islice,'h_vib',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
            !   write(dumpIO_) 0,0
            !   write(dumpIO_) hvib_t
            !   write(dumpIO_) 'hvib'
            !   close(dumpIO_)
            !   !
            !endif
            !
          enddo
          !
          call deinit_gme_I(gme)
          !
          if (job%vib_rot_contr) then 
             !
             write(out,"('vib-rot is not working yet, please check')")
             stop 'vib-rot is not working yet, please check'
             !
             if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and. & 
                     (.not.job%IOmatelem_split.or.job%iswap(1)==0.or.job%iswap(1)==(PT%Nmodes+3)*3 ) ) then
                  !
                  !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(hvib_t) schedule(dynamic)
                  do ideg=1,Ndeg
                    icontr = PT%icase2icontr(isymcoeff,ideg)
                    do jdeg=1,ideg-1
                      jcontr = PT%icase2icontr(isymcoeff,jdeg)
                      hvib_t(icontr,jdeg) = hvib_t(jcontr,ideg)
                    enddo
                  enddo
                  !$omp end parallel do
                  !
                  write(chkptIO_) hvib_t(1:mdimen,1:Ndeg)
                  !
              else
                  !
                  !$omp parallel do private(icontr,ideg,jcontr,jdeg) schedule(dynamic)
                  do ideg=1,Ndeg
                    icontr = PT%icase2icontr(isymcoeff,ideg)
                    do jdeg=1,ideg
                      jcontr = PT%icase2icontr(isymcoeff,jdeg)
                      hvib%me(jcontr,ideg) = hvib_t(jcontr,ideg)
                      hvib%me(icontr,jdeg) = hvib_t(jcontr,ideg)
                    enddo
                  enddo
                  !$omp end parallel do
                  !
                  !write(out,"('vib-rot: hvib must be stored, you should not be here!')")
                  !stop 'vib-rot: hvib must be stored, you should not be here!'
                  !
             endif
             !
          endif
          !
          !if (job%IOmatelem_dump) close(dumpIO_)
          !
          !if (job%verbose>=4) write(out,"('| 100% done')") 
          !
          if (job%verbose>=2) call TimerStop('calc_gvib_contr_matrix')
          !
          if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE')) then 
            !
            if (.not.job%vib_rot_contr) then 
              !
              !$omp parallel do private(icoeff,jcoeff) shared(hvib_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  hvib_t(icoeff,jcoeff) = hvib_t(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              !write(chkptIO) hvib_t
              !
              if (trim(job%IOkinet_action)=='SAVE') then
                   write(chkptIO) hvib_t
              endif
              !
            endif 
            !
          else
            !
            !$omp parallel do private(icoeff,jcoeff) schedule(dynamic)
            do icoeff=1,mdimen
              do jcoeff=1,icoeff-1
                hvib%me(jcoeff,icoeff) = hvib_t(jcoeff,icoeff)
                hvib%me(icoeff,jcoeff) = hvib%me(jcoeff,icoeff)
              enddo
            enddo
            !$omp end parallel do
            !
          endif
          !
          if (job%verbose>=2) write(out,"(/'...done!')")
          !
          deallocate(hvib_t)
          call ArrayStop('hvib-fields')
          !
          if (job%vib_rot_contr) then
            write(chkptIO_) 'hvib'
            close(chkptIO_)
          endif
          !          
          call TimerReport
          !
        endif
        !
        !Finish the contracted checkpointing
        !
        if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and.&
           (.not.job%IOmatelem_split.or.job%iswap(1)==0 )) then
          !
          write(chkptIO) 'End Kinetic part'
          close(chkptIO,status='keep')
          !
        endif 
        !
        ! External field part 
        !
        if (treat_exfF) then 
          !
          if (job%verbose>=2) write(out,"(/'External function...')")
          !
          fitting%iparam(2) = min(fitting%iparam(2),extF_rank)
          fitting%iparam(1) = max(fitting%iparam(1),1)
          !
          if (.not.job%IOextF_divide) then
            !
            fitting%iparam = (/1,extF_rank/)
            !
            if (jrot/=0) then     
               write (out,"(/'PTcontracted_matelem_class: contr. matrix elements can be calculated only at J = 0')") 
               write (out,"('switch to  EXTERNAL NONE for j/=0')") 
               stop 'PTcontracted_matelem_class - illegal use of EXTERNAL for J/=0'
            endif 
            !
            ! Prepare the checkpoint file
            !
            job_is ='external field contracted matrix elements for J=0'
            call IOStart(trim(job_is),chkptIO)
            !
            open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=job%extFmat_file)
            write(chkptIO) 'Start external field'
            !
            ! store the matrix elements 
            !
            write(chkptIO) PT%Maxcontracts
            !
          endif 
          !
          if (job%vib_rot_contr) then 
            allocate(extF_t(mdimen,dimen_p),stat=alloc)
          else 
            allocate(extF_t(mdimen,mdimen),stat=alloc)
          endif
          call ArrayStart('extF-fields',alloc,1,kind(f_t),size(extF_t,kind=hik))
          !
          do imu = fitting%iparam(1),fitting%iparam(2)
            !
            if (job%verbose>=5) write(out,"('imu = ',i8)",advance='NO') imu
            !
            if (.not.job%IOextF_divide) then 
              write(chkptIO) imu
            else
              !
              call open_divided_slice(imu,'extF',job%extmat_suffix,chkptIO_)
              !           
            endif
            !
            !if (job%matelem_append.or.job%IOextmatelem_dump) then
            !  !
            !  if (job%vib_rot_contr) then
            !    !
            !    write(out,"('Appending or dumping is not working with the vib-rot contraction scheme, remove them from input')")
            !    stop 'Appending or dumping is not working with the vib-rot'
            !    !
            !  endif
            !  !
            !  call open_dump_slice(islice,'extF_',job%extmat_suffix,job%extmatelem_append,job%IOextmatelem_dump,dumpIO_)
            !  !
            !endif
            !
            call calc_extF_me_I(imu,gme)
            !
            do isymcoeff =1,PT%Maxsymcoeffs
              !
              Ndeg = PT%Index_deg(isymcoeff)%size1
              !
              if (job%vib_rot_contr) extF_t = 0
              !
              if (job%extmatelem_append) then
                 !
                 do ideg=1,Ndeg
                   !
                   icontr = PT%icase2icontr(isymcoeff,ideg)
                   !
                   read(dumpIO_) icontr,extF_t(icontr,1:icontr)
                   if ( icontr/=PT%icase2icontr(isymcoeff,ideg) ) then
                     write(out,"('Wrong record ',i9,' /= ',i9,' in the dump-chk file ',a)") icontr,&
                                  PT%icase2icontr(isymcoeff,ideg),trim(filename)
                     stop 'Wrong record in the dump-file'
                   endif
                   !
                 enddo
                 !
                 if (isymcoeff==job%iextappend) job%extmatelem_append = .false.
                 !
              else ! no-append means calculation 
                 !
                 !call calc_extF_contr_matrix(imu,isymcoeff,extF_t)
                 !
                 call calc_rot_contr_matrix_I(isymcoeff,me%ExtF(imu),extF_t)
                 !
              endif 
              !
              !call calc_extF_contr_matrix(imu,isymcoeff,extF_t)
              !
              if (job%vib_rot_contr) then 
                 !
                 !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(extF_t) schedule(dynamic)
                 do ideg=1,Ndeg
                    icontr = PT%icase2icontr(isymcoeff,ideg)
                    do jdeg=1,ideg-1
                       jcontr = PT%icase2icontr(isymcoeff,jdeg)
                       extF_t(icontr,jdeg) = extF_t(jcontr,ideg)
                   enddo
                 enddo
                 !$omp end parallel do
                 !
                 if (job%IOextF_divide) then
                   write(chkptIO_) extF_t(1:mdimen,1:Ndeg)
                 endif

                 !omp parallel do private(ideg,jdeg) shared(hvib_t) schedule(dynamic)
                 !do ideg=1,Ndeg
                 !  do jdeg=1,ideg-1   
                 !    extF_t(isymcoeff+jdeg-1,ideg) = extF_t(isymcoeff+ideg-1,jdeg)
                 !  enddo
                 !enddo
                 !omp end parallel do
                 !
                 !if (job%IOextF_divide) then 
                 !  !
                 !  call write_divided_slice(imu,'extF',job%extmat_suffix,mdimen,Ndeg,extF_t)
                 !  !
                 !else
                 !  !
                 !  write(chkptIO) extF_t(1:mdimen,1:Ndeg)
                 !  !
                 !endif

                  !
              !elseif (job%IOextmatelem_dump.and..not.job%extmatelem_append) then 
              !   !
              !   do ideg=1,Ndeg
              !     !
              !     icontr = PT%icase2icontr(isymcoeff,ideg)
              !     !
              !     write(dumpIO_) icontr,extF_t(icontr,1:icontr)
              !     !
              !   enddo
              !   !
              endif
              !
            enddo
            !
            !if (job%IOextmatelem_dump) close(dumpIO_)
            !
            if (.not.job%vib_rot_contr) then 
              !
              !$omp parallel do private(icoeff,jcoeff) shared(extF_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  extF_t(icoeff,jcoeff) = extF_t(jcoeff,icoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              if (job%IOextF_divide) then
                 write(chkptIO_) extF_t
              else
                 write(chkptIO) extF_t
              endif
              !
            endif
            !
            if (job%IOextF_divide) then 
              write(chkptIO_) 'extF'
              close(chkptIO_)
            endif
            !
            !if (job%vib_rot_contr) then 
            !   !
            !   !$omp parallel do private(icoeff,jcoeff) shared(extF_t) schedule(dynamic)
            !   do icoeff=1,mdimen
            !     do jcoeff=1,icoeff-1
            !       extF_t(icoeff,jcoeff) = extF_t(jcoeff,icoeff)
            !     enddo
            !   enddo
            !   !$omp end parallel do
            !   !
            !   if (job%IOextF_divide) then 
            !     !
            !     call write_divided_slice(imu,'extF',job%extmat_suffix,mdimen,mdimen,extF_t)
            !     !
            !   else
            !     !
            !     write(chkptIO) extF_t
            !     !
            !   endif
            !   !
            !endif
            !
            if (job%verbose>=5) write(out,"('...done')",advance='YES') 
            !
          enddo
          !
          deallocate(extF_t)
          call ArrayStop('extF-fields')
          if (.not.job%IOextF_divide) write(chkptIO) 'End external field'
          !
          if (job%verbose>=2) write(out,"('...done!')")
          !
        endif
        !
        call de_initialize_class_contr_objects
        !
      endif 
      !
      ! Rotational matrix elements 
      !
      iclasses = 0 
      dimen   = contr(0)%nlevels
      dimen_p = contr(0)%dimen
      !
      if (FLrotation) then
         !
         if (job%rotsym_do) then
           !
           call PTrot_contracted_matelem_class(jrot)
           !
         else
           !
           if (job%verbose>=2) write(out,"(/'Rotational part...')")
           !
           job_is = 'rot'
           !
           allocate(contr(0)%rot(7),stat=alloc)
           !
           isize = (jmax+1)*(jmax+2)/2
           !
           do k1 =1,size(contr(0)%rot(:))
             !
             allocate(contr(0)%rot(k1)%coeff3d(isize,-2:2,0:1),stat=alloc)
             call ArrayStart('contr(0)-rot-coeff3d',alloc,size(contr(0)%rot(k1)%coeff3d),kind(f_t))
             !
           enddo 
           !
           do k1 = 1,7
             !
             call FLread_coeff_matelem(job_is,k1,1,contr(0)%rot(k1)%coeff3d(:,:,:))
             !
           enddo
           !
         endif
         !
      endif
      !
      ! We have completed transformation of the matrix elements from the standard primitive 
      ! representation to the contarcted representaion.
      ! We can free some memory by deallocating the primitive objects. 
      !
      call FLfree_primitive_objects
      !
      deallocate(extF_N)
      !
      if (verbose>=4) call MemoryReport
      !
      if (verbose>=4) write(out,"('PTcontracted_matelem_class_fast_II/stop: contracted matrix elements for the hamiltonian ')") 
      !
      call TimerStop('Contracted matelements-class-fast')
      !
      !
  contains 
    !
    !
    subroutine open_dump_slice(islice,name,suffix,append,dump,chkptIO)
        !
        integer(ik),intent(in) :: islice
        character(len=*),intent(in) :: name,suffix
        logical,intent(in) :: append,dump
        integer(ik),intent(out)     :: chkptIO
        character(len=4) :: jchar
        character(len=cl) :: filename
          !
          write(job_is,"('dump matrix')")
          !
          call IOStart(trim(job_is),chkptIO)
          !
          write(jchar, '(i4)') islice
          !
          filename = trim(suffix)//trim(adjustl(jchar))//'_dump.chk'
          !
          if (append.and.dump) then 
            open(chkptIO,form='unformatted',action='readwrite',position='rewind',status='old',file=filename)
          elseif(dump) then
            open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
          else
            open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=filename)
          endif
          !
    end subroutine open_dump_slice
    !
    !
    subroutine open_divided_slice(islice,name,suffix,chkptIO)
        !
        integer(ik),intent(in) :: islice
        character(len=*),intent(in) :: name,suffix
        integer(ik),intent(out)     :: chkptIO
        character(len=4) :: jchar
        character(len=cl) :: filename
        !
        write(job_is,"('single swap_matrix')")
        !
        call IOStart(trim(job_is),chkptIO)
        !
        write(jchar, '(i4)') islice
        !
        filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
        !
        open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
        !
        write(chkptIO) trim(name)
        !
    end subroutine open_divided_slice
    !
    subroutine write_divided_slice(islice,name,suffix,N,M,field)
      !
      integer(ik),intent(in) :: islice
      character(len=*),intent(in) :: name,suffix
      integer(ik),intent(in)      :: N,M
      real(rk),intent(in)         :: field(N,M)
      character(len=4) :: jchar
      integer(ik)            :: chkptIO
      character(len=cl)      :: filename
      !
      write(job_is,"('single swap_matrix')")
      !
      call IOStart(trim(job_is),chkptIO)
      !
      write(jchar, '(i4)') islice
      !
      filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
      !
      open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
      !
      write(chkptIO) trim(name)
      !
      write(chkptIO) field
      !
      write(chkptIO) trim(name)
      !
      close(chkptIO)
      !
    end subroutine write_divided_slice
    !
    subroutine initialize_class_contr_objects
       !
       integer(ik) :: nmodes,nclasses,info,iclass,maxncontr,jclass,imode,jmode,icomb,n,extF_rank,ideg,icontr,isymcoeff
       integer(ik) :: iclass_nmodes_,jclass_nmodes_
       real(rk) :: coef_thresh,energy_i
       character(cl) :: func_tag_, sclass, skey
       integer(hik)  :: matsize
       integer(ik) :: i,ind(PT%Nclasses,PT%Nclasses),ielem,ii(PT%Nclasses),kcomb(PT%Nclasses)
       type(PTcoeffT),pointer        :: fl 
       !
       nmodes = PT%Nmodes
       nclasses = PT%Nclasses
       coef_thresh = job%exp_coeff_thresh
       !
       ! indexes of modes in each class
       !
       allocate(iclass_nmodes(nclasses), iclass_imode(nmodes,nclasses), stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast_II:iclass_nmodes',info,size(iclass_nmodes),kind(iclass_nmodes))
       call ArrayStart('PTcontracted_matelem_class_fast_II:iclass_imode',info,size(iclass_imode),kind(iclass_imode))
       !
       do iclass=1, nclasses
         iclass_nmodes(iclass) = PT%mode_class(iclass,PT%mode_iclass(iclass)) - PT%mode_class(iclass,1) + 1
         iclass_imode(1:iclass_nmodes(iclass),iclass) = PT%mode_class(iclass,1:PT%mode_iclass(iclass))
       enddo
       !
       ! read contraction indices - indices of contracted functions that form CI product function
       !
       call read_contr_ind(maxncontr, nclasses, dimen_classes, nu_classes)
       ! note: "dimen_classes", "nu_classes" are allocated inside "read_contr_ind"
       ! count allocated memory
       info = 0
       call ArrayStart('PTcontracted_matelem_class_fast_II:dimen_classes',info,1,kind(dimen_classes),size(dimen_classes,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast_II:nu_classes',info,1,kind(nu_classes),size(nu_classes,kind=hik))
       !   
       if (job%verbose>=4) write(out, '(1x,a,1x,i6)') 'total number of functions:', maxncontr
       if (job%verbose>=4) write(out, '(1x,a,1x,i2)') 'number of classes of contracted functions:', nclasses
       if (job%verbose>=4) write(out, '(1x,a,100(1x,i4))') 'number of contracted functions in each class:', &
                           dimen_classes(1:nclasses)
       !
       call combinations(nclasses, (/(n, n=1, nclasses)/), ncomb, icomb_nclasses, icomb_iclass)
       !
       allocate(iclass_ilambda(PT%Nmodes,PT%Nclasses,PT%Nclasses), stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast_II:iclass_ilambda',info,size(iclass_ilambda),&
                       kind(iclass_ilambda))
       !
       do iclass=1, nclasses
         do jclass=1, nclasses
           if (jclass/=iclass) then
             iclass_ilambda(:,jclass,iclass) = 0
           else
             iclass_ilambda(1:iclass_nmodes(iclass),jclass,iclass) = (/( imode, imode=1,iclass_nmodes(iclass) )/)
           endif
         enddo
       enddo
       !
       allocate(icomb_nclasses0(0:ncomb), icomb_iclass0(nclasses,0:ncomb), stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast_II:icomb_nclasses0',info,size(icomb_nclasses0),&
                       kind(icomb_nclasses0))
       call ArrayStart('PTcontracted_matelem_class_fast_II:icomb_iclass0',info,size(icomb_iclass0),kind(icomb_iclass0))
       icomb_nclasses0 = 0
       icomb_nclasses0(0) = nclasses
       icomb_iclass0(1:icomb_nclasses0(0),0) = (/(iclass, iclass=1, icomb_nclasses0(0))/)
       do icomb=1, ncomb
         n = icomb_nclasses(icomb)
         do iclass=1, nclasses
           if (all(icomb_iclass(1:n,icomb)/=iclass)) then
             icomb_nclasses0(icomb) = icomb_nclasses0(icomb) + 1
             icomb_iclass0(icomb_nclasses0(icomb),icomb) = iclass
           endif
         enddo
       enddo
       !
       ! define the maximal energy within each isymmcoeff combination for different ideg, 
       ! which will be needed for enercut_matelem
       !
       if (allocated(enermax_classes)) deallocate(enermax_classes) 
       !
       allocate(enermax_classes(PT%Maxsymcoeffs),stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast_II:enermax_classes',info,1,kind(enermax_classes),&
                       size(enermax_classes,kind=hik))
       !
       enermax_classes = 0
       !
       do isymcoeff = 1,PT%Maxsymcoeffs
         !
         enermax_classes(isymcoeff) = 0
         !
         icontr = PT%icase2icontr(isymcoeff,1)
         !
         enermax_classes(isymcoeff) = PTcontrenergy_zero(PT%icontr_cnu(:,icontr))
         !
         do ideg = 2,PT%Index_deg(isymcoeff)%size1
           !
           icontr = PT%icase2icontr(isymcoeff,ideg)
           !
           energy_i = PTcontrenergy_zero(PT%icontr_cnu(:,icontr))
           !
           enermax_classes(isymcoeff) = min(energy_i,enermax_classes(isymcoeff))
           !
         enddo
       enddo      
       !
       if (trim(trove%IO_contrCI)/='READ') return
       !   
       !--------------------------------------------------!
       ! read expansion terms for vibrational part of KEO !
       !--------------------------------------------------!
       !
       !if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for vibrational part of KEO'
       !func_tag_ = 'Tvib'
       !
       !call read_expansion_terms(func_tag_, nclasses, nmodes, nmodes, ncomb, icomb_nclasses, icomb_iclass, gvib_icomb_nterms, gvib_icomb_iterm, gvib_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "gvib_icomb_nterms", "gvib_icomb_iterm", "gvib_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       !info = 0
       !
       !call ArrayStart('PTcontracted_matelem_class_fast_II:gvib_icomb_nterms',info,1,kind(gvib_icomb_nterms),size(gvib_icomb_nterms,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:gvib_icomb_iterm',info,1,kind(gvib_icomb_iterm),size(gvib_icomb_iterm,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:gvib_icomb_coefs',info,1,kind(gvib_icomb_coefs),size(gvib_icomb_coefs,kind=hik))
       !
       !------------------------------------------------------------!
       ! read primitive matrix elements for vibrational part of KEO !
       !------------------------------------------------------------!
       !   
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for vibrational part of KEO'
       func_tag_ = 'Tvib'
       allocate(gvib_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gvib_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       !
       do iclass=1, nclasses-1
         dimen = dimen_classes(iclass)
         !
         iclass_nmodes_ = iclass_nmodes(iclass)
         if (iclass==nclasses) iclass_nmodes_ = nmodes
         !
         call read_contr_matelem_expansion_II(iclass,func_tag_,dimen,iclass_nmodes_,iclass_nmodes_,&
               gvib_me(iclass)%nterms,gvib_me(iclass)%me)
         !
         ! note: "me" are allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'gvib_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(gvib_me(iclass)%me,kind=hik))
       enddo
       !
       do imode=1,PT%nmodes
         do jmode=1,PT%nmodes
           !
           fl => me%gvib(imode,jmode)
           !
           allocate(fl%uniq(Nclasses,fl%Ncoeff),stat=info)
           call ArrayStart('gvib-uniq',info,size(fl%uniq),kind(fl%uniq))
           !
         enddo
       enddo
       !
       call read_fast_ci_uniq(func_tag_)
       !
       if (job%verbose>=4) call MemoryReport
       !   
       !-------------------------------------------------!
       ! read expansion terms for rotational part of KEO !
       !-------------------------------------------------!
       !
       !if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for rotational part of KEO'
       !func_tag_ = 'Trot'
       !
       !call read_expansion_terms(func_tag_, nclasses, 3, 3, ncomb, icomb_nclasses, icomb_iclass, grot_icomb_nterms, grot_icomb_iterm, grot_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "grot_icomb_nterms", "grot_icomb_iterm", "grot_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       !info = 0
       !call ArrayStart('PTcontracted_matelem_class_fast_II:grot_icomb_nterms',info,1,kind(grot_icomb_nterms),size(grot_icomb_nterms,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:grot_icomb_iterm',info,1,kind(grot_icomb_iterm),size(grot_icomb_iterm,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:grot_icomb_coefs',info,1,kind(grot_icomb_coefs),size(grot_icomb_coefs,kind=hik))
       !
       !-----------------------------------------------------------!
       ! read primitive matrix elements for rotational part of KEO !
       !-----------------------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for rotational part of KEO'
       func_tag_ = 'Trot'
       allocate(grot_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate grot_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses-1
         dimen = dimen_classes(iclass)
         !
         iclass_nmodes_ = 0
         if (iclass==nclasses) iclass_nmodes_ = 3
         !
         !call read_contr_matelem_expansion(iclass,func_tag_,dimen,iclass_nmodes_,iclass_nmodes_,grot_me(iclass)%nterms,grot_me(iclass)%me)
         !
         call read_contr_matelem_expansion_II(iclass,func_tag_,dimen,iclass_nmodes_,iclass_nmodes_,&
                                               grot_me(iclass)%nterms,grot_me(iclass)%me)

         ! note: "me" is allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'grot_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(grot_me(iclass)%me,kind=hik))
       enddo
       !
       do imode=1,3
         do jmode=1,3
           !
           fl => me%grot(imode,jmode)
           !
           allocate(fl%uniq(Nclasses,fl%Ncoeff),stat=info)
           call ArrayStart('grot-uniq',info,size(fl%uniq),kind(fl%uniq))
           !
         enddo
       enddo
       !
       call read_fast_ci_uniq(func_tag_)
       !
       if (job%verbose>=4) call MemoryReport
       !
       !-----------------------------------------------!
       ! read expansion terms for Coriolis part of KEO !
       !-----------------------------------------------!
       !
       !if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for Coriolis part of KEO'
       !func_tag_ = 'Tcor'
       !   
       !call read_expansion_terms(func_tag_, nclasses, nmodes, 3, ncomb, icomb_nclasses, icomb_iclass, gcor_icomb_nterms, gcor_icomb_iterm, gcor_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "gcor_icomb_nterms", "gcor_icomb_iterm", "gcor_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       !info = 0
       !call ArrayStart('PTcontracted_matelem_class_fast_II:gcor_icomb_nterms',info,1,kind(gcor_icomb_nterms),size(gcor_icomb_nterms,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:gcor_icomb_iterm',info,1,kind(gcor_icomb_iterm),size(gcor_icomb_iterm,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:gcor_icomb_coefs',info,1,kind(gcor_icomb_coefs),size(gcor_icomb_coefs,kind=hik))
       !
       !---------------------------------------------------------!
       ! read primitive matrix elements for Coriolis part of KEO !
       !---------------------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for Coriolis part of KEO'
       func_tag_ = 'Tcor'
       allocate(gcor_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gcor_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses-1
         dimen = dimen_classes(iclass)
         iclass_nmodes_ = iclass_nmodes(iclass)
         jclass_nmodes_ = 0
         if (iclass==nclasses) then 
           iclass_nmodes_ = nmodes
           jclass_nmodes_ = 3
         endif
         !
         call read_contr_matelem_expansion_II(iclass,func_tag_,dimen,iclass_nmodes_,jclass_nmodes_,&
                                              gcor_me(iclass)%nterms,gcor_me(iclass)%me)
         !
         ! note: "me" is allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'gcor_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(gcor_me(iclass)%me,kind=hik))
       enddo
       !
       do imode=1,PT%nmodes
         do jmode=1,3
           !
           fl => me%gcor(imode,jmode)
           !
           allocate(fl%uniq(Nclasses,fl%Ncoeff),stat=info)
           call ArrayStart('gcor-uniq',info,size(fl%uniq),kind(fl%uniq))
           !
         enddo
       enddo
       !
       call read_fast_ci_uniq(func_tag_)
       !
       if (job%verbose>=4) call MemoryReport
       !
       !------------------------------!
       ! read expansion terms for PES !
       !------------------------------!
       !
       !if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for PES'
       !func_tag_ = 'Vpot'
       !
       !call read_expansion_terms(func_tag_, nclasses, 1, 1, ncomb, icomb_nclasses, icomb_iclass, vpot_icomb_nterms, vpot_icomb_iterm, vpot_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "vpot_icomb_nterms", "vpot_icomb_iterm", "vpot_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       !info = 0
       !call ArrayStart('PTcontracted_matelem_class_fast_II:vpot_icomb_nterms',info,1,kind(vpot_icomb_nterms),size(vpot_icomb_nterms,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:vpot_icomb_iterm',info,1,kind(vpot_icomb_iterm),size(vpot_icomb_iterm,kind=hik))
       !call ArrayStart('PTcontracted_matelem_class_fast_II:vpot_icomb_coefs',info,1,kind(vpot_icomb_coefs),size(vpot_icomb_coefs,kind=hik))
       !
       !----------------------------------------!
       ! read primitive matrix elements for PES !
       !----------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for PES'
       func_tag_ = 'Vpot'
       allocate(vpot_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate vpot_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses-1
         dimen = dimen_classes(iclass)
         iclass_nmodes_ = 0
         if (iclass==nclasses) iclass_nmodes_ = 1
         !call read_contr_matelem_expansion(iclass,func_tag_,dimen,iclass_nmodes_,iclass_nmodes_,vpot_me(iclass)%nterms,vpot_me(iclass)%me)
         !
         call read_contr_matelem_expansion_II(iclass,func_tag_,dimen,iclass_nmodes_,iclass_nmodes_,&
                                              vpot_me(iclass)%nterms,vpot_me(iclass)%me)
         !
         ! note: "me" is allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'vpot_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(vpot_me(iclass)%me,kind=hik))
         !
       enddo
       !
       fl => me%poten
       !
       allocate(fl%uniq(Nclasses,fl%Ncoeff),stat=info)
       call ArrayStart('poten-uniq',info,size(fl%uniq),kind(fl%uniq))
       !
       call read_fast_ci_uniq(func_tag_)       
       !
       if (job%verbose>=4) call MemoryReport
       !
       if (trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT') then
          !
          ! read expansion terms for ExtF 
          !
          !if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for ExtF'
          !func_tag_ = 'extF'
          !extF_rank = FLread_extF_rank()
          !
          !call read_expansion_terms(func_tag_, nclasses, extF_rank, 1, ncomb, icomb_nclasses, icomb_iclass, extF_icomb_nterms, extF_icomb_iterm, extF_icomb_coefs)
          
          ! note: "icomb_nclasses", "icomb_iclass", "extF_icomb_nterms", "extF_icomb_iterm", "extF_icomb_coefs" are allocated inside "read_expansion_terms"
          !
          ! count allocated memory
          !info = 0
          !call ArrayStart('PTcontracted_matelem_class_fast_II:extF_icomb_nterms',info,1,kind(extF_icomb_nterms),size(extF_icomb_nterms,kind=hik))
          !call ArrayStart('PTcontracted_matelem_class_fast_II:extF_icomb_iterm',info,1,kind(extF_icomb_iterm),size(extF_icomb_iterm,kind=hik))
          !call ArrayStart('PTcontracted_matelem_class_fast_II:extF_icomb_coefs',info,1,kind(extF_icomb_coefs),size(extF_icomb_coefs,kind=hik))
          !
          !if (job%verbose>=4) call MemoryReport
          !
          ! read primitive matrix elements for ExtF 
          !
          if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for extF'
          func_tag_ = 'extF'
          allocate(extF_me(nclasses), stat=info)
          if (info/=0) then
            write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate extF_me(nclasses)', 'nclasses =', nclasses
            stop
          endif
          !
          extF_rank = FLread_extF_rank()
          !
          do iclass=1, nclasses-1
            dimen = dimen_classes(iclass)
            iclass_nmodes_ = 0
            jclass_nmodes_ = 0
            if (iclass==nclasses) then 
              iclass_nmodes_ = extF_rank
              jclass_nmodes_ = 1
            endif
            call read_contr_matelem_expansion_II(iclass,func_tag_,dimen,iclass_nmodes_,jclass_nmodes_,&
                                                 extF_me(iclass)%nterms,extF_me(iclass)%me)
            !
            ! note: "me" is allocated inside "read_contr_matelem_expansion"
            ! count allocated memory
            write(sclass,'(i4)') iclass
            skey = 'extF_me('//trim(adjustl(sclass))//')'
            info = 0
            call ArrayStart(trim(skey),info,1,rk,size(extF_me(iclass)%me,kind=hik))
          enddo
          !
          do imode=1,extF_rank
              !
              fl => me%extF(imode)
              !
              allocate(fl%uniq(Nclasses,fl%Ncoeff),stat=info)
              call ArrayStart('extF-uniq',info,size(fl%uniq),kind(fl%uniq))
              !
          enddo
          !
          call read_fast_ci_uniq(func_tag_)

          !
       endif
       !
       call MemoryReport
       !
    end subroutine initialize_class_contr_objects
    !
    !
    subroutine de_initialize_class_contr_objects
      !
      integer(ik) :: iclass
      character(cl) :: skey,sclass
      integer(ik) :: nmodes,nclasses
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      !
      write(out, '(/1x,a)') ' Free memory'
      !
      deallocate(iclass_nmodes, iclass_imode)
      call ArrayStop('PTcontracted_matelem_class_fast_II:iclass_nmodes')
      call ArrayStop('PTcontracted_matelem_class_fast_II:iclass_imode')
      !
      deallocate(dimen_classes,nu_classes,enermax_classes)
      call ArrayStop('PTcontracted_matelem_class_fast_II:dimen_classes')
      call ArrayStop('PTcontracted_matelem_class_fast_II:nu_classes')
      call ArrayStop('PTcontracted_matelem_class_fast_II:enermax_classes')
      !
      deallocate(icomb_nclasses, icomb_iclass)
      !  
      if (allocated(gvib_me)) deallocate(gvib_me)
      !
      if (allocated(grot_me)) deallocate(grot_me)
      ! 
      if (allocated(grot_me)) deallocate(gcor_me)
      !
      if (allocated(vpot_me)) deallocate(vpot_me)
      !
      if (treat_exfF) then
        !     
        if (allocated(ExtF_me)) deallocate(ExtF_me)
        !
      endif
      !
      deallocate(iclass_ilambda)
      call ArrayStop('PTcontracted_matelem_class_fast_II:iclass_ilambda')
      !
      deallocate(icomb_nclasses0, icomb_iclass0)
      call ArrayStop('PTcontracted_matelem_class_fast_II:icomb_nclasses0')
      call ArrayStop('PTcontracted_matelem_class_fast_II:icomb_iclass0')
      !
      if (allocated(gme_Nclass)) then
         call ArrayStop("matelem_Nclass")
         deallocate(gme_Nclass)
      endif
      !
      do iclass = 1,PT%Nclasses
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(gme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(gme(iclass)%me)
        endif
        !
      enddo
      !
      if (allocated(prim_vect)) then
         deallocate(prim_vect)
         call ArrayStop('prim_vect')
      endif
      !
      if (allocated(isymcoeff_vs_isym)) then
        deallocate(isymcoeff_vs_isym)
        call ArrayStop('isymcoeff_vs_isym')
      endif
      !
      write(out, '(/a)') 'PTcontracted_matelem_class_fast_II/done'
      !
    end  subroutine de_initialize_class_contr_objects   
    !
    !
    !
    subroutine  calc_rot_contr_matrix_I(isymcoeff,fl,grot)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(out)   :: grot(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,iclass,nmodes,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff
      !
      Maxcontracts = PT%Maxcontracts
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      energy_i = enermax_classes(isymcoeff)
      !
      !fl => me%grot(k1,k2)
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,matelem,icoeff,iclass,nu_i,nu_j,&
        !$omp& iterm,me_class0) shared(grot) schedule(dynamic)
        do jcontr=1,icontr
          !
          if (debug_cut_matelem_with_enermax) then 
            jsymcoeff = PT%icontr2icase(jcontr,1)
            energy_j = enermax_classes(jsymcoeff)
            if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.&
                abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
          endif
          !
          matelem = 0
          !
          do icoeff = 1,fl%Ncoeff
            !
            do iclass=1,Nclasses-1
              !
              nu_i = nu_classes(iclass,icontr)
              nu_j = nu_classes(iclass,jcontr)
              !
              iterm = fl%uniq(iclass,icoeff)
              !
              !me_class0(iclass) = grot_me(iclass)%me(iterm,nu_i,nu_j,1,1)
              !
              me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
              !
              !if (abs(grot_me(iclass)%me(iterm,nu_i,nu_j,1,1)-&
              !         gme(iclass)%me(iterm,nu_i,nu_j))>small_) then 
              !         me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
              !     stop 'grot_me 1'
              !     continue 
              ! endif
              !
            enddo
            !
            nu_i = nu_classes(Nclasses,icontr)
            nu_j = nu_classes(Nclasses,jcontr)
            !
            !me_class0(Nclasses) = grot_me(Nclasses)%me(icoeff,nu_i,nu_j,k1,k2)
            !
            !me_class0(Nclasses) = gme_Nclass(icoeff,nu_i,nu_j)
            me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
            !
            !if (abs(gme_Nclass(icoeff,nu_i,nu_j)-&
            !         gme(Nclasses)%me(icoeff,nu_i,nu_j))>small_) then 
            !         me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
            !       stop 'grot_me 2'
            !     continue 
            !endif
            !
            matelem = matelem + product(me_class0(1:Nclasses))
            !
          enddo ! icoeff
          !
          !if (job%vib_rot_contr) then 
          !  grot(jcontr,ideg) = matelem
          !else
            grot(jcontr,icontr) = matelem
          !endif
          !
        enddo
      !$omp end parallel do
      enddo
      !
    end subroutine calc_rot_contr_matrix_I 
    !
    !
    subroutine  calc_gcor_contr_matrix(k1,k2,isymcoeff,gcor)
      !
      implicit none
      !
      integer(ik),intent(in) :: k1,k2,isymcoeff
      real(rk),intent(inout) :: gcor(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,iclass,nmodes,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff
      type(PTcoeffT),pointer   :: fl
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      Maxcontracts = PT%Maxcontracts
      energy_i = enermax_classes(isymcoeff)
      !
      !fl => me%gcor(k1,k2)
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,matelem,icoeff,iclass,nu_i,nu_j,iterm,&
        !$omp& me_class0) shared(gcor) schedule(dynamic)
        do jcontr=1,icontr
           !
           if (debug_cut_matelem_with_enermax) then 
            jsymcoeff = PT%icontr2icase(jcontr,1)
            energy_j = enermax_classes(jsymcoeff)
            if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !
           matelem = 0
           !
           do icoeff = 1,me%gcor(k1,k2)%Ncoeff
             !
             do iclass=1,Nclasses-1
               !
               nu_i = nu_classes(iclass,icontr)
               nu_j = nu_classes(iclass,jcontr)
               !
               iterm = me%gcor(k1,k2)%uniq(iclass,icoeff)
               !
               !me_class0(iclass) = gcor_me(iclass)%me(iterm,nu_i,nu_j,k1,1)
               me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
               !
               !if (abs(gcor_me(iclass)%me(iterm,nu_i,nu_j,k1,1)-&
               !        gme(iclass)%me(iterm,nu_i,nu_j))>small_) then 
               !        me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
               !    stop 'gcor_me 1'
               !    continue 
               !endif
               !
             enddo
             !
             nu_i = nu_classes(Nclasses,icontr)
             nu_j = nu_classes(Nclasses,jcontr)
             !
             !me_class0(Nclasses) = gcor_me(Nclasses)%me(icoeff,nu_i,nu_j,k1,k2)
             !
             !me_class0(Nclasses) = gme_Nclass(icoeff,nu_i,nu_j)
             me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !
             !if (abs(gme_Nclass(icoeff,nu_i,nu_j)-&
             !        gme(Nclasses)%me(icoeff,nu_i,nu_j))>small_) then 
             !        me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !      stop 'gcor_me 2'
             !    continue 
             !endif
             !
             matelem = matelem + product(me_class0(1:Nclasses))
             !
           enddo ! icoeff
           !
           !if (icontr/=jcontr) matelem = -matelem
           !
           !if (job%vib_rot_contr) then 
           !  gcor(jcontr,ideg) = gcor(jcontr,ideg) + matelem
           !else
             gcor(jcontr,icontr) = gcor(jcontr,icontr) + matelem
           !endif
           !
        enddo
       !$omp end parallel do 
     enddo
     !
    end subroutine  calc_gcor_contr_matrix
    !
    !
    subroutine  calc_vib_contr_matrix_I(isymcoeff,fl,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(out)   :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j,i
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen)
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      !
      Maxcontracts = PT%Maxcontracts
      !
      !fl => me%gvib(k1,k2)
      !
      Ncoeff = fl%Ncoeff
      !
      if (.not.debug_check_symmetries) then
        isym(:) = isymcoeff_vs_isym(:,isymcoeff)
        do i =1,sym%Nrepresen 
          if (isym(i)==0) isym(i) = -1
        enddo
      endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,jsym,matelem,icoeff,iclass,nu_i,nu_j,&
        !$omp& iterm,me_class0) shared(hvib) schedule(dynamic)
        do jcontr=1,icontr
           !
           if (.not.debug_check_symmetries) then
             jsymcoeff = PT%icontr2icase(jcontr,1)
             jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
             if ( all( isym(:)/=jsym(:) ) ) cycle
           endif
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !        
           matelem = 0
           !
           do icoeff = 1,Ncoeff
             !
             do iclass=1,Nclasses-1
               !
               nu_i = nu_classes(iclass,icontr)
               nu_j = nu_classes(iclass,jcontr)
               !
               iterm = fl%uniq(iclass,icoeff)
               !
               !me_class0(iclass) = gvib_me(iclass)%me(iterm,nu_i,nu_j,k1,k2)
               me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)

               !if (abs(gvib_me(iclass)%me(iterm,nu_i,nu_j,k1,k2)-&
               !        gme(iclass)%me(iterm,nu_i,nu_j))>small_) then 
               !        me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
               !    stop 'gvib_me 1'
               !    continue 
               !endif
               !
             enddo
             !
             nu_i = nu_classes(Nclasses,icontr)
             nu_j = nu_classes(Nclasses,jcontr)
             !
             !me_class0(Nclasses) = gvib_me(Nclasses)%me(icoeff,nu_i,nu_j,k1,k2)
             !
             !me_class0(Nclasses) = gme_Nclass(icoeff,nu_i,nu_j)
             !
             me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !
             !if (abs(gme_Nclass(icoeff,nu_i,nu_j)-&
             !        gme(Nclasses)%me(icoeff,nu_i,nu_j))>small_) then 
             !        me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !      stop 'gvib_me 2'
             !    continue 
             !endif
             !
             matelem = matelem + product(me_class0(1:Nclasses))
             !
           enddo ! icoeff
           !
           !matelem = -0.5_rk*matelem
           !
           !if (job%vib_rot_contr) then 
           !  hvib(jcontr,ideg) = hvib(jcontr,ideg) + matelem
           !else
             hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !endif
           !
         enddo
        !$omp end parallel do 
      enddo
      !
    end subroutine  calc_vib_contr_matrix_I
    !
    !
    subroutine  calc_rot_contr_matrix_II(isymcoeff,fl,grot)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(out)   :: grot(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,iclass,nmodes,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff
      integer(ik),allocatable :: uniqu_trans(:,:)
      integer :: info_p,info,Ncoeff
      real(rk),allocatable	:: me_class0_vec(:,:)
      !
      Maxcontracts = PT%Maxcontracts
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      energy_i = enermax_classes(isymcoeff)
      !
      !fl => me%grot(k1,k2)
      Ncoeff = fl%Ncoeff
      !
      allocate(uniqu_trans(Ncoeff,nclasses),stat=info)
      call ArrayStart("grot:uniqu_trans",info,size(uniqu_trans),kind(uniqu_trans))
      !
      uniqu_trans = transpose(fl%uniq)
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel private(me_class0_vec,info_p,jcontr,energy_j,jsymcoeff,matelem,iclass,nu_i,nu_j,icoeff) & 
        !$omp& shared(grot,uniqu_trans) 
        allocate(me_class0_vec(Ncoeff,Nclasses),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array grot: me_class0_vec')") info_p
           stop 'calc_rot_contr_matrix_II me_class0_vec'
        end if
        !
        !$omp do  schedule(dynamic)
        do jcontr=1,icontr
          !
          if (debug_cut_matelem_with_enermax) then 
            jsymcoeff = PT%icontr2icase(jcontr,1)
            energy_j = enermax_classes(jsymcoeff)
            if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
          endif
          !
          do iclass=1,Nclasses-1
              !
              nu_i = nu_classes(iclass,icontr)
              nu_j = nu_classes(iclass,jcontr)
              !
              me_class0_vec(1:Ncoeff,iclass) = gme(iclass)%me(uniqu_trans(1:Ncoeff,iclass),nu_i,nu_j)
              !
          enddo
          !
          nu_i = nu_classes(Nclasses,icontr)
          nu_j = nu_classes(Nclasses,jcontr)
          !
          me_class0_vec(1:Ncoeff,Nclasses) = gme(Nclasses)%me(1:Ncoeff,nu_i,nu_j)
          !
          matelem = 0
          do icoeff =1,Ncoeff
            matelem = matelem + product(me_class0_vec(icoeff,1:Nclasses))
          enddo
          !
          grot(jcontr,icontr) = grot(jcontr,icontr) + matelem
          !
        enddo
        !$omp end do
	    !
	    deallocate(me_class0_vec)
	    !
        !$omp end parallel 
      enddo
      !
      deallocate(uniqu_trans)
      call ArrayStop("grot:uniqu_trans")
      !
    end subroutine calc_rot_contr_matrix_II



    subroutine  calc_gcor_contr_matrix_II(k1,k2,isymcoeff,gcor)
      !
      implicit none
      !
      integer(ik),intent(in) :: k1,k2,isymcoeff
      real(rk),intent(inout) :: gcor(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,iclass,nmodes,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff
      type(PTcoeffT),pointer   :: fl
      integer(ik),allocatable :: uniqu_trans(:,:)
      integer :: info_p,info,Ncoeff
      real(rk),allocatable	:: me_class0_vec(:,:)
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      Maxcontracts = PT%Maxcontracts
      energy_i = enermax_classes(isymcoeff)
      !
      fl => me%gcor(k1,k2)
      Ncoeff = fl%Ncoeff
      !
      allocate(uniqu_trans(Ncoeff,nclasses),stat=info)
      call ArrayStart("gcor:uniqu_trans",info,size(uniqu_trans),kind(uniqu_trans))
      !
      uniqu_trans = transpose(fl%uniq)
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel private(me_class0_vec,info_p,jcontr,energy_j,jsymcoeff,iclass,nu_i,nu_j,matelem,icoeff) &
        !$omp& shared(gcor,uniqu_trans)
        allocate(me_class0_vec(Ncoeff,Nclasses),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array gcor: me_class0_vec')") info_p
           stop 'calc_gcor_contr_matrix_II me_class0_vec'
        end if
        !
        !$omp do  schedule(dynamic)
        do jcontr=1,icontr
          !
          if (debug_cut_matelem_with_enermax) then 
            jsymcoeff = PT%icontr2icase(jcontr,1)
            energy_j = enermax_classes(jsymcoeff)
            if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
          endif
          !
          do iclass=1,Nclasses-1
              !
              nu_i = nu_classes(iclass,icontr)
              nu_j = nu_classes(iclass,jcontr)
              !
              me_class0_vec(1:Ncoeff,iclass) = gme(iclass)%me(uniqu_trans(1:Ncoeff,iclass),nu_i,nu_j)
              !
          enddo
          !
          nu_i = nu_classes(Nclasses,icontr)
          nu_j = nu_classes(Nclasses,jcontr)
          !
          me_class0_vec(1:Ncoeff,Nclasses) = gme(Nclasses)%me(1:Ncoeff,nu_i,nu_j)
          !
          matelem = 0
          do icoeff =1,Ncoeff
            matelem = matelem + product(me_class0_vec(icoeff,1:Nclasses))
          enddo
          !
          gcor(jcontr,icontr) = gcor(jcontr,icontr) + matelem
          !
        enddo
        !$omp end do
	    !
	    deallocate(me_class0_vec)
	    !
        !$omp end parallel 
      enddo
      !
      deallocate(uniqu_trans)
      call ArrayStop("gcor:uniqu_trans")
     !
    end subroutine  calc_gcor_contr_matrix_II
    !


    subroutine  calc_rot_contr_matrix(isymcoeff,fl,grot)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(out)   :: grot(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,iclass,nmodes,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff
      integer :: Ncoeff
      !
      Maxcontracts = PT%Maxcontracts
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      energy_i = enermax_classes(isymcoeff)
      !
      !fl => me%grot(k1,k2)
      Ncoeff = fl%Ncoeff
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,jsymcoeff,energy_j,matelem) shared(grot) schedule(dynamic)
        do jcontr=1,icontr
          !
          if (debug_cut_matelem_with_enermax) then 
            jsymcoeff = PT%icontr2icase(jcontr,1)
            energy_j = enermax_classes(jsymcoeff)
            if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
          endif
          !
          call do_sum_of_prods_by_classes(icontr,jcontr,fl,matelem)
          !
          grot(jcontr,icontr) = grot(jcontr,icontr) + matelem
          !
        enddo
        !$omp end parallel do
	    !
      enddo
      !
    end subroutine calc_rot_contr_matrix



    subroutine  calc_vib_contr_matrix(isymcoeff,fl,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(inout) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j,i
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen)
      integer :: info_p,info
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      !
      Maxcontracts = PT%Maxcontracts
      !
      !fl => me%gvib(k1,k2)
      !
      Ncoeff = fl%Ncoeff
      !
      if (.not.debug_check_symmetries) then
        isym(:) = isymcoeff_vs_isym(:,isymcoeff)
        do i =1,sym%Nrepresen 
          if (isym(i)==0) isym(i) = -1
        enddo
      endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,jsymcoeff,jsym,energy_j,matelem) shared(hvib) schedule(dynamic)
        do jcontr=1,icontr
           !
           if (.not.debug_check_symmetries) then
             jsymcoeff = PT%icontr2icase(jcontr,1)
             jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
             if ( all( isym(:)/=jsym(:) ) ) cycle
           endif
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !        
           call do_sum_of_prods_by_classes(icontr,jcontr,fl,matelem)
           !
           hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !
        enddo
        !$omp end parallel do
	    !
      enddo
      !
    end subroutine calc_vib_contr_matrix
    !




    subroutine  calc_rot_contr_matrix_III(isymcoeff,fl,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(inout) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j,i
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen),nsize,iuniq,nsizes(PT%Nclasses)
      integer :: info_p,info

      real(rk),allocatable :: mat1(:),mat2(:)
      integer(ik),allocatable :: mat_coeff(:,:),mat_uniq(:,:)
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      Maxcontracts = PT%Maxcontracts
      Ncoeff = fl%Ncoeff

      nsize = fl%icoeff(PT%Nclasses-1)%isize(1)
      !
      allocate(mat_coeff(nsize,2:nclasses-1),stat=info)
      call ArrayStart("calc_vib_contr:uniqu_trans",info,size(mat_coeff),kind(mat_coeff))
      !
      allocate(mat_uniq(nsize,2:nclasses-1),stat=info)
      call ArrayStart("calc_vib_contr:mat_uniq",info,size(mat_uniq),kind(mat_uniq))
      !
      do iclass = 1,Nclasses
        !
        nsizes(iclass) = fl%icoeff(iclass)%isize(1)
        !
      enddo
      !
      do iclass = 2,Nclasses-1
        !
        nsize = nsizes(iclass)
        !
        mat_coeff(1:nsize,iclass) = fl%icoeff(iclass)%imat(1:nsize)
        mat_uniq(1:nsize,iclass)  = fl%iuniq(iclass)%imat(1:nsize)
        !
      enddo
      !
      !if (.not.debug_check_symmetries) then
      !  isym(:) = isymcoeff_vs_isym(:,isymcoeff)
      !  do i =1,sym%Nrepresen 
      !    if (isym(i)==0) isym(i) = -1
      !  enddo
      !endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel private(nsize,mat1,mat2,info_p,jcontr,jsymcoeff,jsym,energy_j,nu_i,nu_j,iclass,iterm,icoeff,iuniq,matelem) &
        !$omp& shared(hvib)
        nsize = fl%icoeff(PT%Nclasses-1)%isize(1)
        !
        allocate(mat1(nsize),mat2(nsize),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array mat1 and mat2: calc_rot_contr_matrix_II')") info_p
           stop 'calc_rot_contr_matrix_II mat1 and mat2'
        end if
        !
        !$omp do schedule(dynamic)
        do jcontr=1,icontr
           !
           !if (.not.debug_check_symmetries) then
           !  jsymcoeff = PT%icontr2icase(jcontr,1)
           !  jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
           !  if ( all( isym(:)/=jsym(:) ) ) cycle
           !endif
           !
           !if (debug_cut_matelem_with_enermax) then 
           !  jsymcoeff = PT%icontr2icase(jcontr,1)
           !  energy_j = enermax_classes(jsymcoeff)
           !  if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           !endif
           !
           nu_i = nu_classes(Nclasses,icontr)
           nu_j = nu_classes(Nclasses,jcontr)
           !
           mat1 = gme(Nclasses)%me(:,nu_i,nu_j)
           !
           do iclass = Nclasses-1,2,-1
             !
             nsize = nsizes(iclass)
             !
             nu_i = nu_classes(iclass,icontr)
             nu_j = nu_classes(iclass,jcontr)
             !
             mat2(1:nsize) = gme(iclass)%me(mat_uniq(1:nsize,iclass),nu_i,nu_j)*mat1(1:nsize)
             !
             !do iterm = 1,nsize
             !  !
             !  icoeff = mat_coeff(iterm,iclass)
             !  iuniq  = mat_uniq(iclass)%imat(iterm)
             !  !
             !  mat2(icoeff) = mat2(icoeff) + gme(iclass)%me(iuniq,nu_i,nu_j)*mat1(iterm)
             !  !
             !enddo
             !
             mat1(1:nsizes(iclass-1)) = 0
             do iterm = 1,nsize
               !
               icoeff = mat_coeff(iterm,iclass)
               !
               mat1(icoeff) = mat1(icoeff) +mat2(iterm)
               !
             enddo
             !
           enddo
           !
           nsize = nsizes(1)
           !
           nu_i = nu_classes(1,icontr)
           nu_j = nu_classes(1,jcontr)
           !
           matelem = sum(gme(1)%me(1:nsize,nu_i,nu_j)*mat1(1:nsize))
           !        
           !call do_sum_of_prods_by_classes(icontr,jcontr,fl,matelem)
           !
           hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !
        enddo
        !$omp enddo
        !
        deallocate(mat1,mat2)
        !$omp end parallel
	    !
      enddo
      !
      deallocate(mat_coeff)
      call ArrayStop("calc_vib_contr:uniqu_trans")
      deallocate(mat_uniq)
      call ArrayStop("calc_vib_contr:mat_uniq")
      !
    end subroutine  calc_rot_contr_matrix_III



    subroutine  calc_vib_contr_matrix_III(isymcoeff,fl,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(inout) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j,i
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen),nsize,iuniq,nsizes(PT%Nclasses)
      integer :: info_p,info

      real(rk),allocatable :: mat1(:),mat2(:)
      integer(ik),allocatable :: mat_coeff(:,:),mat_uniq(:,:)
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      Maxcontracts = PT%Maxcontracts
      Ncoeff = fl%Ncoeff

      nsize = fl%icoeff(PT%Nclasses-1)%isize(1)
      !
      allocate(mat_coeff(nsize,2:nclasses-1),stat=info)
      call ArrayStart("calc_vib_contr:uniqu_trans",info,size(mat_coeff),kind(mat_coeff))
      !
      allocate(mat_uniq(nsize,2:nclasses-1),stat=info)
      call ArrayStart("calc_vib_contr:mat_uniq",info,size(mat_uniq),kind(mat_uniq))
      !
      do iclass = 1,Nclasses
        !
        nsizes(iclass) = fl%icoeff(iclass)%isize(1)
        !
      enddo
      !
      do iclass = 2,Nclasses-1
        !
        nsize = nsizes(iclass)
        !
        mat_coeff(1:nsize,iclass) = fl%icoeff(iclass)%imat(1:nsize)
        mat_uniq(1:nsize,iclass)  = fl%iuniq(iclass)%imat(1:nsize)
        !
      enddo
      !
      !if (.not.debug_check_symmetries) then
      !  isym(:) = isymcoeff_vs_isym(:,isymcoeff)
      !  do i =1,sym%Nrepresen 
      !    if (isym(i)==0) isym(i) = -1
      !  enddo
      !endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel private(nsize,mat1,mat2,info_p,jcontr,jsymcoeff,jsym,energy_j,nu_i,nu_j,iclass,iterm,icoeff,iuniq,matelem)&
        !$omp& shared(hvib)
        nsize = fl%icoeff(PT%Nclasses-1)%isize(1)
        !
        allocate(mat1(nsize),mat2(nsize),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array mat1 and mat2: calc_vib_contr_matrix_II')") info_p
           stop 'calc_vib_contr_matrix_II mat1 and mat2'
        end if
        !
        !$omp do schedule(dynamic)
        do jcontr=1,icontr
           !
           !if (.not.debug_check_symmetries) then
           !  jsymcoeff = PT%icontr2icase(jcontr,1)
           !  jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
           !  if ( all( isym(:)/=jsym(:) ) ) cycle
           !endif
           !
           !if (debug_cut_matelem_with_enermax) then 
           !  jsymcoeff = PT%icontr2icase(jcontr,1)
           !  energy_j = enermax_classes(jsymcoeff)
           !  if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           !endif
           !
           nu_i = nu_classes(Nclasses,icontr)
           nu_j = nu_classes(Nclasses,jcontr)
           !
           mat1 = gme(Nclasses)%me(:,nu_i,nu_j)
           !
           do iclass = Nclasses-1,2,-1
             !
             nsize = nsizes(iclass)
             !
             nu_i = nu_classes(iclass,icontr)
             nu_j = nu_classes(iclass,jcontr)
             !
             mat2(1:nsize) = gme(iclass)%me(mat_uniq(1:nsize,iclass),nu_i,nu_j)*mat1(1:nsize)
             !
             !do iterm = 1,nsize
             !  !
             !  icoeff = mat_coeff(iterm,iclass)
             !  iuniq  = mat_uniq(iclass)%imat(iterm)
             !  !
             !  mat2(icoeff) = mat2(icoeff) + gme(iclass)%me(iuniq,nu_i,nu_j)*mat1(iterm)
             !  !
             !enddo
             !
             mat1(1:nsizes(iclass-1)) = 0
             do iterm = 1,nsize
               !
               icoeff = mat_coeff(iterm,iclass)
               !
               mat1(icoeff) = mat1(icoeff) +mat2(iterm)
               !
             enddo
             !
           enddo
           !
           nsize = nsizes(1)
           !
           nu_i = nu_classes(1,icontr)
           nu_j = nu_classes(1,jcontr)
           !
           matelem = sum(gme(1)%me(1:nsize,nu_i,nu_j)*mat1(1:nsize))
           !        
           !call do_sum_of_prods_by_classes(icontr,jcontr,fl,matelem)
           !
           hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !
        enddo
        !$omp enddo
        !
        deallocate(mat1,mat2)
        !$omp end parallel
	    !
      enddo
      !
      deallocate(mat_coeff)
      call ArrayStop("calc_vib_contr:uniqu_trans")
      deallocate(mat_uniq)
      call ArrayStop("calc_vib_contr:mat_uniq")
      !
    end subroutine  calc_vib_contr_matrix_III
    !



    subroutine do_sum_of_prods_by_classes(icontr,jcontr,fl,me_tot)
      !
      implicit none
      !
      type(PTcoeffT),intent(in)   :: fl 
      integer(ik),intent(in) :: icontr,jcontr
      real(rk),intent(out) :: me_tot
      integer(ik) :: nterms(PT%Nclasses),maxnterms
      integer(ik) :: iclass
      integer(ik) :: iterm,iactual
        !
        ! ititialization
        !
        maxnterms = fl%maxnterms
        nterms = fl%nterms
        !
        iclass = 0
        iactual = 0
        iterm = 1
        !me_tot = 0
        !
        call do_expansion(iclass+1_ik,fl,nterms,icontr,jcontr,iterm,me_tot)
        !
    end subroutine do_sum_of_prods_by_classes


    recursive subroutine do_expansion(iclass,fl,nterms,icontr,jcontr,icoeff,me_tot)
       !
       implicit none
       !
       integer(ik) :: iclass
       type(PTcoeffT),intent(in)   :: fl 
       integer(ik),intent(in) :: nterms(PT%Nclasses),icontr,jcontr
       integer(ik),intent(in) :: icoeff
       real(rk),intent(inout) :: me_tot
       integer(ik) :: iterm,ipowers(PT%nmodes),qindex,isparse,imode1,imode2
       real(rk) :: me_prod,me_class
       integer(ik) :: nu_i,nu_j,iactual
       !
       !imode1 = PT%mode_class(iclass,1)
       !imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
       !
       nu_i = nu_classes(iclass,icontr)
       nu_j = nu_classes(iclass,jcontr)
       !
       me_tot = 0
       !
       if (iclass == PT%Nclasses) then
         !
         !iterm = fl%icoeff(iclass)%imat(icoeff)
         !
         me_tot = gme(iclass)%me(icoeff,nu_i,nu_j)
         !
         return
         !
       else 
         !
         do iterm=1,nterms(iclass)
           !
           call do_expansion(iclass+1_ik,fl,nterms,icontr,jcontr,iterm,me_prod)
           !
           me_class = me_prod*gme(iclass)%me(iterm,nu_i,nu_j)
           !
           me_tot = me_tot+me_class 
           !
         enddo
         !
       endif 
       !
    end subroutine do_expansion
    !
    !
    subroutine  calc_vib_contr_matrix_II(isymcoeff,fl,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(inout) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j,i
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen)
      integer(ik),allocatable :: uniqu_trans(:,:)
      integer :: info_p,info
      real(rk),allocatable	:: me_class0_vec(:,:)
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      !
      Maxcontracts = PT%Maxcontracts
      !
      !fl => me%gvib(k1,k2)
      !
      Ncoeff = fl%Ncoeff
      allocate(uniqu_trans(Ncoeff,nclasses),stat=info)
      call ArrayStart("gvib:uniqu_trans",info,size(uniqu_trans),kind(uniqu_trans))
      !
      uniqu_trans = transpose(fl%uniq)
      !
      if (.not.debug_check_symmetries) then
        isym(:) = isymcoeff_vs_isym(:,isymcoeff)
        do i =1,sym%Nrepresen 
          if (isym(i)==0) isym(i) = -1
        enddo
      endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel private(me_class0_vec,info_p,jcontr,energy_j,jsymcoeff,jsym,iclass,nu_i,nu_j,matelem,icoeff) &
        !$omp& shared(hvib,uniqu_trans)        
        allocate(me_class0_vec(Ncoeff,Nclasses),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array gvib: me_class0_vec')") info_p
           stop 'calc_gvib_contr_matrix_II me_class0_vec'
        end if
        !
        !$omp do  schedule(dynamic)
        do jcontr=1,icontr
           !
           if (.not.debug_check_symmetries) then
             jsymcoeff = PT%icontr2icase(jcontr,1)
             jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
             if ( all( isym(:)/=jsym(:) ) ) cycle
           endif
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !        
           matelem = 0
           do iclass=1,Nclasses-1
               !
               nu_i = nu_classes(iclass,icontr)
               nu_j = nu_classes(iclass,jcontr)
               !
               me_class0_vec(1:Ncoeff,iclass) = gme(iclass)%me(uniqu_trans(1:Ncoeff,iclass),nu_i,nu_j)
               !
           enddo
           !
           nu_i = nu_classes(Nclasses,icontr)
           nu_j = nu_classes(Nclasses,jcontr)
           !
           me_class0_vec(1:Ncoeff,Nclasses) = gme(Nclasses)%me(1:Ncoeff,nu_i,nu_j)
           !
           do icoeff =1,Ncoeff
             matelem = matelem + product(me_class0_vec(icoeff,1:Nclasses))
           enddo
           !
           hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !
        enddo
       !$omp end do
	    !
	    deallocate(me_class0_vec)
	    !
        !$omp end parallel 
      enddo
      !
      deallocate(uniqu_trans)
      call ArrayStop("gvib:uniqu_trans")
      !
    end subroutine  calc_vib_contr_matrix_II  
    !


    subroutine  calc_field_contr_matrix(isymcoeff,fl,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      type(PTcoeffT),intent(in)   :: fl
      real(rk),intent(inout) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j,i
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen)
      integer(ik),allocatable :: uniqu_trans(:,:)
      integer :: info_p,info
      real(rk),allocatable	:: me_class0_vec(:,:)
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      !
      Maxcontracts = PT%Maxcontracts
      !
      !fl => me%gvib(k1,k2)
      !
      Ncoeff = fl%Ncoeff
      allocate(uniqu_trans(Ncoeff,nclasses),stat=info)
      call ArrayStart("calc_field_contr_matrix:uniqu_trans",info,size(uniqu_trans),kind(uniqu_trans))
      !
      uniqu_trans = transpose(fl%uniq)
      !
      if (.not.debug_check_symmetries) then
        isym(:) = isymcoeff_vs_isym(:,isymcoeff)
        do i =1,sym%Nrepresen 
          if (isym(i)==0) isym(i) = -1
        enddo
      endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel private(me_class0_vec,info_p,jcontr,energy_j,jsymcoeff,jsym,iclass,nu_i,nu_j,iterm,matelem,icoeff) &
        !$omp& shared(hvib,uniqu_trans) 
        allocate(me_class0_vec(Ncoeff,Nclasses),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array gvib: me_class0_vec')") info_p
           stop 'calc_field_contr_matrix me_class0_vec'
        end if
        !
        !$omp do  schedule(dynamic)
        do jcontr=1,icontr
           !
           if (.not.debug_check_symmetries) then
             jsymcoeff = PT%icontr2icase(jcontr,1)
             jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
             if ( all( isym(:)/=jsym(:) ) ) cycle
           endif
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !
           matelem = 0
           do iclass=1,Nclasses-1
               !
               nu_i = nu_classes(iclass,icontr)
               nu_j = nu_classes(iclass,jcontr)
               !
               do iterm=1,fl%nterms(iclass)
                 !
                 icoeff = fl%iterm(iclass,iterm)
                 me_class0_vec(icoeff,iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
                 !
               enddo
               !
               me_class0_vec(1:Ncoeff,iclass) = gme(iclass)%me(uniqu_trans(1:Ncoeff,iclass),nu_i,nu_j)
               !
           enddo
           !
           nu_i = nu_classes(Nclasses,icontr)
           nu_j = nu_classes(Nclasses,jcontr)
           !
           me_class0_vec(1:Ncoeff,Nclasses) = gme(Nclasses)%me(1:Ncoeff,nu_i,nu_j)
           !
           do icoeff =1,Ncoeff
             matelem = matelem + product(me_class0_vec(icoeff,1:Nclasses))
           enddo
           !
           hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !
        enddo
	    !
	    deallocate(me_class0_vec)
	    !
        !$omp end parallel 
      enddo
      !
      deallocate(uniqu_trans)
      call ArrayStop("calc_field_contr_matrix:uniqu_trans")
      !
    end subroutine  calc_field_contr_matrix  



    !
    subroutine  calc_vpot_contr_matrix_II(isymcoeff,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      real(rk),intent(inout) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j,info,info_p
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen),i
      integer(ik),allocatable :: uniqu_trans(:,:)
      real(rk),allocatable	:: me_class0_vec(:,:)
      type(PTcoeffT),pointer   :: pl
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      !
      Maxcontracts = PT%Maxcontracts
      !
      pl => me%poten
      Ncoeff = pl%Ncoeff
      !
      allocate(uniqu_trans(Ncoeff,nclasses),stat=info)
      call ArrayStart("vpot:uniqu_trans",info,size(uniqu_trans),kind(uniqu_trans))
      !
      uniqu_trans = transpose(pl%uniq)
      !
      if (.not.debug_check_symmetries) then
        isym(:) = isymcoeff_vs_isym(:,isymcoeff)
        do i =1,sym%Nrepresen 
          if (isym(i)==0) isym(i) = -1
        enddo
      endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel private(me_class0_vec,info_p,jcontr,energy_j,jsymcoeff,jsym,iclass,nu_i,nu_j,matelem,icoeff) &
        !$omp& shared(hvib,uniqu_trans)
        !
        allocate(me_class0_vec(Ncoeff,Nclasses),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array vpot: me_class0_vec')") info_p
           stop 'calc_vpot_contr_matrix_II vpot-me_class0_vec'
        end if
        !
        !$omp do  schedule(dynamic)
        do jcontr=1,icontr
           !
           if (.not.debug_check_symmetries) then
             jsymcoeff = PT%icontr2icase(jcontr,1)
             jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
             if ( all( isym(:)/=jsym(:) ) ) cycle
           endif
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !
           do iclass=1,Nclasses-1
             !
             nu_i = nu_classes(iclass,icontr)
             nu_j = nu_classes(iclass,jcontr)
             !
             !iterm = pl%uniq(iclass,icoeff)
             !
             !me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
             me_class0_vec(1:Ncoeff,iclass) = gme(iclass)%me(uniqu_trans(1:Ncoeff,iclass),nu_i,nu_j)
             !
           enddo
           !
           nu_i = nu_classes(Nclasses,icontr)
           nu_j = nu_classes(Nclasses,jcontr)
           !
           me_class0_vec(1:Ncoeff,Nclasses) = gme(Nclasses)%me(1:Ncoeff,nu_i,nu_j)
           !
           !        
           matelem = 0
           do icoeff =1,Ncoeff
             matelem = matelem + product(me_class0_vec(icoeff,1:Nclasses))
           enddo
           !
           hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !
        enddo
       !$omp end do
	    !
	    deallocate(me_class0_vec)
	    !
        !$omp end parallel 
      enddo
      !
      deallocate(uniqu_trans)
      call ArrayStop("vpot:uniqu_trans")
      !
    end subroutine  calc_vpot_contr_matrix_II
    !
    !
    subroutine  calc_extF_contr_matrix_II(k1,isymcoeff,extF)
      !
      integer(ik),intent(in) :: k1,isymcoeff
      !
      real(rk),intent(out)   :: extF(:,:)
      !
      real(rk)    :: matelem,me_class0(PT%Nclasses),energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,iclass,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff
      type(PTcoeffT),pointer   :: fl
      integer(ik),allocatable :: uniqu_trans(:,:)
      real(rk),allocatable	:: me_class0_vec(:,:)
      integer :: info_p,info,Ncoeff
      !
      Maxcontracts = PT%Maxcontracts
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      energy_i = enermax_classes(isymcoeff)
      !
      fl => me%ExtF(k1)
      Ncoeff = fl%Ncoeff
      !
      allocate(uniqu_trans(Ncoeff,nclasses),stat=info)
      call ArrayStart("extF:uniqu_trans",info,size(uniqu_trans),kind(uniqu_trans))
      !
      uniqu_trans = transpose(fl%uniq)
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel private(me_class0_vec,info_p,jcontr,energy_j,jsymcoeff,iclass,nu_i,nu_j,matelem,icoeff) &
        !$omp& shared(extF,uniqu_trans)
        allocate(me_class0_vec(Ncoeff,Nclasses),stat=info_p)
        if (info_p/=0) then
           write (out,"(' Error ',i9,' trying to allocate array extF: me_class0_vec')") info_p
           stop 'calc_extF_contr_matrix_II vpot-me_class0_vec'
        end if
        !
        !$omp do  schedule(dynamic)
        do jcontr=1,icontr
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !
           ! ExtF part
           !
           do iclass=1,Nclasses-1
             !
             nu_i = nu_classes(iclass,icontr)
             nu_j = nu_classes(iclass,jcontr)
             me_class0_vec(1:Ncoeff,iclass) = gme(iclass)%me(uniqu_trans(1:Ncoeff,iclass),nu_i,nu_j)
             !
           enddo
           !
           nu_i = nu_classes(Nclasses,icontr)
           nu_j = nu_classes(Nclasses,jcontr)
           !
           me_class0_vec(1:Ncoeff,Nclasses) = gme(Nclasses)%me(1:Ncoeff,nu_i,nu_j)
           !        
           matelem = 0
           do icoeff =1,Ncoeff
             matelem = matelem + product(me_class0_vec(icoeff,1:Nclasses))
           enddo
           !
           extF(jcontr,icontr) = extF(jcontr,icontr) + matelem
           !
        enddo
        !$omp end do
	    !
	    deallocate(me_class0_vec)
	    !
        !$omp end parallel 
      enddo
      !
      deallocate(uniqu_trans)
      call ArrayStop("extF:uniqu_trans")
      !
    end subroutine calc_extF_contr_matrix_II


    !
    subroutine  calc_vpot_contr_matrix(isymcoeff,hvib)
      !
      implicit none
      !
      integer(ik),intent(in) :: isymcoeff
      real(rk),intent(inout) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,nterms,iclass,nmodes,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff,jdeg,Ncoeff,isym(sym%Nrepresen),jsym(sym%Nrepresen),i
      type(PTcoeffT),pointer   :: pl
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      !
      Maxcontracts = PT%Maxcontracts
      !
      pl => me%poten
      !
      if (.not.debug_check_symmetries) then
        isym(:) = isymcoeff_vs_isym(:,isymcoeff)
        do i =1,sym%Nrepresen 
          if (isym(i)==0) isym(i) = -1
        enddo
      endif
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,jsym,matelem,Ncoeff,icoeff,iclass,nu_i,nu_j,&
        !$omp& iterm,me_class0) shared(hvib) schedule(dynamic)
        do jcontr=1,icontr
           !
           if (.not.debug_check_symmetries) then
             jsymcoeff = PT%icontr2icase(jcontr,1)
             jsym(:) = isymcoeff_vs_isym(:,jsymcoeff)
             if ( all( isym(:)/=jsym(:) ) ) cycle
           endif
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !        
           matelem = 0
           Ncoeff = pl%Ncoeff
           !
           do icoeff = 1,Ncoeff
             !
             do iclass=1,Nclasses-1
               !
               nu_i = nu_classes(iclass,icontr)
               nu_j = nu_classes(iclass,jcontr)
               !
               iterm = pl%uniq(iclass,icoeff)
               !
               !me_class0(iclass) = vpot_me(iclass)%me(iterm,nu_i,nu_j,1,1)
               !
               me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
               !
               !if (abs(vpot_me(iclass)%me(iterm,nu_i,nu_j,1,1)-&
               !        gme(iclass)%me(iterm,nu_i,nu_j))>small_) then 
               !        me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
               !    stop 'vpot 1'
               !    continue 
               !endif
               !
             enddo
             !
             nu_i = nu_classes(Nclasses,icontr)
             nu_j = nu_classes(Nclasses,jcontr)
             !
             !me_class0(Nclasses) = vpot_me(Nclasses)%me(icoeff,nu_i,nu_j,1,1)
             !
             !me_class0(Nclasses) = gme_Nclass(icoeff,nu_i,nu_j)
             !
             me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !
             !if (abs(gme_Nclass(icoeff,nu_i,nu_j)-&
             !        gme(Nclasses)%me(icoeff,nu_i,nu_j))>small_) then 
             !        me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !      stop 'vpot 1'
             !    continue 
             !endif
             !
             matelem = matelem + product(me_class0(1:Nclasses))
             !
           enddo ! icoeff
           !
           !if (job%vib_rot_contr) then 
           !  hvib(jcontr,ideg) = hvib(jcontr,ideg) + matelem
           !else
             hvib(jcontr,icontr) = hvib(jcontr,icontr) + matelem
           !endif
           !
         enddo
        !$omp end parallel do 
      enddo
      !
    end subroutine  calc_vpot_contr_matrix
    !


    !
    subroutine  calc_extF_contr_matrix(k1,isymcoeff,extF)
      !
      integer(ik),intent(in) :: k1,isymcoeff
      !
      !integer(ik),intent(in) :: nu_classes(PT%Nclasses,PT%Maxcontracts)
      !integer(ik),intent(in) :: grot_icomb_nterms(0:ncomb,3,3)
      !
      real(rk),intent(out)   :: extF(:,:)
      !
      real(rk)    :: matelem,me_class0(PT%Nclasses),energy_j,energy_i
      integer(ik) :: iterm,nclasses,icontr,jcontr,iclass,nu_i,nu_j
      integer(ik) :: Maxcontracts,jsymcoeff
      type(PTcoeffT),pointer   :: fl
      !
      Maxcontracts = PT%Maxcontracts
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      energy_i = enermax_classes(isymcoeff)
      !
      fl => me%ExtF(k1)
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp  parallel do private(jcontr,energy_j,jsymcoeff,matelem,icoeff,iclass,nu_i,nu_j,iterm,me_class0) &
        !$omp& shared(hvib) schedule(dynamic)
        do jcontr=1,icontr
           !
           if (debug_cut_matelem_with_enermax) then 
             jsymcoeff = PT%icontr2icase(jcontr,1)
             energy_j = enermax_classes(jsymcoeff)
             if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           endif
           !
           ! ExtF part
           !
           matelem = 0
           !
           do icoeff = 1,fl%Ncoeff
             !
             do iclass=1,Nclasses-1
               !
               nu_i = nu_classes(iclass,icontr)
               nu_j = nu_classes(iclass,jcontr)
               !
               iterm = fl%uniq(iclass,icoeff)
               !
               !me_class0(iclass) = extF_me(iclass)%me(iterm,nu_i,nu_j,1,1)
               !
               me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
               !
               !if (abs(extF_me(iclass)%me(iterm,nu_i,nu_j,1,1)-&
               !        gme(iclass)%me(iterm,nu_i,nu_j))>small_) then 
               !        me_class0(iclass) = gme(iclass)%me(iterm,nu_i,nu_j)
               !    stop 'ext F 1'
               !    continue 
               !endif
               !
             enddo
             !
             nu_i = nu_classes(Nclasses,icontr)
             nu_j = nu_classes(Nclasses,jcontr)
             !
             !me_class0(Nclasses) = extF_me(Nclasses)%me(icoeff,nu_i,nu_j,k1,1)
             !
             !me_class0(Nclasses) = gme_Nclass(icoeff,nu_i,nu_j)
             me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !
             !if (abs(gme_Nclass(icoeff,nu_i,nu_j)-&
             !        gme(Nclasses)%me(icoeff,nu_i,nu_j))>small_) then 
             !        me_class0(Nclasses) = gme(Nclasses)%me(icoeff,nu_i,nu_j)
             !      stop 'extf 2'
             !    continue 
             !endif
             !
             matelem = matelem + product(me_class0(1:Nclasses))
             !
           enddo ! icoeff
           !
           !if (job%vib_rot_contr) then 
           !  extF(jcontr,ideg) = matelem
           !else
             extF(jcontr,icontr) = matelem
           !endif
           !
         enddo
        !$omp end parallel do 
      enddo
      !
    end subroutine calc_extF_contr_matrix
    !


    subroutine calc_gcor_me_I(imode,jmode,gcorme)

      integer(ik),intent(in) :: imode,jmode
      type(me_class),intent(inout)   :: gcorme(PT%Nclasses)
      !
      !real(rk), allocatable,intent(out)   :: gcorme_Nclass(:,:,:)
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms,imode_
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  :: func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      integer(ik)    ::  nclass_imode(2,PT%Nclasses),kclass
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'gcor_me matix elements for iclass = ', PT%Nclasses
      !
      func_tag = 'Tcor'
      target_index = 0 
      target_index(1) = kinorder
      maxnterms = FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      do kclass=1, PT%nclasses
        nclass_imode(1:2,kclass) = (/PT%mode_class(kclass,1),PT%mode_class(kclass,PT%mode_iclass(kclass))/)
      enddo
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      nterms_field = trove%g_cor(imode,jmode)%Ncoeff
      !
      if (me%gcor(imode,jmode)%Ncoeff==0) return
      !
      !matsize = int(nterms_field*dimen*dimen,hik)
      !
      !if (job%verbose>=5) write(out,"('  Allocating ',i6,'x',i7,'x',i7,' = ',i12,' gcor matrix of ',f15.4,' gb')") nterms_field,dimen,dimen,& 
      !                    matsize,real(matsize,rk)*8.0_rk/1024.0_rk**3
      !
      !if (allocated(gcorme_Nclass)) then
      !  call ArrayStop("matelem_Nclass")
      !  deallocate(gcorme_Nclass)
      !endif
      !
      !allocate(gcorme_Nclass(nterms_field,dimen,dimen), stat=info)
      !call ArrayStart("matelem_Nclass",info,1_ik,rk,matsize)
      !gcorme_Nclass= 0
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(gcorme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(gcorme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = gcor_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%gcor(imode,jmode)%Ncoeff
        !
        allocate(gcorme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(gcorme(iclass)%me,kind=hik))
        !
      enddo
      !
      fl => me%gcor(imode,jmode)
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      ! compute contracted matrix elements for operators: G, p_i*G
      !
      call calc_contr_matelem_expansion_Tcor_Nclass(func_tag,imode,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !
      !call store_contr_matelem_expansion_classN(imode,jmode,nclass,func_tag,nmodes,nmodes,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      !gcorme_Nclass(1:fl%Ncoeff,:,:) = me_contr(1:fl%Ncoeff,:,:)
      !
      gcorme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      !gcorme(nclass)%me(:,:,:) = 0
      !!
      !do icoeff = 1,fl%Ncoeff
      !  !
      !  iterm = fl%ifromsparse(icoeff)
      !  !
      !  gcorme(nclass)%me(iterm,:,:) = gcorme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
      !  !
      !enddo
      !
      do iclass = 1,nclass-1
        !
        if (nclass_imode(1,iclass)<=imode.and.imode<=nclass_imode(2,iclass)) then 
           imode_ = imode-nclass_imode(1,iclass)+1
           gcorme(iclass)%me(:,:,:) = gcor_class(iclass,imode_)%me
        else
           gcorme(iclass)%me(:,:,:) = gcor_class(iclass,0)%me
        endif
        !
      enddo   
      !
      if (fl%Ncoeff/=me%gcor(imode,jmode)%Ncoeff) then 
        write(out,"('PTstore_contr_matelem error: Ncoeffs do not agree for non-diagonal gcor-fields =',2i8)") &
                    fl%Ncoeff,me%gcor(jmode,imode)%Ncoeff
        stop 'PTstore_contr_matelem error: Ncoeff does not agree for non-diagonal'
      endif
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr')
      !
    end subroutine calc_gcor_me_I




    subroutine calc_grot_me_I(imode,jmode,grotme)

      integer(ik),intent(in) :: imode,jmode
      type(me_class),intent(inout)   :: grotme(PT%Nclasses)
      !
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  :: func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'grot_me matix elements for iclass = ', PT%Nclasses
      !
      func_tag = 'Trot'
      target_index = 0 
      target_index(1) = kinorder
      maxnterms = FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      nterms_field = trove%g_rot(imode,jmode)%Ncoeff
      !
      if (me%grot(imode,jmode)%Ncoeff==0) return
      !
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(grotme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(grotme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = grot_me(iclass)%nterms
        !
        if (iclass==nclass) then 
          nterms = me%grot(imode,jmode)%Ncoeff
          !nterms = me%grot(imode,jmode)%MaxNterms
        endif
        !
        allocate(grotme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(grotme(iclass)%me,kind=hik))
        !
      enddo
      !
      fl => me%grot(imode,jmode)
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      ! compute contracted matrix elements for operators: G, p_i*G
      !
      call calc_contr_matelem_expansion_Trot_Nclass(func_tag,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !call store_contr_matelem_expansion_classN(imode,jmode,nclass,func_tag,nmodes,nmodes,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      !grotme(nclass)%me(:,:,:) = 0
      !
      !do icoeff = 1,fl%Ncoeff
      !  !
      !  !iterm = fl%ifromsparse(icoeff)
      !  !
      !  iterm = fl%icoeff(nclass)%imat(icoeff)
      !  !
      !  grotme(nclass)%me(iterm,:,:) = grotme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
      !  !
      !enddo
      !
      grotme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      do iclass = 1,nclass-1
         grotme(iclass)%me(:,:,:) = grot_class(iclass)%me
      enddo   
      !
      if (fl%Ncoeff/=me%grot(imode,jmode)%Ncoeff) then 
        write(out,"('PTstore_contr_matelem error: Ncoeffs do not agree for non-diagonal grot-fields =',2i8)") &
                     fl%Ncoeff,me%grot(jmode,imode)%Ncoeff
        stop 'PTstore_contr_matelem error: Ncoeff does not agree for non-diagonal'
      endif
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr')
      !
    end subroutine calc_grot_me_I
    !
    !
    subroutine calc_gvib_me_I(imode,jmode,gvibme)

      implicit none
      integer(ik),intent(in) :: imode,jmode
      type(me_class),intent(inout)   :: gvibme(PT%Nclasses)
      !real(rk), allocatable,intent(out)   :: gvibme_Nclass(:,:,:)
      !
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,imode_,jmode_
      integer(ik) :: idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  ::  func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      integer(ik)    ::  nclass_imode(2,PT%Nclasses),kclass
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'gvib_me matix elements for iclass = ', PT%Nclasses
      !
      func_tag = 'Tvib'
      target_index = 0 
      target_index(1) = kinorder
      maxnterms = FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      do kclass=1, PT%nclasses
        nclass_imode(1:2,kclass) = (/PT%mode_class(kclass,1),PT%mode_class(kclass,PT%mode_iclass(kclass))/)
      enddo
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      nterms_field = trove%g_vib(imode,jmode)%Ncoeff
      !
      if (me%gvib(imode,jmode)%Ncoeff==0) return
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(gvibme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(gvibme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = gvib_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%gvib(imode,jmode)%Ncoeff
        !
        allocate(gvibme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(gvibme(iclass)%me,kind=hik))
        !
      enddo
      !
      fl => me%gvib(imode,jmode)
      !
      if (fl%Ncoeff==0) then 
        write (out,"('calc_gvib_me-error: Ncoef = 0 in gvib imode,jmode',2i8)") imode,jmode
        stop 'calc_gvib_me-error: Ncoef = 0 in gvib '
      endif
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr:gvib',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      ! <p_i*G*p_j>
      call calc_contr_matelem_expansion_Tvib_Nclass(func_tag,imode,jmode,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !
      !call store_contr_matelem_expansion_classN(imode,jmode,nclass,func_tag,nmodes,nmodes,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      !gvibme(nclass)%me(:,:,:) = 0
      !
      !do icoeff = 1,fl%Ncoeff
      !  !
      !  !iterm = fl%ifromsparse(icoeff)
      !  iterm = fl%icoeff(nclass)%imat(icoeff)
      !  !
      !  gvibme(nclass)%me(iterm,:,:) = gvibme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
      !  !
      !enddo
      !
      gvibme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      do iclass = 1,nclass-1
        !
        if (nclass_imode(1,iclass)<=imode.and.imode<=nclass_imode(2,iclass).and.&
            nclass_imode(1,iclass)<=jmode.and.jmode<=nclass_imode(2,iclass)) then
           imode_ = imode-nclass_imode(1,iclass)+1
           jmode_ = jmode-nclass_imode(1,iclass)+1
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,imode_,jmode_)%me
        elseif (nclass_imode(1,iclass)<=imode.and.imode<=nclass_imode(2,iclass)) then 
           imode_ = imode-nclass_imode(1,iclass)+1
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,imode_,0)%me
        elseif (nclass_imode(1,iclass)<=jmode.and.jmode<=nclass_imode(2,iclass)) then 
           jmode_ = jmode-nclass_imode(1,iclass)+1
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,0,jmode_)%me
        else
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,0,0)%me
        endif
        !
      enddo   
      !
      if (fl%Ncoeff/=me%gvib(imode,jmode)%Ncoeff) then 
        write(out,"('PTstore_contr_matelem error: Ncoeffs do not agree for non-diagonal gvib-fields =',2i8)") & 
                     fl%Ncoeff,me%gvib(jmode,imode)%Ncoeff
        stop 'PTstore_contr_matelem error: Ncoeff does not agree for non-diagonal'
      endif
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr:gvib')
      !
    end subroutine calc_gvib_me_I


    subroutine deinit_gme_I(gvibme)

      implicit none
      type(me_class),intent(inout)   :: gvibme(PT%Nclasses)
      !
      integer(ik) :: iclass
      character(4)   ::  sclass
      character(cl)  ::  skey
      !
      do iclass = 1,PT%nclasses
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(gvibme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(gvibme(iclass)%me)
        endif
        !
      enddo
      !
    end subroutine deinit_gme_I



    subroutine calc_Vpot_me_I(vpotme)

      type(me_class),intent(inout)   :: vpotme(PT%Nclasses)
      !real(rk), allocatable,intent(out)   :: Vpotme_Nclass(:,:,:)
      !
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  :: func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'Vpot_me matix elements for iclass = ', PT%Nclasses
      !

      func_tag = 'Vpot'
      !
      target_index = 0 
      target_index(1) = PotOrder
      maxnterms= FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      fl => me%poten
      !
      nterms_field = me%poten%Ncoeff
      !
      if (job%verbose>=6) write(out, '(1x,a,1x,f10.3,1x,a,2i9)') 'allocate array "me_contr", size = ',&
                          real(fl%Ncoeff*max(dimen,nprim)**2,rk)*8.0_rk/1024.0_rk**3,'gb',max(dimen,nprim),fl%Ncoeff
      if (job%verbose>=7) then 
        call MemoryReport
      endif
      !
      !matsize = int(nterms_field*dimen*dimen,hik)
      !
      if (allocated(me_contr)) then 
        write (out,"('me_contr is allocated')")
        stop 'me_contr is allocated'
      endif
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)),stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr:Vpot',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      !if (allocated(vpotme_Nclass)) then
      !  call ArrayStop("matelem_Nclass")
      !  deallocate(vpotme_Nclass)
      !endif
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(vpotme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(vpotme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = vpot_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%poten%Ncoeff
        !
        allocate(vpotme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(vpotme(iclass)%me,kind=hik))
        !
      enddo
      !
      !allocate(vpotme_Nclass(nterms_field,dimen,dimen), stat=info)
      !call ArrayStart("matelem_Nclass",info,1_ik,rk,matsize)
      !vpotme_Nclass= 0
      !
      call calc_contr_matelem_expansion_vpot_Nclass(func_tag,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !call store_contr_matelem_expansion_classN(1,1,nclass,func_tag,1,1,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      vpotme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      !vpotme(nclass)%me(:,:,:) = 0
      !
      !do icoeff = 1,fl%Ncoeff
      !  !
      !  !iterm = fl%ifromsparse(icoeff)
      !  iterm = fl%icoeff(nclass)%imat(icoeff)
      !  !
      !  vpotme(nclass)%me(iterm,:,:) = vpotme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
      !  !
      !enddo
      !
      do iclass = 1,nclass-1
         vpotme(iclass)%me(:,:,:) = vpot_class(iclass)%me
      enddo   
      !
      !vpotme_Nclass = me_contr
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr:Vpot')
      !
    end subroutine calc_Vpot_me_I
    !
    !
    subroutine calc_extF_me_I(ipar,extFme)

      integer(ik),intent(in) :: ipar
      type(me_class),intent(inout)   :: extFme(PT%Nclasses)
      !
      !real(rk), allocatable,intent(out)   :: extFme_Nclass(:,:,:)
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  ::  func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      !
      if (job%verbose>=6.and.ipar==1) write(out, '(/1x,a,1x,i3)') 'extF_me matix elements for iclass = ', PT%Nclasses
      !
      if (job%verbose>=6) write(out, '(1x,i6)') ipar
      !
      func_tag = 'extF'
      !
      target_index = 0 
      target_index(1) = ExtFOrder
      maxnterms= FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      if (me%ExtF(ipar)%Ncoeff==0) return
      !
      fl => me%ExtF(ipar)
      !
      nterms_field = maxval(trove%extF(1:extF_rank)%Ncoeff)
      !
      if (job%verbose>=7) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size = ',&
                                       fl%Ncoeff*max(dimen,nprim)**2*8.0/1024.0**3,'gb'
      !
      matsize = int(nterms_field*dimen*dimen,hik)
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      !if (allocated(extFme_Nclass)) then
      !  call ArrayStop("matelem_Nclass")
      !  deallocate(extFme_Nclass)
      !endif
      !
      !allocate(extFme_Nclass(nterms_field,dimen,dimen), stat=info)
      !call ArrayStart("matelem_Nclass",info,1_ik,rk,matsize)
      !extFme_Nclass= 0
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(extFme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(extFme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = extF_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%extF(ipar)%Ncoeff
        !
        allocate(extFme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(extFme(iclass)%me,kind=hik))
        !
      enddo
      !
      call calc_contr_matelem_expansion_extF_Nclass(func_tag,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !call store_contr_matelem_expansion_classN(ipar,1,nclass,func_tag,extF_rank,1,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      extFme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      !extFme(nclass)%me(:,:,:) = 0
      !
      !do icoeff = 1,fl%Ncoeff
      !  !
      !  !iterm = fl%ifromsparse(icoeff)
      !  iterm = fl%icoeff(nclass)%imat(icoeff)
      !  !
      !  extFme(nclass)%me(iterm,:,:) = extFme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
      !  !
      !enddo
      !
      do iclass = 1,nclass-1
         extFme(iclass)%me(:,:,:) = extF_class(iclass)%me
      enddo   
      !
      !extFme_Nclass(1:fl%Ncoeff,:,:) = me_contr(1:fl%Ncoeff,:,:)
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr')
      !
    end subroutine calc_extF_me_I


    subroutine calc_gcor_me(imode,jmode,gcorme)

      integer(ik),intent(in) :: imode,jmode
      type(me_class),intent(inout)   :: gcorme(PT%Nclasses)
      !
      !real(rk), allocatable,intent(out)   :: gcorme_Nclass(:,:,:)
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms,imode_
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  :: func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      integer(ik)    ::  nclass_imode(2,PT%Nclasses),kclass
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'gcor_me matix elements for iclass = ', PT%Nclasses
      !
      func_tag = 'Tcor'
      target_index = 0 
      target_index(1) = kinorder
      maxnterms = FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      do kclass=1, PT%nclasses
        nclass_imode(1:2,kclass) = (/PT%mode_class(kclass,1),PT%mode_class(kclass,PT%mode_iclass(kclass))/)
      enddo
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      nterms_field = trove%g_cor(imode,jmode)%Ncoeff
      !
      if (me%gcor(imode,jmode)%Ncoeff==0) return
      !
      !matsize = int(nterms_field*dimen*dimen,hik)
      !
      !if (job%verbose>=5) write(out,"('  Allocating ',i6,'x',i7,'x',i7,' = ',i12,' gcor matrix of ',f15.4,' gb')") nterms_field,dimen,dimen,& 
      !                    matsize,real(matsize,rk)*8.0_rk/1024.0_rk**3
      !
      !if (allocated(gcorme_Nclass)) then
      !  call ArrayStop("matelem_Nclass")
      !  deallocate(gcorme_Nclass)
      !endif
      !
      !allocate(gcorme_Nclass(nterms_field,dimen,dimen), stat=info)
      !call ArrayStart("matelem_Nclass",info,1_ik,rk,matsize)
      !gcorme_Nclass= 0
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(gcorme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(gcorme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = gcor_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%gcor(imode,jmode)%MaxNterms
        !
        allocate(gcorme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(gcorme(iclass)%me,kind=hik))
        !
      enddo
      !
      fl => me%gcor(imode,jmode)
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      ! compute contracted matrix elements for operators: G, p_i*G
      !
      call calc_contr_matelem_expansion_Tcor_Nclass(func_tag,imode,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !
      !call store_contr_matelem_expansion_classN(imode,jmode,nclass,func_tag,nmodes,nmodes,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      !gcorme_Nclass(1:fl%Ncoeff,:,:) = me_contr(1:fl%Ncoeff,:,:)
      !
      !gcorme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      gcorme(nclass)%me(:,:,:) = 0
      !
      do icoeff = 1,fl%Ncoeff
        !
        iterm = fl%ifromsparse(icoeff)
        !
        gcorme(nclass)%me(iterm,:,:) = gcorme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
        !
      enddo
      !
      do iclass = 1,nclass-1
        !
        if (nclass_imode(1,iclass)<=imode.and.imode<=nclass_imode(2,iclass)) then 
           imode_ = imode-nclass_imode(1,iclass)+1
           gcorme(iclass)%me(:,:,:) = gcor_class(iclass,imode_)%me
        else
           gcorme(iclass)%me(:,:,:) = gcor_class(iclass,0)%me
        endif
        !
      enddo   
      !
      if (fl%Ncoeff/=me%gcor(imode,jmode)%Ncoeff) then 
        write(out,"('PTstore_contr_matelem error: Ncoeffs do not agree for non-diagonal gcor-fields =',2i8)") &
                     fl%Ncoeff,me%gcor(jmode,imode)%Ncoeff
        stop 'PTstore_contr_matelem error: Ncoeff does not agree for non-diagonal'
      endif
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr')
      !
    end subroutine calc_gcor_me


    subroutine calc_grot_me(imode,jmode,grotme)

      integer(ik),intent(in) :: imode,jmode
      type(me_class),intent(inout)   :: grotme(PT%Nclasses)
      !
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  :: func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'grot_me matix elements for iclass = ', PT%Nclasses
      !
      func_tag = 'Trot'
      target_index = 0 
      target_index(1) = kinorder
      maxnterms = FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      nterms_field = trove%g_rot(imode,jmode)%Ncoeff
      !
      if (me%grot(imode,jmode)%Ncoeff==0) return
      !
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(grotme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(grotme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = grot_me(iclass)%nterms
        !
        if (iclass==nclass) then 
          !nterms = me%grot(imode,jmode)%Ncoeff
          nterms = me%grot(imode,jmode)%MaxNterms
        endif
        !
        allocate(grotme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(grotme(iclass)%me,kind=hik))
        !
      enddo
      !
      fl => me%grot(imode,jmode)
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      ! compute contracted matrix elements for operators: G, p_i*G
      !
      call calc_contr_matelem_expansion_Trot_Nclass(func_tag,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !call store_contr_matelem_expansion_classN(imode,jmode,nclass,func_tag,nmodes,nmodes,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      grotme(nclass)%me(:,:,:) = 0
      !
      do icoeff = 1,fl%Ncoeff
        !
        !iterm = fl%ifromsparse(icoeff)
        !
        iterm = fl%icoeff(nclass)%imat(icoeff)
        !
        grotme(nclass)%me(iterm,:,:) = grotme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
        !
      enddo
      !
      do iclass = 1,nclass-1
         grotme(iclass)%me(:,:,:) = grot_class(iclass)%me
      enddo   
      !
      if (fl%Ncoeff/=me%grot(imode,jmode)%Ncoeff) then 
        write(out,"('PTstore_contr_matelem error: Ncoeffs do not agree for non-diagonal grot-fields =',2i8)") &
                     fl%Ncoeff,me%grot(jmode,imode)%Ncoeff
        stop 'PTstore_contr_matelem error: Ncoeff does not agree for non-diagonal'
      endif
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr')
      !
    end subroutine calc_grot_me
    !
    !
    subroutine calc_gvib_me(imode,jmode,gvibme)

      implicit none
      integer(ik),intent(in) :: imode,jmode
      type(me_class),intent(inout)   :: gvibme(PT%Nclasses)
      !real(rk), allocatable,intent(out)   :: gvibme_Nclass(:,:,:)
      !
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,imode_,jmode_
      integer(ik) :: idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  ::  func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      integer(ik)    ::  nclass_imode(2,PT%Nclasses),kclass
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'gvib_me matix elements for iclass = ', PT%Nclasses
      !
      func_tag = 'Tvib'
      target_index = 0 
      target_index(1) = kinorder
      maxnterms = FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      do kclass=1, PT%nclasses
        nclass_imode(1:2,kclass) = (/PT%mode_class(kclass,1),PT%mode_class(kclass,PT%mode_iclass(kclass))/)
      enddo
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      nterms_field = trove%g_vib(imode,jmode)%Ncoeff
      !
      if (me%gvib(imode,jmode)%Ncoeff==0) return
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(gvibme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(gvibme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = gvib_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%gvib(imode,jmode)%MaxNterms
        !
        allocate(gvibme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(gvibme(iclass)%me,kind=hik))
        !
      enddo
      !
      fl => me%gvib(imode,jmode)
      !
      if (fl%Ncoeff==0) then 
        write (out,"('calc_gvib_me-error: Ncoef = 0 in gvib imode,jmode',2i8)") imode,jmode
        stop 'calc_gvib_me-error: Ncoef = 0 in gvib '
      endif
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr:gvib',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      ! <p_i*G*p_j>
      call calc_contr_matelem_expansion_Tvib_Nclass(func_tag,imode,jmode,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !
      !call store_contr_matelem_expansion_classN(imode,jmode,nclass,func_tag,nmodes,nmodes,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      gvibme(nclass)%me(:,:,:) = 0
      !
      do icoeff = 1,fl%Ncoeff
        !
        !iterm = fl%ifromsparse(icoeff)
        iterm = fl%icoeff(nclass)%imat(icoeff)
        !
        gvibme(nclass)%me(iterm,:,:) = gvibme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
        !
      enddo
      !
      !gvibme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      do iclass = 1,nclass-1
        !
        if (nclass_imode(1,iclass)<=imode.and.imode<=nclass_imode(2,iclass).and.&
            nclass_imode(1,iclass)<=jmode.and.jmode<=nclass_imode(2,iclass)) then
           imode_ = imode-nclass_imode(1,iclass)+1
           jmode_ = jmode-nclass_imode(1,iclass)+1
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,imode_,jmode_)%me
        elseif (nclass_imode(1,iclass)<=imode.and.imode<=nclass_imode(2,iclass)) then 
           imode_ = imode-nclass_imode(1,iclass)+1
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,imode_,0)%me
        elseif (nclass_imode(1,iclass)<=jmode.and.jmode<=nclass_imode(2,iclass)) then 
           jmode_ = jmode-nclass_imode(1,iclass)+1
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,0,jmode_)%me
        else
           gvibme(iclass)%me(:,:,:) = gvib_class(iclass,0,0)%me
        endif
        !
      enddo   
      !
      if (fl%Ncoeff/=me%gvib(imode,jmode)%Ncoeff) then 
        write(out,"('PTstore_contr_matelem error: Ncoeffs do not agree for non-diagonal gvib-fields =',2i8)") &
                     fl%Ncoeff,me%gvib(jmode,imode)%Ncoeff
        stop 'PTstore_contr_matelem error: Ncoeff does not agree for non-diagonal'
      endif
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr:gvib')
      !
    end subroutine calc_gvib_me


    subroutine calc_Vpot_me(vpotme)

      type(me_class),intent(inout)   :: vpotme(PT%Nclasses)
      !real(rk), allocatable,intent(out)   :: Vpotme_Nclass(:,:,:)
      !
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  :: func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      !
      if (job%verbose>=6) write(out, '(/1x,a,1x,i3)') 'Vpot_me matix elements for iclass = ', PT%Nclasses
      !

      func_tag = 'Vpot'
      !
      target_index = 0 
      target_index(1) = PotOrder
      maxnterms= FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      fl => me%poten
      !
      nterms_field = me%poten%Ncoeff
      !
      if (job%verbose>=6) write(out, '(1x,a,1x,f10.3,1x,a,2i9)') 'allocate array "me_contr", size = ',&
                                real(fl%Ncoeff*max(dimen,nprim)**2,rk)*8.0_rk/1024.0_rk**3,'gb',max(dimen,nprim),fl%Ncoeff
      if (job%verbose>=7) then 
        call MemoryReport
      endif
      !
      !matsize = int(nterms_field*dimen*dimen,hik)
      !
      if (allocated(me_contr)) then 
        write (out,"('me_contr is allocated')")
        stop 'me_contr is allocated'
      endif
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)),stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr:Vpot',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      !if (allocated(vpotme_Nclass)) then
      !  call ArrayStop("matelem_Nclass")
      !  deallocate(vpotme_Nclass)
      !endif
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(vpotme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(vpotme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = vpot_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%poten%MaxNterms
        !
        allocate(vpotme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(vpotme(iclass)%me,kind=hik))
        !
      enddo
      !
      !allocate(vpotme_Nclass(nterms_field,dimen,dimen), stat=info)
      !call ArrayStart("matelem_Nclass",info,1_ik,rk,matsize)
      !vpotme_Nclass= 0
      !
      call calc_contr_matelem_expansion_vpot_Nclass(func_tag,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !call store_contr_matelem_expansion_classN(1,1,nclass,func_tag,1,1,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      !vpotme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      vpotme(nclass)%me(:,:,:) = 0
      !
      do icoeff = 1,fl%Ncoeff
        !
        !iterm = fl%ifromsparse(icoeff)
        iterm = fl%icoeff(nclass)%imat(icoeff)
        !
        vpotme(nclass)%me(iterm,:,:) = vpotme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
        !
      enddo
      !
      do iclass = 1,nclass-1
         vpotme(iclass)%me(:,:,:) = vpot_class(iclass)%me
      enddo   
      !
      !vpotme_Nclass = me_contr
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr:Vpot')
      !
    end subroutine calc_Vpot_me
    !
    !
    subroutine calc_extF_me(ipar,extFme)

      integer(ik),intent(in) :: ipar
      type(me_class),intent(inout)   :: extFme(PT%Nclasses)
      !
      !real(rk), allocatable,intent(out)   :: extFme_Nclass(:,:,:)
      integer(ik) :: iclass,nclass,dimen,nprim,ilevel,ideg,iroot,nterms_field,icoeff,iterm,info,Nmodes,idimen,nterms
      integer(hik) :: matsize
      type(PTcoeffT),pointer  :: fl 
      real(rk), allocatable   :: me_contr(:,:,:)
      character(cl)  ::  func_tag
      integer(ik)    ::  target_index(PT%Nmodes),maxnterms
      character(4)   ::  sclass
      character(cl)  ::  skey
      !
      if (job%verbose>=6.and.ipar==1) write(out, '(/1x,a,1x,i3)') 'extF_me matix elements for iclass = ', PT%Nclasses
      !
      if (job%verbose>=6) write(out, '(1x,i6)') ipar
      !
      func_tag = 'extF'
      !
      target_index = 0 
      target_index(1) = ExtFOrder
      maxnterms= FLQindex(trove%Nmodes_e,target_index)
      Nmodes = PT%Nmodes
      !
      nclass = PT%Nclasses
      dimen = contr(nclass)%nroots
      nprim = contr(nclass)%dimen
      !
      if (me%ExtF(ipar)%Ncoeff==0) return
      !
      fl => me%ExtF(ipar)
      !
      nterms_field = maxval(trove%extF(1:extF_rank)%Ncoeff)
      !
      if (job%verbose>=7) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size = ',&
                                     fl%Ncoeff*max(dimen,nprim)**2*8.0/1024.0**3,'gb'
      !
      matsize = int(nterms_field*dimen*dimen,hik)
      !
      allocate(me_contr(fl%Ncoeff,max(dimen,nprim),max(dimen,nprim)), stat=info)
      call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
      !
      !if (allocated(extFme_Nclass)) then
      !  call ArrayStop("matelem_Nclass")
      !  deallocate(extFme_Nclass)
      !endif
      !
      !allocate(extFme_Nclass(nterms_field,dimen,dimen), stat=info)
      !call ArrayStart("matelem_Nclass",info,1_ik,rk,matsize)
      !extFme_Nclass= 0
      !
      do iclass = 1,nclass
        !
        write(sclass,'(i4)') iclass
        skey = 'matelem('//trim(adjustl(sclass))//')'
        !
        if (allocated(extFme(iclass)%me)) then
          call ArrayStop(trim(skey))
          deallocate(extFme(iclass)%me)
        endif
        !
        idimen = contr(iclass)%nroots
        nterms = extF_me(iclass)%nterms
        !
        if (iclass==nclass) nterms = me%extF(ipar)%MaxNterms
        !
        allocate(extFme(iclass)%me(nterms,idimen,idimen), stat=info)
        call ArrayStart(trim(skey),info,1_ik,rk,size(extFme(iclass)%me,kind=hik))
        !
      enddo
      !
      call calc_contr_matelem_expansion_extF_Nclass(func_tag,fl%Ncoeff,fl%IndexQ,fl%coeff,prim_vect,me_contr)
      !call store_contr_matelem_expansion_classN(ipar,1,nclass,func_tag,extF_rank,1,dimen,fl%Ncoeff,nterms_field,me_contr)
      !
      !extFme(nclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
      !
      extFme(nclass)%me(:,:,:) = 0
      !
      do icoeff = 1,fl%Ncoeff
        !
        !iterm = fl%ifromsparse(icoeff)
        iterm = fl%icoeff(nclass)%imat(icoeff)
        !
        extFme(nclass)%me(iterm,:,:) = extFme(nclass)%me(iterm,:,:) +  me_contr(icoeff,1:dimen,1:dimen)
        !
      enddo
      !
      do iclass = 1,nclass-1
         extFme(iclass)%me(:,:,:) = extF_class(iclass)%me
      enddo   
      !
      !extFme_Nclass(1:fl%Ncoeff,:,:) = me_contr(1:fl%Ncoeff,:,:)
      !
      deallocate(me_contr)
      call ArrayStop('PTstore_contr_matelem:me_contr')
      !
    end subroutine calc_extF_me
    !
  end subroutine PTcontracted_matelem_class_fast_II 


subroutine store_contr_matelem_expansion_classN(k1,k2,iclass,func_tag,nmodes_class1,nmodes_class2,ncontr,nterms_class,&
                                                nterms_class_max,me_contr)

  integer(ik), intent(in) :: k1,k2,iclass,nmodes_class1,nmodes_class2,ncontr,nterms_class,nterms_class_max
  character(cl), intent(in) :: func_tag
  real(rk), intent(in) :: me_contr(:,:,:)

  integer(ik) :: IOunit, info
  character(cl) :: IOname, filename
  character(4) :: sclass
  logical :: createfile, closefile
  !
  ! we need to do this subroutine only if we want to save checkpoints  for contr-ci
  !
  if (trim(trove%IO_contrCI)/='SAVE') return
  call TimerStart('fast-ci: store class-N'//trim(func_tag))
  !
  write(sclass,'(i4)') iclass
  filename = 'contrME_'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'
  if (iclass/=PT%Nclasses) then 
    write(out,"('store_contr_matelem_expansion_classN is for the Last class ',i5,' only not for ',i6)") PT%Nclasses,iclass
    stop 'store_contr_matelem_expansion_classN is for the Last class only'
  endif 
  createfile = .false.
  closefile = .false.
  if (k1==1.and.k2==1) createfile = .true.
  if (k1==nmodes_class1.and.k2==nmodes_class2) closefile = .true.
  !
  if (k1<1.or.k2<1) then
    write(out, '(/a,1x,2i3)') 'store_contr_matelem_expansion_classN error: k1,k2 =', k1,k2
    stop 'store_contr_matelem_expansion_classN error: illegal k1,k2'
  endif
  !
  select case (trim(func_tag))
    !
  case ('Tcor')
     if (k1>PT%nmodes.or.k2>3) then
       write(out, '(/a,1x,2i5,a)') 'store_contr_matelem_expansion_classN error: k1,k2 =', k1,k2,trim(func_tag)
       write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class1, ']'
       write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class2, ']'
       stop 'store_contr_matelem_expansion_classN error: gcor'
     endif
  case ('Tvib')
     if (k1>PT%nmodes.or.k2>PT%nmodes) then
       write(out, '(/a,1x,2i5,a)') 'store_contr_matelem_expansion_classN error: k1,k2 =', k1,k2,trim(func_tag)
       write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class1, ']'
       write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class2, ']'
       stop 'store_contr_matelem_expansion_classN error: gvib'
     endif
  case ('Trot')
     if (k1>3.or.k2>3) then
       write(out, '(/a,1x,2i5,a)') 'store_contr_matelem_expansion_classN error: k1,k2 =', k1,k2,trim(func_tag)
       stop 'store_contr_matelem_expansion_classN error: grot'
     endif
  case ('Vpot')
     if (k1>1.or.k2>1) then
       write(out, '(/a,1x,2i5,a)') 'store_contr_matelem_expansion_classN error: k1,k2 =', k1,k2,trim(func_tag)
       write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class1, ']'
       write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class2, ']'
       stop 'store_contr_matelem_expansion_classN error: Vpot'
     endif
  case ('extF')
    !
    !if (k1>extF%rank.or.k2>1) then
    !   write(out, '(/a,1x,2i5,a)') 'store_contr_matelem_expansion_classN error: k1,k2 =', k1,k2,trim(func_tag)
    !   write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class1, ']'
    !   write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'is out of ranges = [', 0, ':', nmodes_class2, ']'
    !   stop 'store_contr_matelem_expansion_classN error: extF'
    !endif
    !
  case default 
    !
    write(out, '(/a,1x,2i5,a)') 'store_contr_matelem_expansion_classN error: illegal func_tag',trim(func_tag)
    stop 'store_contr_matelem_expansion_classN error: extF'
   !
  end select 
  !
  IOname = filename
  call IOStart(trim(IOname), IOunit)
  if (createfile) then
    open(IOunit,form='unformatted',action='write',position='rewind',status='replace',file=filename,iostat=info)
  else
    open(IOunit,form='unformatted',action='write',position='append',status='old',file=filename,iostat=info)
  endif
  !
  if (info/=0) then
    write(out, '(/a,a,a)') 'store_contr_matelem_expansion_classN error: cannot create/append file "', trim(filename), '"'
    stop
  endif
  !
  if (createfile) then
    write(IOunit) 'Start contracted matrix elements'
    write(IOunit) iclass, func_tag, nmodes_class1, nmodes_class2, ncontr,nterms_class_max
  endif
  !
  write(IOunit) k1, k2, nterms_class
  write(IOunit) me_contr(1:nterms_class,1:ncontr,1:ncontr)
  !
  if (closefile) then
    write(IOunit) 'End'
  endif
  !
  close(IOunit)
  call IOStop(trim(IOname))
  call TimerStop('fast-ci: store class-N'//trim(func_tag))
  !
end subroutine store_contr_matelem_expansion_classN


subroutine store_fast_ci_uniq(func_tag)

  character(cl), intent(in) :: func_tag
  !
  integer(ik) :: IOunit, info,imode,jmode,ipar,extF_rank
  character(cl) :: IOname, filename
  character(4) :: sclass
  type(PTcoeffT),pointer        :: fl 
  !
  ! we need to do this subroutine only if we want to save checkpoints  for contr-ci
  !
  if (trim(trove%IO_contrCI)/='SAVE') return
  !
  write(sclass,'(i4)') PT%Nclasses

  filename = 'contrME_'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'
  !
  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='write',position='rewind',status='replace',file=filename,iostat=info)
  !
  if (info/=0) then
    write(out, '(/a,a,a)') 'store_fast_ci_uniq error: cannot create file "', trim(filename), '"'
    stop
  endif
  !
  write(IOunit) 'Start fast-ci uniq'
  !
  select case (trim(func_tag))
    !
  case ('Tcor')
     !
     do imode=1,PT%nmodes
       do jmode=1,3
         !
         fl => me%gcor(imode,jmode)
         !
         write(IOunit) fl%uniq
         !
       enddo
     enddo
     !
  case ('Tvib')
     !
     do imode=1,PT%nmodes
       do jmode=1,PT%nmodes
         !
         fl => me%gvib(imode,jmode)
         !
         write(IOunit) fl%uniq
         !
       enddo
     enddo
     !
  case ('Trot')
     !
     do imode=1,3
       do jmode=1,3
         !
         fl => me%grot(imode,jmode)
         !
         write(IOunit) fl%uniq
         !
       enddo
     enddo
     !
  case ('Vpot')
     !
     write(IOunit) me%poten%uniq
     !
  case ('extF')
    !
    extF_rank = FLread_extF_rank()
    !
    do ipar=1, extF_rank
        !
        fl => me%ExtF(ipar)
        write(IOunit) fl%uniq
        !
    enddo
    !
  case default 
    !
    write(out, '(/a,1x,2i5,a)') 'store_fast_ci_uniq error: illegal func_tag',trim(func_tag)
    stop 'store_fast_ci_uniq error'
   !
  end select 
  write(IOunit) 'End'
  !
  close(IOunit)
  call IOStop(trim(IOname))
  !
end subroutine store_fast_ci_uniq




subroutine read_fast_ci_uniq(func_tag)

  character(cl), intent(in) :: func_tag
  !
  integer(ik) :: IOunit, info,imode,jmode,ipar,extF_rank
  character(cl) :: IOname, filename, buf
  character(4) :: sclass
  type(PTcoeffT),pointer        :: fl 
  !
  ! we need to do this subroutine only if we want to save checkpoints  for contr-ci
  !
  if (trim(trove%IO_contrCI)/='READ') return
  !
  write(sclass,'(i4)') PT%Nclasses

  filename = 'contrME_'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'
  !
  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='read',position='rewind',status='old',file=filename,iostat=info)
  !
  if (info/=0) then
    write(out, '(/a,a,a)') 'read_fast_ci_uniq error: cannot open file "', trim(filename), '"'
    stop
  endif
  !
  read(IOunit) buf(1:18)
  if (buf(1:18)/='Start fast-ci uniq') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_fast_ci_uniq error: file "', trim(filename), '" has bogus header', &
    'read:', buf(1:18), &
    'expected:', 'Start fast-ci uniq'
    stop 'read_fast_ci_uniq error'
  endif
  !
  select case (trim(func_tag))
    !
  case ('Tcor')
     !
     do imode=1,PT%nmodes
       do jmode=1,3
         !
         fl => me%gcor(imode,jmode)
         !
         read(IOunit) fl%uniq
         !
       enddo
     enddo
     !
  case ('Tvib')
     !
     do imode=1,PT%nmodes
       do jmode=1,PT%nmodes
         !
         fl => me%gvib(imode,jmode)
         !
         read(IOunit) fl%uniq
         !
       enddo
     enddo
     !
  case ('Trot')
     !
     do imode=1,3
       do jmode=1,3
         !
         fl => me%grot(imode,jmode)
         !
         read(IOunit) fl%uniq
         !
       enddo
     enddo
     !
  case ('Vpot')
     !
     read(IOunit) me%poten%uniq
     !
  case ('extF')
    !
    extF_rank = FLread_extF_rank()
    !
    do ipar=1, extF_rank
        !
        fl => me%ExtF(ipar)
        write(IOunit) fl%uniq
        !
    enddo
    !
  case default 
    !
    write(out, '(/a,1x,2i5,a)') 'read_fast_ci_uniq error: illegal func_tag',trim(func_tag)
    stop 'read_fast_ci_uniq error: illegal tag'
   !
  end select 
  !
  read(IOunit) buf(1:3)
  if (buf(1:3)/='End') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_fast_ci_uniq error: file "', trim(filename), '" has bogus header', &
    'read:', buf(1:3), &
    'expected:', 'End'
    stop 'read_fast_ci_uniq error'
  endif
  !
  close(IOunit)
  call IOStop(trim(IOname))
  !
end subroutine read_fast_ci_uniq






subroutine store_contr_matelem_expansion_II(k1_,k2_,iclass,func_tag,nmodes_class1,nmodes_class2,ncontr,&
                                            nterms_class,me_contr)

  integer(ik), intent(in) :: k1_,k2_,iclass,nmodes_class1,nmodes_class2,ncontr,nterms_class
  character(cl), intent(in) :: func_tag
  real(rk), intent(in) :: me_contr(:,:,:)

  integer(ik) :: IOunit, info
  character(cl) :: IOname, filename
  character(4) :: sclass
  logical :: createfile, closefile
  !
  ! we need to do this subroutine only if we want to save checkpoints  for contr-ci
  !
  if (trim(trove%IO_contrCI)/='SAVE') return
  call TimerStart('fast-ci: store '//trim(func_tag))
  !
  write(sclass,'(i4)') iclass
  filename = 'contrME_'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'

  createfile = .false.
  closefile = .false.
  if (k1_==0.and.k2_==0) createfile = .true.
  if (k1_==nmodes_class1.and.k2_==nmodes_class2) closefile = .true.

  if (k1_<0.or.k1_>nmodes_class1) then
    write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a)') 'store_contr_matelem_expansion_II error: k1 =', &
                  k1_, 'is out of ranges = [', 0, ':', nmodes_class1, ']'
    stop
  endif

  if (k2_<0.or.k2_>nmodes_class2) then
    write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a)') 'store_contr_matelem_expansion_II error: k2 =', &
                k2_, 'is out of ranges = [', 0, ':', nmodes_class2, ']'
    stop
  endif

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  if (createfile) then
    open(IOunit,form='unformatted',action='write',position='rewind',status='replace',file=filename,iostat=info)
  else
    open(IOunit,form='unformatted',action='write',position='append',status='old',file=filename,iostat=info)
  endif

  if (info/=0) then
    write(out, '(/a,a,a)') 'store_contr_matelem_expansion_II error: cannot create/append file "', trim(filename), '"'
    stop
  endif

  if (createfile) then
    write(IOunit) 'Start contracted matrix elements'
    write(IOunit) iclass, func_tag, nmodes_class1, nmodes_class2, ncontr, nterms_class
  endif

  write(IOunit) k1_, k2_, nterms_class
  write(IOunit) me_contr(1:nterms_class,1:ncontr,1:ncontr)

  if (closefile) then
    write(IOunit) 'End'
  endif

  close(IOunit)
  call IOStop(trim(IOname))
  call TimerStop('fast-ci: store '//trim(func_tag))

end subroutine store_contr_matelem_expansion_II



subroutine read_contr_matelem_expansion_II(iclass, func_tag, ncontr, nmodes_class1, nmodes_class2, nterms_class, me_contr)

  integer(ik), intent(in) :: iclass, ncontr, nmodes_class1, nmodes_class2
  character(4), intent(in) :: func_tag
  integer(ik), intent(out) :: nterms_class
  real(rk), allocatable, intent(out) :: me_contr(:,:,:,:,:)

  integer(ik) :: IOunit, info, iclass_, ncontr_, nmodes_class1_, nmodes_class2_, k1, k2, k1_, k2_
  character(cl) :: IOname, filename, buf, func_tag_, sclass

  write(sclass,'(i4)') iclass
  filename = 'contrME_'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='read',position='rewind',status='old',file=filename,iostat=info)
  if (info/=0) then
    write(out, '(/a,a,a)') 'read_contr_matelem_expansion error: cannot open file "', trim(filename), '"'
    stop 'read_contr_matelem_expansion error'
  endif

  read(IOunit) buf(1:32)
  if (buf(1:32)/='Start contracted matrix elements') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_matelem_expansion error: file "', trim(filename), '" has bogus header', &
    'read:', buf(1:32), &
    'expected:', 'Start contracted matrix elements'
    stop 'read_contr_matelem_expansion error'
  endif

  read(IOunit) iclass_, func_tag_, nmodes_class1_, nmodes_class2_, ncontr_, nterms_class

  if (iclass/=iclass_.or.trim(func_tag)/=trim(func_tag_).or.nmodes_class1/=nmodes_class1_.or.&
      nmodes_class2/=nmodes_class2_.or.ncontr/=ncontr_) then
    write(out, '(/a,a,a/a,1x,i0,1x,a,3(1x,i0)/a,1x,i0,1x,a,3(1x,i0))') &
    'read_contr_matelem_expansion error: file "', trim(filename), '" has bogus header', &
    'read: ', iclass_, trim(func_tag_), nmodes_class1_, nmodes_class2_, ncontr_, &
    'expected:', iclass, trim(func_tag), nmodes_class1, nmodes_class2, ncontr
    stop 'read_contr_matelem_expansion error'
  endif

  if (allocated(me_contr)) deallocate(me_contr)
  allocate(me_contr(nterms_class,ncontr,ncontr,0:nmodes_class1,0:nmodes_class2), stat=info)

  if (info/=0) then
    write(out, '(/a/a,10(1x,i8))') &
    'read_contr_matelem_expansion error: failed to allocate me_contr', &
    'nterms_class, ncontr, nmodes_class1, nmodes_class2 =', nterms_class, ncontr, nmodes_class1, nmodes_class2
    stop 'read_contr_matelem_expansion error'
  endif
  me_contr = 0.0

  do k1=0, nmodes_class1
    do k2=0, nmodes_class2
      read(IOunit) k1_, k2_
      if (k1_<0.or.k1_>nmodes_class1) then
        write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a,1x,i3)') &
        'read_contr_matelem_expansion error: index of element k1 =', &
        k1_, 'is out of ranges = [', 0, ':', nmodes_class1, '] for class =', iclass
        stop 'read_contr_matelem_expansion error'
      endif
      if (k2_<0.or.k2_>nmodes_class2) then
        write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a,1x,i3)') &
        'read_contr_matelem_expansion error: index of element k2 =', k2_, 'is out of ranges = [', &
        0, ':', nmodes_class2, '] for class =', iclass
        stop 'read_contr_matelem_expansion error'
      endif
      read(IOunit,iostat=info) me_contr(1:nterms_class,1:ncontr,1:ncontr,k1_,k2_)
      if (info/=0) then
        write(out, '(/a,a,a,1x,i3,1x,i3)') 'read_contr_matelem_expansion error while reading file "', &
        trim(filename), '", element k1, k2 =', k1, k2
        stop 'read_contr_matelem_expansion error'
      endif
    enddo
  enddo

  read(IOunit) buf(1:3)
  if (buf(1:3)/='End') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_matelem_expansion error: file "', trim(filename), '" has bogus footer', &
    'read:', buf(1:3), &
    'expected:', 'End'
    stop 'read_contr_matelem_expansion error'
  endif

  close(IOunit)
  call IOStop(trim(IOname))

end subroutine read_contr_matelem_expansion_II







subroutine read_contr_matelem_expansion_classN(iclass, imode, jmode, func_tag, ncontr, nmodes_class1, &
                                               nmodes_class2, nterms_class, me_contr)

  integer(ik), intent(in) :: iclass, imode, jmode,  ncontr, nmodes_class1, nmodes_class2
  character(4), intent(in) :: func_tag
  integer(ik), intent(out) :: nterms_class
  real(rk), allocatable, intent(out) :: me_contr(:,:,:,:,:)

  integer(ik) :: IOunit, info, iclass_, ncontr_, nmodes_class1_, nmodes_class2_, k1, k2, k1_, k2_, imode_,jmode_
  character(cl) :: IOname, filename, buf, func_tag_, sclass

  write(sclass,'(i4)') iclass
  filename = 'contrME_classN'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='read',position='rewind',status='old',file=filename,iostat=info)
  if (info/=0) then
    write(out, '(/a,a,a)') 'read_contr_matelem_expansion_classN error: cannot open file "', trim(filename), '"'
    stop 'read_contr_matelem_expansion_classN error'
  endif

  read(IOunit) buf(1:32)
  if (buf(1:32)/='Start contracted matrix elements') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_matelem_expansion_classN error: file "', trim(filename), '" has bogus header', &
    'read:', buf(1:32), &
    'expected:', 'Start contracted matrix elements'
    stop 'read_contr_matelem_expansion_classN error'
  endif

  read(IOunit) iclass_, func_tag_, nmodes_class1_, nmodes_class2_, ncontr_, nterms_class

  if (iclass/=iclass_.or.trim(func_tag)/=trim(func_tag_).or.nmodes_class1/=nmodes_class1_.or.&
      nmodes_class2/=nmodes_class2_.or.ncontr/=ncontr_) then
    write(out, '(/a,a,a/a,1x,i0,1x,a,3(1x,i0)/a,1x,i0,1x,a,3(1x,i0))') &
    'read_contr_matelem_expansion_classN error: file "', trim(filename), '" has bogus header', &
    'read: ', iclass_, trim(func_tag_), nmodes_class1_, nmodes_class2_, ncontr_, &
    'expected:', iclass, trim(func_tag), nmodes_class1, nmodes_class2, ncontr
    stop 'read_contr_matelem_expansion_classN error'
  endif

  if (allocated(me_contr)) deallocate(me_contr)
  allocate(me_contr(nterms_class,ncontr,ncontr,0:nmodes_class1,0:nmodes_class2), stat=info)

  if (info/=0) then
    write(out, '(/a/a,10(1x,i8))') &
    'read_contr_matelem_expansion_classN error: failed to allocate me_contr', &
    'nterms_class, ncontr, nmodes_class1, nmodes_class2 =', nterms_class, ncontr, nmodes_class1, nmodes_class2
    stop 'read_contr_matelem_expansion_classN error'
  endif
  me_contr = 0.0

  do k1=0, nmodes_class1
    do k2=0, nmodes_class2
      read(IOunit) imode_, jmode_, k1_, k2_
      if (k1_<0.or.k1_>nmodes_class1) then
        write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a,1x,i3)') &
        'read_contr_matelem_expansion_classN error: index of element k1 =', k1_, 'is out of ranges = [', &
         0, ':', nmodes_class1, '] for class =', iclass
        stop 'read_contr_matelem_expansion_classN error'
      endif
      if (k2_<0.or.k2_>nmodes_class2) then
        write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a,1x,i3)') &
        'read_contr_matelem_expansion_classN error: index of element k2 =', k2_, 'is out of ranges = [', &
        0, ':', nmodes_class2, '] for class =', iclass
        stop 'read_contr_matelem_expansion_classN error'
      endif
      read(IOunit,iostat=info) me_contr(1:nterms_class,1:ncontr,1:ncontr,k1_,k2_)
      if (info/=0) then
        write(out, '(/a,a,a,1x,i3,1x,i3)') 'read_contr_matelem_expansion_classN error while reading file "', &
         trim(filename), '", element k1, k2 =', k1, k2
        stop 'read_contr_matelem_expansion_classN error'
      endif
    enddo
  enddo

  read(IOunit) buf(1:3)
  if (buf(1:3)/='End') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_matelem_expansion_classN error: file "', trim(filename), '" has bogus footer', &
    'read:', buf(1:3), &
    'expected:', 'End'
    stop 'read_contr_matelem_expansion_classN error'
  endif

  close(IOunit)
  call IOStop(trim(IOname))

end subroutine read_contr_matelem_expansion_classN



  subroutine  PTDVR_free_primitive_basis_functions
       !
       integer(ik) :: ispecies
       !
       do ispecies = 1,PT%Nspecies
         !
         deallocate(dvr%abcissa(ispecies)%coeff1d)
         deallocate(dvr%weight(ispecies)%coeff1d)
         !
         deallocate(dvr%prim_func(ispecies)%coeffs,dvr%prim_dfunc(ispecies)%coeffs)
         !
       enddo
       !
  end subroutine  PTDVR_free_primitive_basis_functions




  subroutine  PTDVR_free_all_fields
       !
       integer(ik)  :: ilevel,nlevels,iclass
       !
       if (.not.trove%DVR) return 
       !
       if (job%verbose>=4) write(out,"('Deallocating DVR objects...')")
       !
       if (associated(dvr%poten)) then 
           deallocate(dvr%poten)
           call ArrayStop('dvr-fields')
       endif 
       !
       if (associated(dvr%gvib)) deallocate(dvr%gvib)
       !
       if (associated(dvr%grot)) deallocate(dvr%grot)
       if (associated(dvr%gcor)) deallocate(dvr%gcor)
       !
       if (associated(dvr%extF)) deallocate(dvr%extF)
       !
       if (associated(dvr%kindex)) deallocate(dvr%kindex)
       if (associated(dvr%icheck_deriv)) deallocate(dvr%icheck_deriv)
       !
       call ArrayStart('contr%eigen%vect-dvr',0,1,4)
       !
       call ArrayStop('contr%eigen%vect-dvr')
       !
       if (associated(dvr%kindex2c)) then 
         deallocate(dvr%kindex2c)
         call ArrayStop('dvr%cindex')
       endif
       !
       if (allocated(contr)) then 
         !
         do iclass = 1,PT%Nclasses
           !
           if (.not.associated(contr(iclass)%eigen) ) cycle
           !
           nlevels = contr(iclass)%nlevels
           !
           do ilevel = 1,nlevels
              !
              nullify(contr(iclass)%eigen(ilevel)%dvr_func)
              !
              if (associated(contr(iclass)%eigen(ilevel)%dvr_func)) deallocate (contr(iclass)%eigen(ilevel)%dvr_func)
              !
           enddo
         enddo
         !
       endif
       !
  end subroutine  PTDVR_free_all_fields


  !
  ! Compute the rotational matrix elements on the symemtrized contracted wavefunctions
  !
  subroutine PTrot_contracted_matelem_class(j)
    !
    integer(ik),intent(in) :: j
    type(PTlevelT),pointer ::  ci,cj
    integer(ik)            :: isize,dimen,nlevels,n,iroot,jroot,k_i,k_j,tau_i,tau_j,icount,jcount,ideg,jdeg,alloc,Jk,dk
    real(rk),allocatable   :: rot_prim(:,:,:),mat(:,:)
    character(len=cl)  :: job_is
    !
    if (j<=0) return
    !
    isize = (j+1)*(j+2)/2
    !
    dimen  = contr(0)%nroots
    nlevels  = contr(0)%nlevels
    !
    allocate(rot_prim(isize,-2:2,0:1),mat(dimen,dimen),stat=alloc)
    call ArrayStart('rot_prim',alloc,size(rot_prim),kind(rot_prim))
    call ArrayStart('rot_prim',alloc,size(mat),kind(mat))
    !
    allocate(me%rot_contr(8,nlevels,nlevels,sym%maxdegen,sym%maxdegen),stat=alloc)
    call ArrayStart('me%rot_contr',alloc,size(me%rot_contr),kind(me%rot_contr))
    !
    me%rot_contr = 0
    !
    !allocate(rot_contr(sym%maxdegen,sym%maxdegen),stat=alloc)
    !
    job_is = 'rot'
    !
    do n=1,8
      !
      mat = 0
      !
      ! read the primitive matrix elements from the 'field' unit
      !
      if (n==8) then
        !
        ! n = 8 -> k**2
        !
        do iroot  = 1,dimen
           !
           k_i   = PT%rot_primindex(iroot-1)%k
           !
           mat(iroot,iroot) = real(k_i**2,rk)
           !
        enddo
        ! 
      else
        !
        call FLread_coeff_matelem(job_is,n,1,rot_prim(:,:,:))
        !
        do iroot  = 1,dimen
           !
           k_i   = PT%rot_primindex(iroot-1)%k
           tau_i = PT%rot_primindex(iroot-1)%tau
           !
           Jk = 1+k_i+(j*(j+1) )/2
           !
           do jroot  = 1,dimen
              !
              k_j   = PT%rot_primindex(jroot-1)%k
              tau_j = PT%rot_primindex(jroot-1)%tau
              dk = k_i - k_j
              !
              if (abs(dk)>2) cycle
              !
              select case(n)
                !
              case (1,3)
                !
                if (tau_i/=tau_j.and.abs(dk)<=1) then 
                  !
                  mat(iroot,jroot) = rot_prim(Jk,dk,tau_i)
                  !
                endif
                !
              case (2)
                !
                if (tau_i==tau_j.and.abs(dk)<=1) then 
                  !
                  mat(iroot,jroot) = rot_prim(Jk,dk,tau_i)
                  !
                endif
                !
              case (4,6)
                !
                if (tau_i==tau_j) then
                  ! 
                  mat(iroot,jroot) = rot_prim(Jk,dk,tau_i)
                  !
                endif
                !
              case (5,7)
                !
                if (tau_i/=tau_j) then
                  ! 
                  mat(iroot,jroot) = rot_prim(Jk,dk,tau_i)
                  !if (iroot>jroot) mat(iroot,jroot) = -mat(iroot,jroot)
                  !
                endif
                !
              end select
              !
           enddo
           !
        enddo
        !
      endif
      !
      do icount = 1,contr(0)%nlevels
        !
        ci => contr(0)%eigen(icount)
        !
        ideg = ci%degeneracy
        !
        do jcount = 1,contr(0)%nlevels
          !
          cj => contr(0)%eigen(jcount)
          !
          jdeg = cj%degeneracy
          !
          me%rot_contr(n,icount,jcount,1:ideg,1:jdeg) = matmul( matmul( transpose(ci%vect),mat ),cj%vect )
          !
          !rot_contr(1:ideg,1:jdeg) = me%rot_contr(n,icount,jcount,1:ideg,1:jdeg)
          !
          !continue
          !
          !print *,n,icount,jcount,me%rot_contr(n,icount,jcount,1:ideg,1:jdeg)
          !
         enddo
         !
      enddo
      !
    enddo
    !
    deallocate(rot_prim,mat)
    call ArrayStop('rot_prim')
    !
  end subroutine PTrot_contracted_matelem_class


  !
  ! This procedure is thought to make the calculations of the contracted mat. elements 
  ! of an arbitrary field (e.g. poten, g_vib, g_rot, g_cor, and extF), 
  ! a general way.
  !
  subroutine PTDVRcontracted_matelem_class (k1,k2,field,func)

    integer(ik),intent(in) :: k1,k2
    real(rk),intent(inout) :: field(:)
    real(rk),external      :: func
    !
    integer(ik) :: icoeff,jcoeff
    integer(hik):: ib
    !
    if (job%verbose>=4) call TimerStart('DVRcontract_matrix_sum_field')
    !
    !$omp parallel do private(icoeff,jcoeff,ib) shared(field) schedule(dynamic)
    do icoeff=1,PT%Maxcontracts
      !
      do jcoeff=1,icoeff
        !
        ib = int(icoeff*(icoeff-1),hik)/2
        ib = ib + jcoeff
        !
        field(ib) = field(ib) + func(icoeff,jcoeff,k1,k2)
        !
      enddo
    enddo
    !$omp end parallel do 
    !
    if (job%verbose>=4) call TimerStop('DVRcontract_matrix_sum_field')
    !
  end subroutine PTDVRcontracted_matelem_class 


  !
  ! This procedure is thought to make the calculations of the contracted mat. elements 
  ! of an arbitrary field (e.g. poten, g_vib, g_rot, g_cor, and extF), 
  ! a general way.
  !
  subroutine PTDVRcontracted_matelem_onthefly_slow(k1,k2,ideriv,jderiv,func,field)

    integer(ik),intent(in) :: k1,k2,ideriv,jderiv
    real(rk),intent(in)    :: func(:)
    real(rk),intent(inout) :: field(:)
    real(rk),allocatable   :: vectori(:),vectorj(:)
    !
    integer(ik) :: icoeff,jcoeff,alloc_p,m,mp1,k,dimen,icase,ilambda,ideg,ilevel,iclasses,jcase,jlambda,&
                   jdeg,jlevel,jclasses
    real(rk)    :: f_t
    integer(hik):: ib
    !
    if (job%verbose>=3) call TimerStart('PTDVRcontracted_matelem_onthefly_slow')
    !
    dimen = dvr%total_size
    !
    !$omp parallel private(vectori,vectorj,alloc_p) shared(field)
    allocate (vectori(dimen),vectorj(dimen),stat=alloc_p)
    if (alloc_p/=0) then
       write (out,"(' Error ',i9,' trying to allocate arrays vectori-2')") alloc_p
       stop 'PTDVRcontracted_.._onthefly, vectori-2 - out of memory'
    end if
    !  
    !$omp do private(icoeff,jcoeff,ib,f_t,m,mp1,k) schedule(dynamic)
    do icoeff=1,PT%Maxcontracts
      !
      if (job%verbose>=6) write(out,"('   icoeff = ',i8)") icoeff
      !
      !call PTDVR_contracted_bases_onthefly(jrot,icoeff,ideriv,vectori)
      !
      icase   = PT%icontr2icase(icoeff,1)
      ilambda = PT%icontr2icase(icoeff,2)
      !
      do iclasses = 1,PT%Nclasses
        !
        ideg = PT%Index_deg(icase)%icoeffs(iclasses,ilambda)
        !
        ilevel = PT%contractive_space(iclasses,icase)
        !
        !vectori(iclasses) = contr(iclasses)%eigen(ilevel)%dvr_func(ideriv,ideg,k)
        !
        do jcoeff=1,icoeff
          !
          jcase   = PT%icontr2icase(jcoeff,1)
          jlambda = PT%icontr2icase(jcoeff,2)
          !
          do jclasses = 1,PT%Nclasses
            !
            jdeg = PT%Index_deg(jcase)%icoeffs(jclasses,jlambda)
            !
            jlevel = PT%contractive_space(jclasses,jcase)
            !
            !vectorj = contr(jclass)%eigen(jlevel)%dvr_func(jderiv,jdeg,k)
            !
            ib = int(icoeff*(icoeff-1),hik)/2
            ib = ib + jcoeff
            !
            f_t = 0
            !
            m = mod(dimen,5)
            !
            if (m/=0) then 
              do k = 1,m
                 !
                 f_t = f_t + func(k)*vectori(k)*vectorj(k)
                 !
              enddo
            endif 
            !
            mp1 = m + 1
            !
            do k = mp1,dimen,5
               !
               f_t = f_t + func(k  )*vectori(k  )*vectorj(k  ) + &
                           func(k+1)*vectori(k+1)*vectorj(k+1) + &
                           func(k+2)*vectori(k+2)*vectorj(k+2) + &
                           func(k+3)*vectori(k+3)*vectorj(k+3) + &
                           func(k+4)*vectori(k+4)*vectorj(k+4)
               !
            enddo
            !
            field(ib) = field(ib) + f_t
            !
          enddo
          !
        enddo
        !
      enddo
      !
    enddo
    !$omp end do
    !
    deallocate (vectori,vectorj)
    !$omp end parallel
    !
    if (job%verbose>=3) call TimerStop('PTDVRcontracted_matelem_onthefly_slow')
    !
  end subroutine PTDVRcontracted_matelem_onthefly_slow 



 subroutine PTDVRcontracted_matelem_all_fields_II(hvib,treat_rotation,grot,gcor)
    !
    real(rk),intent(out)        :: hvib(:,:)
    logical,intent(in)          :: treat_rotation
    !
    real(rk),intent(out) :: grot(:,:,:,:)
    real(rk),intent(out) :: gcor(:,:,:,:)
    !
    real(rk),allocatable   :: vector(:,:)
    !
    integer(ik) :: icoeff,jcoeff,alloc,k,dimen,Nmodes,maxcontr,ideriv,k1,k2,m,mp1,idvr
    integer(ik) :: ib,ib0
    double precision            :: alpha = 1.0d0
    real(rk)                    :: temp,gvib_t(PT%Nmodes),g_t(PT%Nmodes,PT%Nmodes)
    !
    !double precision,external    :: ddot
    !
    if (job%verbose>=3) call TimerStart('PTDVRcontracted_matelem_all')
    !
    if (job%verbose>=4) write(out,"('Contracted matrix elements (all) in DVR representaion...')")
    !
    dimen = dvr%total_size
    Nmodes = PT%Nmodes
    maxcontr = PT%Maxcontracts
    !
    hvib = 0
    !
    idvr = 1
    !
    if (treat_rotation) then 
      !
      grot = 0 
      gcor = 0 
      !
    endif
    !
    allocate (vector(0:PT%Nmodes,PT%Maxcontracts),stat=alloc)
    call ArrayStart('PTDVRcontrac-vect',alloc,size(vector),kind(vector))
    !
    do k = 1,dimen
      !
      if (job%verbose>=6.and.mod(k,1000)==0) write(out,"('   k = ',i8)") k
      !
      !if (job%verbose>=4) call TimerStart('PTDVR_contracted_basis_product')
      !
      !$omp parallel do private(ideriv,icoeff) shared(vector) schedule(dynamic)
      do ideriv = 0,Nmodes
        !
        !if (job%verbose>=6) write(out,"('   ideriv = ',i8)") ideriv
        !
        do icoeff=1,maxcontr
          !
          vector(ideriv,icoeff) = PTDVR_contracted_basis_product(k,icoeff,ideriv)
          !
        enddo
        !
      enddo
      !$omp end parallel do
      !
      !if (job%verbose>=4) call TimerStop('PTDVR_contracted_basis_product')
      !
      ! Potential funciton part 
      !
      !if (job%verbose>=4) call TimerStart('PTDVR-dspr')
      !
      !alpha = dvr%poten(k)
      !
      !call dspr('U',maxcontr,alpha,vector(0,:),1,hvib)
      !
      ! Diagonal vibrational kinetic energy part
      !
      g_t(:,:) = dvr%gvib(:,:,k)
      !
      !omp parallel do private(k1,alpha) shared(hvib) schedule(dynamic)
      !do k1 = 1,Nmodes
      !  !
      !  alpha = g_t(k1,k1)
      !  !
      !  call dspr('U',maxcontr,alpha,vector(k1,:),1,hvib)
      !  !
      !enddo
      !omp end parallel do
      !
      !
      !
      !if (job%verbose>=4) call TimerStop('PTDVR-dspr')
      !
      ! Non-diagonal vibrational kinetic energy part
      !
      !if (job%verbose>=4) call TimerStart('PTDVR-non-diag-gvib')
      !
      !$omp parallel do private(icoeff,alpha,k1,k2,gvib_t,jcoeff,m,mp1) shared(hvib) schedule(dynamic)
      do icoeff=1,maxcontr
        !
        !ib0 = icoeff*(icoeff-1)/2
        !
        alpha = vector(0,icoeff)*dvr%poten(k)
        !
        m = mod(icoeff,5)
        !
        if (m/=0) then
           ! 
           do jcoeff=1,m
             !
             !ib = ib0 + jcoeff
             !
             hvib(icoeff,jcoeff) = hvib(icoeff,jcoeff) + alpha*vector(0,jcoeff)
             !
          enddo
          !
        endif 
        !
        mp1 = m + 1
        !
        do jcoeff = mp1,icoeff,5
          !
          !ib = ib0 + jcoeff
          !
          hvib(icoeff,jcoeff)   = hvib(icoeff,jcoeff  ) + alpha*vector(0,jcoeff  )
          hvib(icoeff,jcoeff+1) = hvib(icoeff,jcoeff+1) + alpha*vector(0,jcoeff+1)
          hvib(icoeff,jcoeff+2) = hvib(icoeff,jcoeff+2) + alpha*vector(0,jcoeff+2)
          hvib(icoeff,jcoeff+3) = hvib(icoeff,jcoeff+3) + alpha*vector(0,jcoeff+3)
          hvib(icoeff,jcoeff+4) = hvib(icoeff,jcoeff+4) + alpha*vector(0,jcoeff+4)
          !hvib(ib+5) = hvib(ib+5) + alpha*vector(0,jcoeff+5)
          !hvib(ib+6) = hvib(ib+6) + alpha*vector(0,jcoeff+6)
          !hvib(ib+7) = hvib(ib+7) + alpha*vector(0,jcoeff+7)
          !hvib(ib+8) = hvib(ib+8) + alpha*vector(0,jcoeff+8)
          !hvib(ib+9) = hvib(ib+9) + alpha*vector(0,jcoeff+9)
          !
        enddo
        !
        do k1 = 1,Nmodes
           !
           do k2 = 1,Nmodes
             gvib_t(k2) = vector(k1,icoeff)*g_t(k1,k2)
           enddo
           !
           !gvib_t(k1) = 0
           !
           do k2 = 1,Nmodes
             !
             !if (k1==k2) cycle
             !
             !m = mod(icoeff,10)
             !
             if (m/=0) then
                ! 
                do jcoeff=1,m
                  !
                  !ib = ib0 + jcoeff
                  !
                  hvib(icoeff,jcoeff) = hvib(icoeff,jcoeff) + gvib_t(k2)*vector(k2,jcoeff)
                  !
               enddo
               !
             endif 
             !
             mp1 = m + 1
             !
             do jcoeff = mp1,icoeff,5
                !
                ib = ib0 + jcoeff
                !
                hvib(icoeff,jcoeff  ) = hvib(icoeff,jcoeff  ) + gvib_t(k2)*vector(k2,jcoeff  )
                hvib(icoeff,jcoeff+1) = hvib(icoeff,jcoeff+1) + gvib_t(k2)*vector(k2,jcoeff+1)
                hvib(icoeff,jcoeff+2) = hvib(icoeff,jcoeff+2) + gvib_t(k2)*vector(k2,jcoeff+2)
                hvib(icoeff,jcoeff+3) = hvib(icoeff,jcoeff+3) + gvib_t(k2)*vector(k2,jcoeff+3)
                hvib(icoeff,jcoeff+4) = hvib(icoeff,jcoeff+4) + gvib_t(k2)*vector(k2,jcoeff+4)
                !hvib(ib+5) = hvib(ib+5) + gvib_t(k2)*vector(k2,jcoeff+5)
                !hvib(ib+6) = hvib(ib+6) + gvib_t(k2)*vector(k2,jcoeff+6)
                !hvib(ib+7) = hvib(ib+7) + gvib_t(k2)*vector(k2,jcoeff+7)
                !hvib(ib+8) = hvib(ib+8) + gvib_t(k2)*vector(k2,jcoeff+8)
                !hvib(ib+9) = hvib(ib+9) + gvib_t(k2)*vector(k2,jcoeff+9)
                !
             enddo
             !
           enddo
           !
        enddo
        !
      enddo
      !$omp end parallel do
      !
      !if (job%verbose>=4) call TimerStop('PTDVR-non-diag-gvib')
      !
      if (treat_rotation) then
        !
        do k1 = 1,3
          do k2 = 1,3
            !
            alpha =dvr%grot(k1,k2,k)
            !
            call dspr('U',maxcontr,alpha,vector(0,:),1,grot(k1,k2,:,:))
            !
          enddo
        enddo
        !
        do k1 = 1,Nmodes
          !
          do k2 = 1,3
            !
            !$omp parallel do private(icoeff,temp,jcoeff) schedule(static)
            do icoeff=1,PT%Maxcontracts
              !
              !ib0 = int(icoeff*(icoeff-1),ik)/2
              !
              temp = vector(k1,icoeff)*dvr%gcor(k1,k2,k)
              !
              do jcoeff=1,icoeff
                 !
                 !ib = ib0 + jcoeff
                 !
                 gcor(k1,k2,icoeff,jcoeff) = gcor(k1,k2,icoeff,jcoeff) + temp*vector(0,jcoeff)
                 !
              enddo
              !
            enddo
            !$omp end parallel do
            !
          enddo
          !
        enddo
        !
      endif
      !
    enddo
    !
    deallocate (vector)
    !
    call ArrayStop('PTDVRcontrac-vect')
    !$omp parallel do private(icoeff,jcoeff) shared(gcor,grot,hvib) schedule(static)
    do icoeff=1,PT%Maxcontracts
      !
      do jcoeff = 1,icoeff-1
         hvib(icoeff,jcoeff)     = hvib(jcoeff,icoeff)
         gcor(:,:,icoeff,jcoeff) = gcor(:,:,jcoeff,icoeff)
         grot(:,:,icoeff,jcoeff) = grot(:,:,jcoeff,icoeff)
      enddo
      !
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) write(out,"('...done!')")
    !
    if (job%verbose>=3) call TimerStop('PTDVRcontracted_matelem_all')
    !
  end subroutine PTDVRcontracted_matelem_all_fields_II



 subroutine PTDVRcontracted_matelem_all_fields(hvib,treat_rotation,grot,gcor)
    !
    real(rk),intent(out)        :: hvib(:,:)
    logical,intent(in)          :: treat_rotation
    !
    real(rk),optional,intent(out) :: grot(:,:,:,:)
    real(rk),optional,intent(out) :: gcor(:,:,:,:)
    !
    real(rk),allocatable   :: vector(:,:)
    !
    integer(ik) :: icoeff,jcoeff,alloc,k,dimen,Nmodes,maxcontr,ideriv,k1,k2,m,mp1,idvr
    integer(ik) :: ib,ib0,kmin,kmax,Nslices,islice,Nswap
    real(rk)    :: temp,gvib_t(0:PT%Nmodes),g_t(PT%Nmodes,PT%Nmodes),gcor_t1(PT%Nmodes,3),&
                   gcor_t2(PT%Nmodes,3),grot_t(3,3)
    !
    !double precision,external    :: ddot
    !
    if (job%verbose>=3) call TimerStart('PTDVRcontracted_matelem_all')
    !
    if (job%verbose>=4) write(out,"('Contracted matrix elements in DVR representaion...')")
    !
    dimen = dvr%total_size
    Nmodes = PT%Nmodes
    maxcontr = PT%Maxcontracts
    !
    hvib = 0
    !
    idvr = 1
    !
    if (treat_rotation) then 
      !
      grot = 0 
      gcor = 0 
      !
    endif
    !
    kmin = 1 ; kmax= dimen
    !
    if (job%iswap(1)/=0.and.trim(job%IOswap_matelem)=='SPLIT') then
      !
      ! number of points per slice
      !
      Nswap = job%iswap(2)
      !
      ! number of swap slices
      !
      Nslices = (dimen/Nswap)+1
      !
      ! the currect slice processed 
      !
      islice = job%iswap(1)
      !
      kmin = (islice-1)*Nswap+1
      kmax = kmin + Nswap - 1 
      !
      if ( islice==Nslices ) kmax = kmin + mod(dimen,Nswap) - 1 
      !
      if (job%verbose>=4) write(out,"(' Number of swap slices = ',i7,' processing DVR points  =  [',i9,'...',i9,']')") &
                          Nslices,kmin,kmax
      !
      !
      if (kmin>dimen.or.kmax>dimen) then 
        write (out,"('DVR-DIVIDE-error: wrong DVR slices requested!' )")
        stop 'DVR-DIVIDE: wrong DVR slices requested'
      endif 
      !
    endif
    !
    allocate (vector(0:PT%Nmodes,PT%Maxcontracts),stat=alloc)
    call ArrayStart('PTDVRcontrac-vect',alloc,size(vector),kind(vector))
    !
    do k = kmin,kmax
      !
      if (job%verbose>=5.and.mod(k,dimen/min(500,dimen))==0) write(out,"('   k = ',i8)") k
      !
      !if (job%verbose>=4) call TimerStart('PTDVR_contracted_basis_product')
      !
      do ideriv = 0,Nmodes
        !
        !if (job%verbose>=6) write(out,"('   ideriv = ',i8)") ideriv
        !
        !$omp parallel do private(icoeff) shared(vector) schedule(static)
        do icoeff=1,maxcontr
          !
          vector(ideriv,icoeff) = PTDVR_contracted_basis_product(k,icoeff,ideriv)
          !
        enddo
        !$omp end parallel do
        !
      enddo
      !
      !if (job%verbose>=4) call TimerStop('PTDVR_contracted_basis_product')
      !
      ! Potential funciton part 
      !
      !if (job%verbose>=4) call TimerStart('PTDVR-dspr')
      !
      !alpha = dvr%poten(k)
      !
      !call dspr('U',maxcontr,alpha,vector(0,:),1,hvib)
      !
      ! Diagonal vibrational kinetic energy part
      !
      g_t(:,:) = dvr%gvib(:,:,k)
      !
      !omp parallel do private(k1,alpha) shared(hvib) schedule(dynamic)
      !do k1 = 1,Nmodes
      !  !
      !  alpha = g_t(k1,k1)
      !  !
      !  call dspr('U',maxcontr,alpha,vector(k1,:),1,hvib)
      !  !
      !enddo
      !omp end parallel do
      !
      !
      !
      !if (job%verbose>=4) call TimerStop('PTDVR-dspr')
      !
      ! Non-diagonal vibrational kinetic energy part
      !
      !if (job%verbose>=4) call TimerStart('PTDVR-non-diag-gvib')
      !
      !$omp parallel do private(icoeff,m,k2,k1,gvib_t,jcoeff,mp1) shared(hvib) schedule(static)
      do icoeff=1,maxcontr
        !
        ! check whether the wavefunciton is not too small to care about 
        !
        temp = sqrt(sum(vector(1:Nmodes,icoeff)**2))
        !
        if ( temp<job%coeff_thresh ) cycle
        !
        ib0 = icoeff*(icoeff-1)/2
        !
        gvib_t(0) = vector(0,icoeff)*dvr%poten(k)
        !
        m = mod(icoeff,5)
        mp1 = m + 1
        !
        do k2 = 1,Nmodes
           !
           gvib_t(k2) = sum(vector(1:Nmodes,icoeff)*g_t(1:Nmodes,k2))
           !
        enddo
        ! 
        do jcoeff=1,icoeff
           !
           hvib(jcoeff,icoeff) = hvib(jcoeff,icoeff) + sum(gvib_t(:)*vector(:,jcoeff))
           !
        enddo
          !
        !endif 
        !
        !do jcoeff = mp1,icoeff,5
        !  !
        !  hvib(jcoeff  ,icoeff) = hvib(jcoeff  ,icoeff) +  sum(gvib_t(:)*vector(:,jcoeff  ))
        !  hvib(jcoeff+1,icoeff) = hvib(jcoeff+1,icoeff) +  sum(gvib_t(:)*vector(:,jcoeff+1))
        !  hvib(jcoeff+2,icoeff) = hvib(jcoeff+2,icoeff) +  sum(gvib_t(:)*vector(:,jcoeff+2))
        !  hvib(jcoeff+3,icoeff) = hvib(jcoeff+3,icoeff) +  sum(gvib_t(:)*vector(:,jcoeff+3))
        !  hvib(jcoeff+4,icoeff) = hvib(jcoeff+4,icoeff) +  sum(gvib_t(:)*vector(:,jcoeff+4))
        !  !
        !enddo
        !
      enddo
      !$omp end parallel do
      !
      !if (job%verbose>=4) call TimerStop('PTDVR-non-diag-gvib')
      !
      if (treat_rotation) then
        !
        !$omp parallel do private(icoeff,m,mp1,k1,gcor_t1,gcor_t2,grot_t,jcoeff) shared(gcor,grot) schedule(static)
        do icoeff=1,PT%Maxcontracts
          !
          !ib0 = icoeff*(icoeff-1)/2
          !
          m = mod(icoeff,5)
          mp1 = m + 1
          !
          do k1 = 1,3
            do k2 = 1,3
              grot_t(:,:) = vector(0,icoeff)*dvr%grot(:,:,k)
            enddo
          enddo
          !
          do k1 = 1,Nmodes
             do k2 = 1,3
               !
              gcor_t1(k1,:) =-vector(k1,icoeff)*dvr%gcor(k1,:,k)
              gcor_t2(k1,:) = vector(0 ,icoeff)*dvr%gcor(k1,:,k)
               !
            enddo
          enddo
          ! 
          do jcoeff=1,icoeff
            !
            grot(:,:,jcoeff,icoeff) = grot(:,:,jcoeff,icoeff) + grot_t(:,:)*vector(0,jcoeff)
            !
            do k1 = 1,Nmodes
              gcor(k1,:,jcoeff,icoeff) = gcor(k1,:,jcoeff,icoeff)+gcor_t1(k1,:)*vector(0,jcoeff)+gcor_t2(k1,:)*vector(k1,jcoeff)
            enddo
            !
          enddo
          !
          !do jcoeff = mp1,icoeff,5
          !  !
          !  ib = ib0 + jcoeff
          !  !
          !  grot(:,:,jcoeff  ,icoeff) = grot(:,:,jcoeff  ,icoeff) + grot_t(:,:)*vector(0,jcoeff  )
          !  grot(:,:,jcoeff+1,icoeff) = grot(:,:,jcoeff+1,icoeff) + grot_t(:,:)*vector(0,jcoeff+1)
          !  grot(:,:,jcoeff+2,icoeff) = grot(:,:,jcoeff+2,icoeff) + grot_t(:,:)*vector(0,jcoeff+2)
          !  grot(:,:,jcoeff+3,icoeff) = grot(:,:,jcoeff+3,icoeff) + grot_t(:,:)*vector(0,jcoeff+3)
          !  grot(:,:,jcoeff+4,icoeff) = grot(:,:,jcoeff+4,icoeff) + grot_t(:,:)*vector(0,jcoeff+4)
          !  !
          !  do k1 = 1,Nmodes
          !     !
          !     gcor(k1,:,jcoeff  ,icoeff) = gcor(k1,:,jcoeff  ,icoeff) + gcor_t1(k1,:)*vector(0,jcoeff  )+gcor_t2(k1,:)*vector(k1,jcoeff  )
          !     gcor(k1,:,jcoeff+1,icoeff) = gcor(k1,:,jcoeff+1,icoeff) + gcor_t1(k1,:)*vector(0,jcoeff+1)+gcor_t2(k1,:)*vector(k1,jcoeff+1)
          !     gcor(k1,:,jcoeff+2,icoeff) = gcor(k1,:,jcoeff+2,icoeff) + gcor_t1(k1,:)*vector(0,jcoeff+2)+gcor_t2(k1,:)*vector(k1,jcoeff+2)
          !     gcor(k1,:,jcoeff+3,icoeff) = gcor(k1,:,jcoeff+3,icoeff) + gcor_t1(k1,:)*vector(0,jcoeff+3)+gcor_t2(k1,:)*vector(k1,jcoeff+3)
          !     gcor(k1,:,jcoeff+4,icoeff) = gcor(k1,:,jcoeff+4,icoeff) + gcor_t1(k1,:)*vector(0,jcoeff+4)+gcor_t2(k1,:)*vector(k1,jcoeff+4)
          !     !
          !  enddo
          !  !
          !enddo
          !
        enddo
        !$omp end parallel do
        !
      endif
      !
    enddo
    !
    !$omp parallel do private(icoeff,jcoeff) shared(gcor,grot,hvib) schedule(static)
    do icoeff=1,PT%Maxcontracts
      !
      do jcoeff = 1,icoeff-1
         hvib(icoeff,jcoeff)     = hvib(jcoeff,icoeff)
         gcor(:,:,icoeff,jcoeff) = gcor(:,:,jcoeff,icoeff)
         grot(:,:,icoeff,jcoeff) = grot(:,:,jcoeff,icoeff)
      enddo
      !
    enddo
    !$omp end parallel do
    !
    deallocate (vector)
    call ArrayStop('PTDVRcontrac-vect')
    !
    if (job%verbose>=4) write(out,"('...done!')")
    !
    if (job%verbose>=3) call TimerStop('PTDVRcontracted_matelem_all')
    !
  end subroutine PTDVRcontracted_matelem_all_fields





 subroutine PTDVRcontracted_matelem_all_fields_compress(hvib,treat_rotation,grot,gcor)
    !
    real(rk),intent(out)        :: hvib(:)
    logical,intent(in)          :: treat_rotation
    !
    real(rk),optional,intent(out) :: grot(:,:,:)
    real(rk),optional,intent(out) :: gcor(:,:,:)
    !
    real(rk),allocatable      :: hvib_t(:,:),vec_stored(:,:,:),vecI(:,:),vecF(:)
    real(rk),allocatable      :: grot_t(:,:,:),gcor_t1(:,:,:),gcor_t2(:,:,:)
    !
    integer(ik),allocatable   :: icontr_stored(:,:,:),istored(:,:),cdimens(:,:)
    integer(ik),allocatable   :: icontrF(:),icontrI(:,:)
    !
    integer(ik) :: icontr,jcontr,alloc,k,dimen,Nmodes,maxcontr,ideriv,k1,k2,iterm
    integer(ik) :: ib,ib0
    real(rk)    :: temp,cdimen_aver_f,idvr
    !
    integer(ik) :: stored_size,unitO,unitC,idimenmax,rec_len,irec_len,cdimen,istore,jstore,idimen,irec,&
                   cdimenI(0:PT%Nmodes),cdimenmax,cdimen_distr(10)
    integer(hik):: matsize
    character(len=cl):: unitfname,filename
    character(len=cl):: swap_file = 'contrbasis'
    !
    !double precision,external    :: ddot
    !
    if (job%verbose>=3) call TimerStart('PTDVRcont_matelem_all_comp')
    !
    if (job%verbose>=4) write(out,"('Contracted matrix elements in DVR representaion...')")
    !
    dimen = dvr%total_size
    Nmodes = PT%Nmodes
    maxcontr = PT%Maxcontracts
    !
    if (job%verbose>=4) write(out,"(' Basis set sizes: contr. = ',i9,'; primitive (DVR) = ',i8)") maxcontr,dimen
    !
    ! preparing matrices to be saved to disk or to be stored in memory and their dimensions
    !
    idimenmax = max(min(int(dimen*job%compress),dimen),1)
    !
    stored_size = min(job%stored_size,maxcontr)
    !
    if (job%verbose>=5) write(out,"(' job%stored_size  = ',i8,' -> ',i8)") job%stored_size,stored_size
    !
    call ArrayStart('PTDVRcontrac-srored-vec',0,1,rk,1_hik)
    call ArrayStart('PTDVRcontrac-srored-index',0,1,ik,1_hik)
    !
    if (stored_size>0) then 
      !
      matsize = int(stored_size,hik)*int(Nmodes+1,hik)*int(idimenmax,hik)
      !
      if (job%verbose>=5) write(out,"(' Allocate  stored matrix of ',i8,' x',i3,' x',i8,' = ',i9,', ',f14.4,'Gb')") & 
                                       stored_size,Nmodes+1,dimen,matsize,real(matsize*8,rk)/1024.0_rk**3
      !
      allocate(vec_stored(dimen,stored_size,0:Nmodes),stat=alloc)
      call ArrayStart('PTDVRcontrac-srored-vec',alloc,1,rk,matsize)
      !
      matsize = int(stored_size,hik)*int(idimenmax,hik)*int(Nmodes+2,hik)
      !
      if (job%verbose>=5) write(out,"(' Allocate istored matrix of ',i8,' x',i3,' x',i8,' = ',i9,', ',f14.4,'Gb')") &
                          stored_size,Nmodes+1,dimen,matsize,real(matsize*4,rk)/1024.0_rk**3
      !
      allocate(icontr_stored(dimen,stored_size,0:Nmodes),stat=alloc)
      !
      call ArrayStart('PTDVRcontrac-srored-index',alloc,1,ik,matsize)
      !
    endif
    !
    allocate(istored(maxcontr,0:Nmodes),stat=alloc)
    call ArrayStart('PTDVRcontrac-srored-index',alloc,size(istored),kind(istored))
    istored = 0
    !
    !allocate(isaved(maxcontr,0:Nmodes),stat=alloc)
    !call ArrayStart('isaved',alloc,size(isaved),kind(isaved))
    !isaved = 0
    !
    allocate(cdimens(maxcontr,0:Nmodes),stat=alloc)
    call ArrayStart('PTDVRcontrac-srored-index',alloc,size(cdimens),ik)
    !
    if (job%verbose>=5) call MemoryReport
    !
    ! this temporaly unit for the vectors 
    !
    unitfname = 'contr. compacted eigenfuncs'
    call iostart(trim(unitfname), unitO)
    !
    ! this temporaly unit for their indices of non-zero elements
    !
    unitfname = 'contr. compacted coeffs'
    call iostart(trim(unitfname), unitC)
    !
    inquire(iolength=rec_len) temp
    rec_len = rec_len*dimen
    !
    inquire(iolength=irec_len) cdimen
    irec_len = irec_len*(dimen+1)
    !
    ! use sctratch 
    !
    if (trim(job%IOswap_matelem)=="NONE") then 
      !
      open(unitO,status='scratch',access='direct',recl=rec_len ) 
      open(unitC,status='scratch',access='direct',recl=irec_len) 
      !
    elseif(trim(job%IOswap_matelem)=="SAVE") then
      !
      ! use the predefined file to store the compacted vectors
      !
      filename = trim(swap_file)//'_vect.tmp'
      open(unitO,access='direct',action = 'readwrite',status='replace',file=filename,recl=rec_len) 
      !
      filename = trim(swap_file)//'_coef.tmp'
      open(unitC,access='direct',action = 'readwrite',status='replace',file=filename,recl=irec_len) 
      !
    elseif(trim(job%IOswap_matelem)=="READ") then
      !
      ! use the predefined file to store the compacted vectors
      !
      filename = trim(swap_file)//'_vect.tmp'
      open(unitO,access='direct',action = 'read',status='old',file=filename,recl=rec_len) 
      !
      filename = trim(swap_file)//'_coef.tmp'
      open(unitC,access='direct',action = 'read',status='old',file=filename,recl=irec_len) 
      !
    endif
    !
    ! prescreen all basis functions, compact and store on the disk
    !
    allocate(vecI(0:Nmodes,dimen),vecF(dimen), stat = alloc)
    call ArrayStart('PTDVRcontrac-vect',alloc,size(vecI),kind(vecI))
    !
    allocate(icontrF(dimen),icontrI(0:Nmodes,dimen), stat = alloc)
    call ArrayStart('PTDVRcontrac-coeff',alloc,size(icontrF),kind(icontrF))
    !
    ! prescreening done for the first time
    !
    if (trim(job%IOswap_matelem)=="SAVE".or.trim(job%IOswap_matelem)=="NONE") then 
       !
       if (job%verbose>=4) write(out,"(/'Pre-screening and compacting...')")
       !
       call TimerStart('Prescreening eigenfuncs')
       !
       cdimenmax = 0
       cdimen_aver_f = 0
       cdimen_distr = 0
       istore = 0
       !
       do icontr=1,maxcontr
         !
         if (job%verbose>=5.and.mod(icontr,maxcontr/min(500,icontr))==0.and.trim(job%IOswap_matelem)=="SAVE") &
             write(out,"('   i = ',i8)") icontr
         !
         do ideriv = 0,Nmodes
           !
           ! prescreen all contr. basis functions, compact and store on the disk
           !
           !$omp parallel do private(k) shared(vecF) schedule(guided)
           do k=1,dimen
             !
             vecF(k) = PTDVR_contracted_basis_product(k,icontr,ideriv)
             !
           enddo
           !$omp end parallel do 
           !
           cdimen = 0 
           icontrF(:) = 0
           !
           do idimen = 1, dimen
              if (abs(vecF(idimen)) > job%coeff_thresh) then
                 cdimen = cdimen + 1
                 icontrF(cdimen) = idimen
                 !
                 !if (cdimen>idimenmax) then 
                 !   !
                 !   write(out,"('idimenmax is too smal (',i9,' vs ',i9,') increase compress-factor, maximum = ',f12.4)") & 
                 !                              idimenmax,cdimen,real(cdimen,rk)/real(dimen,rk)
                 !   stop 'intens: increase compress_factor!'
                 !   !
                 !endif
                 !
                 vecF(cdimen) = vecF(idimen)
                 !
              end if
           end do
           !
           cdimens(icontr,ideriv) = cdimen
           !
           cdimenmax = max(cdimenmax,cdimen)
           !
           ! estimate the distribution of actual sizes between 0..1 with the step = 0.1
           !
           temp = real(cdimen,rk)/real(dimen,rk)
           !
           do k1 = 1,10
             !
             if (temp>(k1-1)*0.1.and.temp<=real(k1*0.1_rk)+small_) cdimen_distr(k1) = cdimen_distr(k1) + 1
             !
           enddo
           !
           cdimen_aver_f = cdimen_aver_f+cdimen
           !
           if (trim(job%IOswap_matelem)=="NONE".and.cdimens(icontr,ideriv)<=idimenmax.and.istore<stored_size) then
             !
             istore = istore + 1
             !
             istored(icontr,ideriv) = istore
             !
             vec_stored(1:cdimen,istore,ideriv) = vecF(1:cdimen)
             icontr_stored(1:cdimen,istore,ideriv) = icontrF(1:cdimen)
             !
           else
             !
             irec = (Nmodes+1)*(icontr-1)+ideriv+1
             !
             write(unitO,rec=irec) vecF(1:cdimen)
             write(unitC,rec=irec) cdimen,icontrF(1:cdimen)
             !
           endif
           !
         enddo
         !
       enddo
       !
       cdimen_aver_f = cdimen_aver_f/real(maxcontr)/real((Nmodes+1))
       !
       if (job%verbose>=4) write(out,"(/a,i9,' with 0.1 step: '/,' ',10f8.2)") &
                                 ' The distribution of the actual dimensions of the contr-vectors between 1 and ',&
                                  dimen,real(cdimen_distr,rk)/real(maxcontr*(Nmodes+1))
       !
       if (job%verbose>=4) write(out,"(' Vectors stored  into the memory =',i9,'; expected = ',i8)") istore,maxcontr
       !
       if (job%verbose>=5) write(out,"(a,i9,'; total dimension ',f12.0,'; average  = ',i9,'; input = ',f12.2)") &
                                     ' Compression: maximal allowed = ',cdimenmax,dimen,cdimen_aver_f,job%compress
       !
       if(trim(job%IOswap_matelem)=="SAVE") then 
         !
         close(unitO,status='keep')
         close(unitC,status='keep')
         !
         return 
       endif
       !
       call TimerStop('Prescreening eigenfuncs')
       !
    else
       !
       if (job%verbose>=4) write(out,"(/'Reading from the disk into the memory...')")
       !
       do icontr=1,maxcontr
         !
         do ideriv = 0,Nmodes
           !
           irec = (Nmodes+1)*(icontr-1)+ideriv+1
           !
           read(unitC,rec=irec) cdimen
           cdimens(icontr,ideriv) = cdimen
           !
         enddo
         !
       enddo
       !
       ! Store some number of vectors into the memory 
       !
       do icontr=1,maxcontr
         !
         if (job%verbose>=5.and.mod(icontr,maxcontr/min(500,icontr))==0) write(out,"('   i = ',i8)") icontr
         !
         do ideriv = 0,Nmodes
           !
           if (cdimens(icontr,ideriv)<=idimenmax.and.istore<stored_size) then
             !
             istore = istore + 1
             !
             istored(icontr,ideriv) = istore
             !
             cdimen = cdimens(icontr,ideriv)
             !
             irec = (Nmodes+1)*(icontr-1)+ideriv+1
             !
             read(unitO,rec=irec) vec_stored(1:cdimen,istore,ideriv)
             read(unitC,rec=irec) cdimen,icontr_stored(1:cdimen,istore,ideriv)
             !
             if (cdimen/=cdimens(icontr,ideriv)) then 
                !
                write(out,"('cdimen and cdimens(icontr,ideriv):',i9,' /= ',i8)") cdimen,cdimens(icontr,ideriv)
                stop 'cdimen <> cdimens'
                !
             endif
             !
           endif
           !
         enddo
         !
       enddo       
       !
    endif
    !
    ! Matrix elements are calculated here: <icontr|H|jcontr> = H(ib)
    !
    hvib = 0
    !
    if (treat_rotation) then 
      !
      grot = 0 
      gcor = 0 
      !
    endif
    !
    allocate (hvib_t(0:PT%Nmodes,dimen),stat=alloc)
    call ArrayStart('PTDVRcontrac-hvib',alloc,size(hvib_t),kind(hvib_t))
    !
    if (treat_rotation) then
      !
      allocate (grot_t(3,3,dimen),stat=alloc)
      call ArrayStart('PTDVRcontrac-grot',alloc,size(grot_t),kind(grot_t))
      !
      allocate (gcor_t1(0:PT%Nmodes,3,dimen),gcor_t2(0:PT%Nmodes,3,dimen),stat=alloc)
      call ArrayStart('PTDVRcontrac-gcor',alloc,size(gcor_t1),kind(gcor_t1))
      call ArrayStart('PTDVRcontrac-gcor',alloc,size(gcor_t2),kind(gcor_t2))
      !
    endif
    !
    ! Start the <icontr|H|jcontr> loops 
    !
    call TimerStart('<icontr|H|jcontr> DVR loops')
    !
    do icontr=1,maxcontr
      !
      if (job%verbose>=5.and.mod(icontr,maxcontr/min(500,icontr))==0) write(out,"('   i = ',i8)") icontr
      !
      ib0 = icontr*(icontr-1)/2
      !
      do ideriv = 0,Nmodes
        !
        if (istored(icontr,ideriv)==0) then
          !
          call TimerStart('Reading eigenfuncs')
          !
          irec = (Nmodes+1)*(icontr-1)+ideriv+1
          !
          cdimen = cdimens(icontr,ideriv)
          !
          read(unitC,rec=irec) cdimen,icontrI(ideriv,1:cdimen)
          read(unitO,rec=irec) vecI(ideriv,1:cdimen)
          !
          if (cdimen/=cdimens(icontr,ideriv)) then 
             !
             write(out,"('cdimen and cdimens(icontr,ideriv):',i9,' /= ',i9,' (ii)')") cdimen,cdimens(icontr,ideriv)
             stop 'cdimen <> cdimens (ii)'
             !
          endif
          !
          cdimenI(ideriv) = cdimen
          !
          call TimerStop('Reading eigenfuncs')
          !
        else
          !
          istore = istored(icontr,ideriv)
          !
          call TimerStart('<icontr|H|jcontr> vector copy ')
          !
          cdimen = cdimens(icontr,ideriv)
          !
          cdimenI(ideriv) = cdimen
          !
          icontrI(ideriv,1:cdimen) = icontr_stored(1:cdimen,istore,ideriv)
          !
          call dcopy(cdimen,vec_stored(1:cdimen,istore,ideriv),1,vecI(ideriv,1:cdimen),1)
          !
          call TimerStop('<icontr|H|jcontr> vector copy ')
          !
        endif
        !
      enddo
      !
      ! Vibrational part 
      !
      call TimerStart('<icontr|H|: Vibrational part ')
      !
      ! Multiplying the left vevtor with the Hamiltonian (vib):
      !
      hvib_t = 0
      !
      idvr = 1
      !
      !$omp parallel do private(idimen,iterm) shared(hvib_t) schedule(guided)
      do idimen = 1,cdimenI(0)
        !
        iterm = icontrI(0,idimen)
        !
        hvib_t(0,iterm) = vecI(0,idimen)*dvr%poten(iterm)
        !
      enddo
      !$omp end parallel do
      !
      do ideriv = 1,Nmodes
        !
        do k2 = 1,Nmodes
          !
          !$omp parallel do private(idimen,iterm) shared(hvib_t) schedule(guided)
          do idimen = 1,cdimenI(k2)
             !
             iterm = icontrI(k2,idimen)
             !
             hvib_t(ideriv,iterm) = hvib_t(ideriv,iterm) + vecI(k2,idimen)*dvr%gvib(k2,ideriv,iterm)
             !
           enddo
           !$omp end parallel do
           !
        enddo
        !
      enddo
      !
      call TimerStop('<icontr|H|: Vibrational part ')
      !
      if (treat_rotation) then
          !
          ! Rotational part
          !
          grot_t = 0
          !
          !$omp parallel do private(idimen,iterm) shared(grot_t) schedule(guided)
          do idimen = 1,cdimenI(0)
            !
            iterm = icontrI(0,idimen)
            !
            do k1 = 1,3
              do k2 = 1,3
                grot_t(:,:,iterm) = vecI(0,idimen)*dvr%grot(:,:,iterm)
              enddo
            enddo
            !
          enddo
          !$omp end parallel do
          !
          ! Coriolis part (1)
          !
          do k1 = 1,Nmodes
            !
            !$omp parallel do private(idimen,iterm) shared(gcor_t1) schedule(guided)
            do idimen = 1,cdimenI(k1)
               !
               iterm = icontrI(k1,idimen)
               !
               do k2 = 1,3
                 !
                 gcor_t1(k1,:,iterm) =-vecI(k1,idimen)*dvr%gcor(k1,:,iterm)
                 !
               enddo
            enddo
            !$omp end parallel do
            !
            ! Coriolis part (2)
            !
            !$omp parallel do private(idimen,iterm) shared(gcor_t1) schedule(guided)
            do idimen = 1,cdimenI(0)
               !
               iterm = icontrI(0,idimen)
               !
               do k2 = 1,3
                 !
                 gcor_t2(k1,:,iterm) = vecI(0 ,idimen)*dvr%gcor(k1,:,iterm)
                 !
               enddo
            enddo
            !$omp end parallel do
            !
          enddo
          !
      endif
      !
      ! complete the matrix element by multiplying with the right vector
      !
      do jcontr = 1,icontr
        !
        ib = ib0 + jcontr
        !
        do ideriv = 0,Nmodes
          !
          ! Read from the disk
          !
          if (istored(jcontr,ideriv)==0) then
            !
            irec = (Nmodes+1)*(jcontr-1)+ideriv+1
            !
            cdimen = cdimens(jcontr,ideriv)
            !
            call TimerStart('Reading eigenfuncs')
            !
            read(unitC, rec = irec) cdimen,icontrI(ideriv,1:cdimen)
            read(unitO, rec = irec) vecI(ideriv,1:cdimen)
            !
            call TimerStop('Reading eigenfuncs')
            !
            call TimerStart('<icontr|H|jcontr>: vib. disk  ')
            !
            call hvib_sum(hvib_t(ideriv,1:dimen),vecI(ideriv,1:cdimen),cdimen,icontrI(ideriv,1:cdimen),temp)
            !
            hvib(ib) = hvib(ib) + temp
            !
            call TimerStop('<icontr|H|jcontr>: vib. disk  ')
            !
            !omp parallel do private(k) reduction(+:dtemp) schedule(guided)
            !do k = 1,cdimen
            !   !
            !   temp = temp + hvib_t(ideriv,icontrI(ideriv,k))*vecI(ideriv,k)
            !   !
            !enddo
            !omp end parallel do
            !
            !hvib(ib) = temp
            !
            if (treat_rotation) then
              !
              call grot_gcor_sum(dimen,idimenmax,cdimens(jcontr,:),icontrI,grot_t,gcor_t1,gcor_t2,vecI,grot(:,:,ib),gcor(:,:,ib))
              !
              !do k = 1,cdimens(jcontr,0)
              !   !
              !   grot(:,:,ib) = grot(:,:,ib) + grot_t(:,:,icontrI(0,k))*vecI(0,k)
              !   !
              !   do k1 = 1,Nmodes
              !      !
              !      gcor(k1,:,ib) = gcor(k1,:,ib) + gcor_t1(k1,:,icontrI(0,k))*vecI(0,k)
              !      !
              !   enddo
              !   !
              !enddo
              !!
              !do k1 = 1,Nmodes
              !   !
              !   do k = 1,cdimens(jcontr,k1)
              !      !
              !      gcor(k1,:,ib) = gcor(k1,:,ib) + gcor_t2(k1,:,icontrI(k1,k))*vecI(k1,k)
              !      !
              !   enddo
              !   !
              !enddo
              !
            endif
            !
          else
            !
            jstore = istored(jcontr,ideriv)
            !
            call TimerStart('<icontr|H|jcontr>: vib. memory')
            !
            cdimen = cdimens(jcontr,ideriv)
            !
            !call TimerStart('<icontr|H|jcontr> ivector copy')
            !
            !icontrI(ideriv,1:cdimen) = icontr_stored(1:cdimen,jstore,ideriv)
            !
            !call TimerStop('<icontr|H|jcontr> ivector copy')
            !
            !call TimerStart('<icontr|H|jcontr> vector copy (2) ')
            !
            !call dcopy(cdimen,vec_stored(:,jstore,ideriv),1,vecI(ideriv,:),1)
            !
            !m = mod(cdimen,5)
            !!
            !if (m/=0) then
            !  !
            !  do k = 1,m
            !     !
            !     icontrI(ideriv,k) = icontr_stored(k,jstore,ideriv)
            !     vecI(ideriv,k) = vec_stored(k,jstore,ideriv)
            !     !
            !  enddo
            !  !
            !endif
            !!
            !mp1 = m + 1
            !omp parallel do private(k) shared(vecI,icontrI) schedule(guided)
            !do k = mp1,cdimen,5
            !   !
            !   vecI(ideriv,k  ) = vec_stored(k  ,ideriv,jstore)
            !   vecI(ideriv,k+1) = vec_stored(k+1,ideriv,jstore)
            !   vecI(ideriv,k+2) = vec_stored(k+2,ideriv,jstore)
            !   vecI(ideriv,k+3) = vec_stored(k+3,ideriv,jstore)
            !   vecI(ideriv,k+4) = vec_stored(k+4,ideriv,jstore)
            !   !
            !   icontrI(ideriv,k  ) = icontr_stored(k  ,ideriv,jstore)
            !   icontrI(ideriv,k+1) = icontr_stored(k+1,ideriv,jstore)
            !   icontrI(ideriv,k+2) = icontr_stored(k+2,ideriv,jstore)
            !   icontrI(ideriv,k+3) = icontr_stored(k+3,ideriv,jstore)
            !   icontrI(ideriv,k+4) = icontr_stored(k+4,ideriv,jstore)
            !   !
            !enddo
            !omp end parallel do
            !
            !call TimerStop('<icontr|H|jcontr> vector copy (2) ')
            !
            !call hvib_sum(hvib_t(ideriv,1:dimen),vecI(ideriv,1:cdimen),cdimen,icontrI(ideriv,1:cdimen),temp)
            !
            call hvib_sum(hvib_t(ideriv,1:dimen),vec_stored(1:cdimen,jstore,ideriv),cdimen,&
                          icontr_stored(1:cdimen,jstore,ideriv),temp)
            !
            hvib(ib) = hvib(ib) + temp
            !
            !omp parallel do private(k) reduction(+:temp) schedule(guided)
            !do k = 1,cdimen
            !   !
            !   temp = temp + hvib_t(ideriv,icontr_stored(k,istore,ideriv))*vec_stored(k,istore,ideriv)
            !   !
            !enddo
            !omp end parallel do
            !
            call TimerStop('<icontr|H|jcontr>: vib. memory')
            !
            !hvib(ib) = temp
            !
            if (treat_rotation) then
              !
              call grot_gcor_sum(dimen,idimenmax,cdimens(jcontr,:),icontr_stored(:,istore,:),grot_t,gcor_t1,gcor_t2,&
                                 vec_stored(:,istore,:),grot(:,:,ib),gcor(:,:,ib))
              !
              !do k = 1,cdimens(jcontr,0)
              !   !
              !   grot(:,:,ib) = grot(:,:,ib) + grot_t(:,:,icontr_stored(k,istore,0))*vec_stored(k,istore,0)
              !   !
              !   do k1 = 1,Nmodes
              !      !
              !      gcor(k1,:,ib) = gcor(k1,:,ib) + gcor_t1(k1,:,icontr_stored(k,istore,0))*vec_stored(k,istore,0)
              !      !
              !   enddo
              !   !
              !enddo
              !!
              !do k1 = 1,Nmodes
              !   !
              !   do k = 1,cdimens(jcontr,k1)
              !      !
              !      gcor(k1,:,ib) = gcor(k1,:,ib) + gcor_t2(k1,:,icontr_stored(k,istore,k1))*vec_stored(k,istore,k1)
              !      !
              !   enddo
              !   !
              !enddo
              !
            endif
            !
          endif 
          !
        enddo
        !
      enddo
      !
    enddo
    !
    call TimerStop('<icontr|H|jcontr> DVR loops')
    !
    if (allocated(icontrI)) deallocate(icontrI)
    if (allocated(icontrF)) deallocate(icontrF)
    if (allocated(icontr_stored)) deallocate(icontr_stored)
    if (allocated(vec_stored)) deallocate(vec_stored)
    if (allocated(hvib_t)) deallocate(hvib_t)
    if (allocated(istored)) deallocate(istored)
    if (allocated(cdimens)) deallocate(cdimens)
    if (allocated(vecI)) deallocate(vecI)
    if (allocated(vecF)) deallocate(vecF)
    if (allocated(grot_t)) deallocate(grot_t)
    if (allocated(gcor_t1)) deallocate(gcor_t1)
    if (allocated(gcor_t2)) deallocate(gcor_t2)
    !
    call ArrayStop('PTDVRcontrac-hvib')
    !
    if (treat_rotation) then
      !
      call ArrayStop('PTDVRcontrac-gcor')
      call ArrayStop('PTDVRcontrac-gcor')
      !
    endif
    !
    call ArrayStop('PTDVRcontrac-vect')
    call ArrayStop('PTDVRcontrac-coeff')
    call ArrayStop('PTDVRcontrac-srored-vec')
    call ArrayStop('PTDVRcontrac-srored-index')
    !
    if (job%verbose>=4) write(out,"('...done!')")
    !
    if (job%verbose>=3) call TimerStop('PTDVRcont_matelem_all_comp')
    !
   contains 
    !
    subroutine hvib_sum(hvib,vec,cdimen,icontr,temp)
      !
      real(rk),intent(in)    :: hvib(:),vec(:)
      integer(ik),intent(in) :: icontr(:),cdimen
      real(rk),intent(out)   :: temp
      integer(ik) :: k,m,mp1
      !
      call TimerStart('<icontr|H|jcontr> hvib_sum')
      !
      temp = 0
      !
      m = mod(cdimen,5)
      !
      if (m/=0) then
        !
        do k = 1,m
           !
           temp = temp + hvib(icontr(k))*vec(k)
           !
        enddo
        !
      endif
      !
      mp1 = m + 1
      !$omp parallel do private(k) reduction(+:temp) schedule(guided)
      do k = mp1,cdimen,5
         !
         temp = temp + hvib(icontr(k  ))*vec(k  )
         temp = temp + hvib(icontr(k+1))*vec(k+1)
         temp = temp + hvib(icontr(k+2))*vec(k+2)
         temp = temp + hvib(icontr(k+3))*vec(k+3)
         temp = temp + hvib(icontr(k+4))*vec(k+4)
         !
      enddo
      !$omp end parallel do
      !
      call TimerStop('<icontr|H|jcontr> hvib_sum')
      !
    end subroutine hvib_sum
    !

    subroutine grot_gcor_sum(dimen,idimenmax,cdimens,icontr,grot_t,gcor_t1,gcor_t2,vec,grot,gcor)
      !
      integer(ik),intent(in) :: dimen,idimenmax,icontr(0:PT%Nmodes,dimen),cdimens(0:PT%Nmodes)
      real(rk),intent(in)    :: grot_t(3,3,dimen),gcor_t1(PT%Nmodes,3,dimen),gcor_t2(PT%Nmodes,3,dimen),vec(0:PT%Nmodes,idimenmax)
      real(rk),intent(out)   :: grot(3,3),gcor(PT%Nmodes,3)
      real(rk)               :: temp
      integer(ik)            :: k,k1,k2
      !
      do k1 = 1,3
        do k2 = 1,3
          !
          temp = 0
          !$omp parallel do private(k) reduction(+:temp) schedule(guided)
          do k = 1,cdimens(0)
            !
            temp = temp + grot_t(k1,k2,icontrI(0,k))*vecI(0,k)
            !
          enddo
          !$omp end parallel do
          !
          grot(k1,k2) = temp
          !
        enddo
      enddo
      !
      do k1 = 1,Nmodes
        do k2 = 1,3
          !
          temp = 0
          !$omp parallel do private(k) reduction(+:temp) schedule(guided)
          do k = 1,cdimens(0)
            !
            temp = temp + gcor_t1(k1,k2,icontrI(0,k))*vecI(0,k)
            !
          enddo
          !$omp end parallel do
          !
          gcor(k1,k2) = temp
          !
        enddo
      enddo

      !
      do k1 = 1,Nmodes
        do k2 = 1,3
          !
          temp = 0
          !$omp parallel do private(k) reduction(+:temp) schedule(guided)
          do k = 1,cdimens(k1)
            !
            temp = temp + gcor_t2(k1,k2,icontrI(k1,k))*vecI(k1,k)
            !
          enddo
          !$omp end parallel do
          !
          gcor(k1,k2) = gcor(k1,k2) + temp
          !
        enddo
      enddo
      !
    end subroutine grot_gcor_sum

    !
  end subroutine PTDVRcontracted_matelem_all_fields_compress






 subroutine PTDVRcontracted_matelem_extF(idvr,extF_rank,extF)
    !
    integer(ik),intent(in) :: extF_rank,idvr
    real(rk),intent(out)   :: extF(:,:,:)
    !
    real(rk),allocatable   :: vector(:)
    !
    integer(ik) :: icoeff,jcoeff,alloc,k,dimen,Nmodes,maxcontr,m,mp1,imu
    integer(ik) :: ib,ib0
    real(rk)    :: extF_(extF_rank),extF_t(extF_rank)
    !
    !double precision,external    :: ddot
    !
    if (job%verbose>=3) call TimerStart('PTDVRcontracted_matelem_extF')
    !
    if (job%verbose>=4) write(out,"('Contracted extF-matrix elements in DVR representaion...')")
    !
    dimen = dvr%total_size
    Nmodes = PT%Nmodes
    maxcontr = PT%Maxcontracts
    !
    extF = 0
    !
    allocate (vector(PT%Maxcontracts),stat=alloc)
    call ArrayStart('PTDVRcontrac-vect',alloc,size(vector),kind(vector))
    !
    do k = 1,dimen
      !
      if (job%verbose>=5.and.mod(k,100)==0) write(out,"('   k = ',i8)") k
      !
      !$omp parallel do private(icoeff) shared(vector) schedule(static)
      do icoeff=1,maxcontr
        !
        vector(icoeff) = PTDVR_contracted_basis_product(k,icoeff,0)
        !
      enddo
      !$omp end parallel do
      !
      extF_(:) = dvr%extF(:,k)
      !
      !$omp parallel do private(icoeff,extF_t,m,jcoeff) shared(extF) schedule(static)
      do icoeff=1,maxcontr
        !
        extF_t(:) = vector(icoeff)*extF_(:)
        do jcoeff=1,icoeff
           extF(:,jcoeff,icoeff) = extF(:,jcoeff,icoeff) + extF_t(:)*vector(jcoeff)
        enddo
        !
      enddo
      !$omp end parallel do
      !
    enddo
    !
    deallocate (vector)
    call ArrayStop('PTDVRcontrac-vect')
    !
    !$omp parallel do private(icoeff,jcoeff) shared(extF) schedule(static)
    do icoeff=1,PT%Maxcontracts
      do jcoeff = 1,icoeff-1
         extF(:,icoeff,jcoeff)     = extF(:,jcoeff,icoeff)
      enddo
    enddo
    !$omp end parallel do
    !
    if (job%verbose>=4) write(out,"('...done!')")
    !
    if (job%verbose>=3) call TimerStop('PTDVRcontracted_matelem_extF')
    !
  end subroutine PTDVRcontracted_matelem_extF



   !
   ! DVR matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Vibrational part of the hamiltonian, potential function
   !
   function DVRpoten_contr_matelem(vl,vr,k1,k2,vector1,vector2) result (poten)

      integer(ik),intent(in)         :: vl,vr
      integer(ik),intent(in)         :: k1,k2 ! not used for this object
      real(rk),intent(in)            :: vector1(dvr%total_size),vector2(dvr%total_size)
      !
      real(rk)                       :: poten
      !
      integer(ik)                   :: k,m,mp1

         if (verbose>=6) write(out,"(/'DVRpoten_contr_matelem/start: dvr matrix elemnts for the hamiltonian ')") 
         !
         if (.not.PTvibrational_me_calc) return
         !
         poten = 0
         !
         m = mod(dvr%total_size,5)
         !
         if (m/=0) then 
           do k = 1,m
              !
              poten = poten + dvr%poten(k)*vector1(k)*vector2(k)
              !
           enddo
         endif 
         !
         mp1 = m + 1
         !
         do k = mp1,dvr%total_size,5
            !
            poten = poten + dvr%poten(k  )*vector1(k  )*vector2(k  ) + &
                            dvr%poten(k+1)*vector1(k+1)*vector2(k+1) + &
                            dvr%poten(k+2)*vector1(k+2)*vector2(k+2) + &
                            dvr%poten(k+3)*vector1(k+3)*vector2(k+3) + &
                            dvr%poten(k+4)*vector1(k+4)*vector2(k+4)
            !
         enddo
         !
      if (verbose>=6) write(out,"('DVRpoten_contr_matelem/end')") 
    
   end function DVRpoten_contr_matelem



   !
   ! DVR matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Vibrational part of the kinetic operator g_vib
   !
   function DVRgvib_contr_matelem(vl,vr,k1,k2,vector1,vector2) result (gvib)

      integer(ik),intent(in)         :: vl,vr,k1,k2
      real(rk),intent(in)            :: vector1(:),vector2(:)
      real(rk)                       :: gvib
      !
      integer(ik)                   :: k

         if (verbose>=6) write(out,"(/'DVRgvib_contr_matelem/start: dvr matrix elemnts for the hamiltonian ')") 
         !
         if (.not.PTvibrational_me_calc) return
         !
         gvib = 0
         !
         do k = 1,dvr%total_size
            !
            gvib = gvib + dvr%gvib(k1,k2,k)*vector1(k)*vector2(k)
            !
         enddo
         !
      if (verbose>=6) write(out,"('DVRgvib_contr_matelem/end')") 
    
   end function DVRgvib_contr_matelem



   !
   ! DVR matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Rotational part of the kinetic energy operator g_rot
   !
   function DVRgrot_contr_matelem(vl,vr,k1,k2,vector1,vector2) result (grot)

      integer(ik),intent(in)         :: vl,vr,k1,k2
      real(rk),intent(in)            :: vector1(:),vector2(:)
      real(rk)                       :: grot
      !
      integer(ik)                   :: k

         if (verbose>=6) write(out,"(/'DVRgrot_contr_matelem/start: dvr matrix elemnts for the hamiltonian ')") 
         !
         if (.not.PTvibrational_me_calc) return
         !
         grot = 0
         !
         do k = 1,dvr%total_size
            !
            grot = grot + dvr%grot(k1,k2,k)*vector1(k)*vector2(k)
            !
         enddo
         !
      if (verbose>=6) write(out,"('DVRgrot_contr_matelem/end')") 
    
   end function DVRgrot_contr_matelem


   !
   ! DVR matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Coriolis part of the kinetic energy operator g_cor
   !
   function DVRgcor_contr_matelem(vl,vr,k1,k2,vector1,vector2) result (gcor)

      integer(ik),intent(in)         :: vl,vr,k1,k2
      real(rk),intent(in)            :: vector1(:),vector2(:)
      real(rk)                       :: gcor
      !
      integer(ik)                   :: k

         if (verbose>=6) write(out,"(/'DVRgcor_contr_matelem/start: dvr matrix elemnts for the hamiltonian ')") 
         !
         if (.not.PTvibrational_me_calc) return
         !
         gcor = 0
         !
         do k = 1,dvr%total_size
            !
            gcor = gcor + dvr%gcor(k1,k2,k)*vector1(k)*vector2(k)
            !
         enddo
         !
      if (verbose>=6) write(out,"('DVRgcor_contr_matelem/end')") 
    
   end function DVRgcor_contr_matelem


   !
   ! DVR matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! ! External field components
   !
   function DVRextF_contr_matelem(vl,vr,imu,k2,vector1,vector2) result (extF)

      integer(ik),intent(in)         :: vl,vr,imu
      integer(ik),intent(in)         :: k2  ! not used for this object
      real(rk),intent(in)            :: vector1(:),vector2(:)
      !
      real(rk)                       :: extF
      !
      integer(ik)                   :: k

         if (verbose>=6) write(out,"(/'DVRextF_contr_matelem/start: dvr matrix elemnts for the hamiltonian ')") 
         !
         if (.not.PTvibrational_me_calc) return
         !
         extF = 0
         !
         do k = 1,dvr%total_size
            !
            extF = extF + dvr%extF(imu,k)*vector1(k)*vector2(k)
            !
         enddo
         !
      if (verbose>=6) write(out,"('DVRextF_contr_matelem/end')") 
    
   end function DVRextF_contr_matelem

  !
  ! find correspondence between contracted quantum numbers: current and for J=0 
  !
  subroutine find_groundstate_icontr(maxcontr)
     !
     integer(ik),intent(out) :: maxcontr
     !
     integer(ik)  :: cnu(0:PT%Nclasses),ideg(0:PT%Nclasses),icase,ib,icontr,iterm,cnu_(1:PT%Nclasses),icontr0,alloc,maxcontr0
     !
     if (job%verbose>=4) write(out,"('   Find correlation between J=0 and J/=0 contr. basis functions...')")
     !
     PT%icase2icontr = 0 
     !icontr2irow(1,1) = 1
     PT%icontr2icase(:,:) = 0
     PT%icontr2icase(1,1) = 1
     !
     maxcontr = size(PT%icontr_cnu,dim=2)
     !
     ! count icontr0-s
     icontr0 = 0
     cnu_ = 0
     !
     do icontr = 1,maxcontr
       !
       if (any(PT%icontr_cnu(1:PT%Nclasses,icontr)/=cnu_(1:PT%Nclasses))) then 
         !
         icontr0 = icontr0 + 1
         cnu_ = PT%icontr_cnu(1:PT%Nclasses,icontr)
         !
       endif
       !
     enddo
     !
     maxcontr0 = icontr0
     !
     allocate(PT%Ncontr02icase0(maxcontr0,2),stat=alloc)
     call ArrayStart('PT%Ncontr02icase0',alloc,size(PT%Ncontr02icase0),kind(PT%Ncontr02icase0))
     !
     ! count ideg0
     icontr0 = 0
     cnu_ = 0
     !
     PT%Ncontr02icase0(1,1) = 1
     PT%Ncontr02icase0(maxcontr0,2) = maxcontr
     !
     do icontr = 1,maxcontr
       !
       if (any(PT%icontr_cnu(1:PT%Nclasses,icontr)/=cnu_(1:PT%Nclasses))) then 
         !
         icontr0 = icontr0 + 1
         cnu_ = PT%icontr_cnu(1:PT%Nclasses,icontr)
         PT%Ncontr02icase0(icontr0,1) = icontr
         if (icontr0>1) PT%Ncontr02icase0(icontr0-1,2) = icontr-1
         !
       endif
       !
     enddo
     !
     ! build correlation
     !
     cnu_ = 0
     icontr0 = 0
     !
     do icase = 1,PT%Maxsymcoeffs
       !
       cnu(:) = PT%contractive_space(:,icase)
       !
       do ib = 1,PT%Index_deg(icase)%size1
         !
         ideg(:) = PT%Index_deg(icase)%icoeffs(:,ib)
         !
         do icontr = 1,size(PT%icontr_cnu,dim=2)
           !
           !cnu_t(1:PT%Nclasses) = PT%icontr_cnu(1:PT%Nclasses,icontr)
           !ideg_t(1:PT%Nclasses) = PT%icontr_ideg(1:PT%Nclasses,icontr)
           !
           if (all(PT%icontr_cnu(1:PT%Nclasses,icontr)==cnu(1:PT%Nclasses)).and.&
               all(PT%icontr_ideg(1:PT%Nclasses,icontr)==ideg(1:PT%Nclasses))) then 
             !
             iterm = icontr
             exit
             !
           endif
           !
         enddo
         !
         PT%icase2icontr(icase,ib) = iterm
         PT%icontr2icase(iterm,1) = icase
         PT%icontr2icase(iterm,2) = ib
         !
         !if (any(PT%icontr_cnu(1:PT%Nclasses,iterm)/=cnu_(1:PT%Nclasses))) then 
         !  !
         !  icontr0 = icontr0 + 1
         !  !
         !  cnu_ = PT%icontr_cnu(1:PT%Nclasses,iterm)
         !  if (iterm>1) PT%icontr2icase(iterm-1,2) = icase-1
         !  PT%icontr2icase(iterm,1) = icase
         !  !
         !endif
         !
       enddo
       !
     enddo
     !
     if (.not.job%vib_rot_contr) return
     !
     allocate(PT%Ncontr0icase(maxcontr0,2),stat=alloc)
     call ArrayStart('PT%Ncontr0icase',alloc,size(PT%Ncontr0icase),kind(PT%Ncontr0icase))
     !
     icontr0 = 0
     cnu_ = 0
     !
     PT%Ncontr0icase(1,1) = 1
     PT%Ncontr0icase(maxcontr0,2) = PT%Maxsymcoeffs
     !
     do icase = 1,PT%Maxsymcoeffs
       !
       cnu(:) = PT%contractive_space(:,icase)
       !
       !do ib = 1,PT%Index_deg(icase)%size1
         !
         if (any(cnu(1:PT%Nclasses)/=cnu_(1:PT%Nclasses))) then 
           !
           icontr0 = icontr0 + 1
           cnu_ = cnu(1:PT%Nclasses)
           PT%Ncontr0icase(icontr0,1) = icase
           if (icontr0>1) PT%Ncontr0icase(icontr0-1,2) = icase-1
           !
         endif
         !
       !enddo
       !
     enddo
     !
  end subroutine find_groundstate_icontr


   !
   ! Matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Vibrational part of the kinetic operator g_vib
   !
   function gvib_contr_matelem_single_term(iterm,im1,im2,nu_i,nu_j,k,k1,k2) result (gvib)

      integer(ik),intent(in)         :: iterm,im1,im2
      integer(ik),intent(in)         :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      integer(ik),intent(in)         :: k(PT%Nmodes)
      integer(ik),intent(in)         :: k1,k2
      real(rk)                       :: gvib
      !
      integer(ik)                   :: imode
      real(rk)                      :: mat(PT%Nmodes)

         if (verbose>=6) write(out,"(/'gvib_contr_matelem_single_term/start: matrix elemnts for the hamiltonian ')") 
         !
         gvib = 1.0_rk
         if (im2<im1) return
         !
         do imode = im1,im2
            !
            !if (imode==PT%Nmodes) then
            !   !
            !   mat(imode) = -0.5_rk*me%gvib(k1,k2)%coeff(iterm,nu_i(imode),nu_j(imode))
            !   !
            if (k1/=imode.and.k2/=imode) then 
              !
              mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
              !
            elseif (k2/=imode) then
              !
              mat(imode) =-me%vibmode(imode,1)%coeff(k(imode),nu_j(imode),nu_i(imode))
              !
            elseif (k1/=imode) then
              !
              mat(imode) = me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))
              !
            else !   if (k1==imode.and.k2==imode) then
              !
              mat(imode) = me%vibmode(imode,2)%coeff(k(imode),nu_i(imode),nu_j(imode))
              !
            endif
            !
         enddo 
         !
         gvib = product(mat(im1:im2))
         ! 
      if (verbose>=6) write(out,"('gvib_contr_matelem_single_term/end')") 
    
   end function gvib_contr_matelem_single_term



   !
   ! Matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Rotational part of the kinetic energy operator g_rot
   !
   function grot_contr_matelem_single_term(iterm,im1,im2,nu_i,nu_j,k,k1,k2) result (grot)

      integer(ik),intent(in)         :: iterm,im1,im2
      integer(ik),intent(in)         :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      integer(ik),intent(in)         :: k(PT%Nmodes)
      integer(ik),intent(in)         :: k1,k2
      real(rk)                      :: grot
      !
      integer(ik)                   :: vr,imode
      real(rk)                      :: mat(PT%Nmodes)

         if (verbose>=6) write(out,"(/'grot_contr_matelem_single_term/start: matrix elemnts for the hamiltonian ')") 
         !
         !if (.not.FLrotation) return 
         !
         do imode = im1,im2
            !
            !if (imode/=PT%Nmodes) then
            !
            mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
            !
            !else
            !   !
            !   mat(imode) = me%grot(k1,k2)%coeff(iterm,nu_i(PT%Nmodes),nu_j(PT%Nmodes))
            !   !
            !endif
            !
         enddo 
         !
         grot = product(mat(im1:im2))
         !
      if (verbose>=6) write(out,"('grot_contr_matelem_single_term/end')") 
    
   end function grot_contr_matelem_single_term


   !
   ! Matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Coriolis part of the kinetic energy operator g_cor
   !
   function gcor_contr_matelem_single_term(iterm,im1,im2,nu_i,nu_j,k,k1,k2) result (gcor)

      integer(ik),intent(in)         :: iterm,im1,im2
      integer(ik),intent(in)         :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      integer(ik),intent(in)         :: k(PT%Nmodes)
      integer(ik),intent(in)         :: k1,k2
      real(rk)                       :: gcor
      !
      integer(ik)                   :: vr,imode
      real(rk)                      :: mat(PT%Nmodes)

         if (verbose>=6) write(out,"(/'gcor_contr_matelem_single_term/start: matrix elemnts for the hamiltonian ')") 
         !
         !if (.not.FLrotation) return
         !
         ! Extract large amplitude quantum numbers
         !
         do imode = im1,im2
           !
           !if (imode/=PT%Nmodes) then
              !
              if (k1/=imode) then 
                 !
                 mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                 !
              else
                 !
                 mat(imode) = me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))-&
                              me%vibmode(imode,1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                 !
                 !
              endif
              !
           !else
           !   !
           !   mat(imode) = me%gcor(k1,k2)%coeff(iterm,nu_i(PT%Nmodes),nu_j(PT%Nmodes))
           !   !
           !endif
           !
         enddo 
         !
         gcor = product(mat(im1:im2))
         !
         !
      if (verbose>=6) write(out,"('gcor_contr_matelem_single_term/end')") 
    
   end function gcor_contr_matelem_single_term



   !
   ! Matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! Vibrational part of the hamiltonian, potential function
   !
   function poten_contr_matelem_single_term(iterm,im1,im2,nu_i,nu_j,k,k1,k2) result (poten)

      integer(ik),intent(in)         :: iterm,im1,im2
      integer(ik),intent(in)         :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      integer(ik),intent(in)         :: k1,k2         !  not used for this object
      integer(ik),intent(in)         :: k(PT%Nmodes)
      real(rk)                       :: poten
      !
      integer(ik)                   :: vr,imode
      real(rk)                      :: mat(PT%Nmodes)

         if (verbose>=6) write(out,"(/'poten_contr_matelem_single_term/start: matrix elemnts for the hamiltonian ')") 
         !
         !if (.not.PTvibrational_me_calc) return
         !
         do imode = im1,im2
            !
            !if (imode==PT%Nmodes) then
            !   !
            !   mat(imode) = me%poten%coeff(iterm,nu_i(PT%Nmodes),nu_j(PT%Nmodes))
            !   !
            !else
               !
               mat(imode) = me%vibmode(imode,0)%coeff(k(imode),nu_i(imode),nu_j(imode))
               !
            !endif
            !
         enddo 
         !
         poten = product(mat(im1:im2))
         !
      if (verbose>=6) write(out,"('poten_contr_matelem_single_term/end')") 
    
   end function poten_contr_matelem_single_term



   !
   ! Matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   ! External field components
   !
   function extF_contr_matelem_single_term(iterm,im1,im2,nu_i,nu_j,k,imu,k2) result (extF)

      integer(ik),intent(in)         :: iterm,im1,im2,imu
      integer(ik),intent(in)         :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      integer(ik),intent(in)         :: k2        !  not used for this object
      integer(ik),intent(in)         :: k(PT%Nmodes)
      real(rk)                       :: extF
      !
      integer(ik)                   :: vr,imode
      real(rk)                      :: mat(PT%Nmodes)

         !
         !if (verbose>=6) write(out,"(/'extF_contr_matelem_single_term/start: matrix elemnts for the hamiltonian ')") 
         !
         do imode = im1,im2
            !
            !if (imode==PT%Nmodes) then
            !   !
            !   mat(imode) = me%extF(imu)%coeff(iterm,nu_i(PT%Nmodes),nu_j(PT%Nmodes))
            !   !
            !else
               !
               mat(imode) = me%vibmode(imode,3)%coeff(k(imode),nu_i(imode),nu_j(imode))
               !
            !endif
            !
         enddo 
         !
         extF = product(mat(im1:im2))
         !
      !if (verbose>=6) write(out,"('extF_contr_matelem_single_term/end')") 
    
   end function extF_contr_matelem_single_term


  !
  !
  ! Contracted matrix elements
  !
  subroutine PTget_primitive_matelements(jrot) 
    !
    integer(ik),intent(in) :: jrot
    !type(FLbasissetT),intent(in)  :: bs(0:PT%Nmodes)
    !
    integer(ik)        :: PotOrder,KinOrder,extForder,MaxExpOrder
    integer(ik)        :: poten_N,gvib_N,grot_N,gcor_N,L2vib_N,Ncoeffs,jmax
    integer(ik)        :: extF_rank,extF_N_
    integer(ik)        :: imu,k1,k2,alloc,isize,ispecies,imode,bsize,Nmodes
    integer(ik),allocatable :: extF_N(:)
    logical            :: treat_rotation
    character(len=cl)  :: job_is
      !
      call TimerStart('Primitive matelements')
      !
      if (job%verbose>=5) write(out,"('PTget_primitive_matelements/start: primitive matrix elements')") 
      !
      extF_rank = FLread_extF_rank()
      !
      allocate(extF_N(max(extF_rank,0)))
      !
      call FLread_fields_dimensions(poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,extF_N,L2vib_N)
      !
      PT%Nterms%poten = poten_N
      PT%Nterms%gvib = gvib_N
      PT%Nterms%grot = grot_N
      PT%Nterms%gcor = gcor_N
      PT%Nterms%jmax = jmax
      Nmodes = PT%Nmodes
      !
      ! Some parts of the Hamiltonian are not needed if J=0 (neither grot nor gcor).
      ! We adopt treat_rotation to switch it on/off
      !
      if (FLrotation.and.jrot/=0) then 
        treat_rotation = .true.
      else
        treat_rotation = .false.
      endif 
      !
      Ncoeffs = max(poten_N,gvib_N,grot_N,gcor_N,L2vib_N)
      MaxExpOrder= max(potorder,kinorder,extForder)
      PT%Nterms%maximal = Ncoeffs
      !
      if (job%verbose>=5) write(out,"('  Allocating and reading me%vibmode objects with primitive matrix elements ...')") 
      !
      if (treat_rotation) then
         !
         job_is = 'rot'
         !
         allocate(me%rot(7),stat=alloc)
         !
         isize = (jmax+1)*(jmax+2)/2
         !
         do k1 =1,size(me%rot(:))
           !
           allocate(me%rot(k1)%coeff(isize,-2:2,0:1),stat=alloc)
           call ArrayStart('me%fields%coeff',alloc,size(me%rot(k1)%coeff),kind(me%rot(k1)%coeff))
           call FLread_coeff_matelem(job_is,k1,1,me%rot(k1)%coeff(:,:,:))
           !
         enddo 
        !
      endif
      !
      allocate (me%vib(1:PT%Nspecies,-1:3))
      !
      do ispecies = 1,PT%Nspecies
        !
        imode = PT%mode_species(ispecies,1)
        !
        job_is = 'vib'
        !
        bsize = job%bset(imode)%range(2)
        !
        k1 = ispecies
        !
        do k2 = -1,3
          !
          allocate (me%vib(k1,k2)%coeff(0:MaxExpOrder,0:bsize,0:bsize),stat=alloc)
          call ArrayStart('me%fields%coeff',alloc,size(me%vib(k1,k2)%coeff),kind(me%vib(k1,k2)%coeff))
          !
          call FLread_coeff_matelem(job_is,k1,k2,me%vib(k1,k2)%coeff(:,:,:))
          !
        enddo
        !
      enddo
      !
      allocate (me%vibmode(1:PT%Nmodes,-1:3))
      !
      do imode = 1,PT%Nmodes
        !
        job_is = 'vib'
        !
        bsize = job%bset(imode)%range(2)
        ispecies = job%bset(imode)%species
        !
        do k2 = -1,3
          !
          allocate (me%vibmode(imode,k2)%coeff(0:MaxExpOrder,0:bsize,0:bsize),stat=alloc)
          call ArrayStart('me%fields%coeff',alloc,size(me%vibmode(imode,k2)%coeff),kind(me%vibmode(imode,k2)%coeff))
          !
          call FLread_coeff_matelem(job_is,ispecies,k2,me%vibmode(imode,k2)%coeff(:,:,:))
          !
        enddo
        !
      enddo
      !
      if (job%verbose>=5) write(out,"('  ...done!')") 
      if (job%verbose>=5) write(out,"('  Allocating objects for the contracted matrix elements ...')") 
      !
      bsize = job%bset(PT%Nmodes)%range(2)
      !
      allocate (me%poten,stat=alloc)
      !
      job_is = 'poten'
      !
      poten_N = FLread_fields_dimension_field(job_is,0,0)
      !
      allocate (me%poten%coeff(poten_N,0:bsize,0:bsize),me%poten%iorder(poten_N),me%poten%IndexQ(Nmodes,poten_N),stat=alloc)
      call ArrayStart('me%fields%coeff',alloc,size(me%poten%coeff),kind(me%poten%coeff))
      call ArrayStart('me%fields%coeff',alloc,size(me%poten%iorder),kind(me%poten%iorder))
      call ArrayStart('me%fields%IndexQ',alloc,size(me%poten%IndexQ),kind(me%poten%IndexQ))
      call ArrayStart('me%fields%iorder',alloc,size(me%poten%IndexQ),kind(me%poten%iorder))
      call FLread_coeff_matelem(job_is,1,1,me%poten%coeff(:,:,:))
      call FLread_IndexQ_field(job_is,1,1,me%poten%IndexQ(:,:))
      !
      me%poten%iorder = 0 
      me%poten%Ncoeff = poten_N
      !
      allocate (me%gvib(Nmodes,Nmodes),stat=alloc)
      !
      job_is = 'gvib'
      do k1 = 1,Nmodes
         do k2 = 1,Nmodes
            !
            gvib_N = FLread_fields_dimension_field(job_is,k1,k2)
            me%gvib(k1,k2)%Ncoeff = gvib_N
            if (gvib_N<1) cycle
            !
            allocate (me%gvib(k1,k2)%coeff(gvib_N,0:bsize,0:bsize),me%gvib(k1,k2)%IndexQ(Nmodes,gvib_N),&
                      me%gvib(k1,k2)%iorder(gvib_N),stat=alloc)
            call ArrayStart('me%fields%coeff',alloc,size(me%gvib(k1,k2)%coeff),kind(me%gvib(k1,k2)%coeff))
            call ArrayStart('me%fields%IndexQ',alloc,size(me%gvib(k1,k2)%IndexQ),kind(me%gvib(k1,k2)%IndexQ))
            call ArrayStart('me%fields%iorder',alloc,size(me%gvib(k1,k2)%IndexQ),kind(me%gvib(k1,k2)%iorder))
            call FLread_coeff_matelem(job_is,k1,k2,me%gvib(k1,k2)%coeff(:,:,:))
            call FLread_IndexQ_field(job_is,k1,k2,me%gvib(k1,k2)%IndexQ(:,:))
            !
            me%gvib(k1,k2)%iorder = 0 
            !
         enddo
      enddo
      !
      allocate (me%grot(3,3),stat=alloc)
      !
      job_is = 'grot'
      do k1 = 1,3
         do k2 = 1,3
            !
            grot_N = FLread_fields_dimension_field(job_is,k1,k2)
            me%grot(k1,k2)%Ncoeff = grot_N
            if (grot_N<1) cycle
            !
            allocate (me%grot(k1,k2)%coeff(grot_N,0:bsize,0:bsize),me%grot(k1,k2)%IndexQ(Nmodes,grot_N),&
                      me%grot(k1,k2)%iorder(grot_N),stat=alloc)
            call ArrayStart('me%fields%coeff',alloc,size(me%grot(k1,k2)%coeff),kind(me%grot(k1,k2)%coeff))
            call ArrayStart('me%fields%IndexQ',alloc,size(me%grot(k1,k2)%IndexQ),kind(me%grot(k1,k2)%IndexQ))
            call ArrayStart('me%fields%iorder',alloc,size(me%grot(k1,k2)%IndexQ),kind(me%grot(k1,k2)%iorder))
            call FLread_coeff_matelem(job_is,k1,k2,me%grot(k1,k2)%coeff(:,:,:))
            call FLread_IndexQ_field(job_is,k1,k2,me%grot(k1,k2)%IndexQ(:,:))
            !
            me%grot(k1,k2)%iorder = 0 
            !
         enddo
      enddo
      !
      allocate (me%gcor(PT%Nmodes,3),stat=alloc)
      !
      job_is = 'gcor'
      do k1 = 1,PT%Nmodes
         do k2 = 1,3
            !
            gcor_N = FLread_fields_dimension_field(job_is,k1,k2)
            me%gcor(k1,k2)%Ncoeff = gcor_N
            if (gcor_N<1) cycle
            !
            allocate (me%gcor(k1,k2)%coeff(gcor_N,0:bsize,0:bsize),me%gcor(k1,k2)%IndexQ(Nmodes,gcor_N),&
                      me%gcor(k1,k2)%iorder(gcor_N),stat=alloc)
            call ArrayStart('me%fields%coeff',alloc,size(me%gcor(k1,k2)%coeff),kind(me%gcor(k1,k2)%coeff))
            call ArrayStart('me%fields%IndexQ',alloc,size(me%gcor(k1,k2)%IndexQ),kind(me%gcor(k1,k2)%IndexQ))
            call ArrayStart('me%fields%iorder',alloc,size(me%gcor(k1,k2)%IndexQ),kind(me%gcor(k1,k2)%iorder))
            call FLread_coeff_matelem(job_is,k1,k2,me%gcor(k1,k2)%coeff(:,:,:))
            call FLread_IndexQ_field(job_is,k1,k2,me%gcor(k1,k2)%IndexQ(:,:))
            !
            me%gcor(k1,k2)%iorder = 0 
            !
         enddo
      enddo
      !
      ! Vibrational angular momentum L2
      !
      if (FLl2_coeffs) then
        !
        allocate (me%L2(PT%Nmodes,PT%Nmodes),stat=alloc)
        !
        job_is = 'L2_vib'
        do k1 = 1,PT%Nmodes
           do k2 = 1,PT%Nmodes
              !
              L2vib_N = FLread_fields_dimension_field(job_is,k1,k2)
              me%L2(k1,k2)%Ncoeff = L2vib_N
              if (L2vib_N<1) cycle
              !
              allocate (me%L2(k1,k2)%coeff(L2vib_N,0:bsize,0:bsize),me%L2(k1,k2)%IndexQ(Nmodes,L2vib_N),&
                        me%L2(k1,k2)%iorder(L2vib_N),stat=alloc)
              call ArrayStart('me%fields%coeff',alloc,size(me%L2(k1,k2)%coeff),kind(me%L2(k1,k2)%coeff))
              call ArrayStart('me%fields%IndexQ',alloc,size(me%L2(k1,k2)%IndexQ),kind(me%L2(k1,k2)%IndexQ))
              call ArrayStart('me%fields%iorder',alloc,size(me%L2(k1,k2)%IndexQ),kind(me%L2(k1,k2)%iorder))
              call FLread_coeff_matelem(job_is,k1,k2,me%L2(k1,k2)%coeff(:,:,:))
              call FLread_IndexQ_field(job_is,k1,k2,me%L2(k1,k2)%IndexQ(:,:))
              !
              me%L2(k1,k2)%iorder = 0 
              !
           enddo
        enddo
        !
      endif
      !
      ! external field partr - optional 
      !
      if (trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT') then 
        !
        allocate (me%extF(extF_rank),stat=alloc)
        !
        job_is = 'externalF'
        do imu = 1,extF_rank
           !
           extF_N_ = FLread_fields_dimension_field(job_is,imu,0)
           me%extF(imu)%Ncoeff = extF_N(imu)
           !
           if (extF_N_<1) cycle
           !
           allocate (me%extF(imu)%coeff(extF_N_,0:bsize,0:bsize),me%extF(imu)%IndexQ(Nmodes,extF_N_),&
                     me%extF(imu)%iorder(extF_N_),stat=alloc)
           !
           call ArrayStart('me%fields%coeff',alloc,size(me%extF(imu)%coeff),kind(me%extF(imu)%coeff))
           call ArrayStart('me%fields%IndexQ',alloc,size(me%extF(imu)%IndexQ),kind(me%extF(imu)%IndexQ))
           call ArrayStart('me%fields%iorder',alloc,size(me%extF(imu)%iorder),kind(me%extF(imu)%iorder))
           call FLread_coeff_matelem(job_is,imu,1,me%extF(imu)%coeff(:,:,:))
           call FLread_IndexQ_field(job_is,imu,1,me%extF(imu)%IndexQ(:,:))
           !
           me%extF(imu)%iorder = 0 
           !
        enddo
        !
      endif 
      !
      ! We have completed transformation of the matrix elements from the standard primitive 
      ! representation to the contarcted representaion.
      ! We can free some memory by deallocating the primitive objects. 
      !
      !call FLfree_primitive_objects 
      !
      deallocate(extF_N)
      !
      if (job%verbose>=5) write(out,"('  ... done!')") 
      !
      if (job%verbose>=5) write(out,"('PTget_primitive_matelements/done!')") 
      !
      if (job%verbose>=5) call MemoryReport
      !
      call TimerStop('Primitive matelements')
      !
  end subroutine PTget_primitive_matelements

   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   subroutine PTmatrixelements_grot_gcor(nu_i,nu_j,grot,gcor)

      integer(ik),intent(in)        :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      real(rk),intent(out)           :: grot(3,3),gcor(PT%Nmodes,3)

      integer(ik)                   :: imode,i,iterm,k1,k2,k(PT%Nmodes)
      integer(ik)                   :: vl,vr
      real(rk)                      :: mat(PT%Nmodes)

         !if (verbose>=6) write(out,"(/'PTmatrixelements_grot_gcor/start: matrix elemnts for the hamiltonian ')") 
         !
         ! Extract large amplitude quantum numbers
         !
         vl = nu_i(PT%Nmodes) ; vr = nu_j(PT%Nmodes)
         !
         ! The J-free part has to be diagonal in terms of the rotational quanta
         !
         !
         ! Rotational and coriolis parts of the kinetic energy operator are turned on when FLrotation is .true.
         !
         grot = 0 
         gcor = 0 
         !
         !
         do k1 = 1,3
           do k2 = 1,3
             !
             do iterm = 1,me%grot(k1,k2)%Ncoeff
                !
                k(:) = me%grot(k1,k2)%IndexQ(:,iterm)
                !
                ! Check if the current iterm belongs to the current perturb. order
                !
                do imode = 1,PT%Nmodes
                   !
                   if (imode/=PT%Nmodes) then
                      !
                      mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                      !
                   else
                      !
                      !
                      mat(imode) =  me%grot(k1,k2)%coeff(iterm,vl,vr)
                      !
                   endif
                   ! 
                enddo
                !
                grot(k1,k2) = grot(k1,k2) + product(mat(:))
                !
             enddo
           enddo
         enddo
         !
         ! 
         ! Coriolis part of the kinetic operator g_cor
         !
         !
         do k1 = 1,PT%Nmodes
            do k2 = 1,3 
              !
              do iterm = 1,me%gcor(k1,k2)%Ncoeff
                !
                k(:) = me%gcor(k1,k2)%IndexQ(:,iterm)
                !
                do imode = 1,PT%Nmodes
                   !
                   if (imode/=PT%Nmodes) then
                      !
                      if (k1/=imode) then 
                         !
                         mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                         !
                      else
                         !
                         mat(imode) =me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                         !
                      endif
                      !
                   else
                      !
                      mat(imode) =  me%gcor(k1,k2)%coeff(iterm,vl,vr)
                      !                        !
                   endif
                   ! 
                enddo
                !
                gcor(k1,k2) = gcor(k1,k2) + product(mat(:))
                !
             enddo
             !
            enddo 
            !
         enddo 
         !
         !
   end subroutine PTmatrixelements_grot_gcor



   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   recursive function PTmatrixelements(norder,nu_i,nu_j,j) result(mat_elem)

      integer(ik),intent(in)        :: norder,nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      integer(ik),intent(in),optional  :: j
      real(rk)                      :: mat_elem,f_Jk

      integer(ik)                   :: imode,i,iterm,k1,k2,k(PT%Nmodes)
      integer(ik)                   :: vl,vr,tau_i,tau_j,k_i,k_j,jk,dk
      real(rk)                      :: pot_t,gvib_t,mat(PT%Nmodes),grot_t,gcor_t
      type(PTcoeffT),pointer        :: fl
      !real(rk)                      :: mat_legatee(0:PT%Nmodes,1:PT%Nterms%maximal)

         !if (verbose>=6) write(out,"(/'PTmatrixelements/start: matrix elemnts for the hamiltonian ')") 
         !
         ! Extract large amplitude quantum numbers
         !
         vl = nu_i(PT%Nmodes) ; vr = nu_j(PT%Nmodes)
         !
         ! The J-free part has to be diagonal in terms of the rotational quanta
         !
         pot_t = 0
         gvib_t = 0 
         !
         if (nu_i(0)==nu_j(0)) then 
            !
            if (PTvibrational_me_calc) then 
              pot_t = 0
              !
              fl => me%poten
              !
              do iterm = 1,fl%Ncoeff
                 !
                 ! Check if the current iterm belongs to the current perturb. order
                 !
                 if (fl%iorder(iterm)/=norder) cycle
                 !
                 k(:) = fl%IndexQ(:,iterm)
                 !
                 do imode = 1,PT%Nmodes
                    !
                    if (imode==PT%Nmodes) then
                       !
                       mat(imode) = fl%coeff(iterm,vl,vr)
                       !
                    else
                       !
                       mat(imode) = me%vibmode(imode,0)%coeff(k(imode),nu_i(imode),nu_j(imode))
                       !
                    endif
                    ! 
                 enddo
                 !
                 pot_t = pot_t + product(mat(:))
                 !
              enddo
              ! 
              ! Vibrational part of the kinetic operator g_vib
              !
              do k1 = 1,PT%Nmodes
                 do k2 = 1,PT%Nmodes
                    !
                    fl => me%gvib(k1,k2)
                    !
                    do iterm = 1,fl%Ncoeff
                       !
                       ! Check if the current iterm belongs to the current perturb. order
                       !
                       if (fl%iorder(iterm)/=norder) cycle
                       !
                       k(:) = fl%IndexQ(:,iterm)
                       !
                       do imode = 1,PT%Nmodes
                          !
                          if (imode==PT%Nmodes) then
                             !
                             mat(imode) = fl%coeff(iterm,vl,vr)
                             !
                          else
                             !
                             if    (k1/=imode.and.k2/=imode) then 
                               !
                               mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                               !
                             elseif (k1==imode.and.k2/=imode) then
                               !
                               mat(imode) =-me%vibmode(imode, 1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                               !
                             elseif (k1/=imode.and.k2==imode) then
                               !
                               mat(imode) = me%vibmode(imode, 1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                               !
                             else !   if (k1==imode.and.k2==imode) then
                               !
                               mat(imode) = me%vibmode(imode, 2)%coeff(k(imode),nu_i(imode),nu_j(imode))
                               !
                             endif
                             !
                             !
                          endif
                          ! 
                       enddo
                       !
                       gvib_t = gvib_t + product(mat(:))
                       !
                    enddo
                    ! 
                 enddo
              enddo
              !
            endif
            !
         endif 
         !
         ! Rotational and Coriolis parts of the kinetic energy operator are turned on when FLrotation is .true.
         !
         grot_t = 0 
         gcor_t = 0 
         !
         if (FLrotation.and.present(J)) then
          if (J/=0) then
            !
            ! Extract rotaitonal quantum numbers
            !
            k_i   = PT%rot_primindex(nu_i(0))%k
            k_j   = PT%rot_primindex(nu_j(0))%k
            tau_i = PT%rot_primindex(nu_i(0))%tau
            tau_j = PT%rot_primindex(nu_j(0))%tau
            !
            Jk = 1+k_i+(j*(j+1) )/2
            dk = k_i - k_j
            f_Jk = 0.5_rk*real(J*(J+1_ik)-k_i**2,ark)
            ! 
            ! Rotational part of the kinetic operator g_rot
            !
            if (abs(dk)<=2) then 

               ! gxx
               !
               fl => me%grot(1,1)
               !
               do iterm = 1,fl%Ncoeff
                  !
                  ! Check if the current iterm belongs to the current perturb. order
                  !
                  if (fl%iorder(iterm)/=norder) cycle 
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  !
                  do imode = 1,PT%Nmodes
                     !
                     if (imode/=PT%Nmodes) then
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                     else
                        !
                        ! four terms that come together: 
                        ! 1/2(Jx^2 - Jy^2) and (JxJy+JyJx)
                        !     (JxJz+JzJx)  and (JzJy+JyJz)
                        !
                        ! first  - all even contributions 
                        if (tau_i==tau_j) then 
                           ! Jx2y2 
                           mat(imode) =  0.5_rk*me%grot(1,1)%coeff(iterm,vl,vr)*me%rot(4)%coeff(Jk,dk,tau_i)
                           !
                           if (k_i==k_j) then 
                              ! two terms A*Jx^2+BJy^2+C*Jz^2
                              mat(imode) = mat(imode) + f_Jk*me%grot(1,1)%coeff(iterm,vl,vr)
                           endif
                        endif 
                     endif
                  enddo
                  grot_t = grot_t + product(mat(:))
                  !
               enddo
               !
               fl => me%grot(2,2)
               !
               do iterm = 1,fl%Ncoeff
                  !
                  ! Check if the current iterm belongs to the current perturb. order
                  !
                  if (fl%iorder(iterm)/=norder) cycle
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  do imode = 1,PT%Nmodes
                     if (imode/=PT%Nmodes) then
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                     else
                        if (tau_i==tau_j) then 
                           ! Jx2y2 
                           mat(imode) =  0.5_rk*(-me%grot(2,2)%coeff(iterm,vl,vr))*me%rot(4)%coeff(Jk,dk,tau_i)
                           !
                           if (k_i==k_j) then 
                              ! two terms A*Jx^2+BJy^2+C*Jz^2
                              mat(imode) = mat(imode) + f_Jk*me%grot(2,2)%coeff(iterm,vl,vr)
                           endif 
                        endif 
                     endif
                  enddo
                  grot_t = grot_t + product(mat(:))
               enddo
               !
               fl => me%grot(3,3)
               !
               do iterm = 1,fl%Ncoeff
                  !
                  if (fl%iorder(iterm)/=norder) cycle
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  !
                  do imode = 1,PT%Nmodes
                     if (imode/=PT%Nmodes) then
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                     else
                        if (tau_i==tau_j.and.k_i==k_j) then 
                           ! two terms A*Jx^2+BJy^2+C*Jz^2
                           mat(imode) = real(k_i**2,rk)*me%grot(3,3)%coeff(iterm,vl,vr) 
                        endif 
                     endif
                  enddo
                  grot_t = grot_t + product(mat(:))
               enddo
               !
               fl => me%grot(1,3)
               !
               do iterm = 1,fl%Ncoeff
                  !
                  if (fl%iorder(iterm)/=norder) cycle
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  do imode = 1,PT%Nspecies
                     if (imode/=PT%Nmodes) then
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                     else
                        if (tau_i==tau_j) then 
                           ! Jxz
                           mat(imode) = me%grot(1,3)%coeff(iterm,vl,vr)*me%rot(6)%coeff(Jk,dk,tau_i)
                        endif 
                     endif
                  enddo
                  grot_t = grot_t + product(mat(:))
               enddo
               !
               fl => me%grot(1,2)
               !
               do iterm = 1,fl%Ncoeff
                  !
                  if (fl%iorder(iterm)/=norder) cycle 
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  ! Check if the current iterm belongs to the current perturb. order
                  do imode = 1,PT%Nmodes
                     if (imode/=PT%Nmodes) then
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                     else
                        if (tau_i/=tau_j) then 
                           ! Jxy
                           mat(imode) = me%grot(1,2)%coeff(iterm,vl,vr)*me%rot(5)%coeff(Jk,dk,tau_i)
                        endif 
                     endif
                  enddo
                  grot_t = grot_t + product(mat(:))
               enddo
               !
               fl => me%grot(2,3)
               !
               do iterm = 1,fl%Ncoeff
                  !
                  if (fl%iorder(iterm)/=norder) cycle
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  do imode = 1,PT%Nmodes
                     if (imode/=PT%Nmodes) then
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                     else
                        if (tau_i/=tau_j) then 
                           ! Jyz
                           mat(imode) = me%grot(2,3)%coeff(iterm,vl,vr)*me%rot(7)%coeff(Jk,dk,tau_i)
                        endif 
                     endif
                  enddo
                  grot_t = grot_t + product(mat(:))
               enddo
               !
            endif 
            ! 
            ! Coriolis part of the kinetic operator g_cor
            !
            if (abs(dk)<=1) then 
               !
               do k1 = 1,PT%Nmodes
                  !
                  fl => me%gcor(k1,1)
                  !
                  do iterm = 1,fl%Ncoeff
                     !
                     if (fl%iorder(iterm)/=norder) cycle
                     !
                     k(:) = fl%IndexQ(:,iterm)
                     do imode = 1,PT%Nmodes
                        if (imode/=PT%Nmodes) then
                           if (k1/=imode) then 
                              mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                           else
                              mat(imode) =me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))-&
                                          me%vibmode(imode,1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                           endif
                        else
                           ! first  - all even contributions 
                           if (tau_i/=tau_j) then 
                              mat(imode) =  me%gcor(k1,1)%coeff(iterm,vl,vr)*me%rot(1)%coeff(Jk,dk,tau_i)
                           endif 
                        endif
                     enddo
                     gcor_t = gcor_t + product(mat(:))
                  enddo
                  !
                  fl => me%gcor(k1,2)
                  !
                  do iterm = 1,fl%Ncoeff
                     !
                     if (fl%iorder(iterm)/=norder) cycle
                     !
                     k(:) = fl%IndexQ(:,iterm)
                     ! Check if the current iterm belongs to the current perturb. order
                     do imode = 1,PT%Nspecies
                        if (imode/=PT%Nmodes) then
                           if (k1/=imode) then 
                              mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                           else
                              mat(imode) =me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))-&
                                          me%vibmode(imode,1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                           endif
                        else
                           ! first  - all even contributions 
                           if (tau_i==tau_j) then 
                              mat(imode) =  me%gcor(k1,2)%coeff(iterm,vl,vr)*me%rot(2)%coeff(Jk,dk,tau_i)
                           endif 
                        endif
                     enddo
                     gcor_t = gcor_t + product(mat(:))
                  enddo
                  !
                  fl => me%gcor(k1,3)
                  !
                  do iterm = 1,fl%Ncoeff
                     if (fl%iorder(iterm)/=norder) cycle
                     k(:) = fl%IndexQ(:,iterm)
                     do imode = 1,PT%Nmodes
                        if (imode/=PT%Nmodes) then
                           if (k1/=imode) then 
                              mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                           else
                              mat(imode) =me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))-&
                                          me%vibmode(imode,1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                           endif
                        else
                           ! first  - all even contributions 
                           if (tau_i/=tau_j) then 
                              mat(imode) =  me%gcor(k1,3)%coeff(iterm,vl,vr)*me%rot(3)%coeff(Jk,dk,tau_i)
                           endif 
                        endif
                     enddo
                     gcor_t = gcor_t + product(mat(:))
                  enddo
               enddo 
            endif 
            !
          endif 
         endif 
         !
         mat_elem = pot_t-0.5_rk*(gvib_t-grot_t-gcor_t)
         !
         !if (verbose>=7) write(out,"('PTmatrixelements:  pot_t,gvib_t,grot_t,gcor_t ',4f18.8)") pot_t,gvib_t,grot_t,gcor_t
         !
         !call TimerStart('PTmatrixelements')
         !
      !if (verbose>=6) write(out,"('PTmatrixelements/end')") 
      !
   end function PTmatrixelements


   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| L2 |w1w2w3...>, where L2 is the total vibrational angular moment
   !
   recursive function PT_L2_matrixelements(norder,nu_i,nu_j) result(mat_elem)

      integer(ik),intent(in)        :: norder,nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      real(rk)                      :: mat_elem

      integer(ik)                   :: imode,i,iterm,k1,k2,k(PT%Nmodes)
      integer(ik)                   :: vl,vr
      real(rk)                      :: gvib_t,mat(PT%Nmodes)
      type(PTcoeffT),pointer        :: fl

         !
         ! Extract large amplitude quantum numbers
         !
         vl = nu_i(PT%Nmodes) ; vr = nu_j(PT%Nmodes)
         !
         gvib_t = 0 
         !
         if (nu_i(0)==nu_j(0)) then 
            !
            if (PTvibrational_me_calc) then 
              ! 
              ! Vibrational angular momentum
              !
              do k1 = 1,PT%Nmodes
                 do k2 = 1,PT%Nmodes
                    !
                    fl => me%L2(k1,k2)
                    !
                    do iterm = 1,fl%Ncoeff
                       !
                       ! Check if the current iterm belongs to the current perturb. order
                       !
                       if (fl%iorder(iterm)/=norder) cycle
                       !
                       k(:) = fl%IndexQ(:,iterm)
                       !
                       do imode = 1,PT%Nmodes
                          !
                          if (imode==PT%Nmodes) then
                             !
                             mat(imode) = fl%coeff(iterm,vl,vr)
                             !
                          else
                             !
                             if    (k1/=imode.and.k2/=imode) then 
                               !
                               mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                               !
                             elseif (k1==imode.and.k2/=imode) then
                               !
                               mat(imode) =-me%vibmode(imode, 1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                               !
                             elseif (k1/=imode.and.k2==imode) then
                               !
                               mat(imode) = me%vibmode(imode, 1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                               !
                             else !   if (k1==imode.and.k2==imode) then
                               !
                               mat(imode) = me%vibmode(imode, 2)%coeff(k(imode),nu_i(imode),nu_j(imode))
                               !
                             endif
                             !
                             !
                          endif
                          ! 
                       enddo
                       !
                       gvib_t = gvib_t + product(mat(:))
                       !
                    enddo
                    ! 
                 enddo
              enddo
              !
            endif
            !
         endif 
         !
         mat_elem = gvib_t
         !
         !if (verbose>=6) write(out,"('PT_L2_matrixelements/end')") 

   end function PT_L2_matrixelements



   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   recursive function PTmatrixelements_DVR(nu_i,nu_j) result(mat_elem)

      integer(ik),intent(in)        :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      real(rk)                      :: mat_elem

      integer(ik)                   :: imode,i,k1,k2,ip(PT%Nmodes)
      integer(hik)                  :: k
      integer(ik)                   :: vl,vr,ispecies
      real(rk)                      :: gvib_t,mat(0:PT%Nmodes),pot_t
      !type(PTcoeffsT),pointer       :: fl,df
      
         !

         !if (verbose>=6) write(out,"(/'PTmatrixelements_DVR/start: matrix elemnts for the hamiltonian ')") 
         !
         ! Extract large amplitude quantum numbers
         !
         !if (present(j)) then
         ! !
         !  if (j/=0) stop 'PTmatrixelements_DVR: j/=0 is not going to work'
         !  !
         !endif
         !
         !mat_elem = 0
         !
         !if (nu_i(0)/=nu_j(0).or..not.PTvibrational_me_calc) return 
         !
         !vl = nu_i(PT%Nmodes) ; vr = nu_j(PT%Nmodes)
         !
         pot_t = 0
         !
         do k = 1,dvr%total_size
            !
            ip(:) = dvr%kindex(k,:)
            !
            mat(0) = dvr%poten(k)
            !
            do ispecies = 1,PT%Nspecies
               !
               !fl => dvr%prim_func(ispecies)
               !wt => dvr%weight(ispecies)
               !
               do i = 1,PT%mode_ispecies(ispecies)
                 !
                 imode = PT%mode_species(ispecies,i)
                 !
                 mat(imode) = dvr%prim_func(ispecies)%coeffs(nu_i(imode),ip(imode))*&
                              dvr%prim_func(ispecies)%coeffs(nu_j(imode),ip(imode))
                 !
               enddo
               !
            enddo
            !
            pot_t = pot_t + product(mat(:))
            !
         enddo
         !
         gvib_t = 0
         ! 
         ! Vibrational part of the kinetic operator g_vib
         !
         do k1 = 1,PT%Nmodes
            do k2 = 1,PT%Nmodes
               !
               do k = 1,dvr%total_size
                  !
                  ip(:) = dvr%kindex(k,:)
                  !
                  mat(0) = dvr%gvib(k1,k2,k)
                  !
                  do ispecies = 1,PT%Nspecies
                     !
                     !fl => dvr%prim_func(ispecies)
                     !df => dvr%prim_dfunc(ispecies)
                     !
                     !wt => dvr%weight(ispecies) : wt%coeff1d(ip(imode))*
                     !
                     do i = 1,PT%mode_ispecies(ispecies)
                        !
                        imode = PT%mode_species(ispecies,i)
                        !
                        vl = nu_i(imode) ; vr = nu_j(imode) 
                        !
                        if    (k1/=imode.and.k2/=imode) then 
                          !
                          mat(imode) = dvr%prim_func(ispecies)%coeffs(vl,ip(imode))*dvr%prim_func(ispecies)%coeffs(vr,ip(imode))
                          !
                        elseif (k1==imode.and.k2/=imode) then
                          !
                          mat(imode) =-dvr%prim_dfunc(ispecies)%coeffs(vl,ip(imode))*dvr%prim_func(ispecies)%coeffs(vr,ip(imode))
                          !
                        elseif (k1/=imode.and.k2==imode) then
                          !
                          mat(imode) = dvr%prim_func(ispecies)%coeffs(vl,ip(imode))*dvr%prim_dfunc(ispecies)%coeffs(vr,ip(imode))
                          !
                        else !   if (k1==imode.and.k2==imode) then
                          !
                          mat(imode) =-dvr%prim_dfunc(ispecies)%coeffs(vl,ip(imode))*dvr%prim_dfunc(ispecies)%coeffs(vr,ip(imode))
                          !
                        endif
                        !
                     enddo 
                     ! 
                  enddo
                  !
                  gvib_t = gvib_t + product(mat(:))
                  ! 
                enddo
                !
            enddo
         enddo
         !
         mat_elem = pot_t-gvib_t
         !
         !
         !call TimerStart('PTmatrixelements_DVR')
         !
      !if (verbose>=6) write(out,"('PTmatrixelements_DVR/end')") 

   end function PTmatrixelements_DVR



! Here we transfer the 1D FBR basis into a DVR bais and compute 
! all fields of the Hamiltonian as well as the primitive functions in the DVR representaion
! 
  subroutine PTDVR_initialize(j,bs,iclass_,reduced_model_,ifread)

    integer(ik),intent(in) :: j                                  ! current rotational quantum    
    type(FLbasissetT),intent(inout)     :: bs(0:PT%Nmodes)          ! Basis set specifications: range and type
    !
    integer(ik),intent(in),optional  :: iclass_
    logical,intent(in),optional  ::  reduced_model_,ifread
    !
    logical                      ::  reduced_model = .false.
    !
    real(ark)                    :: rhostep
    !
    logical                :: treat_rotation = .false.,ifopened
    !
    integer(ik)           :: jrot,imode,v,u,ilevel,jlevel,ispecies,npoints,bs_size,bsize1,alloc,io_slot,jo_slot,dvr_size
    integer(ik)           :: k0,ipoint,k,k_t(PT%Nmodes),irho_eq
    integer(ik)           :: idvrpoint,irho,i,k1,k2,extF_rank,irho_,rec_len
    real(rk),allocatable  :: H1dvr(:,:),e1dvr(:)
    real(ark),allocatable :: phi(:),dphi(:),phi_(:,:),dphi_(:,:),psi(:,:),dpsi(:,:),psi_exp(:,:),phipsi(:)
    real(ark),allocatable :: psi_prim(:,:),dpsi_prim(:,:)
    !
    character(len=cl)     :: unitfname 
    real(rk),allocatable  :: a(:,:),b(:,:),a_(:,:),b_(:,:)
    real(ark),allocatable :: phi0(:),phi1(:),phi2(:),dphi0(:),phi0_(:),dphi0_(:),root(:),root_(:)
    real(ark),allocatable :: w(:),y(:),xi(:),pol(:,:),dpol(:),w_(:),g_(:),u_(:),h_(:),aa(:,:)
    !
    real(ark)             :: f_t,df_t,xval,fval,dfval,f2_t,g2,y1,y2
    real(ark)             :: poten_(-2:2),gvib_(PT%Nmodes,PT%Nmodes,-2:2),grot_(3,3,-2:2),gcor_(PT%Nmodes,3,-2:2)
    real(ark)             :: x(-2:2),df_f(-2:2),c_t,rho_range,x1,x2
    real(ark)              :: poten_t,gvib_t(PT%Nmodes,PT%Nmodes),grot_t(3,3),gcor_t(PT%Nmodes,3)
    real(ark),allocatable  :: extF_t(:)
    real(ark),allocatable  :: extF_(:,:)
    integer(ik),allocatable :: kpow(:)
    character(len=cl)       :: my_fmt !format for I/O specification
    !
    real(ark)             :: dchi_(PT%Nmodes),dchi(PT%Nmodes),f2
    integer(hik)          :: size_total,isum
    !
    integer(ik)           :: mpoints,imu,iclass,im1,im2,powers(trove%Nmodes)
    !
    call TimerStart('PTDVR_initialize')
    !
    if (job%verbose>=4) write(out,"(/'  Initializing the primitve DVR basis set and the DVR-based Hamiltonian...')")
    !
    ! The contracted solutions will be computed at J=0
    !
    jrot = j
    !
    if (verbose>=5) then 
      !
      write(out,"(//'adresses of the DVR coordinates:')")
      !
    endif
    !
    if (present(reduced_model_))  reduced_model = reduced_model_
    !
    if ((FLrotation.and.jrot/=0).or.trim(job%IOkinet_action)=='SAVE') treat_rotation = .true.
    !
    !
    ! Obtain the size of the external field (if exist)
    !
    extF_rank = FLread_extF_rank()
    !
    if (.not.dvr%initialized) then 
       !
       allocate (dvr%abcissa(PT%Nspecies),dvr%weight(PT%Nspecies),dvr%nsize(1:PT%Nmodes))
       allocate (dvr%prim_func(PT%Nspecies),dvr%prim_dfunc(PT%Nspecies),stat=alloc)
       allocate (dvr%drho(PT%Nmodes),stat=alloc)
       !
       dvr%initialized = .true.
       !
    else
       !
       if (job%verbose>=5) write(out,"(/'     De-initializing...')")
       ! 
       ! deallocate the following matrices if they were already allocated:
       !
       do ispecies = 1,PT%Nspecies
         !
         deallocate(dvr%abcissa(ispecies)%coeff1d)
         deallocate(dvr%weight(ispecies)%coeff1d)
         !
         deallocate(dvr%prim_func(ispecies)%coeffs,dvr%prim_dfunc(ispecies)%coeffs)
         !
       enddo
       !
       call ArrayStop('dvr-abcisssa-weight')
       call ArrayStop('dvr%prim_func(ispecies)%coeffs')
       !
       if (associated(dvr%poten)) deallocate(dvr%poten)
       if (associated(dvr%gvib)) deallocate(dvr%gvib)
       if (associated(dvr%grot)) deallocate(dvr%grot)
       if (associated(dvr%gcor)) deallocate(dvr%gcor)
       if (associated(dvr%kindex)) deallocate(dvr%kindex)
       if (associated(dvr%icheck_deriv)) deallocate(dvr%icheck_deriv)
       !
       if (associated(dvr%extF)) deallocate(dvr%extF)
       !
       call ArrayStart('dvr-fields',0,1,4)
       call ArrayStop('dvr-fields')
       !
       if (job%verbose>=5)  write(out,"( '     ...done!')") 
       !
    endif
    !
    if (present(ifread)) then 
      if(trim(job%IOdvr_prim)=='READ') then
        call PTcheck_point_dvr('read')
        return
      endif 
    endif 
    !
    if (job%verbose>=5) then
       write(out,"(/'     Generating the DVR-points...')")
    endif 
    !
    !if (job%verbose>=5) write(out,"( '     ...done!')") 
    if (job%verbose>=5) write(out,"(/'     Generating the primitive funcitons in DVR representation...')")
    !
    do ispecies = 1,PT%Nspecies
      !
      do i = 1,PT%mode_ispecies(ispecies)
        !
        imode = PT%mode_species(ispecies,i)
        !
        dvr%drho(imode) = (bs(imode)%borders(2)-bs(imode)%borders(1))/real(bs(imode)%npoints,kind=ark)
        !
      enddo
      !
      ! Primitive basis functions (Numerov)
      !
      imode = PT%mode_species(ispecies,1)
      !
      npoints = bs(imode)%npoints
      !
      ! size of the dvr grid
      !
      dvr_size = max(bs(imode)%dvrpoints,bs(imode)%range(2)+1)
      !
      allocate (dvr%abcissa(ispecies)%coeff1d(dvr_size),dvr%weight(ispecies)%coeff1d(dvr_size),stat=alloc)
      call ArrayStart('dvr-abcisssa-weight',alloc,size(dvr%abcissa(ispecies)%coeff1d),kind(dvr%abcissa(ispecies)%coeff1d))
      call ArrayStart('dvr-abcisssa-weight',alloc,size(dvr%weight(ispecies)%coeff1d),kind(dvr%weight(ispecies)%coeff1d))
      !
      ! Npoints of primitive basis functions (Numerov)
      !
      npoints = bs(imode)%npoints
      !
      ! size of the primitive basis set 
      !
      bs_size = bs(imode)%range(2)
      !
      !dvr_size = max(bs(imode)%dvrpoints,bs(imode)%range(2))
      !
      mpoints = dvr_size
      !
      rhostep = dvr%drho(imode)
      !
      allocate (dvr%prim_func(ispecies)%coeffs(0:bs_size,dvr_size),stat=alloc)
      allocate (dvr%prim_dfunc(ispecies)%coeffs(0:bs_size,dvr_size),stat=alloc)
      call ArrayStart('dvr%prim_func(ispecies)%coeffs',alloc,size(dvr%prim_func(ispecies)%coeffs),&
                      kind(dvr%prim_func(ispecies)%coeffs))
      call ArrayStart('dvr%prim_func(ispecies)%coeffs',alloc,size(dvr%prim_dfunc(ispecies)%coeffs),&
                      kind(dvr%prim_dfunc(ispecies)%coeffs))
      !
      allocate ( psi_prim(0:bs_size,dvr_size),stat=alloc)
      allocate (dpsi_prim(0:bs_size,dvr_size),stat=alloc)
      call ArrayStart('dvr-numer',alloc,size( psi_prim),kind( psi_prim))
      call ArrayStart('dvr-numer',alloc,size(dpsi_prim),kind(dpsi_prim))
      !
      ! For the Numerov basis functions prepare the reading-in. 
      !
      select case(trim(bs(imode)%type))
        !
      case default 
         !
         write (out,"('PTDVR_initialize: ',a,'-basis is not implemented here')") trim(bs(imode)%type)
         stop 'PTDVR_initialize - illegal basis type '
         !
      case ('HARMONIC')
         !
         continue
         !
      case ('NUMEROV','LEGENDRE','FOURIER','BOX','SINRHO')
         !
         if (dvr_size>bs(imode)%npoints) then 
           !
           write(out,"('PTDVR_initialize..: For ispecies ',i4,' number of points is too small.')") ispecies
           stop 'PTDVR_initialize..: illegal number of points in ispecies'
           !
         endif
         !
         allocate (phi(0:npoints),dphi(0:npoints),phipsi(0:npoints),stat=alloc)
         call ArrayStart('dvr-numer',alloc,size(phi),kind(phi))
         call ArrayStart('dvr-numer',alloc,size(dphi),kind(dphi))
         call ArrayStart('dvr-numer',alloc,size(phipsi),kind(phipsi))
         !
         write(unitfname,"('Numerov basis set # ',i6)") imode
         call IOStart(trim(unitfname),io_slot)
         !
         ! prepare a file for storing the new polynomial-based basis functions 
         !
         write(unitfname,"('Polynomial dvr basis set # ',i6)") imode
         call IOStart(trim(unitfname),jo_slot)
         !
         inquire(jo_slot,opened=ifopened)
         !
         if (ifopened) close(jo_slot)
         !
         inquire(iolength=rec_len) phi
         !
         !rec_len = rec_len*(1+bs(imode)%npoints)
         !
         open(unit=jo_slot,status='scratch',access='direct',action='readwrite',recl=rec_len)
         !
      end select
      !
      !
      ! Start definition of the dvr-grid and basis set here: 
      ! 
      !
      select case(trim(bs(imode)%dvr))
        !
      case default 
         !
         write (out,"('PTDVR_initialize: ',a,'-basis is not implemented here')") trim(bs(imode)%type)
         stop 'PTDVR_initialize - illegal basis type '
         !
      case ('HERMITE')
         !
         allocate (y(dvr_size),w(dvr_size),stat=alloc)
         !
         call ArrayStart('dvr-psi',alloc,size(y),kind(y))
         call ArrayStart('dvr-psi',alloc,size(w),kind(w))

         !
         ! obtain the harmonic constant
         !
         irho_eq = 0 
         !
         if (manifold/=0) irho_eq = mod(&
                          nint( ( trove%chi_eq(trove%Nmodes)-trove%rho_border(1) )/(trove%rhostep),kind=ik ),trove%npoints)
         !
         powers = 0 ; powers(imode) = 2
         k = FLQindex(trove%Nmodes_e,powers)
         f2 = trove%poten%field(k,irho_eq)
         g2 = trove%g_vib(imode,imode)%field(1,irho_eq)
         c_t = sqrt( sqrt( g2/( 2.0_ark*f2 ) ) )
         !
         call gauher(y,w,dvr_size)
         !
         !c_t = trove%coord_f(imode)
         !
         !job%bset(imode)%params(1) = c_t
         !
         dvr%abcissa(ispecies)%coeff1d(1:dvr_size) = y(dvr_size:1:-1)*c_t
         dvr%weight(ispecies)%coeff1d(1:dvr_size)  = w(dvr_size:1:-1)*c_t
         !
         do v = 0,bs_size
           !
           f2_t = 0 
           !
           !omp parallel do private(idvrpoint,xval,fval)
           do idvrpoint = 1,dvr_size
             !
             xval = dvr%abcissa(ispecies)%coeff1d(idvrpoint)
             !
             call Harmonic_polinom(v,c_t,xval,fval,dfval)
             !
             psi_prim (v,idvrpoint)  =  fval
             dpsi_prim(v,idvrpoint)  = dfval-fval*xval/c_t
             !
           enddo
           !omp end parallel do
           !
         enddo
         !
         do i = 0,bs_size
           !
           f_t = sum(psi_prim(i,:)*psi_prim(i,:)*dvr%weight(ispecies)%coeff1d(:))
           !
           if (abs(f_t-1.0)>1e3*sqrt(small_)) then 
              write(out,"('PTdvr...: the dvr-Hermite function ',i8,' is not normalized: ',2g18.8,'; ipoint= ',i8)")  i,f_t
              stop 'PTdvr...: the dvr-Hermite function is not normalized'
           endif
           !
           do v = i+1,bs_size
             !
             f_t = sum(psi_prim(i,:)*psi_prim(v,:)*dvr%weight(ispecies)%coeff1d(:))
             !
             if (f_t>1e3*sqrt(small_)) then 
                write(out,"('PTdvr..: the dvr-Hermite',i8,' and ',i8,' are not orthogonal: ',2g18.8,'; ipoint= ',i8)")  i,v,f_t
                stop 'PTdvr...: the dvr-Hermite functions are not orthogonal'
             endif
             ! 
           enddo 
           !
         enddo
         !
         select case(trim(bs(imode)%type))
            !
         case ('NUMEROV')
            !
            allocate (phi0(0:npoints),xi(0:npoints),stat=alloc)
            !
            forall(i = 0:npoints) xi(i) = bs(imode)%borders(1)+real(i,ark)*rhostep-trove%chi0_ref(imode)
            !
            do v =  0,bs_size
              !
              do ipoint = 0,Npoints
                !
                xval = xi(i)
                !
                call Harmonic_polinom(v,c_t,xval,phi0(i),dfval)
                !
              enddo
              !
              write (jo_slot,rec=v+1) (phi0(i),i=0,Npoints)
              !
            enddo
            !
            deallocate (phi0,xi)
            !
         end select
         !
         if (trim(bs(imode)%type)=='NUMEROV'.and..false.) then 
           !
           bsize1 = bs_size + 1
           !
           allocate (psi(0:bsize1,dvr_size),dpsi(0:bsize1,dvr_size),stat=alloc)
           call ArrayStart('dvr-psi',alloc,size(psi),kind(psi))
           call ArrayStart('dvr-psi',alloc,size(dpsi),kind(dpsi))
           !
           allocate (aa(0:bsize1,0:bsize1),psi_exp(0:bsize1,0:npoints),stat=alloc)
           call ArrayStart('dvr-psi',alloc,size(aa),kind(aa))
           call ArrayStart('dvr-psi',alloc,size(psi_exp),kind(psi_exp))
           !
           do v =  0,bsize1
             do i = 0,npoints
               !
               xval = bs(imode)%borders(1)+real(i,ark)*rhostep-trove%chi0_ref(imode)
               !
               call Harmonic_polinom(v,c_t,xval,fval,dfval)
               !
               psi_exp(v,i) = fval*exp(-0.5_ark*(xval/c_t)**2)
               !
             enddo
           enddo
           !
           rho_range = bs(imode)%borders(2)-bs(imode)%borders(1)
           !
           do v = 0,bsize1
             !
             read (io_slot,rec=v+1) (phi(k0),k0=0,npoints),(dphi(k0),k0=0,npoints)
             !
             do i =  0,bsize1
               !
               phipsi = psi_exp(i,:)*phi(:)
               !
               aa(v,i) =  simpsonintegral_ark(npoints,rho_range,phipsi)
               !
             enddo
           enddo 
           !
           do i =  1,dvr_size
             !
              psi_prim(0:bs_size,i) = matmul(aa, psi(0:bs_size,i))
             dpsi_prim(0:bs_size,i) = matmul(aa,dpsi(0:bs_size,i))
             !
           enddo
           !
           deallocate (psi_exp,aa,psi,dpsi)
           !
         endif 
         !
         deallocate (w,y)
         call ArrayStop('dvr-psi')
         !
      case ('LEGENDRE') 
         !
         x1 = bs(imode)%borders(1)-trove%chi0_ref(imode)
         x2 = bs(imode)%borders(2)-trove%chi0_ref(imode)
         !
         call gaulegf(x1, x2, y, w, dvr_size)
         !
         dvr%abcissa(ispecies)%coeff1d(1:dvr_size) = y(1:dvr_size)
         dvr%weight(ispecies)%coeff1d(1:dvr_size)  = w(1:dvr_size)
         !
         !
         !do i =  1,dvr_size
         !  !
         !  dvr%prim_func (ispecies)%coeffs(0:bs_size,i) = phi_(:,i)
         !  dvr%prim_dfunc(ispecies)%coeffs(0:bs_size,i) = dphi_(:,i)
         !  !
         !enddo
         !
         write(out,"('PTDVR_initialize: Legendre is not fully implemented!')")
         stop 'PTDVR_initialize: Legendre is not fully implemented'
         !
      case ('NUMEROV')
         !
         allocate (H1dvr(dvr_size,dvr_size),e1dvr(dvr_size),stat=alloc)
         if (alloc/=0) then
            write (out,"(' Error ',i9,' trying to allocate H1dvr-fields')") alloc
            stop 'PTDVR_initialize, points -  out of memory'
         end if
         !
         ! Create the field to store the DVR coordinates addresses
         !
         ! Create the Q-DVR matrix
         !
         do ilevel = 1,dvr_size
           do jlevel = ilevel,dvr_size
              !
              H1dvr(ilevel,jlevel) = me%vibmode(imode,-1)%coeff(1,ilevel-1,jlevel-1)
              H1dvr(jlevel,ilevel) = H1dvr(ilevel,jlevel)
              !
           enddo
         enddo
         !
         call lapack_syev(H1dvr,e1dvr)
         !
         ! This defines the DVR-coordinates:
         !
         dvr%abcissa(ispecies)%coeff1d(1:dvr_size) = e1dvr(1:dvr_size)
         !
         deallocate( H1dvr,e1dvr)
         !
         allocate (phi_(0:bs_size,dvr_size),dphi_(0:bs_size,dvr_size),psi_exp(dvr_size,0:npoints),stat=alloc)
         call ArrayStart('dvr-phi',alloc,size(phi_),kind(phi_))
         call ArrayStart('dvr-phi',alloc,size(dphi_),kind(dphi_))
         !
         allocate (a(1:bs_size+1,dvr_size),stat=alloc)
         call ArrayStart('dvr-phi',alloc,size(a),kind(a))
         !
         allocate (b(1:bs_size+1,1),stat=alloc)
         call ArrayStart('dvr-phi',alloc,size(b),kind(b))
         !
         ! read the functions in
         !
         do v = 0,bs_size
           !
           read (io_slot,rec=v+1) (phi(k0),k0=0,npoints),(dphi(k0),k0=0,npoints)
           !
           f2_t = 0 
           !
           !$omp parallel do private(idvrpoint,xval,ipoint,k,x,fval,f_t,dfval,df_t) shared(w)
           do idvrpoint = 1,dvr_size
             !
             xval = dvr%abcissa(ispecies)%coeff1d(idvrpoint)+trove%chi0_ref(imode)
             !
             ipoint = nint( ( xval-bs(imode)%borders(1) )/rhostep,kind=ik )
             !
             k1 = max(0,ipoint-2)-ipoint
             k2 = min(npoints,ipoint+2)-ipoint
             !
             if (k1>-2) k2 = k1+4
             if (k2< 2) k1 = k2-4
             !
             i = -3 
             do k=k1,k2
               !
               i = i + 1
               !
               x(i) = bs(imode)%borders(1)+real(ipoint+k,ark)*rhostep
               !
             enddo
             !
             call polintark(x(-2:2), phi(ipoint-2:ipoint+2),xval, fval, f_t)
             !
             call polintark(x(-2:2),dphi(ipoint-2:ipoint+2),xval,dfval,df_t)
             !
             phi_(v,idvrpoint)  =  fval
             !
             dphi_(v,idvrpoint) = dfval
             !
             if (f_t>1e3*sqrt(small_)) then 
                !
                write(out,"('PTdvr...: Error in polint is too large: ',g18.8,'; ipoint= ',i8)")  f_t,ipoint
                write(out,"('xval,fval,dval = ',3g18.8,' func = ',5g18.8)") xval,fval,dfval,&
                             phi(max(ipoint-2,0):min(ipoint+2,npoints))
                stop 'PTdvr...: Error in polint is too large'
                !
             endif
             !
           enddo
           !$omp end parallel do
           !
         enddo
         !
         do i =  1,dvr_size
           !
            psi_prim(0,i) = 1.0_ark
           dpsi_prim(0,i) = dphi_(0,i)/phi_(0,i)
           !
           do v = 1,bs_size
             !
              psi_prim(v,i) =  phi_(v,i)/phi_(0,i)
             dpsi_prim(v,i) = dphi_(v,i)/phi_(0,i)
             !
           enddo
           !
         enddo
         !
         b = 0 ; b(1,1) = 1.0_ark
         !
         !$omp parallel do private(v) shared(a)
         do v = 0,bs_size
           !
           a(v+1,:) = psi_prim(0,:)*psi_prim(v,:)
           !
         enddo
         !$omp end parallel do
         !
         call lapack_gelss(a(:,:),b(:,:))
         !
         dvr%weight(ispecies)%coeff1d(1:dvr_size) = b(1:dvr_size,1)
         !
         do i =  1,dvr_size
           !
           if (b(i,1)<0.and.abs( b(i,1) )<small_ ) b(i,1) = 0 
           !
         enddo
         !
         if (any(b(:,1)<0)) then 
           !
           write(my_fmt,'(a,i0,a)') "(a,i9,",dvr_size,"(1x,e14.7))"
           !
           write(out,my_fmt) 'PTDVR_initialize: weights are negative for ispecies = ',&
                        ispecies,b(1:dvr_size,1)
           write(out,"('PTDVR_initialize: try to schrink the borders')")
           stop 'PTDVR_initialize: negative weights'
           !
         endif 
         !
         deallocate (phi_,dphi_,a,b)
         call ArrayStop('dvr-phi')
         !
      case ('NUMEROV-POL')
         !
         ! This is a special case of polynomials converted from the Numerov basis functions
         !
         ! extended (+1) number of functions
         !
         bsize1 = bs_size + 1
         !
         allocate (a_(npoints+1,max(3,bsize1+1)),b_(max(npoints+1,3),1),pol(3,0:bsize1),xi(0:npoints),&
                   root(0:bsize1+1),root_(0:bsize1+1),phi0(0:npoints),dphi0(0:npoints),phi1(0:npoints),phi2(0:npoints),&
                   phi0_(dvr_size),dphi0_(dvr_size),kpow(0:bsize1),stat=alloc)
         !
         call ArrayStart('dvr-fields_',alloc,size(a_),kind(a_))
         call ArrayStart('dvr-fields_',alloc,size(b_),kind(b_))
         !
         size_total = int((bsize1+1)**2,hik)+int(3*(bsize1+1)+3*(npoints+1)+dvr_size*2,hik)
         !
         call ArrayStart('dvr-fields_',alloc,1,kind(pol),size_total)
         !
         pol = 0
         !
         ! construct polynomials which are close to the numerov-solutions
         !
         rho_range = bs(imode)%borders(2)-bs(imode)%borders(1)
         !
         ! Numerov-grid coordinates
         !
         forall(i = 0:npoints) xi(i) = bs(imode)%borders(1)+real(i,ark)*rhostep-trove%chi0_ref(imode)
         !
         ! integer powers 
         !
         forall(k = 0:bsize1) kpow(k) = k
         !
         ! Read in the Numerov functions one by one and construct for each a polynomial times weight-function:
         !
         !do v = 0,bsize1
         !  !
         !  read (io_slot,rec=v+1) (phi(k0),k0=0,npoints),(dphi(k0),k0=0,npoints)
         !  !
         !  if (v==0) then 
         !     !
         !     phi0   = phi
         !     dphi0  = dphi
         !     !
         !  endif
         !  !
         !  ! Construct polynomials to mimic the numerov functions:
         !  !
         !  a_ = 0 ; b_ = 0 
         !  !
         !  do i = 0,npoints
         !    !
         !    do k = 1,v+1
         !      !
         !      a_(i+1,k) = xi(i)**(k-1)*phi0(i)
         !      !
         !    enddo
         !    !
         !    b_(i+1,1) = phi(i)
         !    !
         !  enddo
         !  !
         !  call lapack_gelss(a_(:,:),b_(:,:))
         !  !
         !  pol(v,0:bsize1) = b_(1:bsize1+1,1)
         !  !
         !  ! Schmidt-orthogonalization:
         !  !
         !  call polynom_2_func(npoints,xi(:),phi0(:),v,pol(v,0:v),phi(:))
         !  !
         !  f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
         !  !
         !  pol(v,:) = pol(v,:)/sqrt(f_t)
         !  !
         !  call polynom_2_func(npoints,xi(:),phi0(:),v,pol(v,0:v),phi(:))
         !  !
         !  do u = 0,v-1
         !    !
         !    call polynom_2_func(npoints,xi(:),phi0(:),u,pol(u,0:u),dphi(:))
         !    !
         !    f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*dphi(:))
         !    !
         !    pol(v,:) = pol(v,:)-pol(u,:)*f_t
         !    !
         !    call polynom_2_func(npoints,xi(:),phi0(:),v,pol(v,0:v),phi(:))
         !    !
         !    f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
         !    !
         !    pol(v,:) = pol(v,:)/sqrt(f_t)
         !    !
         !    call polynom_2_func(npoints,xi(:),phi0(:),v,pol(v,0:v),phi(:))
         !    !
         !  enddo
         !  !
         !  ! Check the orthonormality: 
         !  !
         !  f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
         !  !
         !  if (abs(f_t-1.0)>1e3*sqrt(small_)) then 
         !     write(out,"('PTdvr...: the numerov-pol ',i8,' is not normalized: ',g18.8)")  v,f_t
         !     stop 'PTdvr...: the numerov-pol  function is not normalized'
         !  endif
         !  !
         !  do u = 0,v-1
         !    !
         !    call polynom_2_func(npoints,xi(:),phi0(:),u,pol(u,0:u),dphi(:))
         !    !
         !    f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*dphi(:))
         !    !
         !    if (abs(f_t)>1e3*sqrt(small_)) then 
         !       write(out,"('PTdvr...: the numerov-pol functions ',i8,' and ',i8,' are not orthogonal: ',2g18.8)")  v,u,f_t
         !       stop 'PTdvr...: the numerov-pol functions are not orthogonal'
         !    endif
         !    !
         !  enddo
         !  !
         !enddo
         !
         !
         ! Alternative construction
         !
         read (io_slot,rec=1) (phi0(k0),k0=0,npoints),(dphi0(k0),k0=0,npoints)
         !
         pol(1,0) = me%vibmode(imode,-1)%coeff(1,0,0)
         pol(2,0) = 0
         pol(3,0) = 1.0_ark
         !
         do v = 1,bsize1
           !
           read (io_slot,rec=v+1) (phi(k0),k0=0,npoints),(dphi(k0),k0=0,npoints)
           !
           ! Construct polynomials to mimic the numerov functions:
           !
           !a_ = 0 ; b_ = 0
           !
           call polynomab_2_func(npoints,xi(:),phi0(:),v-2,pol(1:3,0:v-2),phi2(:))
           call polynomab_2_func(npoints,xi(:),phi0(:),v-1,pol(1:3,0:v-1),phi1(:))
           !
           do i = 0,npoints
             !
             a_(i+1,1) = -phi1(i)
             a_(i+1,2) = -phi2(i)
             a_(i+1,3) = phi1(i)*xi(i)
             !
             b_(i+1,1) = phi(i)
             !
           enddo
           !
           call lapack_gelss(a_(:,1:3),b_(:,1:1))
           !
           pol(1,v-1) = b_(1,1)
           pol(2,v-1) = b_(2,1)
           pol(3,v-1) = b_(3,1)
           !
           ! Schmidt-orthogonalization:
           !
           call polynomab_2_func(npoints,xi(:),phi0(:),v,pol(1:3,0:v),phi(:))
           !
           !f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
           !
           !pol(1:3,v-1) = pol(1:3,v-1)/sqrt(f_t)
           !
           !call polynomab_2_func(npoints,xi(:),phi0(:),v,pol(1:3,0:v),phi(:))
           !
           !f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
           !
           do u = 0,v-1
             !
             call polynomab_2_func(npoints,xi(:),phi0(:),u,pol(1:3,0:u),dphi(:))
             !
             f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*dphi(:))
             !
             df_t = simpsonintegral_ark(npoints,rho_range,dphi(:)*dphi(:))
             !
             if (u<v-2) cycle
             !
             if (u==v-1) pol(1,v-1) = pol(1,v-1)+f_t/df_t
             if (u==v-2) pol(2,v-1) = pol(2,v-1)+f_t/df_t
             !
             call polynomab_2_func(npoints,xi(:),phi0(:),v,pol(1:3,0:v),phi(:))
             !
             !f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*dphi(:))
             !
             !f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
             !
             !pol(0,:) = pol(0,:)/sqrt(f_t)
             !
             !call polynomab_2_func(npoints,xi(:),phi0(:),v,pol(0,0:v),phi(:))
             !
           enddo
           !
           ! Check the orthonormality: 
           !
           call polynomab_2_func(npoints,xi(:),phi0(:),v,pol(1:3,0:v),phi(:))
           !
           f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
           !
           pol(1:3,v-1) = pol(1:3,v-1)/sqrt(f_t)
           !
           call polynomab_2_func(npoints,xi(:),phi0(:),v,pol(1:3,0:v),phi(:))
           !
           f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*phi(:))
           !
           if (abs(f_t-1.0_ark)>1e3*sqrt(small_)) then 
              write(out,"('PTdvr...: the numerov-pol ',i8,' is not normalized: ',g18.8)")  v,f_t
              stop 'PTdvr...: the numerov-pol  function is not normalized'
           endif
           !
           do u = 0,v-1
           !  !
             call polynomab_2_func(npoints,xi(:),phi0(:),u,pol(1:3,0:u),dphi(:))
             !
             f_t =  simpsonintegral_ark(npoints,rho_range,phi(:)*dphi(:))
             !
             if (abs(f_t)>1e3*sqrt(small_)) then 
                write(out,"('PTdvr...: the numerov-pol functions ',i8,' and ',i8,' are not orthogonal: ',2g18.8)")  v,u,f_t
                stop 'PTdvr...: the numerov-pol functions are not orthogonal'
             endif
             !
           enddo

         enddo
         !
         ! print out the found polynomial coefficients:
         !
         if (job%verbose>=5) then
           !
           write(out,"(/5x,'Polynomial expansion coefficients for species = ',i4)") ispecies
           write(out,"(5x,'   v      P0          P1         P2 ')")
           !
           do v = 0,bs_size
             write(out,"(5x,i4,4f12.6)") v,pol(1:3,v)
           enddo
           !
         endif 
         !
         deallocate(a_,b_,phi1,phi2)
         !
         ! find the roots of the polynomial_np
         !
         root = 0 ; root_ = 0 
         !
         root_(0) = xi(0)
         root_(1) = xi(npoints)
         root(0)  = xi(0)
         !
         do v = 1,bsize1
           !
           do i = 1,v
             !
             y1 = root_(i-1)
             y2 = root_(i)
             !
             !root(i) = rtbis_pol(v,pol(v,0:v),y1,y2,(small_))
             !
             root(i) = rtbis_ab_pol(v,pol(1:3,0:v),y1,y2,small_)
             !
           enddo
           !
           root_  = root
           !
           root_(v+1) = xi(npoints)
           !
         enddo
         !
         dvr%abcissa(ispecies)%coeff1d(1:dvr_size) = root(1:dvr_size)
         !
         ! create the abscissas
         !
         !allocate (H1dvr(dvr_size,dvr_size),e1dvr(dvr_size),stat=alloc)
         !if (alloc/=0) then
         !   write (out,"(' Error ',i9,' trying to allocate H1dvr-fields')") alloc
         !   stop 'PTDVR_initialize, points -  out of memory'
         !end if
         !
         ! Create the Q-DVR matrix
         !
         !do v = 0,bs_size
         !  !
         !  call polynom_2_func(npoints,xi(:),phi0(:),v,pol(v,0:v),phi(:))
         !  !
         !  do u = 0,v
         !     !
         !     call polynom_2_func(npoints,xi(:),phi0(:),u,pol(u,0:u),dphi(:))
         !     !
         !     H1dvr(v+1,u+1) = simpsonintegral_ark(npoints,rho_range,phi(:)*dphi(:)*xi(:))
         !     H1dvr(u+1,v+1) = H1dvr(v+1,u+1)
         !     !
         !  enddo
         !enddo
         !
         !call lapack_syev(H1dvr,e1dvr)
         !
         ! This defines the DVR-coordinates:
         !
         !dvr%abcissa(ispecies)%coeff1d(1:dvr_size) = e1dvr(1:dvr_size)
         !
         !deallocate( H1dvr,e1dvr)
         !
         ! projecting the zero-function onto the abcissas by interpolating using the Numerov points
         !
         f2_t = 0 
         !omp parallel do private(idvrpoint,xval,ipoint,k,x,fval,f_t,dfval,df_t) shared(w)
         do idvrpoint = 1,dvr_size
           !
           xval = dvr%abcissa(ispecies)%coeff1d(idvrpoint)+trove%chi0_ref(imode)
           !
           ipoint = nint( ( xval-bs(imode)%borders(1) )/rhostep,kind=ik )
           !
           k1 = max(0,ipoint-2)-ipoint
           k2 = min(npoints,ipoint+2)-ipoint
           !
           if (k1>-2) k2 = k1+4
           if (k2< 2) k1 = k2-4
           !
           i = -3 
           do k=k1,k2
             !
             i = i + 1
             !
             x(i) = bs(imode)%borders(1)+real(ipoint+k,ark)*rhostep
             !
           enddo
           !
           call polintark(x(-2:2), phi0(ipoint+k1:ipoint+k2),xval, fval, f_t)
           !
           phi0_(idvrpoint)  =  fval
           !
           ! in order to compute the derivative of the primitive we will need "d_phi0_d_x/phi0": 
           !
           i = -3 
           do k=k1,k2
             !
             i = i + 1
             !
             if (abs(phi0(ipoint+k))>small_) then 
               !
               df_f(i) = dphi0(ipoint+k)/phi0(ipoint+k)
               !
             else
               !
               df_f(i) = 0
               !
             endif
           enddo
           !
           call polintark(x(-2:2),df_f(-2:2),xval,dfval,df_t)
           !
           dphi0_(idvrpoint) = dfval
           !
           if (f_t>1e3*sqrt(small_).or.df_t>1e5*sqrt(small_)) then 
              !
              write(out,"('PTdvr...: Error in polint is too large: ',2g18.8,'; ipoint= ',i8)")  f_t,df_t,ipoint
              write(out,"('xval,fval,dval = ',3g18.8,' func = ',5g18.8)") xval,fval,dfval,& 
                           phi0(max(ipoint-2,0):min(ipoint+2,npoints))
              write(out,"('dfunc/func                           ',5g18.8)") df_f(-2:2)
              !stop 'PTdvr...: Error in polint is too large'
              !
           endif

         enddo
         !omp end parallel do
         !
         ! store to hard disk in the same format as the Numerov functions - to be used for symmetrization
         !
         do v =  0,bs_size
           !
           call polynomab_2_func(npoints,xi(:),phi0(:),v,pol(1:3,0:v),phi(:))
           !
           write (jo_slot,rec=v+1) (phi(i),i=0,Npoints)
           !
         enddo
         !
         deallocate(xi,root_,root)
         !
         ! constructing the new primitive (polynomial-kind) basis functions along with their derivatives 
         !
         allocate (xi(0:dvr_size-1),w_(0:dvr_size-1),u_(0:dvr_size-1),g_(0:dvr_size-1),&
                   h_(0:dvr_size-1),dpol(0:bs_size),stat=alloc)
         !
         size_total = dvr_size*5+bs_size+1
         !
         call ArrayStart('dvr-fields_',alloc,1,kind(dpol),size_total)
         !
         w_(0:dvr_size-1) =  1.0_ark 
         u_(0:dvr_size-1) =  dphi0_(1:dvr_size) 
         !
         rho_range = bs(imode)%borders(2)-bs(imode)%borders(1)
         !
         xi(0:dvr_size-1) = dvr%abcissa(ispecies)%coeff1d(1:dvr_size)
         !
         do v =  0,bs_size
           !
           call polynomab_2_func(dvr_size-1,xi(:),w_(:),v,pol(1:3,0:v),g_(:),h_(:))
           !
           !!! call polynom_2_func(dvr_size-1,xi(:),w_(:),v,pol(v,0:v),g_(:))
           !
           psi_prim(v,1:dvr_size) = g_(0:dvr_size-1)
           ! 
           ! The derivative of the polynomial:
           !
           !dpol = 0
           !
           !!do u = 0,v-1
           !!  !
           !!  dpol(u) = pol(v,u+1)*real(u+1,rk)
           !!  !
           !!enddo
           !
           !!call polynom_2_func(dvr_size-1,xi(:),w_(:),v  ,dpol(  0:v),g_(:))
           !!call polynom_2_func(dvr_size-1,xi(:),u_(:),v  , pol(v,0:v),h_(:))
           !
           call polynomab_2_func(dvr_size-1,xi(:),u_(:),v  , pol(1:3,0:v),g_(:))
           !
           dpsi_prim(v,1:dvr_size) = g_(0:dvr_size-1)+h_(0:dvr_size-1)
           !
         enddo
         !
         ! Finally defining the weights
         !
         !!dpol = 0
         !
         !!v = bsize1
         !
         !!do u = 0,v-1
         !!  !
         !!  dpol(u) = pol(v,u+1)*real(u+1,rk)
         !!  !
         !!enddo
         !
         do i =  1,dvr_size
           !
           xval = dvr%abcissa(ispecies)%coeff1d(i)
           !
           fval = polynomab(xval,bsize1,pol(1:3,0:bsize1),dfval)
           fval = polynomab(xval,bs_size,pol(1:3,0:bs_size))
           !
           !! fval  = sum( pol(bs_size,0:bs_size)*xval**kpow(0:bs_size) )
           !! dfval = sum( dpol(0:bs_size)*xval**kpow(0:bs_size) )
           !
           h_(i-1) = 1.0_ark / ( fval*dfval )
           !
           !dvr%weight(ispecies)%coeff1d(i) = fval
           !
         enddo
         !
         v = 0
         !
         call polynomab_2_func(dvr_size-1,xi(:),w_(:),v,pol(1:3,0:v),g_(:))
         !
         fval = sum(g_(:)*h_(:)*g_(:))
         !
         !f_t = sum(psi_prim(0,:)*psi_prim(0,:)*dvr%weight(ispecies)%coeff1d(:))
         !
         h_(:) = h_(:)/fval
         !
         dvr%weight(ispecies)%coeff1d(:) = h_(:)
         !
         do i =  1,dvr_size
           !
           if (dvr%weight(ispecies)%coeff1d(i)<0.and.abs( dvr%weight(ispecies)%coeff1d(i) )<small_ ) &
               dvr%weight(ispecies)%coeff1d(i) = 0 
           !
         enddo
         !
         ! An alternative construction of weights
         !
         !allocate (a_(1:bs_size+1,dvr_size),b_(1:bs_size+1,1),stat=alloc)
         !
         !call ArrayStart('dvr-fields_',alloc,1,kind(a_),size(a_))
         !call ArrayStart('dvr-fields_',alloc,1,kind(b_),size(b_))
         !
         !b_ = 0 ; b_(1,1) = 1.0_ark
         !
         !omp parallel do private(v) shared(a)
         !do v = 0,bs_size
         !  !
         !  a_(v+1,:) = psi_prim(0,:)*psi_prim(v,:)
         !  !
         !enddo
         !omp end parallel do
         !
         !call lapack_gelss(a_(1:bs_size+1,:),b_(1:bs_size+1,:))
         !
         !do i =  1,dvr_size
         !  if (b_(i,1)<0.and.abs( b_(i,1) )<small_ ) b_(i,1) = 0 
         !enddo
         !
         !dvr%weight(ispecies)%coeff1d(1:dvr_size) = b_(1:dvr_size,1)
         !
         !if ( any( dvr%weight(ispecies)%coeff1d(1:dvr_size) <0 ) ) then 
         !  !
         !  write(out,"('PTDVR_initialize: weights are negative for ispecies = ',i9,' : ',<dvr_size>(1x,e12.7))") ispecies,b(1:dvr_size,1)
         !  stop 'PTDVR_initialize: negative weights'
         !  !
         !endif 
         !
         !deallocate (a_,b_)
         !
         deallocate (pol,xi,phi0,dphi0,phi0_,dphi0_,kpow,w_,u_,g_,h_,dpol)
         !
         call ArrayStop('dvr-fields_')
         !
      end select
      !
      if (trim(bs(imode)%type)=='NUMEROV') then 
        !
        deallocate (phi,dphi,phipsi)
        !
      endif   
      !
      if (trim(bs(imode)%type)=='NUMEROV'.and.&
          (dvr%abcissa(ispecies)%coeff1d(1)<bs(imode)%borders(1)-trove%chi0_ref(imode).or.&
           dvr%abcissa(ispecies)%coeff1d(dvr_size)>bs(imode)%borders(2)-trove%chi0_ref(imode))) then 
        !
        write(out,"('PTDVR_initialize..: For ispecies ',i4,' the integration area is too small:',2f12.4,' vs ',2f12.4)") & 
            ispecies,bs(imode)%borders(1:2)-trove%chi0_ref(imode),&
            dvr%abcissa(ispecies)%coeff1d(1),dvr%abcissa(ispecies)%coeff1d(dvr_size)
        stop 'PTDVR_initialize..: the integration area is too small'
        !
      endif
      !
      ! including the weights into the prim-functions
      !
      !$omp parallel do private(v)
      do v = 0,bs_size
        !
        dvr%prim_func (ispecies)%coeffs(v,1:dvr_size) =  psi_prim(v,1:dvr_size)*sqrt(dvr%weight(ispecies)%coeff1d(1:dvr_size))
        dvr%prim_dfunc(ispecies)%coeffs(v,1:dvr_size) = dpsi_prim(v,1:dvr_size)*sqrt(dvr%weight(ispecies)%coeff1d(1:dvr_size))
        !
      enddo
      !$omp end parallel do
      !
      ! Check the orthogonality in order to make sure that the dvr-basis and grids are all consistent:
      !
      do i =  0,bs_size
        !
        f_t = sum(dvr%prim_func (ispecies)%coeffs(i,:)*dvr%prim_func (ispecies)%coeffs(i,:))
        !
        if (abs(f_t-1.0)>1e3*sqrt(small_)) then 
           write(out,"('PTdvr...: the dvr function ',i8,' is not normalized: ',2g18.8,'; ipoint= ',i8)")  i,f_t
           stop 'PTdvr...: the dvr function is not normalized'
        endif
        !
        do v = i+1,bs_size
          !
          f_t = sum(dvr%prim_func (ispecies)%coeffs(i,:)*dvr%prim_func (ispecies)%coeffs(v,:))
          !
          if (f_t>1e3*sqrt(small_)) then 
             write(out,"('PTdvr...: the dvr functions ',i8,' and ',i8,' are not orthogonal: ',2g18.8,'; ipoint= ',i8)")  i,v,f_t
             stop 'PTdvr...: the dvr functions are not orthogonal'
          endif
          ! 
        enddo 
        !
      enddo
      !
      deallocate (psi_prim,dpsi_prim)
      call ArrayStop('dvr-numer')
      !
      if (bs_size/=0.and.trim(bs(imode)%type)=='NUMEROV') then
         !
         allocate (H1dvr(bs_size+1,bs_size+1),e1dvr(bs_size+1),w_(dvr_size),g_(dvr_size),aa(bs_size+1,bs_size+1),&
                   extF_t(max(extF_rank,1)),stat=alloc)
         if (alloc/=0) then
            write (out,"(' Error ',i9,' trying to allocate H1dvr-fields')") alloc
            stop 'PTDVR_initialize, points -  out of memory'
         end if
         !
         if (trove%Nmodes_e==trove%Nmodes) then
           !
           dchi = 0
           !
           irho = 0
           !
           do idvrpoint = 1,dvr_size
             !
             dchi(imode) = dvr%abcissa(ispecies)%coeff1d(idvrpoint)
             !
             call FLcalc_poten_kinet_dvr(dchi,irho,poten_t,gvib_t,grot_t,gcor_t,extF_t,reduced_model)
             !
             w_(idvrpoint) = poten_t 
             g_(idvrpoint) = ( gvib_t(imode,imode)*0.5_ark )
             !
           enddo
           !
         else
           !
           dchi = 0
           !
           rhostep = (bs(PT%Nmodes)%borders(2)-bs(PT%Nmodes)%borders(1))/real(bs(PT%Nmodes)%npoints,kind=ark)
           !
           do idvrpoint = 1,dvr_size
             !
             dchi(imode) = dvr%abcissa(ispecies)%coeff1d(idvrpoint)
             !
             xval = dchi(PT%Nmodes)+trove%chi0_ref(PT%Nmodes)
             !  
             irho = mod(nint( ( xval-bs(PT%Nmodes)%borders(1) )/rhostep,ik ),bs(PT%Nmodes)%npoints)
             !
             do i=-2,2
               !
               irho_ = min(max(irho+i,0),bs(PT%Nmodes)%npoints)
               !
               x(i) = trove%rho_border(1)+irho_*trove%rhostep
               !
               dchi_(PT%Nmodes) = x(i)-trove%chi0_ref(PT%Nmodes)
               !
               dchi_(1:trove%Nmodes_e) = dchi(1:trove%Nmodes_e) + trove%chi0_ref(1:trove%Nmodes_e) -&
                                                                  trove%chi_ref(1:trove%Nmodes_e,irho_)
               !
               call FLcalc_poten_kinet_dvr(dchi_,irho_,poten_t,gvib_t,grot_t,gcor_t,extF_t,reduced_model)
               !
               poten_(i) = poten_t
               gvib_(:,:,i) = gvib_t(:,:) 
               !
             enddo
             !
             ! Potential function
             !
             call polintark(x(-2:2),poten_(-2:2),xval,fval,df_t)
             !
             w_(idvrpoint) = fval
             !
             ! Vibrational kinetic part
             !
             call polintark(x(-2:2),gvib_(imode,imode,-2:2),xval,fval,df_t)
             g_(idvrpoint) = fval*0.5_ark
             !
           enddo
           !
         endif
         !
         do i =  0,bs_size
           do v = i,bs_size
             !
             H1dvr(i+1,v+1) = sum(dvr%prim_func (ispecies)%coeffs(i,:)*dvr%prim_func (ispecies)%coeffs(v,:)*w_(:))
             H1dvr(i+1,v+1) = H1dvr(i+1,v+1) + sum(dvr%prim_dfunc(ispecies)%coeffs(i,:)*dvr%prim_dfunc(ispecies)%coeffs(v,:)*g_(:))
             H1dvr(v+1,i+1) = H1dvr(i+1,v+1)
             ! 
           enddo
         enddo
         !
         call lapack_syev(H1dvr,e1dvr)
         !
         aa = real(H1dvr,ark)
         !
         bset%bs1D(ispecies)%ener0(0:bs_size) = e1dvr(1:bs_size+1)-e1dvr(1)
         !
         do idvrpoint = 1,dvr_size
           !
           dvr%prim_func (ispecies)%coeffs(:,idvrpoint) = matmul(transpose(aa(:,:)),dvr%prim_func (ispecies)%coeffs(:,idvrpoint))
           dvr%prim_dfunc(ispecies)%coeffs(:,idvrpoint) = matmul(transpose(aa(:,:)),dvr%prim_dfunc(ispecies)%coeffs(:,idvrpoint))
           !
         enddo
         !
         do i =  0,bs_size
           do v = i,bs_size
             !
             H1dvr(i+1,v+1) = sum(dvr%prim_func (ispecies)%coeffs(i,:)*dvr%prim_func (ispecies)%coeffs(v,:)*w_(:))
             H1dvr(i+1,v+1) = H1dvr(i+1,v+1) + sum(dvr%prim_dfunc(ispecies)%coeffs(i,:)*dvr%prim_dfunc(ispecies)%coeffs(v,:)*g_(:))
             H1dvr(v+1,i+1) = H1dvr(i+1,v+1)
             ! 
           enddo
         enddo
         !
         call IOStart(trim(unitfname),jo_slot)
         !
         inquire(jo_slot,opened=ifopened)
         !
         if (ifopened) then
           !
           allocate(phi_(0:bs_size,0:npoints),stat=alloc)
           !
           do v =  0,bs_size
             !
             read(jo_slot,rec=v+1) (phi_(v,i),i=0,Npoints)
             !
           enddo
           !
           do i =  0,npoints
             !
             phi_(:,i) = matmul(transpose(aa(:,:)),phi_(:,i))
             !
           enddo
           !
           do v =  0,bs_size
             !
             write(jo_slot,rec=v+1) (phi_(v,i),i=0,Npoints)
             !
           enddo
           !
           deallocate(phi_)
           !
         endif
         !
         deallocate(H1dvr,e1dvr,w_,g_,aa,extF_t)
         !
      endif 
      !
    enddo ! next ispecies =>
    !
    if (job%verbose>=4) then 
      write(out,"(/5x,'DVR-abcissas:')")
      do ispecies = 1,PT%Nspecies
         !
         dvr_size = size(dvr%abcissa(ispecies)%coeff1d)
         write(my_fmt,'(a,i0,a)') "(5x,i4,",dvr_size,"f18.8)"
         !
         write(out,my_fmt) ispecies,dvr%abcissa(ispecies)%coeff1d(1:dvr_size)
         !
      enddo 
    endif 
    !
    !
    !
    !  Here we define the the Hamiltonian fields (poten, gvib, grot, gcor) in the DVR representation
    !
    !
    ! count the dvr grid points imposing the 'potencut'-limit. 
    !
    size_total = 0 
    !
    call count_gridpoints(1,k_t,size_total)
    !
    do imode=1,PT%Nmodes
      !
      dvr%nsize(imode) = bs(imode)%dvrpoints
      !
    enddo 
    !
    ! The size of the DVR-spase
    !
    dvr%total_size = size_total
    !
    if (job%verbose>=3) write(out,"(/'     Number of DVR points = ',i8)")  dvr%total_size 
    !
    allocate (dvr%poten(size_total),dvr%gvib(PT%Nmodes,PT%Nmodes,size_total),dvr%kindex(size_total,PT%Nmodes),&
              dvr%icheck_deriv(PT%Nclasses,0:PT%Nmodes),stat=alloc)
    call ArrayStart('dvr-fields',alloc,1,kind(dvr%poten),size_total)
    call ArrayStart('dvr-fields',alloc,1,kind(dvr%gvib),size_total*PT%Nmodes*PT%Nmodes)
    call ArrayStart('dvr-fields',alloc,1,kind(dvr%kindex),size_total)
    call ArrayStart('dvr-fields',alloc,size(dvr%icheck_deriv),kind(dvr%icheck_deriv))
    !
    if (treat_rotation) then 
       !
       allocate (dvr%grot(3,3,size_total),dvr%gcor(PT%Nmodes,3,size_total),stat=alloc)
       !
       call ArrayStart('dvr-fields',alloc,1,kind(dvr%grot),size_total*9)
       call ArrayStart('dvr-fields',alloc,1,kind(dvr%gcor),size_total*3*PT%Nmodes)
       !
    endif
    !
    if (FLextF_coeffs) then 
       !
       allocate (dvr%extF(extF_rank,size_total),stat=alloc)
       call ArrayStart('dvr-fields',alloc,1,kind(dvr%extF),size_total*extF_rank)
       !
    endif
    !
    dvr%kindex = 0 
    !
    ! define the destribution of the grid points over the different mode using the field kindex
    !
    isum = 0
    !
    call count_gridpoints(1,k_t,isum,dvr%kindex)
    !
    ! store the information on the dvr-points destribution for each class separetely 
    !
    if (present(iclass_)) then 
      !
      allocate (contr(iclass_)%dvr_kindex(dvr%total_size,PT%Nmodes),stat=alloc)
      call ArrayStart('dvr-fields-kindex',alloc,size(contr(iclass_)%dvr_kindex),kind(contr(iclass_)%dvr_kindex))
      !
      contr(iclass_)%dvr_kindex = dvr%kindex
      !
      contr(iclass_)%Ndvrpoints = dvr%total_size
      !
    endif 
    !
    ! This object will be need later for the contracted mat. elements 
    !
    dvr%icheck_deriv = 0
    !
    do iclass = 1,PT%Nclasses
      !
      im1 = PT%mode_class(iclass,1)
      im2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
      !
      do i = 1,PT%Nmodes
        !
        if (im1<=i.and.i<=im2) dvr%icheck_deriv(iclass,i) = i
        !
      enddo
      !
    enddo
    !
    if (trove%Nmodes_e/=trove%Nmodes) then
      !
      rhostep = dvr%drho(trove%Nmodes)
      !
    endif
    !
    if (job%verbose>=5) write(out,"( '     ...done!')")
    if (job%verbose>=5) write(out,"(/'     Generating the DVR representation for the Hamiltonian fields...')")
    !
    ! A pointwise generation of the DVR-fields
    !
    !$omp parallel private(extF_t,extF_) 
    allocate(extF_t(max(extF_rank,1)),extF_(max(extF_rank,1),-2:2))
    ! 
    !$omp  do private(idvrpoint,imode,ispecies,k,dchi,irho,poten_t,gvib_t,grot_t,gcor_t,xval,dchi_,i,irho_,x,poten_,gvib_,grot_,&
    !$omp& gcor_,fval,df_t,k1,k2,imu)
    do idvrpoint = 1,size_total
      !
      do imode = 1,PT%Nmodes
        !
        ispecies = PT%Mspecies(imode)
        !
        k = dvr%kindex(idvrpoint,imode)
        !
        dchi(imode) = dvr%abcissa(ispecies)%coeff1d(k)
        !
      enddo
      !
      if (trove%Nmodes_e==trove%Nmodes) then
        !
        irho = 0
        !
        call FLcalc_poten_kinet_dvr(dchi,irho,poten_t,gvib_t,grot_t,gcor_t,extF_t,reduced_model)
        !
        dvr%poten(idvrpoint) = poten_t 
        dvr%gvib(:,:,idvrpoint) = ( gvib_t(:,:)*0.5_ark )
        !
        if (treat_rotation) then 
          !
          dvr%grot(:,:,idvrpoint) = grot_t(:,:)
          dvr%gcor(:,:,idvrpoint) = gcor_t(:,:)
          !
        endif
        !
        if (FLextF_coeffs) then 
          !
          dvr%extF(:,idvrpoint) = extF_t(:)
          !
        endif
        !
      else
        !
        !write(out,"('DVR-non-rigid part was not properly tested yet. Check before using!')")
        !stop 'DVR-non-rigid part was not properly tested yet!'
        !
        imode = PT%Nmodes
        !
        npoints = bs(imode)%npoints
        !
        xval = dchi(imode)+trove%chi0_ref(imode)
        !  
        irho = mod(nint( ( xval-bs(imode)%borders(1) )/rhostep,ik ),bs(imode)%npoints)
        !
        !dchi_(:) = dchi(:)
        !
        do i=-2,2
          !
          irho_ = min(max(irho+i,0),npoints)
          !
          x(i) = trove%rho_border(1)+irho_*trove%rhostep
          !
          dchi_(imode) = x(i)-trove%chi0_ref(imode)
          !
          dchi_(1:trove%Nmodes_e) = dchi(1:trove%Nmodes_e) + trove%chi0_ref(1:trove%Nmodes_e) - &
                                                             trove%chi_ref(1:trove%Nmodes_e,irho_)
          !
          call FLcalc_poten_kinet_dvr(dchi_,irho_,poten_t,gvib_t,grot_t,gcor_t,extF_t,reduced_model)
          !
          poten_(i) = poten_t
          gvib_(:,:,i) = gvib_t(:,:) 
          !
          if (treat_rotation) then 
            !
            grot_(:,:,i) = grot_t(:,:)
            gcor_(:,:,i) = gcor_t(:,:)
            !
          endif 
          !
          if (FLextF_coeffs) then 
            !
            extF_(:,i) = extF_t(:)
            !
          endif
          !
        enddo
        !
        ! Potential function
        !
        call polintark(x(-2:2),poten_(-2:2),xval,fval,df_t)
        !
        dvr%poten(idvrpoint) = fval
        !
        ! Vibrational kinetic part
        !
        do k1 = 1,trove%Nmodes
           do k2 = 1,trove%Nmodes
             !
             call polintark(x(-2:2),gvib_(k1,k2,-2:2),xval,fval,df_t)
             dvr%gvib(k1,k2,idvrpoint) = fval*0.5_ark
             !
           enddo
        enddo
        !
        ! Rotational part and Coriolis parts of the kinetic operator g_rot
        !
        if (treat_rotation) then
          !
          do k1 = 1,3
             do k2 = 1,3
                !
                call polintark(x(-2:2),grot_(k1,k2,-2:2),xval,fval,df_t)
                dvr%grot(k1,k2,idvrpoint) = fval
                ! 
             enddo
          enddo
          !
          !
          do k1 = 1,trove%Nmodes
             do k2 = 1,3
                !
                call polintark(x(-2:2),gcor_(k1,k2,-2:2),xval,fval,df_t)
                dvr%gcor(k1,k2,idvrpoint) = fval
                ! 
             enddo
          enddo
          !
        endif 
        !
        !
        if (FLextF_coeffs) then 
          !
          do imu = 1,extF_rank
              !
              call polintark(x(-2:2),extF_(imu,-2:2),xval,fval,df_t)
              dvr%extF(imu,idvrpoint) = fval
              ! 
          enddo
          !
        endif
        !
      endif
      !
      !if (job%verbose>=7) then
      !  !
      !  k = trove%nmodes**2
      !  !
      !  write(out,"(5x,<trove%nmodes>f18.8,2x,f18.8,x,<k>f18.8)") dchi(:),dvr%poten(idvrpoint) ! ,dvr%gvib(:,:,idvrpoint)
      !  !
      !endif 
      !
    enddo
    !$omp end do 
    !
    deallocate(extF_t,extF_)
    !$omp end parallel
    !
    if (job%verbose>=4) write(out,"('  ...done!')")
    !
    call TimerStop('PTDVR_initialize')
    !
    contains 
    !
    ! procedure for counting the grid points of the full-dimensional grid
    !
    recursive subroutine count_gridpoints(imode,k_src,isum,k_dst)
     integer(ik),intent(in)     :: imode
     integer(ik),intent(inout)  :: k_src(PT%Nmodes)
     integer(hik),intent(out)   :: isum
     integer(ik),optional       :: k_dst(:,:)
     !
     integer(ik) :: i,irho,jmode,jspecies,j,n1,ix,jx
     real(rk)    :: r(trove%Ncoords),xval,rhostep,ener0,jmat(3,3),eval(3)
     real(ark)   :: dchi_t(trove%Nmodes),r_na(trove%Natoms,3)
     real(ark)   :: chi(trove%Nmodes)
     character(len=cl)            :: dir
     !
     do i=1,bs(imode)%dvrpoints
        !
        k_src(imode) = i
        !
        if (imode/=PT%Nmodes) then
          !
          call count_gridpoints(imode+1_ik,k_src,isum,k_dst)
          !
        else
          !
          irho  = 0
          !
          if (trove%Nmodes_e/=trove%Nmodes) then
            !
            jmode = PT%Nmodes
            !
            jspecies = PT%Mspecies(jmode)
            !
            j = k_src(jmode)
            !
            xval = dvr%abcissa(jspecies)%coeff1d(j)+trove%chi0_ref(jmode)
            !
            rhostep = dvr%drho(jmode)
            !  
            irho = nint( ( xval-bs(jmode)%borders(1) )/rhostep,kind=ik )
            !
            dchi_t(jmode) = dvr%abcissa(jspecies)%coeff1d(j)
            !
          endif
          !
          do jmode = 1,trove%Nmodes_e
            !
            jspecies = PT%Mspecies(jmode)
            !
            j = k_src(jmode)
            !
            dchi_t(jmode) = dvr%abcissa(jspecies)%coeff1d(j) + trove%chi0_ref(jmode) - trove%chi_ref(jmode,irho)
            !
          enddo
          !
          ener0 =  FLpoten_linearized_dchi(dchi_t,irho)
          !
          do n1 = 1,trove%Natoms
             do ix = 1,3
               !
               r_na(n1,ix) = trove%b0(n1,ix,irho) + sum( trove%Amatrho(n1,ix,1:trove%Nmodes_e,irho)*dchi_t(1:trove%Nmodes_e) )
               !
             enddo
          enddo
          !
          do ix = 1,3
             do jx = 1,3
               !
               Jmat(ix,jx) = jmat_gg(ix,jx,trove%b0(:,:,irho),r_na(:,:))
               !
             enddo
          enddo
          !
          call lapack_syev(jmat(:,:),eval(:))
          !
          if (trove%lincoord/=0) eval = 1.0
          !
          !call FLfromcartesian2local(r_na,r)
          !
          !dir = 'INVERSE'
          !
          !chi = MLcoordinate_transform_func(r,size(chi),dir)
          !
          if (ener0<=job%potencut.and.all(eval(:)>sqrt(small_)) ) then
            !
            isum = isum + 1
            !
            if (present(k_dst)) k_dst(isum,:) = k_src(:)
            !
          endif
          !
        endif
        !
     enddo
     !
   end subroutine count_gridpoints
   !
   function jmat_gg(g1,g2,a,b) result (v)
     !
     integer(ik),intent(in) :: g1,g2
     real(ark),intent(in)   :: a(:,:),b(:,:)
     real(ark)              :: v
      !
      v = -sum( trove%mass(:)*b(:,g1)*a(:,g2) )
      !
      if (g1==g2) v = v + sum( trove%mass(:)*( a(:,1)*b(:,1)+a(:,2)*b(:,2)+a(:,3)*b(:,3) ) )
      !
   end function jmat_gg

   subroutine polynom_2_func(npoints,x,basis,np,pol,func)
      !
      integer(ik),intent(in)  :: npoints,np
      real(ark),intent(in)    :: x(0:npoints),basis(0:npoints),pol(0:np)
      real(ark),intent(out)   :: func(0:npoints)
      !
      integer(ik) :: k,i
      real(ark)    :: fval,xval
      !
      do i = 0,npoints
        !
        fval = pol(0)
        xval = x(i)
        !
        do k = 1,np
          fval = fval + pol(k)*xval**k
        enddo
        !
        func(i) = fval*basis(i)
        !
      enddo

   end subroutine polynom_2_func

   subroutine polynomab_2_func(npoints,x,basis,np,pol,func,dfunc)
      !
      integer(ik),intent(in)  :: npoints,np
      real(ark),intent(in)    :: x(0:npoints),basis(0:npoints),pol(1:3,0:np)
      real(ark),intent(out)   :: func(0:npoints)
      real(ark),intent(out),optional  :: dfunc(0:npoints)
      !
      integer(ik) :: k,i
      real(ark)    :: fm1,fp1,f0,xval,dfm1,dfp1,df0
      !
      if (np<0) then 
        func = 0
        if (present(dfunc)) dfunc = 0
        return
      endif
      !
      do i = 0,npoints
        !
        xval = x(i)
        !
        fm1 = 0
        f0  = 1.0_ark
        !
        dfm1 = 0
        df0  = 0
        !
        do k = 0,np-1
          !
          fp1 = ( pol(3,k)*xval-pol(1,k) )*f0 - pol(2,k)*fm1
          fm1 = f0
          f0 = fp1
          !
          if (present(dfunc)) then 
            !
            dfp1 = ( pol(3,k)*xval-pol(1,k) )*df0 - pol(2,k)*dfm1+pol(3,k)*fm1
            dfm1 = df0
            df0 = dfp1
            !
          endif
          !
        enddo
        !
        func(i) = f0*basis(i)
        !
        if (present(dfunc)) then 
          !
          dfunc(i) = df0*basis(i)
          !
        endif 
        !
      enddo

   end subroutine polynomab_2_func


   function polynomab(x,np,pol,df) result(f)
      !
      integer(ik),intent(in)  :: np
      real(ark),intent(in)    :: x,pol(1:3,0:np)
      real(ark),intent(out),optional    :: df
      !
      integer(ik)  :: k
      real(ark)    :: fm1,fp1,f0,f,dfm1,dfp1,df0
      !
      f = 0
      if (present(df)) df = 0
      !
      if (np<0) return
      !
      fm1 = 0
      f0  = 1.0_ark
      !
      dfm1 = 0
      df0  = 0
      !
      do k = 0,np-1
        !
        fp1 = ( pol(3,k)*x-pol(1,k) )*f0 - pol(2,k)*fm1
        fm1 = f0
        f0 = fp1
        !
        if (present(df)) then 
          !
          dfp1 = ( pol(3,k)*x-pol(1,k) )*df0 - pol(2,k)*dfm1+pol(3,k)*fm1
          dfm1 = df0
          df0 = dfp1
          !
        endif
        !
      enddo
      !
      f = f0
      if (present(df)) df = df0

   end function polynomab





   real(ark) function rtbis_pol(np,pol,x1,x2,xacc)
     !
     integer(ik),intent(in) :: np
     real(ark),intent(in)   :: pol(0:np),x1,x2
     real(rk),intent(in)    :: xacc
     integer(ik)            :: j,k(0:np)
     real(ark)              :: dx,f,fmid,xmid
     !
     integer(ik) :: jmax
     parameter (jmax=100) !  maximum allowed number of bisections.
     !
     !using bisection, find the root of a function func known to lie between x1 and x2. the
     !root, returned as rtbis, will be refined until its accuracy is \B1xacc.
     !
     forall(j = 0:np) k(j) = j
     !
     fmid=sum( pol(:)*x2**k(:) )
     !
     f=sum( pol(:)*x1**k(:) )
     !
     if(f*fmid.ge.0.) stop 'root must be bracketed in rtbis'
     ! orient the search so that f>0 lies at x+dx.
     if(f.lt.0.0_ark) then  
       rtbis_pol=x1
       dx=x2-x1
     else
       rtbis_pol=x2
       dx=x1-x2
     endif
     !
     do j=1,jmax ! bisection loop.
       !
       dx=dx*0.5_ark
       xmid=rtbis_pol+dx
       fmid=sum( pol(:)*xmid**k(:) )
       if(fmid.le.0.) rtbis_pol=xmid
       if(abs(dx).lt.xacc .or. fmid.eq.0.) return
       !
     enddo
     !
     stop 'too many bisections in rtbis_pol'
     !
   end function rtbis_pol


   real(ark) function rtbis_ab_pol(np,pol,x1,x2,xacc)
     !
     integer(ik),intent(in) :: np
     real(ark),intent(in)   :: pol(1:2,0:np),x1,x2
     real(rk),intent(in)    :: xacc
     integer(ik)            :: j,k(0:np)
     real(ark)              :: dx,f,fmid,xmid
     !
     integer(ik) :: jmax
     parameter (jmax=100) !  maximum allowed number of bisections.
     !
     !using bisection, find the root of a function func known to lie between x1 and x2. the
     !root, returned as rtbis, will be refined until its accuracy is \B1xacc.
     !
     forall(j = 0:np) k(j) = j
     !
     fmid=polynomab(x2,np,pol)
     !
     f=polynomab(x1,np,pol)
     !
     if(f*fmid.ge.0.) stop 'root must be bracketed in rtbis'
     ! orient the search so that f>0 lies at x+dx.
     if(f.lt.0.0_ark) then  
       rtbis_ab_pol=x1
       dx=x2-x1
     else
       rtbis_ab_pol=x2
       dx=x1-x2
     endif
     !
     do j=1,jmax ! bisection loop.
       !
       dx=dx*0.5_ark
       xmid=rtbis_ab_pol+dx
       !
       fmid=polynomab(xmid,np,pol)
       !
       if(fmid.le.0.) rtbis_ab_pol=xmid
       if(abs(dx).lt.xacc .or. fmid.eq.0.) return
       !
     enddo
     !
     stop 'too many bisections in rtbis_pol'
     !
   end function rtbis_ab_pol


   !
  end subroutine PTDVR_initialize



  subroutine PTDVR_contracted_basis_generate(j)


    integer(ik),intent(in) :: j     ! current rotational quantum

    real(rk)               :: f_prim,sum_f,sum_d(PT%Nmodes),mat_f(PT%Nmodes),mat_d(PT%Nmodes)
    integer(ik)            :: k,ic,iclass,ideg,im1,im2,alloc
    integer(ik)            :: imode,iprim,ispecies,ilevel,nlevels,level_degen
    integer(ik)            :: ip(PT%Nmodes),nu(PT%Nmodes),icp(PT%Nmodes)
    !
    logical                ::  reduced_model = .false.
    !
    !type(PTlevelT)         ::    vec
    !
    integer(hik)           :: matsize
      !
      if (job%verbose>=4) write(out,"(/'Converting the contracted basis into the DVR-grid representaion...')")
      !
      call TimerStart('PTDVR_contracted_basis_generate')
      !
      call PTDVR_initialize(j,job%bset,reduced_model_=reduced_model,ifread=.true.)
      !
      if(trim(job%IOdvr_prim)=='SAVE') call PTcheck_point_dvr('save')
      !
      if (trim(job%IOswap_matelem)=='JOIN') return
      !
      !call PTDVR_initialize(j,job%bset,reduced_model_=reduced_model)
      !
      ! interconnect the dvr_kindex-s between classes 
      !
      if (job%verbose>=4) write(out,"(/' Interconnect destribution of the points between classes and modes...')")
      !
      allocate (dvr%kindex2c(dvr%total_size,PT%Nclasses),stat=alloc)
      !
      dvr%kindex2c = 0
      !
      matsize = int(PT%Nclasses,hik)*dvr%total_size
      !
      call ArrayStart('dvr%cindex',alloc,1,kind(dvr%kindex2c),matsize)
      !
      !$omp parallel do private(k,ip,iclass,im1,im2,ic,icp) schedule(dynamic)
      do k = 1,dvr%total_size
         !
         ip(:) = dvr%kindex(k,:)
         !
         loop_c : do iclass = 1,PT%Nclasses
           !
           im1 = PT%mode_class(iclass,1)
           im2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
           !
           do ic = 1,contr(iclass)%Ndvrpoints
             !
             icp(im1:im2) = contr(iclass)%dvr_kindex(ic,im1:im2)
             !
             if ( all(icp(im1:im2)==ip(im1:im2)) ) then 
                !
                dvr%kindex2c(k,iclass) = ic
                !
                cycle loop_c
                !
             endif
             !
           enddo
           !
         enddo loop_c
         !
      enddo
      !$omp end parallel do 
      !
      if (job%verbose>=4) write(out,"(/' Allocate the dvr-arrays for the contracted basis set...')")
      !
      do iclass = 1,PT%Nclasses
        !
        nlevels = contr(iclass)%nlevels
        !
        im1 = PT%mode_class(iclass,1)
        im2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
        !
        do ilevel = 1,nlevels
           !
           level_degen = contr(iclass)%eigen(ilevel)%degeneracy
           !
           allocate (contr(iclass)%eigen(ilevel)%dvr_func(0:PT%Nmodes,level_degen,contr(iclass)%Ndvrpoints),stat=alloc)
           !
           matsize = int(PT%Nmodes+1,hik)*int(level_degen,hik)*contr(iclass)%Ndvrpoints
           !
           call ArrayStart('contr%eigen%vect-dvr',alloc,1,kind(contr(iclass)%eigen(ilevel)%dvr_func),matsize)
           !
        enddo
        !
      enddo
      !
      !$omp  parallel do private(iclass,im1,im2,nlevels,ic,ip,ilevel,level_degen,ideg,sum_f,sum_d,iprim,nu,imode,&
      !$omp& ispecies,mat_f,mat_d,f_prim) schedule(dynamic)
      do iclass = 1,PT%Nclasses
         !
         im1 = PT%mode_class(iclass,1)
         im2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
         !
         nlevels = contr(iclass)%nlevels
         !
         do ic = 1,contr(iclass)%Ndvrpoints
           !
           ip(im1:im2) = contr(iclass)%dvr_kindex(ic,im1:im2)
           !
           do ilevel = 1,nlevels
              !
              level_degen = contr(iclass)%eigen(ilevel)%degeneracy
              !
              do ideg = 1,level_degen
                !
                sum_f = 0
                sum_d = 0
                !
                do iprim=1,contr(iclass)%dimen
                   !
                   nu(im1:im2) = contr(iclass)%prim_bs%icoeffs(im1:im2,iprim)
                   !
                   do imode = im1,im2
                     !
                     ispecies = PT%Mspecies(imode)
                     !
                     !fl => dvr%prim_func(ispecies)
                     !df => dvr%prim_dfunc(ispecies)
                     !
                     ! finction contribution for each mode
                     !
                     mat_f(imode) = dvr%prim_func(ispecies)%coeffs(nu(imode),ip(imode))
                     !
                     ! derivatives of the funciton wrt to imode
                     !
                     mat_d(imode) = dvr%prim_dfunc(ispecies)%coeffs(nu(imode),ip(imode))
                     !
                   enddo
                   !
                   !vec => contr(iclass)%eigen(ilevel)
                   !
                   f_prim = contr(iclass)%eigen(ilevel)%vect(iprim,ideg)
                   !
                   sum_f = sum_f +  f_prim*product(mat_f(im1:im2))
                   !
                   do imode = im1,im2
                     !
                     sum_d(imode) = sum_d(imode) + f_prim*product(mat_f(im1:imode-1))*product(mat_f(imode+1:im2))*mat_d(imode)
                     !
                   enddo
                   !
                enddo
                !
                contr(iclass)%eigen(ilevel)%dvr_func(0      ,ideg,ic) = sum_f
                contr(iclass)%eigen(ilevel)%dvr_func(im1:im2,ideg,ic) = sum_d(im1:im2)
                !
              enddo
              !
           enddo
           !
         enddo
         !
      enddo
      !$omp end parallel do
      !
      !call PTDVR_free_primitive_basis_functions
      !
      call TimerStop('PTDVR_contracted_basis_generate')
      !
      if (job%verbose>=4) write(out,"('...done')")
      !
      if (job%verbose>=5)  call MemoryReport
      !
   end subroutine PTDVR_contracted_basis_generate





 subroutine PTDVRcontracted_basis_store
    !
    real(rk),allocatable   :: vector(:,:)
    !
    integer(ik) :: icoeff,alloc,k,dimen,Nmodes,maxcontr,ideriv,chkptIO,rec_len
    character(len=cl)  :: unitfname
    !
    if (job%verbose>=3) call TimerStart('PTDVRcontracted_basis_store')
    !
    if (job%verbose>=4) write(out,"('Contracted matrix elements store in DVR representaion...')")
    !
    dimen = dvr%total_size
    Nmodes = PT%Nmodes
    maxcontr = PT%Maxcontracts
    !
    allocate (vector(0:Nmodes,dimen),stat=alloc)
    call ArrayStart('PTDVRcontrac-vect',alloc,size(vector),kind(vector))
    !
    ! prepare chk-files
    !
    inquire(iolength=rec_len) vector
    !
    unitfname ='DVR-contracted functions'
    call IOStart(trim(unitfname),chkptIO)
    open(chkptIO,action='write',access='direct',recl=rec_len,status='replace',file=trim(job%contrfile%dvr))
    !
    !write(chkptIO) 'contr-dvr-start'
    !
    !write(chkptIO) maxcontr,dimen,Nmodes
    !
    do icoeff=1,maxcontr
      !
      !write(chkptIO) icoeff
      !
      do ideriv = 0,Nmodes
        !
        !$omp parallel do private(k) shared(vector) schedule(dynamic)
        do k = 1,dimen
        !
        !if (job%verbose>=6) write(out,"('   ideriv = ',i8)") ideriv
          !
          vector(ideriv,k) = PTDVR_contracted_basis_product(k,icoeff,ideriv)
          !
        enddo
        !$omp end parallel do
        !
      enddo
      !
      write(chkptIO,rec=icoeff) (vector(ideriv,:),ideriv = 0,Nmodes)
      !
    enddo
    !
    !write(chkptIO) 'contr-dvr-end'
    !
    close(chkptIO,status='keep')
    !
    deallocate (vector)
    call ArrayStop('PTDVRcontrac-vect')
    !
    if (job%verbose>=4) write(out,"('...done!')")
    !
    if (job%verbose>=3) call TimerStop('PTDVRcontracted_basis_store')
    !
  end subroutine PTDVRcontracted_basis_store




 !
 ! contr. mat elements using the prestored contr. functions
 !
 subroutine PTDVRcontracted_matelem_all_fields_fly(hvib,treat_rotation,grot,gcor)
    !
    real(rk),intent(out)        :: hvib(:)
    logical,intent(in)          :: treat_rotation
    !
    real(rk),optional,intent(out) :: grot(:,:,:)
    real(rk),optional,intent(out) :: gcor(:,:,:)
    !
    real(rk),allocatable   :: vector(:,:)
    !
    integer(ik) :: jcoeff,alloc,k,dimen,Nmodes,maxcontr,ideriv,k1,k2,m,mp1,icoeff
    integer(ik) :: ib,ib0,icoeff_
    integer(ik) :: nswap
    integer(hik) :: matsize
    real(rk)                    :: temp
    real(rk),allocatable        :: gvib_t(:,:),gcor_t1(:,:,:),gcor_t2(:,:,:),grot_t(:,:,:)
    real(rk),allocatable        :: swapvec(:,:,:)
    !
    if (job%verbose>=3) call TimerStart('PTDVRcontracted_matelem_all')
    !
    if (job%verbose>=4) write(out,"('Contracted matrix elements in DVR representaion...')")
    if (job%verbose>=4) write(out,"('  Size of the the contr. basis = ',i8)") PT%Maxcontracts
    !
    dimen = dvr%total_size
    Nmodes = PT%Nmodes
    maxcontr = PT%Maxcontracts
    !
    hvib = 0
    !
    if (treat_rotation) then 
      !
      grot = 0 
      gcor = 0 
      !
    endif
    !
    allocate (vector(0:PT%Nmodes,dimen),stat=alloc)
    call ArrayStart('PTDVRcontrac-vect',alloc,size(vector),kind(vector))
    !
    allocate (gvib_t(0:Nmodes,dimen),stat=alloc)
    matsize = int(Nmodes+1,hik)*int(dimen,hik)
    call ArrayStart('PTDVRcontrac-vect',alloc,1,kind(gvib_t),matsize )
    !
    if (treat_rotation) then
      !
      allocate (gcor_t1(Nmodes,3,dimen),gcor_t2(Nmodes,3,dimen),grot_t(3,3,dimen),stat=alloc)
      matsize = int(6*Nmodes+9,hik)*int(dimen,hik)
      call ArrayStart('PTDVRcontrac-vect',alloc,1,kind(gvib_t),matsize )
      !
    endif
    !
    ! Prepaper the chk-file with the contr. function in DVR representation
    !
    !inquire(iolength=rec_len) vector
    !
    !unitfname ='DVR-contracted functions'
    !call IOStart(trim(unitfname),chkptIO)
    !open(chkptIO,access='direct',recl=rec_len,action='read',status='old',file=trim(job%contrfile%dvr))
    !
    m = mod(dimen,10)
    mp1 = m+1
    !
    nswap = 0
    !
    if (job%swap_size>0) then
      !
      if (job%verbose>=4) call TimerStart('PTDVRcontracted_swap')
      !
      nswap = min(job%swap_size,maxcontr)
      !
      allocate (swapvec(0:nmodes,nswap,dimen),stat=alloc)
      !
      matsize = int(Nmodes+1,hik)*int(dimen,hik)*int(nswap,hik)
      call ArrayStart('PTDVRcontrac-swap-vec',alloc,1,kind(swapvec),matsize )
      !
      do icoeff=1,nswap
         !
         !read(chkptIO,rec=icoeff) (vector(ideriv,:),ideriv = 0,Nmodes)
         !
         do ideriv = 0,Nmodes
           !
           !$omp parallel do private(k) shared(swapvec) schedule(dynamic)
           do k = 1, dimen
              !
              swapvec(ideriv,icoeff,k) = PTDVR_contracted_basis_product(k,icoeff,ideriv)
              !
           end do
           !$omp end parallel do
           !
         enddo
         !
       enddo
       !
       if (job%verbose>=4) call TimerStop('PTDVRcontracted_swap')
       !
    endif
    !
    if (job%verbose>4) call MemoryReport
    !
    do icoeff=1,maxcontr
       !
       if (job%verbose>=5.and.mod(icoeff,maxcontr/400)==0) write(out,"('   i = ',i8)") icoeff
       !
       ib0 = icoeff*(icoeff-1)/2
       !
       if (icoeff<=nswap) then 
         !
         do ideriv = 0,Nmodes
           !
           !$omp parallel do private(k) shared(vector) schedule(guided)
           do k = 1,dimen
              !
              vector(ideriv,k) = swapvec(ideriv,icoeff,k)
              !
           end do
           !$omp end parallel do
           !
         end do
         !
       else
         !
         !if (job%verbose>=4) call TimerStart('PTDVRcontracted_basis_product')
         !
         do ideriv = 0,Nmodes
           !
           !$omp parallel do private(k) shared(vector) schedule(static)
           do k = 1, dimen
              !
              vector(ideriv,k) = PTDVR_contracted_basis_product(k,icoeff,ideriv)
              !
           end do
           !$omp end parallel do
           !
         enddo
         !
         !if (job%verbose>=4) call TimerStop('PTDVRcontracted_basis_product')
         !
       endif
       !
       !$omp parallel do private(k) shared(gvib_t) schedule(guided)
       do k = 1,dimen
         gvib_t(0,k)        = vector(0,k)*dvr%poten(k)
         gvib_t(1:Nmodes,k) = 0
       enddo
       !$omp end parallel do
       !
       do k2 = 1,Nmodes
         !
         do k1 = 1,Nmodes
            !
            !$omp parallel do private(k) shared(gvib_t) schedule(guided)
            do k = 1,dimen
              !
              gvib_t(k2,k)  = gvib_t(k2,k) + vector(k1,k)*dvr%gvib(k1,k2,k)
              !
            enddo
            !$omp end parallel do
            !
         enddo
         !
       enddo
       !
       if (treat_rotation) then
          !
          do k1 = 1,3
            do k2 = 1,3
              !
              !$omp parallel do private(k) shared(grot_t) schedule(guided)
              do k = 1,dimen
                grot_t(k1,k2,k) = vector(0,k)*dvr%grot(k1,k2,k)
              enddo
              !$omp end parallel do
              !
            enddo
          enddo
          !
          do k1 = 1,Nmodes
            !
            do k2 = 1,3
              !
              !$omp parallel do private(k) shared(gcor_t1,gcor_t2) schedule(guided)
              do k = 1,dimen
                gcor_t1(k1,k2,k) =-vector(k1,k)*dvr%gcor(k1,k2,k)
                gcor_t2(k1,k2,k) = vector( 0,k)*dvr%gcor(k1,k2,k)
              enddo
              !$omp end parallel do
              !
            enddo
          enddo
          !
       endif
       !
       do jcoeff=icoeff,1,-1
         !
         if (jcoeff/=icoeff) then 
           !
           if (jcoeff<=nswap) then 
             !
             do ideriv = 0,Nmodes
               !
               !$omp parallel do private(k) shared(vector) schedule(guided)
               do k = 1,dimen
                  vector(ideriv,k) = swapvec(ideriv,jcoeff,k)
               end do
               !$omp end parallel do
               !
             end do
             !
           else
             !
             !if (job%verbose>=4) call TimerStart('PTDVRcontracted_basis_product')
             !
             do ideriv = 0,Nmodes
               !
               !$omp parallel do private(k) shared(vector) schedule(static)
               do k = 1, dimen
                  vector(ideriv,k) = PTDVR_contracted_basis_product(k,jcoeff,ideriv)
               end do
               !$omp end parallel do
               !
             enddo
             !
             !if (job%verbose>=4) call TimerStop('PTDVRcontracted_basis_product')
             !
           endif
           !
         endif
         !
         ib = ib0 + jcoeff
         !
         !if (job%verbose>=4) call TimerStart('PTDVRcontracted_sum')
         !
         !temp = 0.0_rk
         !!
         !do k2 = 0,Nmodes
         !  !
         !  temp = ddot(dimen,gvib_t(k2,:),1,vector(k2,:),1)
         !  !
         !endif
         !
         temp = 0
         !
         do k2 = 0,Nmodes
            !
            if (m/=0) then
              do k = 1,m
                !
                temp = temp + gvib_t(k2,k)*vector(k2,k)
                !
              enddo
            endif
            !
            !$omp parallel do private(k) reduction(+:temp) schedule(static)
            do k = mp1,dimen,10
              !
              temp = temp + gvib_t(k2,k  )*vector(k2,k  ) &
                          + gvib_t(k2,k+1)*vector(k2,k+1) &
                          + gvib_t(k2,k+2)*vector(k2,k+2) &
                          + gvib_t(k2,k+3)*vector(k2,k+3) &
                          + gvib_t(k2,k+4)*vector(k2,k+4) &
                          + gvib_t(k2,k+5)*vector(k2,k+5) &
                          + gvib_t(k2,k+6)*vector(k2,k+6) &
                          + gvib_t(k2,k+7)*vector(k2,k+7) &
                          + gvib_t(k2,k+8)*vector(k2,k+8) &
                          + gvib_t(k2,k+9)*vector(k2,k+9)
              !
            enddo
            !$omp end parallel do
            !
         enddo
         !
         hvib(ib) = hvib(ib) + temp
         !
         if (treat_rotation) then
           !
           do k1 = 1,3
             do k2 = 1,3
               !
               temp = 0.0_rk
               !
               if (m/=0) then 
                 do k = 1,m
                   !
                   temp = temp + grot_t(k1,k2,k)*vector(0,k)
                   !
                 enddo
               endif
               !
               !$omp parallel do private(k) reduction(+:temp) schedule(guided)
               do k = mp1,dimen,5
                 !
                 temp = temp + grot_t(k1,k2,k  )*vector(0,k  ) &
                             + grot_t(k1,k2,k+1)*vector(0,k+1) &
                             + grot_t(k1,k2,k+2)*vector(0,k+2) &
                             + grot_t(k1,k2,k+3)*vector(0,k+3) &
                             + grot_t(k1,k2,k+4)*vector(0,k+4)
                 !
               enddo
               !$omp end parallel do
               !
               grot(k1,k2,ib) = grot(k1,k2,ib) + temp
               !
             enddo
           enddo
           !
           do k2 = 1,3
             !
             do k1 = 1,Nmodes
               !
               temp = 0.0_rk
               !
               if (m/=0) then 
                 do k = 1,m
                   !
                   temp = temp + gcor_t1(k1,k2,k)*vector(0,k) + gcor_t2(k1,k2,k)*vector(k1,k)
                   !
                 enddo
               endif
               !
               !$omp parallel do private(k) reduction(+:temp) schedule(guided)
               do k = mp1,dimen,5
                 !
                 temp = temp + gcor_t1(k1,k2,k  )*vector(0,k  ) + gcor_t2(k1,k2,k  )*vector(k1,k  ) &
                             + gcor_t1(k1,k2,k+1)*vector(0,k  ) + gcor_t2(k1,k2,k+1)*vector(k1,k+1) &
                             + gcor_t1(k1,k2,k+2)*vector(0,k  ) + gcor_t2(k1,k2,k+2)*vector(k1,k+2) &
                             + gcor_t1(k1,k2,k+3)*vector(0,k  ) + gcor_t2(k1,k2,k+3)*vector(k1,k+3) &
                             + gcor_t1(k1,k2,k+4)*vector(0,k  ) + gcor_t2(k1,k2,k+4)*vector(k1,k+4)
                 !
               enddo
               !$omp end parallel do
               !
               gcor(k1,k2,ib) = gcor(k1,k2,ib) + temp
               !
             enddo
             !
           enddo
           !
         endif
         !
         !if (job%verbose>=4) call TimerStop('PTDVRcontracted_sum')
         !
       enddo
       !
    enddo
    !
    deallocate (vector)
    deallocate (gvib_t)
    if (treat_rotation) deallocate (gvib_t,gcor_t1,gcor_t2,grot_t)
    call ArrayStop('PTDVRcontrac-vect')
    !
    if (nswap>0) then 
      !
      deallocate (swapvec)
      call ArrayStop('PTDVRcontrac-swap-vec')
      !
    endif
    !
    !read(chkptIO) buf(1:13)
    !
    !if (buf(1:13)/='contr-dvr-end') then
    !    write (out,"(' checkpoint file contr_dvr.chk has bogus footer: ',a,'/= contr-dvr-end')") buf(1:15)
    !    stop 'contr_dvr.chk - bogus file format'
    !end if
    !
    !close(chkptIO)
    !
    if (job%verbose>=4) write(out,"('...done!')")
    !
    if (job%verbose>=3) call TimerStop('PTDVRcontracted_matelem_all')
    !
  end subroutine PTDVRcontracted_matelem_all_fields_fly





  function PTDVR_contracted_basis_product(k,icoeff,ideriv)  result(vector)

    integer(ik),intent(in) :: k,icoeff,ideriv   
    real(rk)               :: vector

    real(rk)               :: mat_class(PT%Nclasses)
    integer(ik)            :: icase,ilambda,iclass,ideg,ic
    integer(ik)            :: ilevel,ideriv_,Nclasses
      !
      if (verbose>=5) write(out,"('Converting the contracted basis into the DVR-grid representaion...')")
      !
      !call TimerStart('PTDVR_contracted_basis_product')
      !
      icase   = PT%icontr2icase(icoeff,1)
      ilambda = PT%icontr2icase(icoeff,2)
      Nclasses = PT%Nclasses
      !
      mat_class = 0.0_rk
      !
      do iclass = 1,Nclasses
        !
        ic = dvr%kindex2c(k,iclass)
        !
        if (ic<1) cycle
        !
        ideriv_ = dvr%icheck_deriv(iclass,ideriv)
        !
        ilevel = PT%contractive_space(iclass,icase)
        !
        ideg = PT%Index_deg(icase)%icoeffs(iclass,ilambda)
        !
        mat_class(iclass) = contr(iclass)%eigen(ilevel)%dvr_func(ideriv_,ideg,ic)
        !
      enddo
      !
      vector = product(mat_class(:))
      !
      !call TimerStop('PTDVR_contracted_basis_product')
      !
      if (verbose>=5) write(out,"('...done')")

   end function PTDVR_contracted_basis_product







   !
   ! Matrix elements calculations of the terms containing 
   ! values of the potential and kinetic energy expansions
   ! <v1v2v3...|  f |w1w2w3...> - contracted wavefunctions 
   !
   subroutine PTmatrixelements_single_contrterm(im1,im2,nu_i,nu_j,k1,k2,poten,gvib,grot,gcor)

      integer(ik),intent(in)         :: im1,im2
      integer(ik),intent(in)         :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
      integer(ik),intent(in),optional:: k1,k2
      real(rk),intent(out),optional  :: poten
      real(rk),intent(out),optional  :: gvib
      real(rk),intent(out),optional  :: grot
      real(rk),intent(out),optional  :: gcor
      !
      integer(ik)                   :: k(PT%Nmodes)  
      integer(ik)                   :: vl,vr,imode,iterm
      real(rk)                      :: mat(PT%Nmodes)
      type(PTcoeffT),pointer        :: fl

         if (verbose>=6) write(out,"(/'PTmatrixelements_single_contrterm/start: matrix elemnts for the hamiltonian ')") 
         !
         ! Extract large amplitude quantum numbers
         !
         vl = nu_i(PT%Nmodes) ; vr = nu_j(PT%Nmodes)
         !
         ! and the corresponding power 
         !
         iterm = k(PT%Nmodes)
         !
         ! Vibrational part 
         !
         ! Potential part of the hamiltonian 
         !
         if (PTvibrational_me_calc) then 
           !
           if(present(poten)) then 
             !
             poten  = 0
             !
             fl => me%poten
             !
             do iterm = 1,fl%Ncoeff
                !
                k(:) = fl%IndexQ(:,iterm)
                !
                do imode = im1,im2
                   !
                   if (imode==PT%Nmodes) then
                      !
                      mat(imode) = fl%coeff(iterm,vl,vr)
                      !
                      !mat(imode) = fl%me(iterm,vl,vr)
                      !
                   else
                      !
                      mat(imode) = me%vibmode(imode,0)%coeff(k(imode),nu_i(imode),nu_j(imode))
                      !
                      !mat(imode) = bs%matelements(0,k(imode),nu_i(imode),nu_j(imode))
                      !
                   endif
                   !
                enddo 
                !
                poten = poten + product(mat(im1:im2))
                !
             enddo
             !
           endif
           !
           ! Vibrational part of the kinetic operator g_vib
           !
           if(present(gvib).and.present(k1).and.present(k2)) then 
             !
             gvib  = 0 
             !
             fl => me%gvib(k1,k2)
             !
             do iterm = 1,me%gvib(k1,k2)%Ncoeff
                !
                k(:) = fl%IndexQ(:,iterm)
                !
                do imode = im1,im2
                   !
                   if (imode==PT%Nmodes) then
                      !
                      mat(imode) = fl%coeff(iterm,vl,vr)
                      !
                      !mat(imode) = fl%me(iterm,vl,vr)
                      !
                   else
                      !
                      if    (k1/=imode.and.k2/=imode) then 
                        !
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                        !
                        !mat(imode) = bs%matelements(-1,k(imode),nu_i(imode),nu_j(imode))
                        !
                      elseif (k1==imode.and.k2/=imode) then
                        !
                        mat(imode) =-me%vibmode(imode,1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                        !
                        !mat(imode) =-bs%matelements(1,k(imode),nu_j(imode),nu_i(imode))
                        !
                      elseif (k1/=imode.and.k2==imode) then
                        !
                        mat(imode) = me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                        !
                        !mat(imode) = bs%matelements(1,k(imode),nu_i(imode),nu_j(imode))
                        !
                      else !   if (k1==imode.and.k2==imode) then
                        !
                        mat(imode) = me%vibmode(imode,2)%coeff(k(imode),nu_i(imode),nu_j(imode))
                        !
                        !mat(imode) = bs%matelements(2,k(imode),nu_i(imode),nu_j(imode))
                        !
                      endif
                      !
                      !
                   endif
                   !
                enddo 
                !
                gvib = gvib + product(mat(im1:im2))
                ! 
                !
             enddo
             ! 
           endif 
           !
         endif 
         !
         ! Rotational and coriolis parts of the kinetic energy operator are turned on when FLrotation is .true.
         !
         if (FLrotation) then
            !
            !if (.not.present(grot).or..not.present(gcor)) then 
            !  !
            !  write(out,"('PTmatrixelements_single_contrterm: grot or gcor are not present for FLrotation')")
            !  stop 'PTmatrixelements_single_contrterm: grot or gcor is not present'
            !  !
            !endif
            ! 
            ! Rotational part of the kinetic operator g_rot
            !
            if(present(grot).and.present(k1).and.present(k2)) then 
              !
              grot  = 0 
              !
              fl => me%grot(k1,k2)
              !
              do iterm = 1,fl%Ncoeff
                !
                k(:) = fl%IndexQ(:,iterm)
                !
                mat = 1.0_rk
                !
                do imode = im1,im2
                   !
                   if (imode/=PT%Nmodes) then
                      !
                      mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                      !
                      !mat(imode) = bs%matelements(-1,k(imode),nu_i(imode),nu_j(imode))
                      !
                   else
                      !
                      mat(imode) = fl%coeff(iterm,vl,vr)
                      !
                      !mat(imode) = fl%me(iterm,vl,vr)
                      !
                   endif
                   !
                enddo 
                !
                grot = grot + product(mat(im1:im2))
                !
                !
              enddo 
              !
            endif 
            ! 
            ! Coriolis part of the kinetic operator g_cor
            !
            if(present(gcor).and.present(k1).and.present(k2)) then 
              !
              gcor = 0
              !
              fl => me%gcor(k1,k2)
              !
              do iterm = 1,fl%Ncoeff
                !
                k(:) = fl%IndexQ(:,iterm)
                !
                do imode = im1,im2
                  !
                  if (imode/=PT%Nmodes) then
                     !
                     if (k1/=imode) then 
                        !
                        mat(imode) = me%vibmode(imode,-1)%coeff(k(imode),nu_i(imode),nu_j(imode))
                        !
                        !mat(imode) = bs%matelements(-1,k(imode),nu_i(imode),nu_j(imode))
                        !
                     else
                        !
                        mat(imode) = me%vibmode(imode,1)%coeff(k(imode),nu_i(imode),nu_j(imode))-&
                                     me%vibmode(imode,1)%coeff(k(imode),nu_j(imode),nu_i(imode))
                        !
                        !mat(imode) =bs%matelements(1,k(imode),nu_i(imode),nu_j(imode))-&
                        !            bs%matelements(1,k(imode),nu_j(imode),nu_i(imode))
                        !
                     endif
                     !
                  else
                     !
                     mat(imode) = fl%coeff(iterm,vl,vr)
                     !
                     !mat(imode) = fl%me(iterm,vl,vr)
                     !
                  endif
                  !
                enddo 
                !
                gcor = gcor + product(mat(im1:im2))
                !
                !
              enddo 
              !
            endif 
            !
         endif 
         !
      if (verbose>=6) write(out,"('PTmatrixelements_single_contrterm/end')") 
    
   end subroutine PTmatrixelements_single_contrterm

   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_corr
   !
   function PTmatrixelements_contr(icontr,jcontr,j,k_i,k_j,tau_i,tau_j) result(mat_elem)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in),optional  :: j,k_i,k_j,tau_i,tau_j
      real(rk)                      :: mat_elem
      !
      real(rk)                      :: mat_t,mat_r(3,3)
      integer(ik)                   :: k1,k2
      integer(ik)                   :: jk,dk
      real(rk)                      :: hvib_t,grot_t,gcor_t
      logical                       :: do_poten

         if (verbose>=7) write(out,"(/'PTmatrixelements_contr/start: matrix elemnts for the hamiltonian ')") 
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         do_poten = .true.
         !
         ! The J-free part has to be diagonal in terms of the rotational quanta
         !
         hvib_t = 0
         !
         !if (present(J).and.present(k_i).and.present(k_j).and.present(tau_i).and.present(tau_j)) then
         !
         if (k_i/=k_j.or.tau_i/=tau_j) do_poten = .false.
         !
         !endif
         !
         if (PTvibrational_me_calc.and.do_poten) then 
            !
            hvib_t = hvib%me(icontr,jcontr)
            !
         endif 
         !
         ! Rotational and Coriolis parts of the kinetic energy operator are turned on when FLrotation is .true.
         !
         grot_t = 0 
         gcor_t = 0 
         !
         if (FLrotation.and.present(J)) then
           if (J/=0) then
             !
             ! Extract rotaitonal quantum numbers
             !
             Jk = 1+k_i+(j*(j+1) )/2
             dk = k_i - k_j
             ! 
             ! Rotational part of the kinetic operator g_rot
             !
             !
             if (abs(dk)<=2) then 
                 do k2 = 1,3
                   do k1 = 1,k2
                      !
                      mat_r(k1,k2) = grot(k1,k2)%me(icontr,jcontr) 
                      !
                   enddo
                 enddo 
                 !
                 if (tau_i==tau_j) then 
                   !
                   ! Jx2y2
                   grot_t = grot_t + 0.5_rk*( mat_r(1,1)-mat_r(2,2) )*contr(0)%rot(4)%coeff3d(Jk,dk,tau_i)
                   !
                   ! Jxz
                   !
                   grot_t = grot_t + mat_r(1,3)*contr(0)%rot(6)%coeff3d(Jk,dk,tau_i)
                   !
                   ! and now the odd ones 
                   !
                 else
                   !
                   ! Jxy
                   !
                   grot_t = grot_t + mat_r(1,2)*contr(0)%rot(5)%coeff3d(Jk,dk,tau_i)
                   !
                   ! Jyz
                   !
                   grot_t = grot_t + mat_r(2,3)*contr(0)%rot(7)%coeff3d(Jk,dk,tau_i)
                   !
                 endif 
                 !
                 if (tau_i==tau_j.and.k_i==k_j) then 
                    !
                    ! two terms A*Jx^2+BJy^2+C*Jz^2
                    !
                    grot_t = grot_t + 0.5_rk*real(J*(J+1_ik)-k_i**2,rk)*&
                                      ( mat_r(1,1)+mat_r(2,2) )
                    !
                    grot_t = grot_t + real(k_i**2,rk)*mat_r(3,3)
                    !
                 endif 
               !   
             endif
             ! 
             ! Coriolis part of the kinetic operator g_cor
             !
             !
             if (abs(dk)<=1) then 
               !
               do k2 = 1,3
                 !
                 if ( (tau_i==tau_j.and.k2==2).or.(tau_i/=tau_j.and.k2/=2) ) then 
                   !
                   mat_t = gcor(k2)%me(icontr,jcontr)
                   !
                   !if (icontr<jcontr) mat_t = -mat_t
                   !
                   gcor_t = gcor_t + mat_t*contr(0)%rot(k2)%coeff3d(Jk,dk,tau_i)
                   !
                 endif 
                 !
               enddo 
               ! 
             endif
             !
           endif
         endif
         !
         !grot_t = 0
         !
         mat_elem = hvib_t-0.5_rk*(-grot_t-gcor_t)
         !
         if (verbose>=8) write(out,"('PTmatrixelements_contr:  pot_t,gvib_t,grot_t,gcor_t ',4f18.8)") hvib_t,grot_t,gcor_t
         !
         !call TimerStart('PTmatrixelements_contr')
         !
      if (verbose>=7) write(out,"('PTmatrixelements_contr/end')") 
    
   end function PTmatrixelements_contr



   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_corr
   ! The current version works with symmetrically adapted rot. basis fucntions 
   ! which are not k-factorized
   !
   function PTmatrixelements_contr_gamma(icontr,jcontr,j,icount,jcount,ideg,jdeg) result(mat_elem)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in),optional  :: j,icount,jcount,ideg,jdeg
      real(rk)                      :: mat_elem
      !
      real(rk)                      :: mat_t,mat_r(3,3)
      integer(ik)                   :: k1,k2
      real(rk)                      :: hvib_t,grot_t,gcor_t,grot_4,grot_5,grot_6,grot_7,grot_8
      logical                       :: do_poten

         if (verbose>=7) write(out,"(/'PTmatrixelements_contr_gamma/start: matrix elemnts for the hamiltonian ')") 
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         do_poten = .true.
         !
         ! The J-free part has to be diagonal in terms of the rotational quanta
         !
         hvib_t = 0
         !
         if (icount/=jcount.or.ideg/=jdeg) do_poten = .false.
         !
         if (PTvibrational_me_calc.and.do_poten) then 
            !
            hvib_t = hvib%me(icontr,jcontr)
            !
         endif 
         !
         ! Rotational and Coriolis parts of the kinetic energy operator are turned on when FLrotation is .true.
         !
         grot_t = 0 
         gcor_t = 0 
         !
         if (FLrotation.and.present(J)) then
           if (J/=0) then
             ! 
             ! Rotational part of the kinetic operator g_rot
             !
             do k2 = 1,3
               do k1 = 1,k2
                  !
                  mat_r(k1,k2) = grot(k1,k2)%me(icontr,jcontr) 
                  !
               enddo
             enddo
             !
             ! Jxz
             !
             grot_6 = mat_r(1,3)*me%rot_contr(6,icount,jcount,ideg,jdeg)
             !
             ! Jxy
             !
             grot_5 = mat_r(1,2)*me%rot_contr(5,icount,jcount,ideg,jdeg)
             !
             ! Jyz
             !
             grot_7 = mat_r(2,3)*me%rot_contr(7,icount,jcount,ideg,jdeg)
             !
             ! terms from A*Jx^2+BJy^2+C*Jz^2
             !
             grot_8 = me%rot_contr(8,icount,jcount,ideg,jdeg)*( mat_r(3,3)-0.5_rk*( mat_r(1,1)+mat_r(2,2) ) )
             !
             ! Jx2y2
             !
             grot_4 = 0.5_rk*( mat_r(1,1)-mat_r(2,2) )*me%rot_contr(4,icount,jcount,ideg,jdeg)
             !
             grot_t = grot_t + grot_4 + grot_5 + grot_6 + grot_7 + grot_8
             !
             if (icount==jcount.and.ideg==jdeg) grot_t = grot_t + 0.5_rk*( mat_r(1,1)+mat_r(2,2) )*real(J*(J+1_ik),rk)
             ! 
             ! Coriolis part of the kinetic operator g_cor
             !
             do k2 = 1,3
                !
                mat_t = gcor(k2)%me(icontr,jcontr)
                !
                !if (icontr<jcontr) mat_t = -mat_t
                !
                gcor_t = gcor_t + mat_t*me%rot_contr(k2,icount,jcount,ideg,jdeg)
                !
             enddo 
             !
           endif
         endif
         !
         !gcor_t = 0
         !
         mat_elem = hvib_t-0.5_rk*(-grot_t-gcor_t)
         !
         if (verbose>=8) write(out,"('PTmatrixelements_contr_gamma:  pot_t,gvib_t,grot_t,gcor_t ',4f18.8)") hvib_t,grot_t,gcor_t
         !
         !call TimerStart('PTmatrixelements_contr_gamma')
         !
      if (verbose>=7) write(out,"('PTmatrixelements_contr_gamma/end')") 
    
   end function PTmatrixelements_contr_gamma



   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   ! Coriolis part of the kinetic energy operator g_cor
   !
   function PTmatrixelements_contr_hvib(icontr,jcontr,k_i,k_j,tau_i,tau_j) result(hvib_)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in)        :: k_i,k_j,tau_i,tau_j
      real(rk)                      :: hvib_
      !
      integer(ik)                   :: jterm
         !
         hvib_ = 0
         !
         if (k_i/=k_j.or.tau_i/=tau_j.or..not.PTvibrational_me_calc) return
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         !
         hvib_ = hvib%me(icontr,jcontr)
         !
         if (verbose>=8) write(out,"('PTmatrixelements_contr_hvib:  hvib',f18.8)") hvib_
         !
   end function PTmatrixelements_contr_hvib


   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   ! Rotational part of the kinetic energy operator g_rot
   !
   function PTmatrixelements_contr_grot(icontr,jcontr,j,k_i,k_j,tau_i,tau_j) result(grot_)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in)        :: j,k_i,k_j,tau_i,tau_j
      real(rk)                      :: grot_
      !
      real(rk)                      :: mat_r(3,3)
      integer(ik)                   :: k1,k2
      integer(ik)                   :: jk,dk

         if (verbose>=7) write(out,"(/'PTmatrixelements_contr_grot/start: matrix elemnts for the hamiltonian ')") 
         !
         grot_ = 0 
         !
         if (.not.FLrotation) return
         !
         if (abs(k_i - k_j)>2.or.J==0) return
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         !
         ! Extract rotaitonal quantum numbers
         !
         Jk = 1+k_i+(j*(j+1) )/2
         dk = k_i - k_j
         ! 
         ! Rotational matrix
         !
         do k2 = 1,3
           do k1 = 1,k2
              !
              mat_r(k1,k2) = grot(k1,k2)%me(icontr,jcontr) 
              !
           enddo
         enddo 
         !
         if (tau_i==tau_j) then 
           !
           ! Jx2y2
           grot_ = grot_ + 0.5_rk*( mat_r(1,1)-mat_r(2,2) )*contr(0)%rot(4)%coeff3d(Jk,dk,tau_i)
           !
           ! Jxz
           !
           grot_ = grot_ + mat_r(1,3)*contr(0)%rot(6)%coeff3d(Jk,dk,tau_i)
           !
           ! and now the odd ones 
           !
         else
           !
           ! Jxy
           !
           grot_ = grot_ + mat_r(1,2)*contr(0)%rot(5)%coeff3d(Jk,dk,tau_i)
           !
           ! Jyz
           !
           grot_ = grot_ + mat_r(2,3)*contr(0)%rot(7)%coeff3d(Jk,dk,tau_i)
           !
         endif 
         !
         if (tau_i==tau_j.and.k_i==k_j) then 
            !
            ! two terms A*Jx^2+BJy^2+C*Jz^2
            !
            grot_ = grot_ + 0.5_rk*real(J*(J+1_ik)-k_i**2,rk)*&
                              ( mat_r(1,1)+mat_r(2,2) )
            !
            grot_ = grot_ + real(k_i**2,rk)*mat_r(3,3)
            !
         endif 
         !
         grot_ = 0.5_rk*grot_
         !
         if (verbose>=8) write(out,"('PTmatrixelements_contr_grot:  grot',f18.8)") grot_
         !
         !call TimerStart('PTmatrixelements_contr')
         !
      if (verbose>=7) write(out,"('PTmatrixelements_contr_grot/end')") 
    
   end function PTmatrixelements_contr_grot



   !
   ! Matrix elements calculations of the fields on the product of the primitive (1D) eigenfunctions
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   ! Coriolis part of the kinetic energy operator g_cor
   !
   function PTmatrixelements_contr_gcor(icontr,jcontr,j,k_i,k_j,tau_i,tau_j) result(gcor_)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in)        :: j,k_i,k_j,tau_i,tau_j
      real(rk)                      :: gcor_
      !
      real(rk)                      :: mat_t
      integer(ik)                   :: k1,k2
      integer(ik)                   :: jk,dk

         !
         gcor_ = 0 
         !
         if (.not.FLrotation) return
         !
         if (abs(k_i - k_j)>1.or.J==0) return
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         !
         ! Extract rotaitonal quantum numbers
         !
         Jk = 1+k_i+(j*(j+1) )/2
         dk = k_i - k_j
         ! 
         ! Rotational part of the kinetic operator g_cor
         !
         do k2 = 1,3
           !
           if ( (tau_i==tau_j.and.k2==2).or.(tau_i/=tau_j.and.k2/=2) ) then 
             !
             mat_t = gcor(k2)%me(icontr,jcontr)
             !
             !if (icontr<jcontr) mat_t = -mat_t
             !
             gcor_ = gcor_ + mat_t*contr(0)%rot(k2)%coeff3d(Jk,dk,tau_i)
             !
           endif 
           !
         enddo 
         !
         gcor_ = 0.5_rk*gcor_
         !
         if (verbose>=8) write(out,"('PTmatrixelements_contr_gcor:  gcor',f18.8)") gcor_
         !    
   end function PTmatrixelements_contr_gcor



   !
   !
   ! Matrix elements calculations of the fields on the product of the contructed eigenfunctions
   ! with the rotational basis set in the fully symmetrized representaion 
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   ! Coriolis part of the kinetic energy operator g_cor
   !
   function PTmatrixelements_symrot_contr_hvib(icontr,jcontr,j,icount,jcount,ideg,jdeg) result(hvib_t)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in)        :: j,icount,jcount,ideg,jdeg
      real(rk)                      :: hvib_t
      !
      !integer(ik)                   :: iterm,jterm,ib
         !
         hvib_t = 0
         !
         if (icount/=jcount.or.ideg/=jdeg.or..not.PTvibrational_me_calc) return
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         !
         hvib_t = hvib%me(icontr,jcontr)
         !
         if (verbose>=8) write(out,"('PTmatrixelements_symrot_contr_hvib:  hvib',f18.8)") hvib_t
         !
   end function PTmatrixelements_symrot_contr_hvib




   !
   ! Matrix elements calculations of the fields on the product of the contructed eigenfunctions
   ! with the rotational basis set in the fully symmetrized representaion 
   !
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   ! Rotational part of the kinetic energy operator g_rot
   !
   function PTmatrixelements_symrot_contr_grot(icontr,jcontr,j,icount,jcount,ideg,jdeg) result(grot_t)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in)        :: j,icount,jcount,ideg,jdeg
      real(rk)                      :: grot_t,grot_4,grot_5,grot_6,grot_7,grot_8
      !
      real(rk)                      :: mat_r(3,3)
      integer(ik)                   :: k1,k2
      !integer(ik)                   :: ib,iterm,jterm
         !
         if (verbose>=7) write(out,"(/'PTmatrixelements_symrot_contr_grot/start: matrix elemnts for the hamiltonian ')") 
         !
         grot_t = 0 
         !
         if (.not.FLrotation) return
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         !
         do k2 = 1,3
           do k1 = 1,k2
              !
              mat_r(k1,k2) = grot(k1,k2)%me(icontr,jcontr) 
              !
           enddo
         enddo
         !
         ! Jxz
         !
         grot_6 = mat_r(1,3)*me%rot_contr(6,icount,jcount,ideg,jdeg)
         !
         ! Jxy
         !
         grot_5 = mat_r(1,2)*me%rot_contr(5,icount,jcount,ideg,jdeg)
         !
         ! Jyz
         !
         grot_7 = mat_r(2,3)*me%rot_contr(7,icount,jcount,ideg,jdeg)
         !
         ! terms from A*Jx^2+BJy^2+C*Jz^2
         !
         grot_8 = me%rot_contr(8,icount,jcount,ideg,jdeg)*( mat_r(3,3)-0.5_rk*( mat_r(1,1)+mat_r(2,2) ) )
         !
         ! Jx2y2
         !
         grot_4 = 0.5_rk*( mat_r(1,1)-mat_r(2,2) )*me%rot_contr(4,icount,jcount,ideg,jdeg)
         !
         grot_t = grot_t + grot_4 + grot_5 + grot_6 + grot_7 + grot_8
         !
         if (icount==jcount.and.ideg==jdeg) grot_t = grot_t + 0.5_rk*( mat_r(1,1)+mat_r(2,2) )*real(J*(J+1_ik),rk)
         !
         grot_t = 0.5_rk*grot_t
         !
         !if (verbose>=8) write(out,"('PTmatrixelements_symrot_contr_grot:  grot',f18.8)") grot_t

      if (verbose>=7) write(out,"('PTmatrixelements_symrot_contr_grot/end')") 
    
   end function PTmatrixelements_symrot_contr_grot




   !
   ! Matrix elements calculations of the fields on the product of the contructed eigenfunctions
   ! with the rotational basis set in the fully symmetrized representaion 
   !
   ! <v1v2v3...| fields |w1w2w3...>, where fields = V, T_vib, T_rot, ot T_cor
   !
   ! Coriolis part of the kinetic energy operator g_cor
   !
   function PTmatrixelements_symrot_contr_gcor(icontr,jcontr,j,icount,jcount,ideg,jdeg) result(gcor_t)

      integer(ik),intent(in)        :: icontr,jcontr
      integer(ik),intent(in)        :: j,icount,jcount,ideg,jdeg
      real(rk)                      :: gcor_t
      !
      real(rk)                      :: mat_t
      integer(ik)                   :: k1,k2
      !integer(ik)                   :: ib,iterm,jterm
         !
         gcor_t = 0 
         !
         if (.not.FLrotation) return
         !
         !iterm = max(icontr,jcontr)
         !jterm = min(icontr,jcontr)
         !ib = iterm*(iterm-1)/2+jterm
         ! 
         ! Coriolis part of the kinetic operator g_cor
         !
         do k2 = 1,3
            !
            mat_t = gcor(k2)%me(icontr,jcontr)
            !
            !if (icontr<jcontr) mat_t = -mat_t
            !
            gcor_t = gcor_t + mat_t*me%rot_contr(k2,icount,jcount,ideg,jdeg)
            !
         enddo 
         !
         gcor_t = 0.5_rk*gcor_t
         !
         !if (verbose>=8) write(out,"('PTmatrixelements_symrot_contr_gcor:  gcor',f18.8)") gcor_t
         !    
   end function PTmatrixelements_symrot_contr_gcor



  !
  ! This subroutine is to test reading the stored eigenfunctions. 
  ! In order to do something meaningful we check the orthogonality 
  ! of the eigenfunctions. The eigenffunctiosn are given in the primite 
  ! basis set representation. 
  !
  subroutine PTeigenfunction_orthogonality(ener_region)

    real(rk),intent(in) :: ener_region(2)
    integer(ik)         :: i,IOunit_quanta,IOunit_vector,rlevel,alloc,ilevel,jlevel,idimen,jdimen
    integer(ik)         :: jrot_,gamma_,ib_,term_,dimenmax,irecord_t
    real(rk)            :: energy_,f_orthog
    integer(ik),allocatable :: jrot(:),gamma(:),ib(:),term(:),irecord(:)
    real(rk),allocatable :: energy(:),ivector(:),jvector(:),f_t(:)
    character(len=cl)  :: unitfname,buf
    integer(ik)        :: imode,numax(0:PT%Nmodes),nu(0:PT%Nmodes)

      !
      ! storing the eigenfunctions to the hard disk
      !
      if (trim(job%IOeigen_action)/='READ') then
        !
        write (out,"(' eigenfunction_orthogonality: change IOeigen_action to READ')") 
        stop 'eigenfunction_orthogonality: wrong IOeigen_action'
        !
      endif 
      !
      unitfname ='Quantum numbers of the eigensolution'
      call IOStart(trim(unitfname),IOunit_quanta)
      unitfname ='Eigenvectors in the primitive basis set'
      call IOStart(trim(unitfname),IOunit_vector)
      !
      call check_point_active_space('READ')
      !
      ! Read the quantum numbers and term values,
      ! twice:
      ! 1st only to count the number levels satisfying the given conditions;
      ! 2nd to read and store the quntum numbers and energies.
      !
      rlevel = 0
      !
      do ib_ = 1,3
        read(IOunit_quanta,"(20a)") buf
      enddo
      !
      read(buf,*) ib_,dimenmax
      !
      do i = 1,2
        !
        !read(IOunit_quanta,"(a)") buf
        !read(IOunit_quanta,"(a)") buf
        !
        if (i==2) then
           if (rlevel<=0) then 
              write(out,"(/'eigenfunction_orthogonality: no levels within specified codinitions')")
              return
           endif
           !
           allocate (jrot(rlevel),gamma(rlevel),ib(rlevel),term(rlevel),&
                     irecord(rlevel),energy(rlevel),stat=alloc)
           !
           call ArrayStart('eigenf_orthog:energy',alloc,size(energy),kind(energy))
           !
           if (alloc/=0) then
              write (out,"(' eigenfunction_orthogonality/Error  ',i9,' trying to allocate arrays for quanta')") alloc
              stop 'eigenfunction_orthogonality, quanta  - out of memory'
           end if
           !
           ! Go back to the first record
           !
           !
           rewind(IOunit_quanta)
           !
           ! skip the header
           !
           do ib_ = 1,14+PT%Nmodes
             read(IOunit_quanta,"(20a)") buf
           enddo 
           !
           !read(IOunit_quanta,"(a)") buf
           !
        endif 
        !
        ilevel = 0
        rlevel = 0 
        !
        !read(IOunit_quanta,"(a)") buf
        !
        read(IOunit_quanta,"(a)") buf
        !
        do while(buf(1:32)/='End Quantum numbers and energies') 
          !
          ilevel = ilevel + 1
          !
          read(buf,*) irecord_t,gamma_,ib_,term_,energy_,jrot_
          !
          if (ener_region(1)<=energy_.and.energy_<=ener_region(2)) then
            !
            rlevel = rlevel + 1
            !
            if (i==2) then
              irecord(rlevel)  = irecord_t
              gamma  (rlevel)  = gamma_
              ib     (rlevel)  = ib_
              term   (rlevel)  = term_
              energy (rlevel)  = energy_
              jrot   (rlevel)  = jrot_
              !
            endif 
            !
          endif 
          !
          read(IOunit_quanta,"(a)") buf
          !
        enddo
        !
      enddo
      !
      !dimenmax = maxval(dimen)
      !
      allocate (ivector(dimenmax),jvector(dimenmax),stat=alloc)
      !
      call ArrayStart('eigenf_orthog:ivector',alloc,2*size(ivector),kind(ivector))
      !
      do ilevel = 1,rlevel
        !
        idimen = dimenmax
        !
        read(IOunit_vector,rec=ilevel) ivector(1:idimen)
        !
        f_orthog = dot_product(ivector(1:idimen),ivector(1:idimen))
        !
        if (abs(f_orthog-1.0_rk)>0.1_rk**(rk-1)) then 
           write(out,"('vector  ',i8,18x,' is not normal: ',g18.8)") & 
                        ilevel,f_orthog
        endif 
        !
        do jlevel = ilevel+1,rlevel
          !
          jdimen = dimenmax
          !
          if (jlevel/=jlevel) then 
             write(out,"('PTeigenfunction_orthogonality: two vectors with different size in the dot product: ',4i8)") & 
                          ilevel,jlevel,idimen,jdimen
             stop 'PTeigenfun_orth: two vectors with different size in the dot product'
          endif 

          !
          read(IOunit_vector,rec=jlevel) jvector(1:jdimen)
          !
          f_orthog = dot_product(ivector(1:idimen),jvector(1:jdimen))
          !
          if (abs(f_orthog)>0.1_rk**(rk-1)) then 
             write(out,"('vectors ',i8,' and ',i8,' are not orthogonal: ',g18.8)") & 
                          ilevel,jlevel,f_orthog
          endif 
          !
        enddo
      enddo


      do imode = 0,PT%Nmodes
        !
        numax(imode) = maxval(PT%p_active_space%primt(imode,:),dim=1)
        !
      enddo
      !
      
      !
      allocate (f_t(0:maxval(numax,dim=1)),stat=alloc)
      !
      do ilevel = 1,rlevel
        !
        idimen = dimenmax
        !
        read(IOunit_vector,rec=ilevel) ivector(1:idimen)
        !
        do imode = 1,PT%Nmodes
          !
          f_t = 0 
          !
          do ib_ = 1,dimenmax
            !
            nu(:)=PT%p_active_space%primt(:,ib_)
            !
            f_t(nu(imode)) = f_t(nu(imode)) + ivector(ib_)**2
            !
          enddo
          !
          write(out,"(/'ilevel,imode,energy = ',2i8,f16.8)") ilevel,imode,energy(ilevel)
          !
          do ib_ = 0,numax(imode)
            !
            write(out,"(i8,f18.8)") ib_,f_t(ib_)
            !
          enddo
          !
        enddo
        !
      enddo

      deallocate(f_t)


      !
      deallocate(jrot)
      deallocate(gamma)
      deallocate(ib)
      deallocate(term)
      deallocate(irecord)
      deallocate(energy)
      deallocate(ivector)
      deallocate(jvector)
      !
      call ArrayStop('eigenf_orthog:energy')
      call ArrayStop('eigenf_orthog:ivector')

  end subroutine PTeigenfunction_orthogonality



  !
  ! This subroutine is to test reading the stored eigenfunctions. 
  ! In order to do something meaningful we check the matrix elements of the 
  ! Hamiltonian and the orthogonality of the eigenfunctions. 
  ! The eigenffunctions are given in the contracted basis setrepresentation. 
  !
  subroutine PTTest_eigensolution(jmin,jmax)

    integer(ik),intent(in) :: jmin,jmax

    integer(ik)         :: alloc,ilevel
    integer(ik)         :: irecord_t
    real(rk)            :: f_orthog
    real(rk),allocatable :: ivector(:),jvector(:)
    character(len=cl)  :: unitfname,buf
    integer(ik)        :: nu(0:PT%Nmodes)

    type(PTeigenfile)  :: filenames,basename
    type(PSolutionT)   :: solut(jmin:jmax)
    real(rk)           :: zpe,value,f_t
    integer(ik)        :: j,chkptIO,Npolyad_t,iline,nroots,nlevels,dimen,iroot,iroot_t,ilevel_t,ideg
    integer(ik)        :: gamma,chkptIO_vect(jmin:jmax),rec_len,mat_size,ib,icoeff
    character(len=34)  :: buf34
    character(len=25)  :: buf25
    type(PTintcoeffsT) :: irecord(jmin:jmax)
    integer(ik)        :: Maxsymcoeffs(jmin:jmax),max_deg_size(jmin:jmax),Maxcontracts(jmin:jmax)
    integer(ik)        :: jroot,jlevel,jdeg
    !
    type(PTintcoeffs1dT)  :: index_deg_size(jmin:jmax)
    type(PTintcoeffs2dT)  :: contractive_space(jmin:jmax),icase2icontr(jmin:jmax),icontr2icase(jmin:jmax)
    type(PTintcoeffs3dT)  :: index_deg(jmin:jmax),rot_index(jmin:jmax)
    !
    integer(ik)        :: isize
    integer(ik)        :: k0,tau0,j_t,ilarge_coef_t
    integer(ik)        :: irotsize(jmin:jmax),idegsize(jmin:jmax)
    character(len=cl)  :: job_is
    character(len=4)   :: char_j
    integer(ik) :: iunit
    integer(ik) :: ncontr,maxcontr
    character(len=cl)   :: task


      if (job%verbose>=2) write (out,"(//'Test the read/write procedure of the eigenvectors and all auxiliary information.')")
      !
      ! reading the eigenfunctions from the hard disk
      !
      if (trim(job%IOeigen_action)/='READ') then
        !
        write (out,"(' PTTest_eigensolution_contracted: change IOeigen_action to RESTORE')") 
        stop 'PTTest_eigensolution_contracted: wrong IOeigen_action'
        !
      endif 
      !
      if (job%verbose>=2) write (out,"(/'Restore the J=0 contracted basis functions...')")
      !
      call PTcheck_point_contracted_space('READ')
      !
      ! file names with eigensolution for all J-values specified 
      !
      basename%dscr       = 'eigen_descr'
      basename%primitives = 'eigen_quanta'
      basename%vectors    = 'eigen_vectors'
      !
      zpe = 0
      !
      if (job%verbose>=2) write (out,"(/'Restore the eigenfunctions ...')")
      !
      do j=jmin,jmax
        !
        write(char_j,"(i4)") j
        !
        if (job%verbose>=2) write (out,"('j = ',i8)") j
        !
        filenames%dscr       = trim(basename%dscr)//trim(adjustl(char_j))//'.chk'
        filenames%primitives = trim(basename%primitives)//trim(adjustl(char_j))//'.chk'
        filenames%vectors    = trim(basename%vectors)//trim(adjustl(char_j))//'.chk'

        !
        ! Connect files with the stored eigenvectors, eigevalues, quantum numbers 
        !
        ! 1. File with the quantum numbers and energies of the eigensolution.
        !
        if (job%verbose>=2) write (out,"('File with quantum numbers and eigen-energies  ...')")
        !
        unitfname ='Quantum numbers of the eigensolution'
        call IOStart(trim(unitfname),chkptIO)
        open(chkptIO,action='read',position='rewind',status='old',file=filenames%dscr) 
        !        
        ! fingerprint part
        !
        call FLfingerprint('read',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
        !
        read(chkptIO,"(a34)") buf34
        if (buf34/='Start Quantum numbers and energies') then
          write (out,"(' Quantum numbers checkpoint file ',a,' has bogus header: ',a)") job%contrfile%primitives,buf34
          stop 'PTTest_eigensolution - bogus file format'
        end if
        !
        read(chkptIO,*) Npolyad_t
        if (Npolyad_t/=job%Npolyads_contr) then
          write (out,"('contracted polyad thresholds ',i8,' is different from ',i8,' in checkpoint file ',a)") & 
                job%Npolyads_contr,Npolyad_t,job%contrfile%primitives
          stop 'PTTest_eigensolution - not consistent contr. polyad number'
        end if
        !
        !
        iline = 14+PT%Nmodes
        irecord_t = 0 
        !
        !
        read(chkptIO,"(20a)") buf
        if (buf(1:3)/='Cla') then
          write (out,"('Contracted checkpoint file ',a,' has bogus line Class: ',a)") buf
          stop 'PTTest_eigensolution - bogus line Class'
        end if
        !
        read(chkptIO,*) nroots,solut(j)%dimen
        dimen = solut(j)%dimen
        !
        ! count the actual number of roots (taking into account degeneracy) and levels (unique roots)
        !
        iroot = 0
        ilevel = 0 
        buf = ""
        do while (iroot<=nroots.and.buf(1:3)/='End'.and.buf(1:3)/='Cla')
          read(chkptIO,"(20a)") buf
          if (buf(1:3)=='End'.or.buf(1:3)=='Cla') cycle
          iroot = iroot + 1
          read(buf,*) irecord_t,iroot_t,ilevel_t,ideg
          !
          if (ideg==1) ilevel = ilevel + 1
          !
        enddo 
        nroots = iroot
        nlevels = ilevel
        !
        ! return to the reading record 
        !
        rewind(chkptIO)
        do ib = 1,iline
           read(chkptIO,"(20a)") buf
        enddo 
        !
        iline = iline + nroots+2
        !
        allocate (solut(j)%eigen(nlevels),&
                  solut(j)%iroot(nlevels,sym%maxdegen),stat=alloc)
        call ArrayStart('contr%eigen%vect',alloc,size(solut(j)%iroot),kind(solut(j)%iroot))
        !
        if (alloc/=0) then
           write (out,"(' Error ',i9,' trying to allocate eigen-field')") alloc
           stop 'PTTest_eigensolution, eigen -  out of memory'
        end if
        !
        allocate (irecord(j)%icoeffs(nlevels,sym%maxdegen),stat=alloc)
        if (alloc/=0) then
           write (out,"(' Error ',i9,' trying to allocate irecord-field')") alloc
           stop 'PTTest_eigensolution, solution -  out of memory'
        end if
        !
        allocate (solut(j)%ilevel(nroots),solut(j)%ideg(nroots),stat=alloc)
        call ArrayStart('solut%eigen%vect',alloc,2*nroots,kind(solut(j)%ilevel))
        !
        irecord(j)%icoeffs = 0 
        !
        solut(j)%max_degen = 1
        !
        !ilevel = 0
        !
        do iroot = 1,nroots
          !
          read(chkptIO,*) irecord_t,&
                          gamma,&
                          ilevel,ideg,&
                          value,&
                          nu(0:PT%Nmodes),ilarge_coef_t
          !
          if (ideg==1) then    
            !
            allocate (solut(j)%eigen(ilevel)%nu(0:PT%Nmodes),stat=alloc)
            call ArrayStart('contr%eigen%vect',alloc,size(solut(j)%eigen(ilevel)%nu),& 
                             kind(solut(j)%eigen(ilevel)%nu))
            !
          endif
          ! 
          ! iroot  - counts all eigenvecors taking into all degenerate components
          ! ilevel - counts eigenvalues, i.e. only unique (degenerate) components 
          ! ideg   - counts the degener. component for the given ilevel 
          ! 
          ! the record where the eigenvector is stored 
          irecord(j)%icoeffs(ilevel,ideg) = irecord_t
          ! the symmetry of the eigenlevel (integer) 
          solut(j)%eigen(ilevel)%isym = gamma
          ! the symmetry of the eigenlevel (character) 
          solut(j)%eigen(ilevel)%gamma = trim(sym%label(gamma))
          ! the degeneracy of the eigenlevel
          solut(j)%eigen(ilevel)%degeneracy = sym%degen(gamma)
          ! the eigenvalue
          solut(j)%eigen(ilevel)%value = value
          ! assignment (primitive bset represent.) according to the largest coeffic.  
          solut(j)%eigen(ilevel)%nu(0:PT%Nmodes) = nu(0:PT%Nmodes)
          ! the number of the largest coeff. in the expansion of the eigenfunction (in terms of the contr. bset)
          solut(j)%eigen(ilevel)%ilarge_coeff = ilarge_coef_t
          ! the maximal degeneracy of all eigenvectors for a given quantum j
          solut(j)%max_degen = max(solut(j)%max_degen,sym%degen(gamma))
          ! the address of the level for a given root 
          solut(j)%ilevel(iroot) = ilevel 
          ! the address of the degenerate component for a given root
          solut(j)%ideg(iroot) = ideg 
          ! the address of the root for the given pair of (level,degenerate component)
          solut(j)%iroot(ilevel,ideg) = iroot
          !
        enddo 
        !
        if (j==0) zpe = solut(j)%eigen(1)%value
        !
        ! total number of roots
        solut(j)%nroots = nroots
        ! total number of levels (levels<=nroots)
        solut(j)%nlevels = nlevels
        !
        if (job%verbose>=6) write(out,"(/'PTTest_eigensolution..: Number of roots: ',i8)") nroots
        !
        read(chkptIO,"(a32)") buf34(1:32)
        if (buf34(1:32)/='End Quantum numbers and energies') then
          write (out,"('Quantum numbers  checkpoint file ',a,' has bogus footer: ',a)") job%contrfile%primitives,buf34(1:32)
          stop 'PTcheck_point_contracted_space - bogus file footer format'
        end if
        !
        close(chkptIO,status='keep')
        !
        !
        ! 2. File with the description of the contracted basis set functions. 
        !
        if (job%verbose>=2) write (out,"('File with the discription of the eigensolution...')")
        !
        unitfname ='Description of the primitive basis set'
        !
        call IOStart(trim(unitfname),chkptIO)
        open(chkptIO,action='read',position='rewind',status='old',file=filenames%primitives) 
        !
        read(chkptIO,"(a25)") buf25
        if (buf25/='Start Primitive basis set') then
          write (out,"(' Primitive checkpoint file ',a,' has bogus header: ',a)") trim(filenames%primitives),buf25
          stop 'check_point_active_space - bogus file format'
        end if
        !
        read(chkptIO,"(3i8)") Maxsymcoeffs(j),max_deg_size(j),Maxcontracts(j)
        !
        mat_size = max_deg_size(j)
        !
        allocate (Index_deg(j)%iiimat(Maxsymcoeffs(j),0:PT%Nclasses,mat_size),stat=alloc)
        call ArrayStart('Index_deg%icoeffs',alloc,size(Index_deg(j)%iiimat),ik)
        !
        allocate (Index_deg_size(j)%imat(Maxsymcoeffs(j)),stat=alloc)
        call ArrayStart('Index_deg%icoeffs',alloc,size(Index_deg_size(j)%imat),ik)
        !
        allocate (contractive_space(j)%iimat(0:PT%Nclasses,Maxsymcoeffs(j)),stat=alloc)
        call ArrayStart('contractive_space',alloc,size(contractive_space(j)%iimat),ik)
        !
        allocate (icase2icontr(j)%iimat(Maxsymcoeffs(j),mat_size),stat=alloc)
        call ArrayStart('icase2icontr',alloc,size(icase2icontr(j)%iimat),ik)
        !
        allocate (icontr2icase(j)%iimat(Maxcontracts(j),2),stat=alloc)
        call ArrayStart('icontr2icase',alloc,size(icontr2icase(j)%iimat),ik)
        !
        iroot = 0 
        !
        do ilevel = 1,Maxsymcoeffs(j)
          !
          read(chkptIO,*)  Index_deg_size(j)%imat(ilevel),contractive_space(j)%iimat(0:PT%Nclasses,ilevel)
          !
          do ib = 1,Index_deg_size(j)%imat(ilevel)
             !
             iroot = iroot + 1
             !
             read(chkptIO,*)  iroot_t,Index_deg(j)%iiimat(ilevel,0:PT%Nclasses,ib)
             !
             ! 
             ! this object defines the correlation between the iroot and (ico)
             icontr2icase(j)%iimat(iroot,1) = ilevel
             icontr2icase(j)%iimat(iroot,2) = ib
             !
             if (iroot/=iroot_t) then 
               !
               write(out,"('PTTest_eigensolution: inconsistent records ',2i8,' in filenames%primitives')") iroot_t,iroot
               stop 'illegal counting record'
               ! 
             endif 
             !
          enddo
          !
        enddo
        !
        ! Rotational quanta 
        !
        read(chkptIO,"(3i8)") irotsize(j),idegsize(j)
        !
        allocate (rot_index(j)%iiimat(irotsize(j),idegsize(j),2),stat=alloc)
        call ArrayStart('rot_index',alloc,size(rot_index(j)%iiimat),ik)
        !
        ! In total there are 2J+1 rotational term values
        !
        do ilevel = 1,2*j+1
          !
          read(chkptIO,*)  icoeff,ib,j_t,k0,tau0
          !
          if (j_t/=j.or.icoeff>irotsize(j).or.icoeff<1.or.ib>idegsize(j).or.ib<1.or.k0>j.or.k0<0.or.tau0<0.or.tau0>2) then 
            !
            write(out,"('PTTest_eigensolution: illegal rotational quanta filenames%primitives :',4i8,' (icoeff,ib,k,tau) ')") &
                         icoeff,ib,k0,tau0
            stop 'illegal rotational quanta '
            ! 
          endif 
          !
          rot_index(j)%iiimat(icoeff,ib,1) = k0
          rot_index(j)%iiimat(icoeff,ib,2) = tau0
          !
        enddo
        !
        !
        read(chkptIO,"(a23)") buf34(1:23)
        if (buf34(1:23)/='End Primitive basis set') then
          write (out,"(' Checkpoint file ',a,' has bogus header: ',a)") job%contrfile%dscr, buf34(1:23)
          stop 'PTcheck_point_contracted_space - bogus file format'
        end if
        !
        ! 3. File with the eigenvectors in the contracted basis set representaion. 
        !
        if (job%verbose>=2) write (out,"('Connect to the file with  eigenvectors...')")
        !
        write(unitfname,"('Eigenvectors for j = ',i6)") j
        !
        call IOStart(trim(unitfname),chkptIO_vect(j))
        inquire(iolength=rec_len) f_t
        !
        rec_len = rec_len*Maxcontracts(j)
        !
        open(chkptIO_vect(j),access='direct',recl=rec_len,action='read',status='old',file=filenames%vectors)
        !
     enddo
     !
     ! Start with testing the eigenfunctions by checking their orthogonrmality
     !
     if (job%verbose>=2) write (out,"(/'Check the orthonormality of the eigevectors...')")
     !
     do j = jmin,jmax
       !
       if (job%verbose>=2) write (out,"('J = ',i8)") j 
       if (job%verbose>=2) write (out,"('Size of the contracted basis set = ',i8)") Maxcontracts(j)
       !
       dimen = Maxcontracts(j)
       !
       nroots = solut(j)%nroots
       !
       allocate (ivector(dimen),jvector(dimen),stat=alloc)
       !
       call ArrayStart('eigenf_orthog:ivector',alloc,2*size(ivector),kind(ivector))
       !
       do iroot = 1,nroots
         !
         ilevel = solut(j)%ilevel(iroot)
         ideg = solut(j)%ideg(iroot)
         !
         irecord_t = irecord(j)%icoeffs(ilevel,ideg)
         !
         read(chkptIO_vect(j),rec=irecord_t) ivector(1:dimen)
         !
         f_orthog = dot_product(ivector(1:dimen),ivector(1:dimen))
         !
         if (abs(f_orthog-1.0_rk)>0.1_rk**(rk-1)) then 
            write(out,"('vector  ',2i8,18x,' is not normal: ',g18.8)") & 
                         ilevel,ideg,f_orthog
         endif 
         !
         if (job%verbose>=4) then 
            write(out,"('<',2i4,'| H |',2i4,'> =',g24.14)") ilevel,ideg,ilevel,ideg,f_orthog
         endif 
         !
         do jroot = iroot+1,nroots
           !
           jlevel = solut(j)%ilevel(jroot)
           jdeg = solut(j)%ideg(jroot)
           !
           irecord_t = irecord(j)%icoeffs(jlevel,jdeg)
           !
           read(chkptIO_vect(j),rec=irecord_t) jvector(1:dimen)
           !
           f_orthog = dot_product(ivector(1:dimen),jvector(1:dimen))
           !
           if (abs(f_orthog)>0.1_rk**(rk-1)) then 
              write(out,"('vectors ',2i8,' and ',2i8,' are not orthogonal: ',g18.8)") & 
                           ilevel,ideg,jlevel,jdeg,f_orthog
           endif 
           !
           if (job%verbose>=4.and.abs(f_orthog)>0.0001) then 
              write(out,"('<',2i4,'| H |',2i4,'> = ',g18.8)") ilevel,ideg,jlevel,jdeg,f_orthog
           endif 
           !
         enddo
       enddo
       !
       deallocate(ivector,jvector)
       call ArrayStop('eigenf_orthog:ivector')
       !
     enddo
     !
     if (job%verbose<4) write (out,"(/'If no information appeared - the basis functions ARE orthonormal better than 0.0001.'/)")
     !
     ! Continue with testing of the Hamiltonian matrix
     !
     if (job%verbose>=2) write (out,"(/'Check the eigenfunctions to be eigensolution of the Schroedinger equation...')")
     !
     if (job%verbose>=2) write (out,"('Restore the J=0 matrix elements of the Hamiltonia...')")
     !
     !call restore_vib_matrix_elements
     !
     task = 'top'
     call PTrestore_rot_kinetic_matrix_elements(j,task,iunit,ncontr,maxcontr)
     !
     ! obtain the rotational matrix elements
     !
     if (job%verbose>=2) write (out,"('Restore the rotational matrix elements of the angular momenta')")
     !
     job_is = 'rot'
     !
     allocate(contr(0)%rot(7),stat=alloc)
     !
     isize = (jmax+1)*(jmax+2)/2
     !
     do k0 =1,size(contr(0)%rot(:))
       !
       allocate(contr(0)%rot(k0)%coeff3d(isize,-2:2,0:1),stat=alloc)
       call ArrayStart('gvib-grot-gcor-fields',alloc,size(contr(0)%rot(k0)%coeff3d),kind(f_t))
       !
     enddo 
     !
     do k0 = 1,7
       !
       !call FLread_rot_matelem(k1,contr(0)%rot(k1)%coeff3d(:,:,:))
       call FLread_coeff_matelem(job_is,k0,1,contr(0)%rot(k0)%coeff3d(:,:,:))
       !
     enddo
     !
     !
     contains 
     !
     ! find correspondence between contracted quantum numbers: current and for J=0 
     !
     subroutine find_correlation(j)
        !
        integer(ik),intent(in)  :: j 
        !
        integer(ik)  :: cnu(0:PT%Nclasses),ideg(0:PT%Nclasses),icase,ib,icontr,iterm
        integer(ik)  :: cnu_t(PT%Nclasses),ideg_t(PT%Nclasses)
        !
        icase2icontr(j)%iimat = 0 
        !
        do icase = 1,Maxsymcoeffs(j)
          !
          cnu(:) = contractive_space(j)%iimat(:,icase)
          !
          do ib = 1,Index_deg_size(j)%imat(icase)
            !
            ideg(:) = Index_deg(j)%iiimat(icase,:,ib)
            !
            do icontr = 1,size(PT%icontr_cnu,dim=2)
              !
              cnu_t(1:PT%Nclasses) = PT%icontr_cnu(1:PT%Nclasses,icontr)
              ideg_t(1:PT%Nclasses) = PT%icontr_ideg(1:PT%Nclasses,icontr)
              !
              if (all(PT%icontr_cnu(1:PT%Nclasses,icontr)==cnu(1:PT%Nclasses)).and.&
                  all(PT%icontr_ideg(1:PT%Nclasses,icontr)==ideg(1:PT%Nclasses))) then 
                !
                iterm = icontr
                exit
                !
              endif
              !
            enddo
            !
            icase2icontr(j)%iimat(icase,ib) = iterm
            !
          enddo
          !
        enddo
        !
     end subroutine find_correlation
     !
  end subroutine PTTest_eigensolution


  !
  ! This subroutine is to test reading the stored eigenfunctions. 
  ! In order to do something meaningful we check the matrix elements of the 
  ! Hamiltonian and the orthogonality of the eigenfunctions. 
  ! The eigenffunctions are given in the contracted basis setrepresentation. 
  !
  subroutine PTanalysis_density(j)

    integer(ik),intent(in) :: j
    integer(ik)            :: imode,jmode,kmode
    !
    integer(ik)         :: alloc,ilevel
    integer(ik)         :: irecord_t
    real(rk)            :: f_orthog
    real(rk),allocatable :: ivector(:),jvector(:),jrot_mat(:,:,:)
    character(len=cl)  :: unitfname,buf
    integer(ik)        :: nu(0:PT%Nmodes)

    type(PTeigenfile)  :: filenames,basename
    character(len=4) :: char_j
    type(PSolutionT) :: solut(j:j)
    real(rk)         :: zpe,value,f_t
    integer(ik)      :: chkptIO,Npolyad_t,iline,nroots,nlevels,dimen,iroot,iroot_t,ilevel_t,ideg
    integer(ik)      :: gamma,chkptIO_vect(j:j),rec_len,mat_size,ib,icoeff
    character(len=34) :: buf34
    character(len=25) :: buf25
    type(PTintcoeffsT) :: irecord(j:j)
    integer(ik)        :: Maxsymcoeffs(j:j),max_deg_size(j:j),Maxcontracts(j:j)
    integer(ik)        :: jroot,jlevel,jdeg
    !
    type(PTintcoeffs1dT)  :: index_deg_size(j:j)
    type(PTintcoeffs2dT)  :: contractive_space(j:j),icase2icontr(j:j),icontr2icase(j:j)
    type(PTintcoeffs3dT)  :: index_deg(j:j),rot_index(j:j)
    !
    integer(ik)        :: dimen_p,dimen_s,irow,jrow,cnu_i(0:PT%Nclasses),cnu_j(0:PT%Nclasses)
    integer(ik)        :: isize,deg_i(0:PT%Nclasses),deg_j(0:PT%Nclasses)
    integer(ik)        :: icontr,jcontr,k_i,k_j,tau_i,tau_j,k0,tau0,ielem,jelem,j_t,ilarge_coef_t,iclasses,isym_t,ideg_t
    integer(ik)        :: irotsize(j:j),idegsize(j:j),Nclasses
    character(len=3)   :: cgamma(0:PT%Nclasses)
    character(len=cl)  :: job_is
    !
    real(rk),allocatable :: dens(:,:,:)
    integer(ik)        :: dens_size(3),ilist,jlist,nlist,i1,i2,i3,Jk,dk
    !
    real(rk),allocatable :: Hmat_p(:,:),Hmat_s(:,:)
    character(len=cl)    :: my_fmt !format for I/O specification

     if (job%verbose>=2) write (out,"(//'Test the read/write procedure of the eigenvectors and all auxiliary information.')")
     !
     ! reading the eigenfunctions from the hard disk
     !
     if (trim(job%IOeigen_action)/='READ') then
       !
       write (out,"(' PTanalysis_density_contracted: change IOeigen_action to READ')") 
       stop 'PTanalysis_density_contracted: wrong IOeigen_action'
       !
     endif 
     !
     if (job%verbose>=2) write (out,"(/'Restore the J=0 contracted basis functions...')")
     !
     call PTcheck_point_contracted_space('READ')
     !
     ! file names with eigensolution for all J-values specified 
     !
     basename%dscr       = 'eigen_descr'
     basename%primitives = 'eigen_quanta'
     basename%vectors    = 'eigen_vectors'
     !
     Nclasses  = PT%Nclasses 
     !
     zpe = 0
     !
     if (job%verbose>=2) write (out,"(/'Restore the eigenfunctions ...')")
     !
     !
     write(char_j,"(i4)") j
     !
     if (job%verbose>=2) write (out,"('j = ',i8)") j
     !
     filenames%dscr       = trim(basename%dscr)//trim(adjustl(char_j))//'.chk'
     filenames%primitives = trim(basename%primitives)//trim(adjustl(char_j))//'.chk'
     filenames%vectors    = trim(basename%vectors)//trim(adjustl(char_j))//'.chk'

     !
     ! Connect files with the stored eigenvectors, eigevalues, quantum numbers 
     !
     ! 1. File with the quantum numbers and energies of the eigensolution.
     !
     if (job%verbose>=2) write (out,"('File with quantum numbers and eigen-energies  ...')")
     !
     unitfname ='Quantum numbers of the eigensolution'
     call IOStart(trim(unitfname),chkptIO)
     open(chkptIO,action='read',position='rewind',status='old',file=filenames%dscr) 
     !        
     ! fingerprint part
     !
     call FLfingerprint('read',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
     !
     read(chkptIO,"(a34)") buf34
     if (buf34/='Start Quantum numbers and energies') then
       write (out,"(' Quantum numbers checkpoint file ',a,' has bogus header: ',a)") job%contrfile%primitives,buf34
       stop 'PTanalysis_density - bogus file format'
     end if
     !
     read(chkptIO,*) Npolyad_t
     if (Npolyad_t/=job%Npolyads_contr) then
       write (out,"('contracted polyad thresholds ',i8,' is different from ',i8,' in checkpoint file ',a)") & 
             job%Npolyads_contr,Npolyad_t,job%contrfile%primitives
       stop 'PTanalysis_density - not consistent contr. polyad number'
     end if
     !
     !
     iline = 14+PT%Nmodes
     irecord_t = 0 
     !
     !
     read(chkptIO,"(20a)") buf
     if (buf(1:3)/='Cla') then
       write (out,"('Contracted checkpoint file ',a,' has bogus line Class: ',a)") buf
       stop 'PTanalysis_density - bogus line Class'
     end if
     !
     read(chkptIO,*) nroots,solut(j)%dimen
     dimen = solut(j)%dimen
     !
     ! count the actual number of roots (taking into account degeneracy) and levels (unique roots)
     !
     iroot = 0
     ilevel = 0 
     buf = ""
     do while (iroot<=nroots.and.buf(1:3)/='End'.and.buf(1:3)/='Cla')
       read(chkptIO,"(20a)") buf
       if (buf(1:3)=='End'.or.buf(1:3)=='Cla') cycle
       iroot = iroot + 1
       read(buf,*) irecord_t,iroot_t,ilevel_t,ideg
       !
       if (ideg==1) ilevel = ilevel + 1
       !
     enddo 
     nroots = iroot
     nlevels = ilevel
     !
     ! return to the reading record 
     !
     rewind(chkptIO)
     do ib = 1,iline
        read(chkptIO,"(20a)") buf
     enddo 
     !
     iline = iline + nroots+2
     !
     allocate (solut(j)%eigen(nlevels),&
               solut(j)%iroot(nlevels,sym%maxdegen),stat=alloc)
     call ArrayStart('contr%eigen%vect',alloc,size(solut(j)%iroot),kind(solut(j)%iroot))
     !
     if (alloc/=0) then
        write (out,"(' Error ',i9,' trying to allocate eigen-field')") alloc
        stop 'PTanalysis_density, eigen -  out of memory'
     end if
     !
     allocate (irecord(j)%icoeffs(nlevels,sym%maxdegen),stat=alloc)
     if (alloc/=0) then
        write (out,"(' Error ',i9,' trying to allocate irecord-field')") alloc
        stop 'PTanalysis_density, solution -  out of memory'
     end if
     !
     allocate (solut(j)%ilevel(nroots),solut(j)%ideg(nroots),stat=alloc)
     call ArrayStart('solut%eigen%vect',alloc,2*nroots,kind(solut(j)%ilevel))
     !
     irecord(j)%icoeffs = 0 
     !
     solut(j)%max_degen = 1
     !
     !ilevel = 0
     !
     do iroot = 1,nroots
       !
       read(chkptIO,*) irecord_t,&
                       gamma,&
                       ilevel,ideg,&
                       value,&
                       nu(0:PT%Nmodes),ilarge_coef_t ! ,isym(0:nclasses)

       !
       if (ideg==1) then    
         !
         allocate (solut(j)%eigen(ilevel)%nu(0:PT%Nmodes),stat=alloc)
         call ArrayStart('contr%eigen%vect',alloc,size(solut(j)%eigen(ilevel)%nu),& 
                          kind(solut(j)%eigen(ilevel)%nu))
         !
       endif
       ! 
       ! iroot  - counts all eigenvecors taking into all degenerate components
       ! ilevel - counts eigenvalues, i.e. only unique (degenerate) components 
       ! ideg   - counts the degener. component for the given ilevel 
       ! 
       ! the record where the eigenvector is stored 
       irecord(j)%icoeffs(ilevel,ideg) = irecord_t
       ! the symmetry of the eigenlevel (integer) 
       solut(j)%eigen(ilevel)%isym = gamma
       ! the symmetry of the eigenlevel (character) 
       solut(j)%eigen(ilevel)%gamma = trim(sym%label(gamma))
       ! the degeneracy of the eigenlevel
       solut(j)%eigen(ilevel)%degeneracy = sym%degen(gamma)
       ! the eigenvalue
       solut(j)%eigen(ilevel)%value = value
       ! assignment (primitive bset represent.) according to the largest coeffic.  
       solut(j)%eigen(ilevel)%nu(0:PT%Nmodes) = nu(0:PT%Nmodes)
       ! the number of the largest coeff. in the expansion of the eigenfunction (in terms of the contr. bset)
       solut(j)%eigen(ilevel)%ilarge_coeff = ilarge_coef_t
       ! the maximal degeneracy of all eigenvectors for a given quantum j
       solut(j)%max_degen = max(solut(j)%max_degen,sym%degen(gamma))
       ! the address of the level for a given root 
       solut(j)%ilevel(iroot) = ilevel 
       ! the address of the degenerate component for a given root
       solut(j)%ideg(iroot) = ideg 
       ! the address of the root for the given pair of (level,degenerate component)
       solut(j)%iroot(ilevel,ideg) = iroot
       ! symmetries 
       !solut(j)%eigen(ilevel)%cgamma(:) = sym%label(isym(:))
       !
     enddo 
     !
     if (j==0) zpe = solut(j)%eigen(1)%value
     !
     ! total number of roots
     solut(j)%nroots = nroots
     ! total number of levels (levels<=nroots)
     solut(j)%nlevels = nlevels
     !
     if (job%verbose>=6) write(out,"(/'PTanalysis_density..: Number of roots: ',i8)") nroots
     !
     read(chkptIO,"(a32)") buf34(1:32)
     if (buf34(1:32)/='End Quantum numbers and energies') then
       write (out,"('Quantum numbers  checkpoint file ',a,' has bogus footer: ',a)") job%contrfile%primitives,buf34(1:32)
       stop 'PTcheck_point_contracted_space - bogus file footer format'
     end if
     !
     close(chkptIO,status='keep')
     !
     !
     ! 2. File with the description of the contracted basis set functions. 
     !
     if (job%verbose>=2) write (out,"('File with the discription of the eigensolution...')")
     !
     unitfname ='Description of the primitive basis set'
     !
     call IOStart(trim(unitfname),chkptIO)
     open(chkptIO,action='read',position='rewind',status='old',file=filenames%primitives) 
     !
     read(chkptIO,"(a25)") buf25
     if (buf25/='Start Primitive basis set') then
       write (out,"(' Primitive checkpoint file ',a,' has bogus header: ',a)") trim(filenames%primitives),buf25
       stop 'check_point_active_space - bogus file format'
     end if
     !
     read(chkptIO,"(3i8)") Maxsymcoeffs(j),max_deg_size(j),Maxcontracts(j)
     !
     mat_size = max_deg_size(j)
     !
     allocate (Index_deg(j)%iiimat(Maxsymcoeffs(j),0:PT%Nclasses,mat_size),stat=alloc)
     call ArrayStart('Index_deg%icoeffs',alloc,size(Index_deg(j)%iiimat),ik)
     !
     allocate (Index_deg_size(j)%imat(Maxsymcoeffs(j)),stat=alloc)
     call ArrayStart('Index_deg%icoeffs',alloc,size(Index_deg_size(j)%imat),ik)
     !
     allocate (contractive_space(j)%iimat(0:PT%Nclasses,Maxsymcoeffs(j)),stat=alloc)
     call ArrayStart('contractive_space',alloc,size(contractive_space(j)%iimat),ik)
     !
     allocate (icase2icontr(j)%iimat(Maxsymcoeffs(j),mat_size),stat=alloc)
     call ArrayStart('icase2icontr',alloc,size(icase2icontr(j)%iimat),ik)
     !
     allocate (icontr2icase(j)%iimat(Maxcontracts(j),2),stat=alloc)
     call ArrayStart('icontr2icase',alloc,size(icontr2icase(j)%iimat),ik)
     !
     iroot = 0 
     !
     do ilevel = 1,Maxsymcoeffs(j)
       !
       read(chkptIO,*)  Index_deg_size(j)%imat(ilevel),contractive_space(j)%iimat(0:PT%Nclasses,ilevel)
       !
       do ib = 1,Index_deg_size(j)%imat(ilevel)
          !
          iroot = iroot + 1
          !
          read(chkptIO,*)  iroot_t,Index_deg(j)%iiimat(ilevel,0:PT%Nclasses,ib)
          !
          ! 
          ! this object defines the correlation between the iroot and (ico)
          icontr2icase(j)%iimat(iroot,1) = ilevel
          icontr2icase(j)%iimat(iroot,2) = ib
          !
          if (iroot/=iroot_t) then 
            !
            write(out,"('PTanalysis_density: inconsistent records ',2i8,' in filenames%primitives')") iroot_t,iroot
            stop 'illegal counting record'
            ! 
          endif 
          !
       enddo
       !
     enddo
     !
     ! Rotational quanta 
     !
     read(chkptIO,"(3i8)") irotsize(j),idegsize(j)
     !
     allocate (rot_index(j)%iiimat(irotsize(j),idegsize(j),2),stat=alloc)
     call ArrayStart('rot_index',alloc,size(rot_index(j)%iiimat),ik)
     !
     ! In total there are 2J+1 rotational term values
     !
     do ilevel = 1,2*j+1
       !
       read(chkptIO,*)  icoeff,ib,j_t,k0,tau0
       !
       if (j_t/=j.or.icoeff>irotsize(j).or.icoeff<1.or.ib>idegsize(j).or.ib<1.or.k0>j.or.k0<0.or.tau0<0.or.tau0>2) then 
         !
         write(out,"('PTanalysis_density: illegal rotational quanta filenames%primitives :',4i8,' (icoeff,ib,k,tau) ')") &
                      icoeff,ib,k0,tau0
         stop 'illegal rotational quanta '
         ! 
       endif 
       !
       rot_index(j)%iiimat(icoeff,ib,1) = k0
       rot_index(j)%iiimat(icoeff,ib,2) = tau0
       !
     enddo
     !
     !
     read(chkptIO,"(a23)") buf34(1:23)
     if (buf34(1:23)/='End Primitive basis set') then
       write (out,"(' Checkpoint file ',a,' has bogus header: ',a)") job%contrfile%dscr, buf34(1:23)
       stop 'PTcheck_point_contracted_space - bogus file format'
     end if        
     !
     ! 3. File with the eigenvectors in the contracted basis set representaion. 
     !
     if (job%verbose>=2) write (out,"('Connect to the file with  eigenvectors...')")
     !
     write(unitfname,"('Eigenvectors for j = ',i6)") j
     !
     call IOStart(trim(unitfname),chkptIO_vect(j))
     inquire(iolength=rec_len) f_t
     !
     rec_len = rec_len*Maxcontracts(j)
     !
     open(chkptIO_vect(j),access='direct',recl=rec_len,action='read',status='old',file=filenames%vectors)
     !
     !
     if (analysis%reduced_density) then 
       !
       ! Finish the restoring and start the calculation of the reduced density 
       !
       !
       if (job%verbose>=2) write (out,"('Size of the contracted basis set = ',i8)") Maxcontracts(j)
       !
       if (job%verbose>=2) write (out,"(/'Calculation of the reduced density ...'/)")
       !
       dimen = Maxcontracts(j)
       !
       nroots = solut(j)%nroots
       !
       ilist = 1 
       !
       do while (ilist<size(analysis%dens_list).and.analysis%dens_list(ilist)/=-1)
         !
         ilist = ilist + 1 
         !
       enddo
       !
       nlist = ilist-4 ! minloc(analysis%dens_list(:),dim=1)-4
       !
       if (nlist>size(analysis%dens_list)-3) then 
         !
         write(out,"('PTanalysis_density: too many entries in dens_list: ',i8,' max - ',i8)") nlist,size(analysis%dens_list)-3
         stop 'PTanalysis_density: too many entries in dens_list'
         !
       endif 
       !
       imode = analysis%dens_list(nlist+1) ; jmode = analysis%dens_list(nlist+2) ; kmode = analysis%dens_list(nlist+3)
       !
       dens_size(1) = maxval(contractive_space(j)%iimat(imode,:),dim=1) 
       dens_size(2) = maxval(contractive_space(j)%iimat(jmode,:),dim=1) 
       dens_size(3) = maxval(contractive_space(j)%iimat(kmode,:),dim=1) 
       !
       allocate (ivector(dimen),dens(dens_size(1),dens_size(2),dens_size(3)),stat=alloc)
       !
       call ArrayStart('density:ivector,dens',alloc,size(ivector),kind(ivector))
       !
       write(out,"(/'   state    cnu1    cnu2    cnu3    density: ')")
       !
       do ilist = 1,nlist
         !
         iroot = analysis%dens_list(ilist)
         !
         if (iroot>nroots) cycle
         !
         ilevel = solut(j)%ilevel(iroot)
         ideg = solut(j)%ideg(iroot)
         !
         irecord_t = irecord(j)%icoeffs(ilevel,ideg)
         !
         read(chkptIO_vect(j),rec=irecord_t) ivector(1:dimen)
         !
         f_orthog = dot_product(ivector(1:dimen),ivector(1:dimen))
         !
         if (abs(f_orthog-1.0_rk)>0.1_rk**(rk-1)) then 
            write(out,"('vector  ',2i8,18x,' is not normal: ',g18.8)") & 
                         ilevel,ideg,f_orthog
         endif 
         !
         if (job%verbose>=5) then 
            write(out,"('<',2i4,'| H |',2i4,'> =',g24.14)") ilevel,ideg,ilevel,ideg,f_orthog
         endif
         !
         dens = 0 
         !
         do ielem = 1,dimen
           !
           irow = icontr2icase(j)%iimat(ielem,1)
           ideg = icontr2icase(j)%iimat(ielem,2)
           !
           cnu_i(:) = contractive_space(j)%iimat(:,irow)
           !
           deg_i(:) = Index_deg(j)%iiimat(irow,:,ideg)
           !
           k_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),1)
           tau_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),2)
           !
           dens(cnu_i(imode),cnu_i(jmode),cnu_i(kmode)) = dens(cnu_i(imode),cnu_i(jmode),cnu_i(kmode)) &
                                                        + ivector(ielem)**2
           !
         enddo
         !
         do i1 = 1,dens_size(1)
           do i2 = 1,dens_size(2)
             do i3 = 1,dens_size(3)
               !
               if (dens(i1,i2,i3)>small_) then 
                 !
                 write(out,"(4i8,x,f20.14)") iroot,i1,i2,i3,dens(i1,i2,i3)
                 !
               endif
               !
             enddo
           enddo
         enddo
         !
       enddo
       !
       deallocate(ivector,dens)
       !
       call ArrayStop('density:ivector,dens')
       !
       if (job%verbose>=2) write (out,"(/'...Done!'/)")
       !
       !
       allocate (ivector(dimen),stat=alloc)
       !
       call ArrayStart('eigencoef:ivector',alloc,size(ivector),kind(ivector))
       !
       write(out,"(/'   state    cnu1    cnu2    cnu3    density: ')")
       !
       do ilist = 1,nlist
         !
         iroot = analysis%dens_list(ilist)
         !
         if (iroot>nroots) cycle
         !
         ilevel = solut(j)%ilevel(iroot)
         ideg = solut(j)%ideg(iroot)
         !
         irecord_t = irecord(j)%icoeffs(ilevel,ideg)
         !
         read(chkptIO_vect(j),rec=irecord_t) ivector(1:dimen)
         !
         f_orthog = dot_product(ivector(1:dimen),ivector(1:dimen))
         !
         if (abs(f_orthog-1.0_rk)>0.1_rk**(rk-1)) then 
            write(out,"('vector  ',2i8,18x,' is not normal: ',g18.8)") & 
                         ilevel,ideg,f_orthog
         endif 
         !
         if (job%verbose>=5) then 
            write(out,"('<',2i4,'| H |',2i4,'> =',g24.14)") ilevel,ideg,ilevel,ideg,f_orthog
         endif
         !
         write(my_fmt,'(a,i0,a)') "(2x,a2,2i7,f14.6,e16.8,3x,a1,3i3,a3,",Nclasses,"(i3),a1)"
         !
         do ielem = 1,dimen
           !
           irow = icontr2icase(j)%iimat(ielem,1)
           ideg = icontr2icase(j)%iimat(ielem,2)
           !
           cnu_i(:) = contractive_space(j)%iimat(:,irow)
           !
           deg_i(:) = Index_deg(j)%iiimat(irow,:,ideg)
           !
           k_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),1)
           tau_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),2)

           if (abs(ivector(ielem))>1e-4) then  
             !
             write(out,my_fmt) & 
                        solut(j)%eigen(ilevel)%gamma,iroot,ielem,solut(j)%eigen(ilevel)%value,"(",&
                        ivector(ielem), &
                        j,k_i,tau_i,") (",cnu_i(1:Nclasses),")"
             !
           endif
           !
           !
         enddo
         !
       enddo 
       !
       deallocate(ivector)
       !
       call ArrayStop('eigencoef:ivector')
       !
       if (job%verbose>=2) write (out,"(/'...Done!'/)")
       !
     endif 
     !
     ! Rotational matrix 
     !
     if (analysis%rotation_matrix) then 
        !
        write(out,"(/'   Expectation values of the rotational matrix: ')")
        !
        if (job%verbose>=2) write (out,"('Restore the rotational matrix elements of the angular momenta')")
        !
        job_is = 'rot'
        !
        allocate(contr(0)%rot(7),stat=alloc)
        !
        isize = (j+1)*(j+2)/2
        !
        do k0 =1,size(contr(0)%rot(:))
          !
          allocate(contr(0)%rot(k0)%coeff3d(isize,-2:2,0:1),stat=alloc)
          call ArrayStart('gvib-grot-gcor-fields',alloc,size(contr(0)%rot(k0)%coeff3d),kind(f_t))
          !
        enddo 
        !
        do k0 = 1,7
          !
          !call FLread_rot_matelem(k1,contr(0)%rot(k1)%coeff3d(:,:,:))
          call FLread_coeff_matelem(job_is,k0,1,contr(0)%rot(k0)%coeff3d(:,:,:))
          !
        enddo
        !
        allocate (ivector(dimen),jvector(dimen),jrot_mat(3,nlist,nlist),stat=alloc)
        !
        call ArrayStart('density:ivector,jrot-mat',alloc,2*size(ivector)+size(jrot_mat),kind(ivector))
        !
        write(out,"(/'       x       k1      k2     Jrot-matrix: ')")
        !
        jrot_mat = 0 
        !
        do ilist = 1,nlist
          !
          iroot = analysis%dens_list(ilist)
          !
          if (iroot>nroots) cycle
          !
          ilevel = solut(j)%ilevel(iroot)
          ideg = solut(j)%ideg(iroot)
          !
          irecord_t = irecord(j)%icoeffs(ilevel,ideg)
          !
          read(chkptIO_vect(j),rec=irecord_t) ivector(1:dimen)
          !
          f_orthog = dot_product(ivector(1:dimen),ivector(1:dimen))
          !
          if (abs(f_orthog-1.0_rk)>0.1_rk**(rk-1)) then 
             write(out,"('vector  ',2i8,18x,' is not normal: ',g18.8)") & 
                          ilevel,ideg,f_orthog
          endif 
          !
          if (job%verbose>=5) then 
             write(out,"('<',2i4,'| H |',2i4,'> =',g24.14)") ilevel,ideg,ilevel,ideg,f_orthog
          endif
          !
          do jlist = 1,nlist
            !
            jroot = analysis%dens_list(jlist)
            !
            if (jroot>nroots) cycle
            !
            jlevel = solut(j)%ilevel(jroot)
            jdeg = solut(j)%ideg(jroot)
            !
            irecord_t = irecord(j)%icoeffs(jlevel,jdeg)
            !
            read(chkptIO_vect(j),rec=irecord_t) jvector(1:dimen)
            !
            f_orthog = dot_product(jvector(1:dimen),jvector(1:dimen))
            !
            if (abs(f_orthog-1.0_rk)>0.1_rk**(rk-1)) then 
               write(out,"('vector  ',2i8,18x,' is not normal: ',g18.8)") & 
                            jlevel,jdeg,f_orthog
            endif 
            !
            do ielem = 1,dimen
              !
              if (abs(ivector(ielem))<small_) cycle
              !
              irow = icontr2icase(j)%iimat(ielem,1)
              ideg = icontr2icase(j)%iimat(ielem,2)
              !
              cnu_i(:) = contractive_space(j)%iimat(:,irow)
              !
              deg_i(:) = Index_deg(j)%iiimat(irow,:,ideg)
              !
              k_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),1)
              tau_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),2)
              !
              do jelem = 1,dimen
                !
                if (abs(jvector(jelem))<small_) cycle
                !
                jrow = icontr2icase(j)%iimat(jelem,1)
                jdeg = icontr2icase(j)%iimat(jelem,2)
                !
                cnu_j(:) = contractive_space(j)%iimat(:,jrow)
                !
                deg_j(:) = Index_deg(j)%iiimat(jrow,:,jdeg)
                !
                k_j = rot_index(j)%iiimat(cnu_j(0),deg_j(0),1)
                tau_j = rot_index(j)%iiimat(cnu_j(0),deg_j(0),2)
                !
                Jk = 1+k_i+(j*(j+1) )/2
                dk = k_i - k_j
                !
                if (abs(dk)<=1.and.all(cnu_i(1:PT%Nclasses)==cnu_j(1:PT%Nclasses)).and.&
                                   all(deg_i(1:PT%Nclasses)==deg_j(1:PT%Nclasses))) then 
                  !
                  do i1=1,3
                    !
                    if ( (tau_i==tau_j.and.i1==2).or.(tau_i/=tau_j.and.i1/=2) ) then
                      !
                      f_t = contr(0)%rot(i1)%coeff3d(Jk,dk,tau_i)
                      !
                      jrot_mat(i1,ilist,jlist) = jrot_mat(i1,ilist,jlist) &
                                               + ivector(ielem)*jvector(jelem)*contr(0)%rot(i1)%coeff3d(Jk,dk,tau_i)
                      !
                    endif
                    !
                  enddo
                  !
                endif 
                !
              enddo
              !
            enddo
            !
          enddo
          !
        enddo
        !
          do ilist = 1,nlist
            do jlist = 1,nlist
              !
              write(out,"(3f20.14,3i8)") jrot_mat(:,ilist,jlist),ilist,jlist
              !
            enddo
          enddo
        !
        deallocate(ivector,jvector,jrot_mat)
        !
        call ArrayStop('density:ivector,jrot-mat')
        !
        if (job%verbose>=2) write (out,"(/'...Done!'/)")
        !
     endif 
     !
     ! Hamiltonian
     !
     if (analysis%check_Hamiltonian) then 
       !
       if (job%verbose>=2) write (out,"('Construct the Hamiltonia matrix in the contracted basis set representaion...')")
       !
       ! The Hamiltonian test starts here:
       !
       !
       if (job%verbose>=2) write (out,"(/'j = ',i8)") j
       if (job%verbose>=2) write (out,"('Number of the eugen-solutions (incl. degeneracy) = ',i8)") solut(j)%nroots
       !
       ! Define the correlation between the J=0 contracted basis functions
       ! (used to computed the matrix elements of Hamiltonian)
       ! and the vibrational part of the J basis functions. 
       ! IMPORTANT!
       !
       call find_correlation(j)
       !
       dimen_p = Maxcontracts(j)
       !
       nroots = solut(j)%nroots
       !
       dimen_s = nroots
       !
       !allocate (ivector(dimen_p),jvector(dimen_p),stat=alloc)
       !call ArrayStart('eigenf_orthog:ivector',alloc,2*size(ivector),kind(ivector))
       !
       ! primitive Hamiltonian matrix
       !
       allocate(Hmat_p(dimen_p,dimen_p),stat=alloc)
       call ArrayStart('Hmat:test',alloc,size(Hmat_p),kind(Hmat_p))
       !
       ! Hamiltonian matrix in the symmetrized eigenstate representation
       !
       allocate(Hmat_s(dimen_s,dimen_s),stat=alloc)
       call ArrayStart('Hmat:test',alloc,size(Hmat_s),kind(Hmat_s))
       !
       !irow = PT%icontr2icase(icoeff,1)
       !ib   = PT%icontr2icase(icoeff,2)
       !
       do ielem = 1,Maxcontracts(j)
         !
         irow = icontr2icase(j)%iimat(ielem,1)
         ideg = icontr2icase(j)%iimat(ielem,2)
         !
         cnu_i(:) = contractive_space(j)%iimat(:,irow)
         !
         deg_i(:) = Index_deg(j)%iiimat(irow,:,ideg)
         !
         !isize = Index_deg_size(j)%imat(irow)
         !
         do jelem = 1,Maxcontracts(j)
           !
           jrow = icontr2icase(j)%iimat(jelem,1)
           jdeg = icontr2icase(j)%iimat(jelem,2)
           !
           cnu_j(:) = contractive_space(j)%iimat(:,jrow)
           deg_j(:) = Index_deg(j)%iiimat(jrow,:,jdeg)
           !
           !jsize = Index_deg_size(j)%imat(jrow)
           !
           ! Determine the address of matrix elements in the J=0 representaion
           !
           icontr = icase2icontr(j)%iimat(irow,ideg)
           jcontr = icase2icontr(j)%iimat(jrow,jdeg)
           k_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),1)
           k_j = rot_index(j)%iiimat(cnu_j(0),deg_j(0),1)
           tau_i = rot_index(j)%iiimat(cnu_i(0),deg_i(0),2)
           tau_j = rot_index(j)%iiimat(cnu_j(0),deg_j(0),2)
           !
           ! Matrix elements 
           !
           !mat_elem = 0
           !
           if (FLrotation.and.j/=0) then
              hmat_p(ielem,jelem) = PTmatrixelements_contr(icontr,jcontr,j,k_i,k_j,tau_i,tau_j)
           else 
              ! J-free calculations
              hmat_p(ielem,jelem) = PTmatrixelements_contr(icontr,jcontr)
              !
           endif 
           !
         enddo
         !
       enddo
       !
       if (job%verbose>=2) write (out,"('... and transform to the representaion of the eigenstates of the Hamiltonia...')")
       !
       ! Now we unitary transform the Ham_p matrix into the representaion  of its eigenfunctions
       ! in order to get (if succesful) a diagonal matrix. 
       !
       nroots = solut(j)%nroots
       !
       allocate (ivector(dimen_p),jvector(dimen_p),stat=alloc)
       call ArrayStart('eigenf_orthog:ivector',alloc,2*size(ivector),kind(ivector))
       !
       do iroot = 1,nroots
         !
         !if (job%verbose>=2) write (out,"('j = ',i8)") j
         !
         ilevel = solut(j)%ilevel(iroot)
         ideg = solut(j)%ideg(iroot)
         !
         irecord_t = irecord(j)%icoeffs(ilevel,ideg)
         !
         read(chkptIO_vect(j),rec=irecord_t) ivector(1:dimen_p)
         !
         do jroot = 1,iroot
           !
           jlevel = solut(j)%ilevel(jroot)
           jdeg = solut(j)%ideg(jroot)
           !
           irecord_t = irecord(j)%icoeffs(jlevel,jdeg)
           !
           read(chkptIO_vect(j),rec=irecord_t) jvector(1:dimen_p)
           !
           !
           jvector(:) = matmul(hmat_p(:,:),jvector(:))  
           !
           hmat_s(iroot,jroot) = dot_product(ivector(:),jvector(:))
           !
           if (iroot/=jroot.and.abs(hmat_s(iroot,jroot))>0.1_rk**(rk-3)) then 
              write(out,"('Hmat_s matrix  is not diagonal for <',i8,'|H|',i8,'> : ',g18.8)") & 
                           iroot,jroot,hmat_s(iroot,jroot)
           endif 
           !
           if (job%verbose>=4) then 
              write(out,"(' <',i4,'|H|',i4,'>  = ',g18.8)")  iroot,jroot,hmat_s(iroot,jroot)
           endif 
           !
           if (iroot==jroot) then 
              !
              ilarge_coef_t = solut(j)%eigen(ilevel)%ilarge_coeff

              !f_t = maxval(ivector(:)**2,dim=1)-small_
              !ilarge_coef_t = maxloc(ivector(:)**2,dim=1,mask=ivector(:)**2.ge.f_t)

              !
              !ilarge_coef_t = maxloc()
              !
              ilevel_t   = icontr2icase(j)%iimat(ilarge_coef_t,1)
              ideg_t = icontr2icase(j)%iimat(ilarge_coef_t,2)
              !
              cnu_i(:) = contractive_space(j)%iimat(:,ilevel_t)
              deg_i(:) = Index_deg(j)%iiimat(ilevel_t,:,ideg_t)
              !
              k0 = rot_index(j)%iiimat(cnu_i(0),deg_i(0),1)
              tau0 = rot_index(j)%iiimat(cnu_i(0),deg_i(0),2)
              !
              ! Define the symmetries of each contracted class
              do iclasses = 1,PT%Nclasses
                !
                cgamma(iclasses) = contr(iclasses)%eigen(cnu_i(iclasses))%gamma
                !
              enddo 
              !
              ! and the rotation is a special case, which is not defined in the
              ! (J=0) object contr(iclasses)%eigen 
              !
              call MLrotsymmetry_func(j,k0,tau0,isym_t,ideg_t)
              
              cgamma(0) = sym%label(isym_t)
              !
              write(out,'(2x,a4,i7,2f14.6,3x,"(",a3,";",3i3,")",1x,"("'//fmt%Aclasses//',";",'//fmt%Nmodes0//',")")') & 
                    (solut(j)%eigen(ilevel)%gamma),iroot, &
                    hmat_s(iroot,jroot),solut(j)%eigen(ilevel)%value,&
                    cgamma(0),j,k0,tau0, &
                    cgamma(1:PT%Nclasses), &
                    solut(j)%eigen(ilevel)%nu(1:PT%Nmodes)
              !
           endif 
           !
           continue
           !
         enddo
         !
       enddo
       !
       !
       deallocate(Hmat_p,Hmat_s)
       call ArrayStop('Hmat:test')
       !
       deallocate(ivector,jvector)
       call ArrayStop('eigenf_orthog:ivector')
       !
     endif 

     !
     if (job%verbose>=4) call TimerReport
     contains 

     !
     !
     ! find correspondence between contracted quantum numbers: current and for J=0 
     !
     subroutine find_correlation(j)
        !
        integer(ik),intent(in)  :: j 
        !
        integer(ik)  :: cnu(0:PT%Nclasses),ideg(0:PT%Nclasses),icase,ib,icontr,iterm
        integer(ik)  :: cnu_t(PT%Nclasses),ideg_t(PT%Nclasses)
        !
        icase2icontr(j)%iimat = 0 
        !
        do icase = 1,Maxsymcoeffs(j)
          !
          cnu(:) = contractive_space(j)%iimat(:,icase)
          !
          do ib = 1,Index_deg_size(j)%imat(icase)
            !
            ideg(:) = Index_deg(j)%iiimat(icase,:,ib)
            !
            do icontr = 1,size(PT%icontr_cnu,dim=2)
              !
              cnu_t(1:PT%Nclasses) = PT%icontr_cnu(1:PT%Nclasses,icontr)
              ideg_t(1:PT%Nclasses) = PT%icontr_ideg(1:PT%Nclasses,icontr)
              !
              if (all(PT%icontr_cnu(1:PT%Nclasses,icontr)==cnu(1:PT%Nclasses)).and.&
                  all(PT%icontr_ideg(1:PT%Nclasses,icontr)==ideg(1:PT%Nclasses))) then 
                !
                iterm = icontr
                exit
                !
              endif
              !
            enddo
            !
            icase2icontr(j)%iimat(icase,ib) = iterm
            !
          enddo
          !
        enddo
        !
     end subroutine find_correlation
     
  end subroutine PTanalysis_density



  !
  ! read-write the eigenfunctions: 
  ! all necessary information 
  !
  subroutine check_point_active_space(action)

   character(len=*), intent(in) :: action ! 'SAVE' or 'READ'
   !
   call TimerStart('check_point_active_space')
   select case (action)
     case default
       write (out,"(' check_point_active_space - action ',a,' is not valid')") trim(action)
       stop 'check_point_active_space - bogus command'
     case ('SAVE','save')
       call checkpointSave
     case ('APPEND')
       call checkpointAppend
     case ('CLOSE','close')
       call checkpointClose
     case ('READ','read')
       call checkpointRestore
   end select
   call TimerStop('check_point_active_space')

   contains 

   !
   subroutine checkpointSave
     !
     implicit none
     !
     character(len=cl)  :: unitfname,my_fmt,filename
     integer(ik)        :: chkptIO,ib,rec_len,ilevel,icoeff,irotsize,idegsize,j0,k0,tau0,mat_size,Nrepresen,&
                           igamma,ielem,ideg,Ntotal(sym%Nrepresen)
     real(rk)           :: f_t
     character(len=7)  :: char_j
     !
     ! we simply open this unit
     !
     Nrepresen = sym%Nrepresen
     !
     Ntotal = PT%Max_sym_levels
     !
     do igamma  =1,Nrepresen
       !
       if (.not.job%select_gamma(igamma)) cycle
       !
       if(.not.job%ignore_vectors) then
	       write(unitfname,"('Eigenvectors for ',i2)") igamma
	       call IOStart(trim(unitfname),chkptIO)
	       inquire(iolength=rec_len) f_t
	       !
	       if (job%IOvector_symm) then 
		     rec_len = rec_len*max(Ntotal(igamma),1)
	       else
		     rec_len = rec_len*PT%Maxcontracts
	       endif 
	       !
	       write(char_j,"(i2)") igamma
	       !
	       filename = trim(job%eigenfile%vectors)//'_'//trim(adjustl(char_j))//'.chk'
	       !
	
		open(chkptIO,access='direct',recl=rec_len,action='write',status='replace',file=filename) 
       endif
       !
       !if (.not.job%select_gamma(igamma)) cycle
       !
       write(unitfname,"('Quantum numbers of solution gamma = ',i2)") igamma
       call IOStart(trim(unitfname),chkptIO)
       !
       write(char_j,"(i2)") igamma
       !
       filename = trim(job%eigenfile%dscr)//'_'//trim(adjustl(char_j))//'.chk'
       !
       open(chkptIO,action='write',position='rewind',status='replace',file=filename) 
       !        
       ! In this module we store the eigensolution, if required. 
       ! So we start here and store the fingeprints, which will let us 
       ! make sure that we do not mix up different input files with wrong eigenfunctions. 
       ! We will also store the information on the primitive basis set - quantum numbers, 
       ! positions of basis functions in the primitive active space array, and so on. 
       !
       ! fingerprint part
       !
       call FLfingerprint('write',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
       !
       write(chkptIO,"('Start Quantum numbers and energies')") 
       !
       ! Introduce here the contracted threshols
       !
       write(chkptIO,"(i8,' <== Contracted polyad number')")  job%Npolyads_contr
       write(chkptIO,"('Class #',i8)") 1
       !
       if (job%IOvector_symm) then 
         mat_size = Ntotal(igamma)
         ib = Ntotal(igamma)
       else
         mat_size = PT%Maxprimitive
         ib = sum(PT%Max_sym_levels(:)*sym%degen(:))
       endif 
       !
       write(chkptIO,"(2i14,'  <-  number of roots and dimension of basis ')") ib,mat_size
       !
     enddo
     !
     !
     ! Now we save the active space (quantum numbers) for the prmitive basis set
     !
     !
     unitfname ='Description of the primitive basis set'
     call IOStart(trim(unitfname),chkptIO)
     !
     filename = trim(job%eigenfile%primitives)//'.chk'
     !
     open(chkptIO,action='write',position='rewind',status='replace',file=filename)
     !
     write(chkptIO,"('Start Primitive basis set')") 
     !
     !
     write(chkptIO,"(4i8,' <- Maxsymcoeffs,max_deg_size,Maxcontracts,Nclasses')") PT%Maxsymcoeffs,PT%max_deg_size,&
                     PT%Maxcontracts,PT%Nclasses
     !
     ilevel = 0 
     !
     do icoeff = 1,PT%Maxsymcoeffs
       !
       write(chkptIO,'(i8,'//fmt%Nclasses//')')  PT%Index_deg(icoeff)%size1,PT%contractive_space(0:PT%Nclasses,icoeff)
       !
       do ib = 1,PT%Index_deg(icoeff)%size1
          !
          ilevel = ilevel + 1
          !
          write(chkptIO,'(i8,'//fmt%Nclasses//')')  ilevel,PT%Index_deg(icoeff)%icoeffs(0:PT%Nclasses,ib)
          !
       enddo
       !
     enddo
     !
     ! Store the J,k,tau distribution 
     !
     irotsize = size(PT%rot_index,dim=1)
     idegsize = size(PT%rot_index,dim=2)
     !
     write(chkptIO,"(2i8,' <- rot-size,rot-max-degen')") irotsize,idegsize
     !
     ilevel = 0 
     !
     do icoeff = 1,irotsize
       !
       do ib = 1,contr(0)%eigen(icoeff)%degeneracy
          !
          ilevel = ilevel + 1
          !
          j0 = PT%rot_index(icoeff,ib)%j
          k0 = PT%rot_index(icoeff,ib)%k
          tau0 = PT%rot_index(icoeff,ib)%tau
          !
          write(chkptIO,"(5i8)")  icoeff,ib,j0,k0,tau0
          !
       enddo
       !
     enddo
     !
     write(chkptIO,"('End Primitive basis set')") 
     !
     if (job%IOvector_symm) then
       !
       write(chkptIO,"('Start irreducible transformation')") 
       !
       mat_size = size(PT%irr(1)%repres,dim=3)
       !
       !write(my_fmt,"(i1,'i8')") Nrepresen
       !
       write(my_fmt,'(I0,a4)') Nrepresen,'(i8)'
       !
       write(chkptIO,"(i8,' <- total maximal degeneracy')") mat_size
       write(chkptIO,'('//trim(my_fmt)//',a)') Ntotal(1:Nrepresen),' <- number of vectors in each irrep'
       !
       write(my_fmt,'(I0,a11)') mat_size,'(2x,e23.14)'
       !
       do igamma = 1,Nrepresen
         !
         do icoeff = 1,PT%Maxsymcoeffs
            !
            write(chkptIO,"(i8)") PT%irr(igamma)%N(icoeff)
            !
         enddo
         !
         do icoeff = 1,PT%Max_sym_levels(igamma)
            !
            do ideg = 1,sym%degen(igamma)
               !
               write(chkptIO,'('//trim(my_fmt)//')') PT%irr(igamma)%repres(icoeff,ideg,1:mat_size)
               !
            enddo
            !
         enddo
         !
       enddo
       !
       !
       write(chkptIO,"('End irreducible transformation')") 
       !
       close(chkptIO,status='keep')
       !
     endif
     !
     !
   end subroutine checkpointSave
   !
   !
   subroutine checkpointAppend
     !
     character(len=cl)  :: unitfname
     integer(ik)        :: chkptIO,ib,rec_len,ilevel,icoeff,irotsize,idegsize,j0,k0,tau0,nroots,irec,i,igamma
     real(rk)           :: f_t
     character(len=34)  :: buf34
     character(len=500)  :: buf500
     character(len=7)  :: char_j
     !
     write(out,"(' APPEND IS TEMPORALLY SWITCHED OFF')")
     stop 'APPEND IS TEMPORALLY SWITCHED OFF'
     !
     ! we simply open this unit
     !
     !if (trove%FBR) then
        !
        do igamma  =1,sym%Nrepresen
          !
          write(unitfname,"('Eigenvectors for ',i2)") igamma
          call IOStart(trim(unitfname),chkptIO)
          inquire(iolength=rec_len) f_t
          !
          if (job%IOvector_symm) then 
            rec_len = rec_len*PT%Max_sym_levels(igamma)
          else
            rec_len = rec_len*PT%Maxcontracts
          endif 
          !
          write(char_j,"(i2)") igamma
          !
          job%eigenfile%vectors    = trim(job%eigenfile%vectors)//'_'//trim(adjustl(char_j))//'.chk'
          !
          open(chkptIO,access='direct',recl=rec_len,action='write',status='old',file=job%eigenfile%vectors) 
          !
        enddo
        !
     !endif
     !
     !call FLfingerprint('write',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
     !
     unitfname ='Quantum numbers of the eigensolution'
     call IOStart(trim(unitfname),chkptIO)
     open(chkptIO,action='readwrite',position='rewind',status='old',file=job%eigenfile%dscr) 
     !        
     ! fingerprint part
     !
     call FLfingerprint('read',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
     !
     read(chkptIO,"(a34)") buf34
     if (buf34/='Start Quantum numbers and energies') then
       write (out,"(' Checkpoint file ',a,' has bogus header: ',a)") job%eigenfile%dscr, buf34
       stop 'check_point_active_space - bogus file format'
     end if
     !
     do while (buf500(1:5) /= 'Class')
        read(chkptIO, '(a)') buf500
     end do
     !
     read(chkptIO, '(i8)') nroots
     !
     nroots = 0
     !
     do
        !
        read(chkptIO, '(a)') buf500
        if (buf500(1:3) == 'End') exit
        !
        read(buf500, *) irec, igamma, ilevel
        !
        nroots = nroots + 1
        !
     end do
     !
     PTNlevels = ilevel 
     PTNroots = irec
     !
     rewind(chkptIO)
     !
     buf500 = ''
     !
     do while (buf500(1:5) /= 'Class')
        read(chkptIO, '(a)') buf500
     end do
     !
     do i = 0,nroots
       read(chkptIO, '(a)') buf500
     enddo
     !
   end subroutine checkpointAppend
   !
   subroutine checkpointClose
     !
     implicit none
     !
     !
     character(len=cl)  :: unitfname
     integer(ik)        :: chkptIO,igamma
     !
     do igamma  =1,sym%Nrepresen
       !
       if (.not.job%select_gamma(igamma)) cycle
       !
       if(.not.job%ignore_vectors) write(unitfname,"('Eigenvectors for ',i2)") igamma
       !
       if(.not.job%ignore_vectors) call IOStart(trim(unitfname),chkptIO)
       !
       if(.not.job%ignore_vectors)close(chkptIO,status='keep') 
       !
       write(unitfname,"('Quantum numbers of solution gamma = ',i2)") igamma
       call IOStart(trim(unitfname),chkptIO)
       !
       write(chkptIO,"('End Quantum numbers and energies')") 
       close(chkptIO,status='keep') 
       !
     enddo
     !
   end subroutine checkpointClose
   !
   subroutine checkpointRestore
     !
     implicit none
     !
     character(len=15) :: buf
     character(len=34) :: buf34,buf25
     character(len=cl)  :: unitfname,filename
     integer(ik)        :: chkptIO,alloc,ib_t,ib,Maxcoeffs_t,rec_len,igamma
     real(rk)           :: f_t    ! dummy object
     character(len=7)  :: char_j
     !
     !
     ! Eigenvalues and quanta section 
     !        
     ! fingerprint part
     !
     !
     !read(chkptIO,"(a32)") buf32
     !if (buf34(1:32)/='End Quantum numbers and energies') then
     !  write (out,"(' Checkpoint file ',a,' has bogus footer: ',a)") job%eigenfile%dscr, buf
     !  stop 'check_point_active_space - bogus file footer format'
     !end if


     do igamma  =1,sym%Nrepresen
       !
       write(unitfname,"('Quantum numbers of solution gamma = ',i2)") igamma
       call IOStart(trim(unitfname),chkptIO)
       !
       write(char_j,"(i2)") igamma
       !
       filename = trim(job%eigenfile%dscr)//'_'//trim(adjustl(char_j))//'.chk'
       !
       open(chkptIO,action='read',position='rewind',status='old',file=filename) 
       !
       call FLfingerprint('read',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
       !
       read(chkptIO,"(a34)") buf34
       if (buf34/='Start Quantum numbers and energies') then
         write (out,"(' Checkpoint file ',a,' has bogus header: ',a)") job%eigenfile%dscr, buf34
         stop 'check_point_active_space - bogus file format'
       end if
       !
     enddo
     !
     write(out,"('!!!!!!!!!!!!! PLEASE CAREFULLY CHECK THIS PLACE !!!!!!!!!!!!!!!!!!')")
     !
     do igamma  =1,sym%Nrepresen
       !
       write(unitfname,"('Eigenvectors for ',i2)") igamma
       call IOStart(trim(unitfname),chkptIO)
       inquire(iolength=rec_len) f_t
       !
       if (job%IOvector_symm) then 
         rec_len = rec_len*PT%Max_sym_levels(igamma)
       else
         rec_len = rec_len*PT%Maxcontracts
       endif 
       !
       write(char_j,"(i2)") igamma
       !
       job%eigenfile%vectors    = trim(job%eigenfile%vectors)//'_'//trim(adjustl(char_j))//'.chk'
       !
       open(chkptIO,access='direct',recl=rec_len,action='read',status='old',file=job%eigenfile%vectors) 
       !
     enddo


     !
     !unitfname ='Eigenvectors in the primitive basis set'
     !call IOStart(trim(unitfname),chkptIO)
     !
     !inquire(iolength=rec_len) f_t
     !
     !rec_len = rec_len*PT%Maxcoeffs
     !
     !
     !open(chkptIO,access='direct',recl=rec_len,action='read',status='old',file=job%eigenfile%vectors) 
     !
   end subroutine checkpointRestore


  end subroutine check_point_active_space



  !
  ! read-write the contracted basis sets 
  !
  subroutine PTcheck_point_dvr(action)

   character(len=*), intent(in) :: action ! 'SAVE' or 'READ'
   !
   call TimerStart('PTcheck_point_dvr')
   select case (action)
     case default
       write (out,"(' PTcheck_point_dvr - action ',a,' is not valid')") trim(action)
       stop 'PTcheck_point_dvr - bogus command'
     case ('SAVE','save')
       call checkpointSave
     case ('READ','read')
       call checkpointRestore
     case ('NONE','none')
       return
   end select
   call TimerStop('PTcheck_point_dvr')


   contains 

   !        
   ! In this module we store the dvr%abcissas, point-indexing, basis funcitons in DVR representaion, 
   ! potential and kinetic energies
   !
   subroutine checkpointSave
     !
     character(len=cl)  :: unitfname
     integer(ik)        :: chkptIO,ispecies,dvr_size,imode,npoints,bs_size,extF_rank
     !
     ! File for the DVR objects
     !
     unitfname ='Checkpoint for DVR objects'
     call IOStart(trim(unitfname),chkptIO)
     !
     open(chkptIO,action='write',form='unformatted',position='rewind',status='replace',file=job%dvr_chkfile) 
     !
     write(chkptIO) 'DVR check point'
     !
     write(chkptIO) PT%Nspecies,PT%Nmodes

     do ispecies = 1,PT%Nspecies
       !
       dvr_size = size(dvr%abcissa(ispecies)%coeff1d,dim=1)
       !
       imode = PT%mode_species(ispecies,1)
       ! 
       npoints = job%bset(imode)%npoints
       !
       bs_size = job%bset(imode)%range(2)
       !
       write(chkptIO) ispecies,dvr_size,npoints,bs_size
       !
       write(chkptIO) 'abcissa'
       !
       write(chkptIO) dvr%abcissa(ispecies)%coeff1d
       !
       write(chkptIO) 'prim_func'
       !
       write(chkptIO) dvr%prim_func(ispecies)%coeffs
       !
       write(chkptIO) dvr%prim_dfunc(ispecies)%coeffs
       !
     enddo
     !
     write(chkptIO) 'indexes'
     !
     write(chkptIO) dvr%total_size
     !
     write(chkptIO) dvr%kindex
     !
     write(chkptIO) dvr%icheck_deriv
     !
     write(chkptIO) 'poten'
     !
     write(chkptIO) dvr%poten
     !
     write(chkptIO) 'gvib'
     !
     write(chkptIO) dvr%gvib
     !
     if (trim(job%IOkinet_action)=='SAVE') then
        !
        write(chkptIO) 'grot'
        !
        write(chkptIO) dvr%grot
        !
        write(chkptIO) 'gcor'
        !
        write(chkptIO) dvr%gcor
        !
     endif
     !
     if (FLextF_coeffs) then 
        !
        write(chkptIO) 'extF'
        !
        extF_rank = FLread_extF_rank()
        !
        write(chkptIO) extF_rank
        !
        write(chkptIO) dvr%extF
        !
     endif
     !
     write(chkptIO) 'End DVR check point'
     !
     close(chkptIO,status='keep')
     !
   end subroutine checkpointSave

   !
   subroutine checkpointRestore
     !
     character(len=cl)  :: unitfname,buf
     integer(ik)        :: chkptIO,ispecies,dvr_size,imode,npoints,bs_size,extF_rank,alloc
     integer(ik)        :: Nspecies,Nmodes,ispecies_,dvr_size_,npoints_,bs_size_,extF_rank_
     character(len=cl)  :: my_fmt !format for I/O specification
     !        
     ! In this module we read the dvr%abcissas, point-indexing, basis funcitons in DVR representaion, 
     ! potential and kinetic energies
     !
     ! File for the DVR objects
     !
     unitfname ='Checkpoint for DVR objects'
     call IOStart(trim(unitfname),chkptIO)
     !
     open(chkptIO,action='read',form='unformatted',position='rewind',status='old',file=job%dvr_chkfile) 
     !
     read(chkptIO) buf(1:15)
     !
     call check_buf(buf(1:15),'DVR check point',job%dvr_chkfile)
     !
     read(chkptIO) Nspecies,Nmodes
     !
     call check_number(Nspecies,PT%Nspecies,'wrong Nspecies',job%dvr_chkfile)
     call check_number(Nmodes,PT%Nmodes,'wrong Nmodes',job%dvr_chkfile)
     !
     if (job%verbose>=4) write(out,"(/5x,'DVR-abcissas:')")
     !
     do ispecies = 1,PT%Nspecies
       !
       imode = PT%mode_species(ispecies,1)
       !
       dvr_size = max(job%bset(imode)%dvrpoints,job%bset(imode)%range(2)+1)
       bs_size = job%bset(imode)%range(2)
       !
       read(chkptIO) ispecies_,dvr_size_,npoints,bs_size_
       !
       call check_number(ispecies_,ispecies,'wrong ispecies',job%dvr_chkfile)
       call check_number(dvr_size_,dvr_size,'wrong dvr_size',job%dvr_chkfile)
       call check_number(npoints,job%bset(imode)%npoints,'wrong npoints',job%dvr_chkfile)
       call check_number(bs_size_,bs_size,'wrong bs_size',job%dvr_chkfile)
       !
       allocate (dvr%abcissa(ispecies)%coeff1d(dvr_size),stat=alloc)
       call ArrayStart('dvr-abcisssa-weight',alloc,size(dvr%abcissa(ispecies)%coeff1d),kind(dvr%abcissa(ispecies)%coeff1d))
       !
       allocate (dvr%prim_func(ispecies)%coeffs(0:bs_size,dvr_size),stat=alloc)
       allocate (dvr%prim_dfunc(ispecies)%coeffs(0:bs_size,dvr_size),stat=alloc)
       call ArrayStart('dvr%prim_func(ispecies)%coeffs',alloc,size(dvr%prim_func(ispecies)%coeffs),&
                        kind(dvr%prim_func(ispecies)%coeffs))
       call ArrayStart('dvr%prim_func(ispecies)%coeffs',alloc,size(dvr%prim_dfunc(ispecies)%coeffs),&
                        kind(dvr%prim_dfunc(ispecies)%coeffs))
       !
       read(chkptIO) buf(1:7)
       !
       call check_buf(buf(1:7),'abcissa',job%dvr_chkfile)
       !
       read(chkptIO) dvr%abcissa(ispecies)%coeff1d
       !
       if (job%verbose>=4) then 
         write(my_fmt,'(a,i0,a)') "(5x,i4,",dvr_size,"f18.8)"
         write(out,my_fmt) ispecies,dvr%abcissa(ispecies)%coeff1d(1:dvr_size)
       endif 
       !
       read(chkptIO) buf(1:9)
       !
       call check_buf(buf(1:9),'prim_func',job%dvr_chkfile)
       !
       read(chkptIO) dvr%prim_func(ispecies)%coeffs
       !
       read(chkptIO) dvr%prim_dfunc(ispecies)%coeffs
       !
     enddo
     !
     read(chkptIO) buf(1:7)
     !
     call check_buf(buf(1:7),'indexes',job%dvr_chkfile)
     !
     read(chkptIO) dvr%total_size
     !
     if (job%verbose>=3) write(out,"(/'     Number of DVR points = ',i8)")  dvr%total_size 
     !
     allocate (dvr%poten(dvr%total_size),dvr%gvib(PT%Nmodes,PT%Nmodes,dvr%total_size),dvr%kindex(dvr%total_size,PT%Nmodes),&
               dvr%icheck_deriv(PT%Nclasses,0:PT%Nmodes),stat=alloc)
     call ArrayStart('dvr-fields',alloc,1,kind(dvr%poten),dvr%total_size)
     call ArrayStart('dvr-fields',alloc,1,kind(dvr%gvib),dvr%total_size*PT%Nmodes*PT%Nmodes)
     call ArrayStart('dvr-fields',alloc,1,kind(dvr%kindex),dvr%total_size)
     call ArrayStart('dvr-fields',alloc,size(dvr%icheck_deriv),kind(dvr%icheck_deriv))
     !
     read(chkptIO) dvr%kindex
     !
     read(chkptIO) dvr%icheck_deriv
     !
     read(chkptIO) buf(1:5)
     !
     call check_buf(buf(1:5),'poten',job%dvr_chkfile)
     !
     read(chkptIO) dvr%poten
     !
     read(chkptIO) buf(1:4)
     !
     call check_buf(buf(1:4),'gvib',job%dvr_chkfile)
     !
     read(chkptIO) dvr%gvib
     !
     if (trim(job%IOkinet_action)=='SAVE') then
        !
        allocate (dvr%grot(3,3,dvr%total_size),dvr%gcor(PT%Nmodes,3,dvr%total_size),stat=alloc)
        !
        call ArrayStart('dvr-fields',alloc,1,kind(dvr%grot),dvr%total_size*9)
        call ArrayStart('dvr-fields',alloc,1,kind(dvr%gcor),dvr%total_size*3*PT%Nmodes)
        !
        read(chkptIO) buf(1:4)
        !
        call check_buf(buf(1:4),'grot',job%dvr_chkfile)
        !
        read(chkptIO) dvr%grot
        !
        read(chkptIO) buf(1:4)
        !
        call check_buf(buf(1:4),'gcor',job%dvr_chkfile)
        !
        read(chkptIO) dvr%gcor
        !
     endif
     !
     if (FLextF_coeffs) then 
        !
        allocate (dvr%extF(extF_rank,dvr%total_size),stat=alloc)
        call ArrayStart('dvr-fields',alloc,1,kind(dvr%extF),dvr%total_size*extF_rank)
        !
        read(chkptIO) buf(1:4)
        !
        call check_buf(buf(1:4),'extF',job%dvr_chkfile)
        !
        extF_rank = FLread_extF_rank()
        !
        read(chkptIO) extF_rank_
        !
        call check_number(extF_rank_,extF_rank,'wrong extF_rank',job%dvr_chkfile)
        !
        read(chkptIO) dvr%extF
        !
     endif
     !
     read(chkptIO) buf(1:19)
     !
     call check_buf(buf(1:19),'End DVR check point',job%dvr_chkfile)
     !
     close(chkptIO,status='keep')
     !
   end subroutine checkpointRestore

   subroutine check_buf(buf,label,file)

     character(len=*) :: buf,label,file

      if (buf/=label) then
        write (out,"(' DVR-chk-file: ',a,' has bogus header: ',a)") file,buf,label
        stop 'DVR-chk-file - bogus file format'
      end if

   end subroutine check_buf

   subroutine check_number(Nbuf,N,message,file)

     integer(ik) :: Nbuf,N
     character(len=*) :: message,file

      if (Nbuf/=N) then
        write (out,"(' DVR-chk-file: ',a,1x,a,1x,2i0)") file,message,Nbuf,N
        stop 'DVR-chk-file: wrong integer number'
      end if

   end subroutine check_number
   !
  end subroutine PTcheck_point_dvr
  
  

  !
  ! read-write the contracted basis sets 
  !
  subroutine PTcheck_point_contracted_space(action)
     !
     implicit none
     !
   character(len=*), intent(in) :: action ! 'SAVE' or 'READ'
   !
   call TimerStart('PTcheck_point_contracted_space')
   select case (action)
     case default
       write (out,"(' PTcheck_point_contracted_space - action ',a,' is not valid')") trim(action)
       stop 'PTcheck_point_contracted_space - bogus command'
     case ('SAVE','save')
       call checkpointSave
     case ('CLOSE','close')
       call checkpointClose
     case ('READ','read')
       call checkpointRestore
   end select
   call TimerStop('PTcheck_point_contracted_space')

   contains 

   !
   subroutine checkpointSave
     !
     implicit none
     !
     character(len=cl)  :: unitfname
     integer(ik)        :: chkptIO,chkptIO_vect,ib,rec_len,maxsize,iclasses,irecord,&
                           level_degen,ideg,dimen,iroots,Nmodes
     real(rk)           :: f_t
     character(len=cl) :: my_fmt !format for I/O specification
     !
     ! File for the conctracted coefficients
     !
     unitfname ='Contracted eigenvectors in terms of prim. basis set'
     call IOStart(trim(unitfname),chkptIO_vect)
     inquire(iolength=rec_len) f_t
     !
     nmodes = PT%Nmodes
     !
     maxsize = 0
     !
     do iclasses = 1,PT%Nclasses
       maxsize = max(contr(iclasses)%dimen,maxsize)
     enddo 
     !
     rec_len = rec_len*maxsize
     !
     open(chkptIO_vect,access='direct',recl=rec_len,action='write',status='replace',file=job%contrfile%vectors)
     !
     ! File for the quantum numbers of the contracted solution
     !
     unitfname = 'Quantum numbers of the contracted eigensolution'
     call IOStart(trim(unitfname),chkptIO)
     open(chkptIO,action='write',position='rewind',status='replace',file=job%contrfile%dscr) 
     !        
     ! In this module we store the eigensolution, if required. 
     ! So we start here and store the fingeprints, which will let us 
     ! make sure that we do not mix up different input files with wrong eigenfunctions. 
     ! We will also store the information on the primitive basis set - quantum numbers, 
     ! positions of basis functions in the primitive active space array, and so on. 
     !
     ! fingerprint part
     !
     call FLfingerprint('write',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
     !
     write(chkptIO,"('Start Quantum numbers and energies (record,symmetry,degeneracy,energy,quanta)')") 
     !
     !
     ! Introduce here the contracted threshols
     !
     write(chkptIO,"(i8,' <== Contracted polyad number')")  job%Npolyads_contr
     !
     irecord = 0 
     !
     write(my_fmt,'(a,i0,a,i0,a)') "(i7,i4,i8,i4,f20.12,",nmodes+1,"i4,2x,",Nmodes+1,"i4,2x,f17.8)"
     !
     do iclasses = 1,PT%Nclasses
       !
       write(chkptIO,"('Class #',i8)") iclasses
       write(chkptIO,"(2i14,'  <-  number of roots and dimension of basis ')") contr(iclasses)%nroots,contr(iclasses)%dimen
       !
       iroots = 0 
       !
       do ib = 1,contr(iclasses)%nlevels
         !
         level_degen = contr(iclasses)%eigen(ib)%degeneracy
         dimen = contr(iclasses)%dimen
         !
         iroots = iroots + level_degen
         !
         do ideg = 1,level_degen
           !
           irecord = irecord + 1
           write(chkptIO_vect,rec=irecord) contr(iclasses)%eigen(ib)%vect(1:dimen,ideg)
           !write(chkptIO,'(i7,i4,i8,i4,f20.12,<nmodes+1>i4,2x,<nmodes+1>i4,2x,f17.8)')  irecord,&
           write(chkptIO,my_fmt)  irecord,&
                             contr(iclasses)%eigen(ib)%isym,&
                             ib,ideg,&
                             contr(iclasses)%eigen(ib)%value,&
                             contr(iclasses)%eigen(ib)%nu(0:PT%Nmodes),&
                             contr(iclasses)%eigen(ib)%normal(0:PT%Nmodes),contr(iclasses)%eigen(ib)%largest_coeff
           !
         enddo
         !
       enddo 
       !
       if (iroots/=contr(iclasses)%nroots) then
         write (out,"('/PTcheck_point_contracted_space-save:')")
         write (out,"('N of roots do not agree to N of degen. levels:',2i8,' iclass=',i8)") contr(iclasses)%nroots,&
                      iroots,iclasses
         stop 'PTcheck_point_contracted_space - not consistent nroots and levels/degeneracy'
       end if

       !
     enddo 
     !
     write(chkptIO,"('End Quantum numbers and energies')") 
     !
     close(chkptIO     ,status='keep')
     close(chkptIO_vect,status='keep')
     !
     ! Now we save the active space (quantum numbers) of the prmitive basis set
     !
     ! File for the quantum numbers of the primitive basis set 
     !
     unitfname ='Description of the primitive basis set for each class'
     call IOStart(trim(unitfname),chkptIO)
     open(chkptIO,action='write',position='rewind',status='replace',file=job%contrfile%primitives) 
     !
     write(chkptIO,"('Start Primitive basis set')") 
     !
     do iclasses = 1,PT%Nclasses
       !
       write(chkptIO,"(i8,' <- dimen for class # ',i6)") contr(iclasses)%dimen,iclasses
       !
       do ib = 1,contr(iclasses)%dimen
        !
        write(chkptIO,'('//fmt%Nmodes//')')  contr(iclasses)%prim_bs%icoeffs(:,ib)
        !
       enddo 
       !
     enddo 
     !
     write(chkptIO,"('End Primitive basis set')")
     !
     close(chkptIO,status='keep')
     !
     ! Additional objects for the DVR representaion
     !
     if (trove%dvr) then
       !
       unitfname ='DVR-objects in the contracted representaion'
       call IOStart(trim(unitfname),chkptIO)
       open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=job%contrfile%dvr)
       !
       write(chkptIO) 'Start DVR contr'
       !
       write(chkptIO) PT%Nclasses,PT%Nmodes
       !
       do iclasses = 1,PT%Nclasses
         !
         write(chkptIO) iclasses
         !
         write(chkptIO) contr(iclasses)%Ndvrpoints
         !
         write(chkptIO) contr(iclasses)%dvr_kindex
         !
       enddo
       !
       write(chkptIO) 'End DVR contr'
       !
       close(chkptIO,status='keep')
       !
     endif 
     !
   end subroutine checkpointSave
   !
   !
   subroutine checkpointClose
     !
     implicit none
     !
     character(len=cl)  :: unitfname
     integer(ik)        :: chkptIO
     !
     ! we simply close this one
     !
     unitfname ='Contracted eigenvectors in terms of prim. basis set'
     call IOStart(trim(unitfname),chkptIO)
     !
     close(chkptIO,status='keep') 
     !
     unitfname ='Quantum numbers of the contracted eigensolution'
     call IOStart(trim(unitfname),chkptIO)
     !
     close(chkptIO,status='keep') 
     !
     unitfname ='Description of the primitive basis set for each class'
     call IOStart(trim(unitfname),chkptIO)
     !
     close(chkptIO,status='keep') 
     !
   end subroutine checkpointClose
   !
   subroutine checkpointRestore
     !
     implicit none
     !
     character(len=20) :: buf
     character(len=34) :: buf34
     character(len=cl) :: unitfname,buf_t
     integer(ik)       :: chkptIO,alloc,ib,Maxcoeffs_t,rec_len,chkptIO_vect,Npolyad_t,&
                          iclasses,irecord_t,level_degen,ideg,maxsize,nlevels,nroots,dimen,&
                          nu_t(0:PT%Nmodes),gamma,iroot,iroot_t,ilevel_t,Ncontracts,ilevel_,iroot_,&
                          Nclasses,Nmodes,total_size,iclass_,Ndvrpoints
     real(rk)          :: f_t,value,zpe_contr,spread,largest_coeff
     type(PTlevelT),pointer ::  cf
     type(PTintcoeffsT) :: irecord(PT%Nclasses)
     integer(ik)        :: ipol,isym,degeneracy,nu(0:PT%Nmodes),ilevel,iline,normal(0:PT%Nmodes)
     logical            :: normalmode_input = .false., largest_coeff_input = .false.
     !
     ! File for the quantum numbers of the contracted solution
     !
     unitfname = 'Quantum numbers of the contracted eigensolution'
     call IOStart(trim(unitfname),chkptIO)
     open(chkptIO,action='read',position='rewind',status='old',file=job%contrfile%dscr) 
     !
     ! fingerprint part
     !
     call FLfingerprint('read',chkptIO,PT%Norder,PT%Npolyads,(/job%enercutoff%primt,job%enercutoff%contr/))
     !
     read(chkptIO,"(a34)") buf34
     if (buf34/='Start Quantum numbers and energies') then
       write (out,"(' Quantum numbers checkpoint file ',a,' has bogus header: ',a)") job%contrfile%primitives,buf34
       stop 'PTcheck_point_contracted_space - bogus file format'
     end if
     !
     read(chkptIO,"(i8,a4)") Npolyad_t,buf34(1:4)
     if (Npolyad_t<job%Npolyads_contr) then
       write (out,"(' contracted polyad threshold ',i8,' is larger than ',i8,' in checkpoint file ',a,' is for  ',a)") & 
             job%Npolyads_contr,Npolyad_t,job%contrfile%primitives
       stop 'PTcheck_point_contracted_space - not consistent contr. polyad number'
     end if
     !
     if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and.Npolyad_t/=job%Npolyads_contr) then
       write (out,"(' saving contr. mat.elements with different polyad numbers will be ambigous')")  
       write (out,"(' polyad = ',i8,';  polyad_contract = ',i8)") Npolyad_t,job%Npolyads_contr
       stop 'PTcheck_point_contracted_space - not consistent contr. polyad number'
     end if
     !
     if (trim(buf34(1:3))==' <=') normalmode_input = .true.
     if (trim(buf34(1:4))==' <==') largest_coeff_input = .true.
     !
     iline = 14+PT%Nmodes
     irecord_t = 0 
     !
     do iclasses = 1,PT%Nclasses
       !
       read(chkptIO,"(20a)") buf
       if (buf(1:3)/='Cla') then
         write (out,"('Contracted checkpoint file ',a,' has bogus line Class: ',a)") buf
         stop 'PTcheck_point_contracted_space - bogus line Class'
       end if
       !
       read(chkptIO,*) nroots,contr(iclasses)%dimen
       dimen = contr(iclasses)%dimen
       !
       ! count the actual number of roots
       !
       iroot = 0
       ilevel = 0 
       buf_t = ""
       do while (iroot<=nroots.and.buf_t(1:3)/='End'.and.buf_t(1:3)/='Cla')
         read(chkptIO,"(80a)") buf_t
         if (buf_t(1:3)=='End'.or.buf_t(1:3)=='Cla') cycle
         read(buf_t,*) irecord_t,iroot_t,ilevel_t,ideg,value
         !
         !if (value<=job%enercutoff%contr.or..not.job%vib_contract) then 
           !
           iroot = iroot + 1
           if (ideg==1) ilevel = ilevel + 1
           !
         !endif
         !
       enddo 
       nroots = iroot
       nlevels = ilevel
       !
       ! return to the original record 
       !
       rewind(chkptIO)
       do ib = 1,iline
          read(chkptIO,"(20a)") buf
       enddo 
       !
       iline = iline + nroots+2
       !
       !if (allocated(contr(iclasses)%eigen)) then
       !  !
       !  write(out,"(//'PTcheck_point_contracted_space: illegal allocation, ')")
       !  write(out,"('contr(iclasses)%eigen has been created before')")
       !  !stop 'PTcheck_point_contracted_space: illegal allocation'
       !  !
       !endif
       !
       allocate (contr(iclasses)%eigen(nlevels),&
                 contr(iclasses)%iroot(nlevels,sym%maxdegen),stat=alloc)
       call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%iroot),kind(contr(iclasses)%iroot))
       !
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate eigen-field')") alloc
          stop 'PTcheck_point_contracted_space, eigen -  out of memory'
       end if
       !
       allocate (contr(iclasses)%prim_bs%icoeffs(0:PT%Nmodes,dimen),&
                 irecord(iclasses)%icoeffs(nlevels,sym%maxdegen),stat=alloc)
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate solution-field')") alloc
          stop 'PTcheck_point_contracted_space, solution -  out of memory'
       end if
       !
       allocate (contr(iclasses)%ilevel_chk(nroots),stat=alloc)
       call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%ilevel_chk),& 
                         kind(contr(iclasses)%ilevel_chk))

       allocate (contr(iclasses)%ilevel(nroots),contr(iclasses)%ideg(nroots),stat=alloc)
       call ArrayStart('contr%eigen%vect',alloc,2*nroots,kind(contr(iclasses)%ilevel))
       !
       irecord(iclasses)%icoeffs = 0 
       !
       contr(iclasses)%max_degen = 1
       !
       ilevel_ = 0
       iroot_ = 0 
       !
       do iroot = 1,nroots
         !
         largest_coeff = 1.0_rk
         !
         if (normalmode_input.and.largest_coeff_input) then
           !
           read(chkptIO,*) irecord_t,isym,ilevel,ideg,value,nu(0:PT%Nmodes),normal(0:PT%Nmodes),largest_coeff
           !
         elseif (normalmode_input) then 
           !
           read(chkptIO,*) irecord_t,isym,ilevel,ideg,value,nu(0:PT%Nmodes),normal(0:PT%Nmodes)
           !
         elseif (largest_coeff_input) then 
           !
           read(chkptIO,*) irecord_t,isym,ilevel,ideg,value,nu(0:PT%Nmodes),largest_coeff
           !
         else 
           !
           read(chkptIO,*) irecord_t,isym,ilevel,ideg,value,nu(0:PT%Nmodes)
           !
           normal = nu
           !
         endif 
         !
         !if (value<=job%enercutoff%contr.or..not.job%vib_contract) then 
           !
           iroot_ = iroot_ + 1
           if (ideg==1) ilevel_ = ilevel_ + 1
           !
           if (iroot_/=iroot.or.ilevel_/=ilevel) then
              write (out,"(' Error in cutting of the contracted basis set, iroots dont agree :',4i0)") iroot_,iroot,ilevel_,&
                           ilevel
              stop 'PTcheck_point_contr: Error in cutting of the contr.bset'
           end if
           !
           if (ideg==1) then    
             !
             allocate (contr(iclasses)%eigen(ilevel)%nu(0:PT%Nmodes),stat=alloc)
             allocate (contr(iclasses)%eigen(ilevel)%normal(0:PT%Nmodes),stat=alloc)
             call ArrayStart('contr%eigen%vect',alloc,2*size(contr(iclasses)%eigen(ilevel)%nu),& 
                              kind(contr(iclasses)%eigen(ilevel)%nu))
             !
           endif 
           !
           irecord(iclasses)%icoeffs(ilevel,ideg) = irecord_t
           contr(iclasses)%eigen(ilevel)%isym = isym 
           contr(iclasses)%eigen(ilevel)%degeneracy = sym%degen(isym)
           contr(iclasses)%eigen(ilevel)%value = value
           contr(iclasses)%eigen(ilevel)%largest_coeff = largest_coeff
           contr(iclasses)%eigen(ilevel)%lquant = sym%lquant(isym)
           !
           contr(iclasses)%eigen(ilevel)%nu(0:PT%Nmodes) = nu(0:PT%Nmodes)
           contr(iclasses)%eigen(ilevel)%normal(0:PT%Nmodes) = normal(0:PT%Nmodes)
           !
           if (trove%triatom_sing_resolve.and.job%bset(0)%range(2)/=0) then
               contr(iclasses)%eigen(ilevel)%lquant = normal(0)
           endif
           !
           gamma = isym
           !
           contr(iclasses)%eigen(ilevel)%gamma = trim(sym%label(gamma))
           !
           contr(iclasses)%max_degen = max(contr(iclasses)%max_degen,sym%degen(isym))
           !
           contr(iclasses)%ilevel(iroot) = ilevel 
           contr(iclasses)%ideg(iroot) = ideg 
           contr(iclasses)%iroot(ilevel,ideg) = iroot
             !
         !endif 
         !
       enddo 
       !
       zpe_contr = contr(iclasses)%eigen(1)%value
       !
       contr(iclasses)%ilevel_chk = 0 
       !
       iroot_t  = 0 
       ilevel_t = 0
       !
       do iroot = 1,nroots
        !
        ilevel = contr(iclasses)%ilevel(iroot)
        !
        isym  = contr(iclasses)%eigen(ilevel)%isym
        ideg = contr(iclasses)%ideg(iroot)
        degeneracy = contr(iclasses)%eigen(ilevel)%degeneracy
        value = contr(iclasses)%eigen(ilevel)%value
        nu(0:PT%Nmodes) = contr(iclasses)%eigen(ilevel)%nu(0:PT%Nmodes)
        normal(0:PT%Nmodes) = contr(iclasses)%eigen(ilevel)%normal(0:PT%Nmodes)
        !
        ipol   = PTpolyadRules(nu)
        spread = PTquanta_spread(nu) 
        !
        ! do not apply the polyad-threshold but only for the non-Harmonic basis 
        !
        !if (ipol<=job%Npolyads_contr.and.value-zpe_contr<=job%enercutoff%contr.or.spread<=job%cluster) then 
          !
          iroot_t = iroot_t + 1
          !
          if (ideg==1) then 
             ilevel_t = ilevel_t + 1
          else
            do ib = 1,iroot-1
               if (contr(iclasses)%ilevel(ib)==ilevel) then 
                  ilevel_t = contr(iclasses)%ilevel(contr(iclasses)%ilevel_chk(ib))
                  exit
               endif 
            enddo 
            !
          endif 
          !
          contr(iclasses)%ilevel_chk(iroot) = iroot_t
          contr(iclasses)%ilevel(iroot_t) = ilevel_t
          contr(iclasses)%ideg(iroot_t) = ideg 
          contr(iclasses)%iroot(ilevel_t,ideg) = iroot_t
          irecord(iclasses)%icoeffs(ilevel_t,ideg) = irecord(iclasses)%icoeffs(ilevel,ideg)
          !
          if (ideg==1) then  
            contr(iclasses)%eigen(ilevel_t)%isym = isym 
            contr(iclasses)%eigen(ilevel_t)%degeneracy = degeneracy
            contr(iclasses)%eigen(ilevel_t)%value = value
            contr(iclasses)%eigen(ilevel_t)%nu(0:PT%Nmodes) = nu(0:PT%Nmodes)
            contr(iclasses)%eigen(ilevel_t)%normal(0:PT%Nmodes) = normal(0:PT%Nmodes)
            contr(iclasses)%eigen(ilevel_t)%gamma = trim(sym%label(isym))
            !
            !
          endif 
          !
        !endif 
        !
       enddo 
       !
       if (job%verbose>=6) write(out,"(/'PTcheck_.._contr_...restore..: Number of roots: ',i8)") nroots
       !
       contr(iclasses)%nroots = iroot_t
       contr(iclasses)%nlevels = ilevel_t
       !
     enddo 
     !
     read(chkptIO,"(a32)") buf34(1:32)
     if (buf34(1:32)/='End Quantum numbers and energies') then
       write (out,"('Quantum numbers  checkpoint file ',a,' has bogus footer: ',a)") job%contrfile%primitives,buf34(1:32)
       stop 'PTcheck_point_contracted_space - bogus file footer format'
     end if
     !
     close(chkptIO,status='keep')
     !
     ! File for the conctracted coefficients
     !
     unitfname ='Contracted eigenvectors in terms of prim. basis set'
     call IOStart(trim(unitfname),chkptIO_vect)
     inquire(iolength=rec_len) f_t
     !
     maxsize = 0
     !
     do iclasses = 1,PT%Nclasses
       maxsize = max(contr(iclasses)%dimen,maxsize)
     enddo 
     !
     rec_len = rec_len*maxsize
     !
     open(chkptIO_vect,access='direct',recl=rec_len,action='read',status='old',file=job%contrfile%vectors)
     !
     do iclasses = 1,PT%Nclasses
       !
       dimen = contr(iclasses)%dimen
       !
       do iroot = 1,contr(iclasses)%nroots
         !
         ilevel = contr(iclasses)%ilevel(iroot)
         isym  = contr(iclasses)%eigen(ilevel)%isym
         ideg = contr(iclasses)%ideg(iroot)
         !
         if (ideg==1) then 
           !
           level_degen = contr(iclasses)%eigen(ilevel)%degeneracy
           !
           allocate (contr(iclasses)%eigen(ilevel)%vect(dimen,level_degen),stat=alloc)
           call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%eigen(ilevel)%vect),& 
                           kind(contr(iclasses)%eigen(ilevel)%vect))
           !
         endif
         !
         irecord_t = irecord(iclasses)%icoeffs(ilevel,ideg)
         read(chkptIO_vect,rec=irecord_t) contr(iclasses)%eigen(ilevel)%vect(1:dimen,ideg)
         !
       enddo 
       !
     enddo 
     !
     ! The primitive active space quantum numbers:
     !
     unitfname ='Description of the primitive basis set for each class'
     call IOStart(trim(unitfname),chkptIO)
     open(chkptIO,action='read',position='rewind',status='old',file=job%contrfile%primitives) 
     !
     read(chkptIO,"(a25)") buf34(1:25)
     if (buf34(1:25)/='Start Primitive basis set') then
       write (out,"(' Checkpoint file ',a,' has bogus header: ',a)") job%contrfile%dscr, buf34(1:25)
       stop 'PTcheck_point_contracted_space - bogus file format'
     end if
     !
     do iclasses = 1,PT%Nclasses
       !
       read(chkptIO,*) dimen
       !
       if (dimen/=contr(iclasses)%dimen) then 
         !
         write(out,"('PTcheck_point_contracted_space: illegal -dimen- = ',i8,'(',i8,')  in checkpointRestore of ',a)")  & 
                      dimen,contr(iclasses)%dimen,job%contrfile%dscr
         !
       endif 
       !
       do ib = 1,contr(iclasses)%dimen
        !
        read(chkptIO,*)  contr(iclasses)%prim_bs%icoeffs(0:PT%Nmodes,ib)
        !
        nu_t = contr(iclasses)%prim_bs%icoeffs(0:PT%Nmodes,ib)
        !
        continue
        !
       enddo 
       !
       deallocate(irecord(iclasses)%icoeffs)
       !
     enddo 
     !
     PT%zpe_contr = 0 
     !
     do iclasses = 1,PT%Nclasses
        cf => contr(iclasses)%eigen(1)
        !
        PT%zpe_contr = PT%zpe_contr + cf%value
        ! 
     enddo
     !
     read(chkptIO,"(a23)") buf34(1:23)
     if (buf34(1:23)/='End Primitive basis set') then
       write (out,"(' Checkpoint file ',a,' has bogus header: ',a)") job%contrfile%dscr, buf34(1:23)
       stop 'PTcheck_point_contracted_space - bogus file format'
     end if
     !
     !
     ! Additional objects for the DVR representaion
     !
     if (trove%dvr) then
       !
       unitfname ='DVR-objects in the contracted representaion'
       call IOStart(trim(unitfname),chkptIO)
       open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=job%contrfile%dvr)
       !
       read(chkptIO) buf(1:15)
       !
       call check_buf(buf(1:15),'Start DVR contr',job%contrfile%dvr)
       !
       read(chkptIO) Nclasses,Nmodes
       !
       call check_number(Nclasses,PT%Nclasses,'wrong Nclasses',job%contrfile%dvr)
       call check_number(Nmodes,PT%Nmodes,'wrong Nmodes',job%contrfile%dvr)
       !
       do iclasses = 1,PT%Nclasses
         !
         read(chkptIO) iclass_
         !
         call check_number(iclass_,iclasses,'wrong iclasses',job%contrfile%dvr)
         !
         read(chkptIO) contr(iclasses)%Ndvrpoints
         !
         Ndvrpoints = contr(iclasses)%Ndvrpoints
         !
         allocate (contr(iclasses)%dvr_kindex(contr(iclasses)%Ndvrpoints,PT%Nmodes),stat=alloc)
         call ArrayStart('dvr-fields-kindex',alloc,size(contr(iclasses)%dvr_kindex),kind(contr(iclasses)%dvr_kindex))
         !
         read(chkptIO) contr(iclasses)%dvr_kindex
         !
       enddo
       !
       read(chkptIO)  buf(1:13)
       !
       call check_buf(buf(1:13),'End DVR contr',job%contrfile%dvr)
       !
       close(chkptIO,status='keep')
       !
     endif 
     !
   end subroutine checkpointRestore
   !
   subroutine check_buf(buf,label,file)
     !
     implicit none
     !
     character(len=*) :: buf,label,file

      if (buf/=label) then
        write (out,"(' DVR-chk-file: ',a,' has bogus header: ',a)") file,buf,label
        stop 'DVR-contr-chk-file - bogus file format'
      end if

   end subroutine check_buf
   !
   subroutine check_number(Nbuf,N,message,file)
     !
     implicit none
     !
     integer(ik) :: Nbuf,N
     character(len=*) :: message,file

      if (Nbuf/=N) then
        write (out,"(' DVR-chk-file: ',a,1x,a,1x,2i0)") file,message,Nbuf,N
        stop 'DVR-contr-chk-file: wrong integer number'
      end if

   end subroutine check_number
   !
  end subroutine PTcheck_point_contracted_space



!
!
! Here we construct the primitve matrix and diagonalize it
!
  subroutine PThamiltonianMat(jrot,nroots,diagonalizer_,uv_syevr_,postprocess_)

    integer(ik),intent(in) :: jrot ! rotational quantum number
    integer(ik),intent(out):: nroots ! number of roots found
    character(len=cl),intent(in),optional  :: diagonalizer_
    real(rk),intent(in),optional  :: uv_syevr_
    logical,intent(in),optional   :: postprocess_
    !
    integer(ik) :: alloc,i0,dimen,MaxTerm
    character(len=cl):: diagonalizer_used
    real(rk)  :: upper_ener,factor
    !
    integer(ik) :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes),nu(0:PT%Nmodes),ipol,ib,jb,i,j,tau_j,Nmodes,idvrpoints(PT%Nmodes),idvr0,ipot
    !
    type(PTcoeffsT),pointer    ::  cf
    !
    real(rk) :: mat_elem,MaxEigenvects,termvalue,ZPE,mat_elem_
    !
    double precision :: vrange(2)
    real(rk),allocatable :: b(:),a(:,:),c(:,:),d(:,:),e(:)
    integer  :: nroot_t,lquant,Nmodes1,itrial
    double precision,allocatable :: work(:)
    integer,allocatable :: iwork(:)
    integer          :: info,lwork,liwork
    character(len=1)   :: rng
    double precision   :: alpha = 1.0d0,beta=0.0d0
    integer(ik),allocatable       :: count_index(:,:),count_degen(:)
    integer(ik)        :: icount,ideg,jdeg,jroot,iroot_in,iroot,Ndeg,Ncount
    real(rk)           :: largest_coeff
    logical            :: postprocess
    integer(ik)        :: kmax, nmax,n_i,n_j,v_i,v_j,k_i,k_j
    character(len=cl)  :: my_fmt1,my_fmt2 !format for I/O specification
    !
    Nmodes = PT%Nmodes
    !
    if (job%verbose>=4) write(out,"(/'PThamiltonianMat/start: variational solution '/)") 
    !
    if (present(diagonalizer_)) then 
        diagonalizer_used = diagonalizer_
    else 
        diagonalizer_used = job%diagonalizer
    endif 
    !
    if (present(uv_syevr_)) then 
        upper_ener = uv_syevr_
    else 
        upper_ener = job%upper_ener
    endif 
    !
    if (present(postprocess_)) then
        postprocess = postprocess_
    else 
        postprocess = .false.
    endif 
    !
    if (job%verbose>=5) write(out,"( 'Diagonalizer used: ',a)") trim(diagonalizer_used)
    !
    call TimerStart('PThamil..Mat')
    !
    if (size(PT%BasissetType)/=PT%Nmodes+1) then 
       write(out,"('PTzeroorder: size(BasissetType)/=PT%Nmodes+1',2i8)") size(PT%BasissetType),PT%Nmodes+1
       stop 'PTzeroorder: size(BasissetType)/=PT%Nmodes+1'
    endif
    !
    !determine the size of the Htotal:
    !
    !dimen = sum(PT%MaxIndex_nu(0:PT%Npolyads))
    !
    cf => PT%Htotal
    !
    dimen = size(cf%coeffs,dim=1)
    !
    if (job%verbose>=0) then 
        write (out,"('Size of the variational matrix  = ',i7,' out of ',i7,' elements.')") dimen,PT%Maxcoeffs
    endif
    !
    allocate (a(dimen,dimen),b(dimen),stat=alloc)
    call ArrayStart('PThamiltonianMat_a',alloc,size(a),kind(a))
    call ArrayStart('PThamiltonianMat_b',alloc,size(b),kind(b))
    !
    a = 0
    !
    ! vibrational angular momentum
    !
    if (jrot<0) then
     allocate (c(dimen,dimen),stat=alloc)
     call ArrayStart('PThamiltonianMat_c',alloc,size(c),kind(c))
    endif
    !
    kmax = job%bset(0)%range(2)
    nmax = job%bset(Nmodes)%range(2)
    if ( kmax/=0 ) then 
      nmax = (job%bset(Nmodes)%range(2)+1)/(kmax+1)-1
    endif
    !
    if (job%verbose>=3) then 
       write(out,"(/'Primitive matrix elements calculations...')")
    endif
    !
    !$omp parallel do private(i,j,nu_i,nu_j,mat_elem) shared(a) schedule(static)
    do i = 1,dimen
      !
      if (job%verbose>=5.and.mod(i,100)==0) print("('  i = ',i8)"), i
      !
      nu_i(:) = PT%active_space%icoeffs(:,i)
      !
      ! singularity resolved by Associated Legendres
      if (trove%triatom_sing_resolve) then
        v_i = nu_i(Nmodes)
        n_i = mod(v_i,nmax+1)
        k_i = (v_i-n_i)/(nmax+1)
        !nu_i(nmodes) = n_i
      endif
      !
      do j = i,dimen
        !
        nu_j(:) = PT%active_space%icoeffs(:,j)
        !
        if (trove%triatom_sing_resolve) then
          v_j = nu_j(Nmodes)
          n_j = mod(v_j,nmax+1)
          k_j = (v_j-n_j)/(nmax+1)
          !nu_j(nmodes) = n_j
          if (k_i/=k_j) cycle
        endif
        !
        ! Matrix elements 
        !
        mat_elem = 0
        !
        if (all( nu_i(1:)>=PT%range(1,1:) ).and. all( nu_i(1:)<=PT%range(2,1:) ).and. & 
          !
          all( nu_j(1:)>=PT%range(1,1:) ).and. all( nu_j(1:)<=PT%range(2,1:) ) ) then
          !
          if (FLrotation.and.Jrot>0) then
            !
            if (trove%DVR) then 
              !
              stop 'PTmatrixelements_dvr is not implemented for J/=0 yet'
              !
            else 
              !
              mat_elem = PTmatrixelements(0,nu_i,nu_j,jrot)
              !
            endif 
            !
          else
            !
            ! J-free calculations
            !
            if (trove%DVR) then 
              mat_elem = PTmatrixelements_dvr(nu_i,nu_j)
            else 
              mat_elem = PTmatrixelements(0,nu_i,nu_j) 
            endif
            !
            !if (FLl2_coeffs.and.dimen>25) then
            ! !
            ! mat_elem = PT_L2_matrixelements(0,nu_i,nu_j)
            ! !
            !endif
            !
            if (jrot==-1.or.jrot==-2) then
              !
              if (trove%DVR) then 
                write(out,"('L2@DVR is not implemented in PThamiltonianMat')")
                stop 'L2@DVR is not implemented in PThamiltonianMat'
                !
               else
                !
                !c(i,j) = mat_elem
                !c(j,i) = c(i,j)
                !
                mat_elem_ = PT_L2_matrixelements(0,nu_i,nu_j)
                !
                c(i,j) = mat_elem_
                c(j,i) = c(i,j)
                !
              endif
              !
            endif
            !
          endif 
          ! 
        endif
        !
        a(i,j) =mat_elem
        a(j,i) =mat_elem
        !
      enddo
      !
      b(i) = a(i,i)
      !
    enddo 
    !$omp end parallel do 
    !
    ! be verbose
    !
    call TimerStop('PThamil..Mat')
    !
    ! A special case of jort = -3 is for the Harmnoic basis and Order=4
    !
    if ( jrot==-3 ) then
      c = a
      nroots = dimen
    else
       !
       ! Diagonalization 
       !
       
       !
       ! The diagonalization will be done with Lapack. 
       ! We will need matrix "a" prepared in appropriate way 
       !
       b = 0
       !
       !  diagonalization with lapack_syev
       !
       call TimerStart('Diagonalization')
       !
       if (job%verbose>=3) then 
          write(out,"(/'Diagonalization...')")
       endif 
       !
       select case (trim(diagonalizer_used)) 
       !
       case default
         !
         write (out,"('PThamiltonianMat: type of the diagonalizer  ',a,' unknown')") trim(diagonalizer_used)
         stop 'PThamiltonianMat - wrong diagonalizer '
         !
       case('SYEV') 
         !
         !
         !call lapack_syev(a(1:dimen,1:dimen),b(:))
         !
         lwork = 50*size(a,dim=1)
         !
         allocate(work(lwork))
         !
         call dsyev('V','U',dimen,a(1:dimen,1:dimen),dimen,b,work,-1,info)
         !
         if (int(work(1))>size(work)) then 
           !
           lwork = int(work(1))
           !
           deallocate(work)
           !
           allocate(work(lwork))
           !
           call dsyev('V','U',dimen,a(1:dimen,1:dimen),dimen,b,work,lwork,info)
           !
         else
           !
           call dsyev('V','U',dimen,a(1:dimen,1:dimen),dimen,b,work,lwork,info)
           !
         endif 
         !
         deallocate(work)
         !
         if (info/=0) then
           write (out,"('PThamiltonianMat-dsyev returned ',i8)") info
           stop 'PThamiltonianMat-lapack_dsyev - dsyev failed'
         end if
         !
         nroots = dimen
         !
       case('SYEVD') 
         !
         lwork  = 50*size(a,dim=1)
         liwork = 50*size(a,dim=1)
         !
         allocate(work(lwork),iwork(liwork))
         !
         call dsyevd('V','U',dimen,a(1:dimen,1:dimen),dimen,b,work,-1,iwork,-1,info)
         !
         if (int(work(1))>size(work).or.int(iwork(1))>size(iwork)) then 
           !
           lwork = int(work(1))
           liwork = int(iwork(1))
           !
           deallocate(work,iwork)
           !
           allocate(work(lwork),iwork(liwork))
           !
           call dsyevd('V','U',dimen,a(1:dimen,1:dimen),dimen,b,work,lwork,iwork,liwork,info)
           !
           nroots = dimen
           !
         else
           !
           call dsyevd('V','U',dimen,a(1:dimen,1:dimen),dimen,b,work,lwork,iwork,liwork,info)
           !
         endif 
         !
         deallocate(work,iwork)
         !
         if (info/=0) then
           write (out,"('PThamiltonianMat-dsyevd returned ',i8)") info
           stop 'PThamiltonianMat-lapack_dsyevd - dsyev failed'
         end if
         nroots = dimen
         !
       case('SYEVR') 
         !
         vrange(1) = -100000.0_rk ; vrange(2) = upper_ener+a(1,1)
         !
         if (upper_ener/=1e9) then 
            rng = 'V'
         else
            rng = 'A'
         endif 
         !
         call lapack_syevr(a(1:dimen,1:dimen),b(1:dimen),rng,iroots=nroot_t,vrange=vrange) 
         !
         nroots= nroot_t 
         !
       end select 
       !
       call TimerStop('Diagonalization')
       !
       cf%coeffs(1:dimen,1:dimen) = a(1:dimen,1:dimen)
       !
       ! Store eigenvalues
       ! ZPE
       !
       ZPE  = safe_max
       MaxTerm  = 1
       !
       do jb=1,nroots
          if (b(jb)<=ZPE) then 
              ZPE = b(jb)
              write(out,"(/'Zero-point-energy is ',f18.6)") ZPE
          endif
       enddo
       !
       ! Determine the assignment of the eigenvectors using the largest coefficient principle 
       ! 
       ! and Reporting the final results 
       !
       write(out,"(/'Variational eigenvalues:',/'      i        value       quanta')") 
       !
       do ib=1,nroots
          !
          MaxEigenvects  = small_
          MaxTerm  = 1
          !
          do jb=1,dimen
             if (abs(a(jb,ib))>=MaxEigenvects) then 
                 MaxEigenvects = abs( a(jb,ib) )
                 MaxTerm = jb
             endif
             nu_j(:) = PT%active_space%icoeffs(:,jb)
             if (job%verbose>=7) write(out,"(2i8,f19.8,30i4)") ib,jb,a(jb,ib), & 
                          (nu_j(i0),i0=0,min(PT%Nmodes,30))
             !
          enddo
          !
          nu_i(:) = PT%active_space%icoeffs(:,MaxTerm)
          PT%quanta%icoeffs(ib,:) = nu_i(:)
          !
          if (trove%triatom_sing_resolve) then
            v_i = nu_i(Nmodes)
            n_i = mod(v_i,nmax+1)
            k_i = (v_i-n_i)/(nmax+1)
            PT%lquant%icoeffs(ib,1)=k_i
            PT%quanta%icoeffs(ib,Nmodes) = n_i
          endif
          !
          termvalue = b(ib)-ZPE
          !
          PT%largest%coeffs(ib,1) = a(MaxTerm,ib)
          !
          write(out,"(i7,f18.8,40i3)") ib,termvalue,(nu_i(i0),i0=0,min(40,PT%Nmodes))
          !
       enddo
       !
       PT%Ewhole%coeffs(:,1) = b(:)
       !
    endif
    !
    ! Define Vibrational angular momenta or Harmonic-osciallators
    !
    if (jrot==-1.or.jrot==-2.or.jrot==-3) then
        !
        PT%Hclass%coeffs = c
        !
        ! Lvib-case
        if (jrot==-1.or.jrot==-2) then
           !
           ! transform the matrix elements of the vib. angular momentum 
           ! to the new basis of eigenfunctions of H-reduced and store in C-matrix
           !
           call dgemm('T','N',dimen,dimen,dimen,alpha,& 
                       cf%coeffs,dimen,&
                       c,dimen,beta,&
                       a,dimen)
           !   
           call dgemm('N','N',dimen,dimen,dimen,alpha,&
                      a,dimen,&
                      cf%coeffs,dimen,beta,&
                      c,dimen)
           !
        endif
        !
        ! Now c-matrix should be block-diagonal: diagonal for non-degenerate and 
        ! non-diagonal for the clusters of degenerate states.
        ! 
        ! Here we count the degenerate srates and form groups from the corresponding eigenfunctions
        !
        allocate (count_index(dimen,dimen),count_degen(dimen),stat=alloc)
        call ArrayStart('PThamiltonianMat:count_index',alloc,size(count_index),kind(count_index))
        call ArrayStart('PThamiltonianMat:count_degen',alloc,size(count_degen),kind(count_degen))
        !
        count_index = 0
        count_index(1,1) = 1
        count_degen(1) = 1
        !
        icount = 1
        ideg = 1
        iroot_in = 1
        !
        if (job%verbose>=6) write(out,"('nroots = ',i5)") nroots
        !
        do iroot = 2,nroots
          !
          nu = PT%quanta%icoeffs(iroot,:)
          ipol = PTpolyadRules(nu)
          !
          ! apply the polyad- and cluster-thresholds only for the non-Harmonic basis 
          !
          if ( ipol>job%Npolyads_contr.and.&
               .not.( postprocess ).and.&
               .not.( abs( PT%Ewhole%coeffs(iroot,1)-PT%Ewhole%coeffs(iroot-1,1) )<job%degen_threshold.and.&
                      iroot-1==iroot_in)  ) then
               !
             cycle 
             !
          endif
          !
          if ( abs(PT%Ewhole%coeffs(iroot,1)-PT%Ewhole%coeffs(iroot_in,1))<job%degen_threshold )  then
            !
            ideg = ideg + 1
            !
          else
            !
            ideg = 1
            icount = icount + 1
            !
          endif 
          !
          if (job%verbose>=6) write(out,"('iroot,icount,ideg = ',3i5)") iroot,icount,ideg
          !
          count_index(icount,ideg) = iroot
          count_degen(icount) = ideg
          !
          ! last iroot taken in
          iroot_in = iroot
          !
        enddo
        !
        Ncount = icount
        !
        iroot = iroot_in
        !
        if (job%verbose>=5) then
          write(out,"(/'levels, states selected =  ',2i8)") icount,iroot_in
        endif
        !
        lwork = 50*maxval(count_degen(1:Ncount),dim=1)
        !
        !if (job%verbose>=7) print*,count_degen
        !
        if (job%verbose>=6) write(out,"('maxdeg, lwork',2i8)") maxval(count_degen(1:Ncount),dim=1),lwork
        !
        allocate(work(lwork),stat=alloc)
        call ArrayStart('PThamiltonianMat:work',alloc,size(work),kind(work))
        !
        a = 0
        ! 
        ! for each degenerate cluster (incl. Ndeg=1) build a small 
        ! Lquant matrix Ndeg x Ndeg and diagonalize
        ! This should produce a diagonal Lquant (ang. vibr. mometna) matrix
        !
        if ( jrot/=-3.and.job%verbose>=5 ) write(out,"('   Diagonalize <i|Lvib|j> for clusters with the same L...')") 
        if ( jrot==-3.and.job%verbose>=5 ) write(out,"('   Diagonalize H-blocks clusters for degenerate states...')") 
        !
        do icount = 1,Ncount
           !
           Ndeg  = count_degen(icount)
           !
           allocate (d(Ndeg,Ndeg),e(Ndeg),stat=alloc)
           call ArrayStart('PThamiltonianMat_d',alloc,size(d),kind(d))
           call ArrayStart('PThamiltonianMat_d',alloc,size(e),kind(e))
           !
           do ideg = 1,Ndeg
             !
             iroot = count_index(icount,ideg)
             !
             do jdeg = 1,Ndeg
               !
               jroot = count_index(icount,jdeg)
               !
               d(ideg,jdeg) = c(iroot,jroot)
               !
             enddo
           enddo
           !
           call lapack_dsyev(d,e)
           !
           !call dsyev('V','U',Ndeg,d,Ndeg,e,work,lwork,info)
           !
           do ideg = 1,Ndeg
             !
             iroot = count_index(icount,ideg)
             !
             forall (jdeg=1:Ndeg) a(count_index(icount,jdeg),iroot) = d(jdeg,ideg)
             !
             b(iroot) = e(ideg)
             !
           enddo
           !
           deallocate (d,e)
           call ArrayStop('PThamiltonianMat_d')
           !
        enddo
        !
        deallocate(work)
        deallocate (count_index,count_degen)
        call ArrayStop('PThamiltonianMat:count_index')
        call ArrayStop('PThamiltonianMat:count_degen')
        call ArrayStop('PThamiltonianMat:work')
        !
        ! Transform to the eigenfunctions to the L-representtation, where
        ! Lz^2 is diagonal 
        !
        if (job%verbose>=5) write(out,"('   Transform to the diagonal representation ...')") 
        !   
        call dgemm('N','N',dimen,dimen,dimen,alpha,&
                   cf%coeffs,dimen,&
                   a,dimen,beta,&
                   c,dimen)

        cf%coeffs = c
        !
        ! check if L2 is diagonal by transforming the primite 
        ! matrix elemenets of L2 to the new representation 
        !
        !if (job%verbose>=5) write(out,"('   Transform the Hamiltonian or Lvib and check if it is diagonal ...')")         
        !
        call dgemm('T','N',dimen,dimen,dimen,alpha,& 
                    cf%coeffs,dimen,&
                    PT%Hclass%coeffs,dimen,beta,&
                    a,dimen)
        !   
        call dgemm('N','N',dimen,dimen,dimen,alpha,&
                   a,dimen,&
                   cf%coeffs,dimen,beta,&
                   c,dimen)

        !
        ! Only for the lvib-case 
        !
        if (jrot==-1.or.jrot==-2) then
           !
           if (job%verbose>=5) write(out,"(/a)") "   Obtain vibrational angular momenta"
           !
           Nmodes1 = PT%Nmodes+1
           factor = 1.0_rk
           !
           itrial = 2
           !
           write(my_fmt1,'(a,i0,a)') "(i7,f18.8,",nmodes+1,"i3,f15.8,a,i6)"
           write(my_fmt2,'(a,i0,a)') "(i7,f18.8,",nmodes+1,"i3,f15.8)"
           !
           do i=1,nroots
             !
             ! Here we check the diagonality 
             !
             largest_coeff = 0
             MaxTerm = 1
             !
             if (i>1) then 
               largest_coeff = maxval(c(:i-1,1)**2,dim=1,mask=c(:i-1,1)**2.ge.0.0_rk) 
               MaxTerm = maxloc(c(:i-1,1)**2,dim=1,mask=c(:i-1,1)**2.ge.0.0_rk)
             endif
             !
             if ((largest_coeff>sqrt(small_).and.Jrot==-1).or.( largest_coeff>1e5*sqrt(small_).and.Jrot==-2 )) then 
               !
               write(out,"(a,g18.4,' i = ',i5,' ; lquant2 =  ',f14.6)") & 
                           'PThamiltonianMat: non-diagonal lquant elements are too large ',largest_coeff,i,c(i,i)
               stop 'PThamiltonianMat:  non-diagonal lquant '
               !
             endif
             !
             ! Check the diagonal elements if they make sense (positive)
             !
             if (c(i,i)<-sqrt(small_)) then 
               write(out,"('PThamiltonianMat: non-diagonal should not be negative:',f18.4,' i = ',i4)") c(i,i),i
               stop 'PThamiltonianMat: illegal non-diagonal'
             endif
             !
             ! here is the special case when lquant = l x constant
             ! we take lquant(1) = constant and use it to re-scale all other values else, if this works. 
             !
             if ( i==itrial ) then
               if ( nint( sqrt( abs( c(i,i) ) ) )==1 ) then
                 factor = sqrt(abs(c(i,i)))
               elseif ( sqrt( abs( c(i,i) ) )>sqrt(small_) ) then
                 factor = sqrt(abs(c(i,i)))
               else
                 itrial = itrial + 1
               endif 
             endif
             !
             PT%lquant%icoeffs(i,1) = nint(sqrt(abs(c(i,i)))/factor,ik)
             !
             !if (abs(real(PT%lquant%icoeffs(i,1)**2,rk)-c(i,i))>100.0*sqrt(small_)) then 
             !  write(out,"('PThamiltonianMat: lquant is not an integer:',i,1x,f18.4,' i = ',i4)") PT%lquant%icoeffs(i,1)**2,c(i,i),i
             !  !stop 'PThamiltonianMat: illegal lquant '
             !endif
             !
             if (job%verbose>=4) then
                 !
                 termvalue = PT%Ewhole%coeffs(i,1)-ZPE
                 !
                 if (abs(real(PT%lquant%icoeffs(i,1)**2,rk)-c(i,i)*factor)>100.0*sqrt(small_)) then
                    !
                    write(out,my_fmt1) i,termvalue,(PT%quanta%icoeffs(i,i0),i0=0,PT%Nmodes),' /= ',&
                                       sqrt(abs(c(i,i)))/factor,PT%lquant%icoeffs(i,1)
                    !
                 else
                    !
                    write(out,my_fmt2) i,termvalue,(PT%quanta%icoeffs(i,i0),i0=0,PT%Nmodes),sqrt(abs(c(i,i)))/factor
                    !
                 endif
                 !
             endif
             !
           enddo
           !
           if ( factor>sqrt(small_) ) then
             write(out,"(' All lquant-values have been rescaled by the lquant(1) factor = 1/',f18.12,' to make lquant(1) ==1 ')") & 
                          factor
           endif
           !
        elseif (jrot==-3) then
           !
           Nmodes1 = PT%Nmodes+1
           !
           ZPE  = safe_max
           !
           do jb=1,nroots
              if (b(jb)<=ZPE) then 
                  ZPE = b(jb)
              endif
           enddo
           !
           write(out,"(/'Zero-point-energy is ',f18.6)") ZPE
           !
           write(my_fmt1,'(a,i0,a)') "(i7,f18.8,",nmodes+1,"i3)"
           !
           do i=1,nroots
             !
             ! Assign the new basis functions = eigenfunctions
             !
             MaxEigenvects  = small_
             MaxTerm  = 1
             !
             MaxEigenvects = maxval(cf%coeffs(:,i)**2,dim=1)-small_
             MaxTerm = maxloc(cf%coeffs(:,i)**2,dim=1,mask=cf%coeffs(:,i).ge.MaxEigenvects)
             !
             nu_i(:) = PT%active_space%icoeffs(:,MaxTerm)
             PT%quanta%icoeffs(i,:) = nu_i(:)
             !
             PT%largest%coeffs(i,1) = cf%coeffs(MaxTerm,i)
             !
             PT%Ewhole%coeffs(i,1) = b(i)
             !
             termvalue = b(i)-ZPE
             !
             if (job%verbose>=4) then
               !
               write(out,my_fmt1) i,termvalue,(PT%quanta%icoeffs(i,i0),i0=0,PT%Nmodes)
               !
             endif
             !
           enddo
           !
        endif
        !
        ! sort the einvalues ann eigenvectors with the energy 
        !
        do i =1,-nroots
          !
          termvalue = PT%Ewhole%coeffs(i,1)
          !
          do j =i+1,nroots
            !
            if (termvalue>PT%Ewhole%coeffs(j,1)) then 
              !
              termvalue = PT%Ewhole%coeffs(j,1)
              PT%Ewhole%coeffs(j,1) = PT%Ewhole%coeffs(i,1)
              PT%Ewhole%coeffs(i,1) = termvalue
              !
              lquant = PT%lquant%icoeffs(j,1)
              PT%lquant%icoeffs(j,1) = PT%lquant%icoeffs(i,1)
              PT%lquant%icoeffs(i,1) = lquant
              !
              b(:)   = a(:,j)
              a(:,j) = a(:,j)
              a(:,j) = b(:)
              !
            endif 
            !
          enddo
          !
        enddo
        !
        deallocate(c)
        call ArrayStop('PThamiltonianMat_c')
        !
    endif
    !
    deallocate(a,b)
    call ArrayStop('PThamiltonianMat_a')
    call ArrayStop('PThamiltonianMat_b')
    !
    if (job%verbose>=4) write(out,"('PThamiltonianMat/end')") 
    !
  end subroutine PThamiltonianMat



!
!
! Here we construct the primitve Hamiltonian matrix, 
! transform to a reduced contracted basis set constructed from reduced, usually harmonic(red=2) hamiltonian 
! and diagonalize it to produce a contracted solution
!
  subroutine PThamiltonianMat_contracted_reduced(jrot,iclasses,nroots)
     !
     implicit none
     !
    integer(ik),intent(in) :: jrot,iclasses ! rotational quantum number, classes
    integer(ik),intent(inout):: nroots ! number of roots found
    !
    integer(ik) :: alloc,dimen,MaxTerm
    real(rk)    :: temp
    !
    integer(ik) :: nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes),i,j,k,l,k_i,k_j,tau_i,tau_j,gamma,ideg,level_degen
    !
    integer(ik) :: nlevels,ilevel,jlevel,iroot,nsym(sym%Nrepresen,sym%maxdegen),ndeg,dimen_s,ipol,nmodes
    integer(ik) :: gamma_i,gamma_j,ideg_i,ideg_j,dimen_i,dimen_j,ndeg_i,ndeg_j,level_,maxdeg,ideg_k,klevel
    integer(ik) :: kmode,im1,im2
    !
    real(rk),allocatable  :: eigen_t(:,:),eigen(:,:,:)
    !
    real(rk) :: mat_elem,MaxEigenvects,termvalue,ZPE,ener
    !
    double precision :: work0(1)
    real(rk),allocatable :: b(:),a(:,:),h(:,:),transf_i(:,:),transf_j(:,:),e(:),mat_t(:,:),energy(:),mat_tt(:,:)
    integer(ik),allocatable :: igamma(:),oldlevel(:,:,:),iii(:)
    double precision,allocatable :: work(:)
    integer          :: info,lwork
    double precision   :: alpha = 1.0d0,beta=0.0d0
    logical           ::  reduced_model,diagonal
    character(len=cl) :: my_fmt  !format for I/O specification
    !
    if (job%verbose>=4) write(out,"(/'Second pre-diagonalization stage of the harmonic basis'/)") 
    !
    call TimerStart('PThamil-contr..Mat')
    !
    if (size(PT%BasissetType)/=PT%Nmodes+1) then 
       write(out,"('PTzeroorder: size(BasissetType)/=PT%Nmodes+1',2i8)") size(PT%BasissetType),PT%Nmodes+1
       stop 'PTzeroorder: size(BasissetType)/=PT%Nmodes+1'
    endif
    !
    nmodes = PT%Nmodes
    !
    dimen = nroots
    !
    kmode = PT%mode_class(iclasses,1)
    !
    reduced_model = .false. !.true.
    diagonal = .false.
    !
    if (reduced_model) then 
      !
      im1 = PT%mode_class(iclasses,1)
      im2 = PT%mode_class(iclasses,PT%mode_iclass(iclasses))
      !
      call PT_exclude_specific_modes(im1,im2,trove%NPotOrder,diagonal)
      !
      !call PT_exclude_specific_modes(im1,im2,job%bset(kmode)%model,diagonal)
      !
    endif 
    !
    if (job%verbose>=3) then 
       write(out,"(/'  Primitive matrix elements calculations...')")
    endif 
    !
    if (job%verbose>=0) then 
        write (out,"('  Size of the variational matrix  = ',i7,' out of ',i7,' elements.')") dimen,PT%Maxcoeffs
    endif
    !
    allocate (a(dimen,dimen),b(dimen),stat=alloc)
    call ArrayStart('PThamiltonianMat_reduced',alloc,size(a),kind(a))
    call ArrayStart('PThamiltonianMat_reduced',alloc,size(b),kind(b))
    !
    !$omp parallel do private(i,j,nu_i,nu_j,mat_elem) shared(a) schedule(static)
    do i = 1,dimen
      !
      if (job%verbose>=5.and.mod(i,100)==0) print("('  i = ',i8)"), i
      !
      nu_i(:) = PT%active_space%icoeffs(:,i)
      !
      do j = i,dimen
        !
        nu_j(:) = PT%active_space%icoeffs(:,j)
        !
        ! Matrix elements 
        !
        mat_elem = 0
        !
        if (all( nu_i(1:)>=PT%range(1,1:) ).and. all( nu_i(1:)<=PT%range(2,1:) ).and. & 
          !
          all( nu_j(1:)>=PT%range(1,1:) ).and. all( nu_j(1:)<=PT%range(2,1:) ) ) then
          !
          if (FLrotation.and.Jrot/=0) then
            !
            if (trove%DVR) then 
              !
              stop 'PTmatrixelements_dvr is not implemented for J/=0 yet'
              !
            else 
              !
              mat_elem = PTmatrixelements(0,nu_i,nu_j,jrot)
              !
            endif 
            !
          else 
            !
            ! J-free calculations
            !
            if (trove%DVR) then 
              !  mat_elem = PTmatrixelements_dvr(i,j,nu_i,nu_j)
              stop 'PTmatrixelements_dvr is not implemented for PThamiltonianMat_contracted_reduced yet'
              !
            else 
              mat_elem = PTmatrixelements(0,nu_i,nu_j) 
            endif
            !
          endif 
          ! 
        endif
        !
        a(i,j) =mat_elem
        a(j,i) =mat_elem
        !
      enddo
      !
      b(i) = a(i,i)
      !
    enddo 
    !$omp end parallel do 
    !
    ! bring all mode-reductions back
    !
    if (reduced_model) call PT_exclude_specific_modes(-1,PT%Nmodes+1)
    !
    ! Transform this Hamiltonian matrix into the (reduced) symmetrized contracted representaion 
    !
    contr(iclasses)%dimen  = dimen
    nlevels = contr(iclasses)%nlevels
    nroots = contr(iclasses)%nroots
    !
    if (job%verbose>=4) write(out,"('  ... done!')") 
    !
    ! count energies from different symmetry blocks
    !
    nsym(:,:) = 0
    maxdeg = 1
    do ilevel=1,nlevels
      !
      gamma=contr(iclasses)%eigen(ilevel)%isym
      ndeg = sym%degen(gamma)
      maxdeg = max(ndeg,maxdeg)
      do ideg = 1,ndeg
         !
         nsym(gamma,ideg) = nsym(gamma,ideg) + 1
         !
      enddo
      !
    enddo
    !
    iroot = 0
    !
    allocate(igamma(nlevels),stat=alloc)
    !
    dimen_s = max(maxval(nsym),1)
    !
    allocate(oldlevel(sym%Nrepresen,sym%maxdegen,dimen_s),stat=alloc)
    call ArrayStart('PThamiltonianMat_reduced-oldlevel',alloc,size(oldlevel),kind(oldlevel))
    !
    nsym(:,:) = 0
    !
    do ilevel=1,nlevels
      !
      gamma=contr(iclasses)%eigen(ilevel)%isym
      !
      ndeg = sym%degen(gamma)
      !
      do ideg = 1,ndeg
         !
         nsym(gamma,ideg) = nsym(gamma,ideg) + 1
         !
         iroot = iroot + 1
         !
         oldlevel(gamma,ideg,nsym(gamma,ideg)) = ilevel
         !
      enddo
      !
    enddo   
    !
    ! check found dimensions for consistency:
    !
    do gamma=1,sym%Nrepresen
      do ideg = 2,sym%degen(gamma)
         !
         if (nsym(gamma,ideg)/=nsym(gamma,ideg-1)) then 
           !
           write(out,"('PThamiltonianMat_reduced: sizes of blocks for different degen. are inconsistent:')")
           write(out,"(' gamma,ideg,ideg-1,nsym(gamma,ideg),nsym(gamma,ideg-1) = ',5i0)") gamma,ideg,ideg-1,nsym(gamma,ideg),&
                       nsym(gamma,ideg-1)
           stop 'PThamiltonianMat_reduced: inconsistent degen-s' 
           !
         endif
         !
      enddo
      !
    enddo   
    !
    if (iroot/=dimen) then 
      !
      write(out,"('PThamiltonianMat_reduced: iroot /= dimen:',2i0)") iroot,dimen
      !
      !stop 'PThamiltonianMat_reduced: iroot /= dimen' 
      !
    endif
    !
    allocate(eigen(nlevels,dimen,maxdeg),eigen_t(dimen,maxdeg),energy(nlevels),stat=alloc)
    call ArrayStart('PThamiltonianMat_reduced-eigen',alloc,size(eigen),kind(eigen))
    call ArrayStart('PThamiltonianMat_reduced-eigen',alloc,size(eigen_t),kind(eigen_t))
    call ArrayStart('PThamiltonianMat_reduced-eigen',alloc,size(energy),kind(energy))
    !
    eigen = 0
    iroot = 0
    ilevel = 0
    !
    do gamma_i = 1,sym%Nrepresen
      !
      ndeg_i = sym%degen(gamma_i)
      !
      ndeg = max( maxval( nsym(gamma_i,:),dim=1 ),1 )
      !
      allocate(iii(ndeg),stat=alloc)
      !
      loop_i : do ideg_i = 1,ndeg_i
         !
         dimen_i = nsym(gamma_i,ideg_i)
         !
         if (dimen_i == 0) cycle loop_i
         !
         allocate(transf_i(1:dimen,1:dimen_i),e(dimen_i),stat=alloc)
         call ArrayStart('PThamiltonianMat_reduced-h',alloc,size(transf_i),kind(transf_i))
         call ArrayStart('PThamiltonianMat_reduced-h',alloc,size(e),kind(e))
         !
         do i = 1,dimen_i
           !
           level_ = oldlevel(gamma_i,ideg_i,i)
           !
           transf_i(:,i) = contr(iclasses)%eigen(level_)%vect(:,ideg_i)
           !
         enddo
         !
         !deallocate(h,transf,e)
         !
         allocate(mat_t(1:dimen_i,1:dimen),stat=alloc)
         call ArrayStart('PThamiltonianMat_reduced-temp',alloc,size(mat_t),kind(mat_t))
         !
         do gamma_j = 1,sym%Nrepresen
           !
           ndeg_j = sym%degen(gamma_j)
           !
           loop_j : do ideg_j = 1,ndeg_j
              !
              dimen_j = nsym(gamma_j,ideg_j)
              !
              if (dimen_j == 0) cycle loop_j
              !
              allocate(h(dimen_i,dimen_j),transf_j(1:dimen,1:dimen_j),stat=alloc)
              call ArrayStart('PThamiltonianMat_reduced-h',alloc,size(h),kind(h))
              call ArrayStart('PThamiltonianMat_reduced-h',alloc,size(transf_j),kind(transf_j))
              !
              do i = 1,dimen_j
                !
                level_ = oldlevel(gamma_j,ideg_j,i)
                !
                transf_j(:,i) = contr(iclasses)%eigen(level_)%vect(:,ideg_j)
                !
              enddo
              !
              !tmat(gamma,ideg)%coeff2d(:,:)
              !
              ! transformation to the symmetrized basis: 
              !
              call dgemm('T','N',dimen_i,dimen,dimen,alpha,& 
                          transf_i,dimen,&
                          a,dimen,beta,&
                          mat_t,dimen_i)
              !   
              call dgemm('N','N',dimen_i,dimen_j,dimen,alpha,&
                         mat_t,dimen_i,&
                         transf_j,dimen,beta,&
                         h,dimen_i)
              !
              !do i = 1,dimen_i
              !   do j = 1,dimen_j
              !     !
              !     temp = 0
              !     !
              !     do k = 1,dimen
              !       do l = 1,dimen
              !         !
              !         temp = temp + transf_i(k,i)*a(k,l)*transf_j(l,j)
              !         !
              !       enddo
              !     enddo
              !     !
              !     h(i,j) = temp
              !     !
              !   enddo
              !enddo
              !
              ! diagonalization using LAPACK's dsyev
              !
              if (gamma_i==gamma_j.and.ideg_i==ideg_j) then 
                 !
                 dimen_s = dimen_i
                 !
                 call dsyev('V','U',dimen_s,h,dimen_s,e,work0,-1,info)
                 !
                 lwork = int(work0(1))
                 !
                 allocate(work(lwork))
                 !
                 call dsyev('V','U',dimen_s,h,dimen_s,e,work,lwork,info)
                 !
                 deallocate(work)
                 allocate(mat_tt(1:dimen,1:dimen_s),stat=alloc)
                 !
                 ! transform to the primitive representation
                 !
                 !mat_tt = 0
                 !
                 !call dgemm('N','N',dimen,dimen_s,dimen_s,alpha,&
                 !                   transform,dimen_s,&
                 !                   h,dimen_s,&
                 !                   beta, mat_t,dimen)
                 !
                 do i = 1,dimen_s
                   !
                   call dgemv('N',dimen,dimen_s,alpha,transf_i(:,:),dimen,h(:,i),1,beta,mat_tt(:,i),1)
                   !
                 enddo
                 !
                 !
                 !do j = 1,dimen
                 !   do i = 1,dimen_s
                 !     !
                 !     temp = 0
                 !     !
                 !     do k = 1,dimen_s
                 !       !
                 !       temp = temp + transf(j,k)*h(k,i)
                 !       !
                 !     enddo
                 !     !
                 !     mat_tt(j,i) = temp
                 !     !
                 !   enddo
                 !enddo
                 !
                 !if (ideg_i==1) then
                 !   !
                 !   do ideg_k = 1,ndeg_i
                 !     !
                 !     do i = 1,dimen_i
                 !       !
                 !       level_ = oldlevel(gamma_i,ideg_i,i)
                 !       !
                 !       transf_j(:,i) = contr(iclasses)%eigen(level_)%vect(:,ideg_i)
                 !       !
                 !     enddo
                 !     
                 !     !
                 !   enddo
                 !   !
                 !endif
                 !
                 do i = 1,dimen_s
                   !
                   iroot = iroot  + 1
                   !
                   if (ideg_i==1) then
                      !
                      ilevel = ilevel + 1
                      energy(ilevel) = e(i)
                      igamma(ilevel) = gamma_i
                      iii(i) = ilevel
                      level_ = ilevel
                      !
                      do ideg_k = 1,ndeg_i
                        !
                        !call dgemv('N',dimen,dimen_s,alpha,transf_j(:,:),dimen,h(:,i),1,beta,eigen(level_,:,ideg_k),1)
                        !
                        do j = 1,dimen
                           !do i = 1,dimen_s
                             !
                             temp = 0
                             !
                             do k = 1,dimen_s
                               !
                               klevel = oldlevel(gamma_i,ideg_i,k)
                               !
                               temp = temp + contr(iclasses)%eigen(klevel)%vect(j,ideg_k)*h(k,i)
                               !
                             enddo
                             !
                             eigen(ilevel,j,ideg_k) = temp
                             !
                           !enddo
                        enddo
                        !
                      enddo
                      !
                    else
                      !
                      level_ = iii(i)
                      !
                      if ( abs( energy(level_)-e(i) )>job%degen_threshold ) then 
                         !
                         if (job%verbose>=6) write(out,"(a,i7,',',2(i3,','),1x,f12.4,'/= ',f12.4,' (1), thresh = ',g12.4)") &
                                                   '  Degenerate energies do not agree: i,gamma,ideg  = ',&
                                                   i,gamma_i,ideg_i,e(i),energy(level_),job%degen_threshold
                         !
                         if ( abs( energy(level_)-e(i) )>1.0 ) then
                           write(out,"(a,i7,',',2(i3,','),1x,f12.4,'/= ',f12.4,' (1), thresh = ',g12.4)") & 
                                       '  The degeneracy of energies is in trouble: i,gamma,ideg  = ',&
                                       i,gamma_i,ideg_i,e(i),energy(level_),1.0
                           stop ' second pre-diag: Degenerate energies do not agree' 
                         endif 
                         !
                      endif 
                      !
                    endif
                    !
                    !eigen(level_,:,ideg_i) = mat_tt(:,i)
                    !
                 enddo
                 !
                 deallocate(mat_tt,stat=alloc)
                 call ArrayStop('PThamiltonianMat_reduced-temp')
                 !
              else
                 !
                 do i = 1,dimen_i
                    do j = 1,dimen_j
                      !
                      if (abs(h(i,j))>(10.0_rk)**(-(rk-4))) then 
                        if (job%verbose>=6) &
                        write(out,"('  <',2i3,1x,',',i5,'|H|',2i3,1x,',',i5,'> = ',f16.8,' > 1e-4')") &
                                   gamma_i,ideg_i,i,gamma_j,ideg_j,j,h(i,j)
                        !
                        if (abs(h(i,j))>1.0) then 
                          write(out,"('  <',2i3,1x,',',i5,'|H|',2i3,1x,',',i5,'> = ',f16.8,' > 1: too much!')") & 
                                gamma_i,ideg_i,i,gamma_j,ideg_j,j,h(i,j)
                          stop 'second pre-diag: too large non-diagonal matrix element' 
                        endif 
                      endif 
                      !
                    enddo
                 enddo
                 !
              endif
              deallocate(h)
              deallocate(transf_j)
              !
              call ArrayStop('PThamiltonianMat_reduced-h')
              !
           enddo loop_j
           !
         enddo
         ! 
         deallocate(e)
         deallocate(mat_t,transf_i)
         !
      enddo loop_i
      deallocate(iii)
      !
    enddo
    !
    nlevels = ilevel
    nroots = iroot
    !
    ! sort the einvalues ann eigenvectors with the energy 
    !
    do ilevel =1,nlevels
      !
      ener = energy(ilevel)
      !
      do jlevel =ilevel+1,nlevels
        !
        if (ener>energy(jlevel)) then 
          !
          ener = energy(jlevel)
          energy(jlevel) = energy(ilevel)
          energy(ilevel) = ener
          !
          eigen_t(:,:)      = eigen(jlevel,:,:)
          eigen(jlevel,:,:) = eigen(ilevel,:,:)
          eigen(ilevel,:,:) = eigen_t(:,:)
          !
          gamma          = igamma(jlevel)
          igamma(jlevel) = igamma(ilevel)
          igamma(ilevel) = gamma
          !
        endif 
        !
      enddo
      !
    enddo
    !
    deallocate(a,b)
    call ArrayStop('PThamiltonianMat_reduced')
    !
    ZPE  = safe_max
    MaxTerm  = 1
    !
    do ilevel=1,nlevels
       if (energy(ilevel)<=ZPE) then 
           ZPE = energy(ilevel)
           write(out,"(/'Zero-point-energy is ',f18.6)") ZPE
       endif
    enddo
    !
    ! Determine the assignment of the eigenvectors using the largest coefficient principle 
    ! and Reporting the final results 
    !
    ! Form the new contracted basis set as a truncated set of found eignevectos using the polyad-threshold
    !
    iroot = 0
    contr(iclasses)%max_degen = 1
    !
    if (job%verbose>=2) then 
        !
        write(out,"(//'Contracted solution: post-processed')")
        write(out,"('      i       ener         deg  symmetry  quanta:')")
        !
    end if 
    !
    jlevel = 0
    !
    PT%quanta%icoeffs = 0
    !
    loop_level: do ilevel=1,nlevels
       !
       gamma = igamma(ilevel)
       !
       ideg =1
       !
       ! Find the largest coefficient maxTerm in the contracted representaion:
       !
       MaxEigenvects = maxval(eigen(ilevel,:,ideg)**2,dim=1)-small_
       MaxTerm = maxloc(eigen(ilevel,:,ideg)**2,dim=1,mask=eigen(ilevel,:,ideg)**2.ge.MaxEigenvects)
       !
       nu_i(:) = PT%active_space%icoeffs(:,MaxTerm)
       PT%quanta%icoeffs(ilevel,:) = nu_i(:)
       ipol = PTpolyadRules(nu_i)
       !
       if (ipol>job%Npolyads_contr) cycle loop_level
       !
       jlevel= jlevel + 1
       !
       do ideg = 1,sym%degen(gamma)
         !
         iroot = iroot + 1
         !
       enddo
       !
    enddo loop_level
    !
    nroots = iroot
    nlevels = jlevel
    !
    do ilevel=1,contr(iclasses)%nlevels
       deallocate(contr(iclasses)%eigen(ilevel)%vect)
       deallocate(contr(iclasses)%eigen(ilevel)%nu)
       deallocate(contr(iclasses)%eigen(ilevel)%normal)
    enddo
    !
    !deallocate(contr(iclasses)%eigen)
    !deallocate(contr(iclasses)%ilevel)
    !deallocate(contr(iclasses)%iroot)
    !deallocate(contr(iclasses)%ideg)
    !
    !call ArrayStop('contr%eigen%vect')
    !
    !allocate (contr(iclasses)%eigen(nroots),contr(iclasses)%iroot(nroots,sym%maxdegen),&
    !          contr(iclasses)%ilevel(nroots),contr(iclasses)%ideg(nroots),stat=alloc)
    !
    !call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%ilevel),kind(contr(iclasses)%ilevel))
    !call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%ideg),kind(contr(iclasses)%ideg))
    !call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%iroot),kind(contr(iclasses)%iroot))
    !
    iroot = 0
    !
    do ilevel=1,nlevels
       !
       gamma = igamma(ilevel)
       !
       level_degen = sym%degen(gamma)
       !
       allocate (contr(iclasses)%eigen(ilevel)%vect(dimen,level_degen),&
                 contr(iclasses)%eigen(ilevel)%nu(0:Nmodes),&
                 contr(iclasses)%eigen(ilevel)%normal(0:Nmodes),stat=alloc)
                 !
       !call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%eigen(ilevel)%vect),& 
       !                                   kind(contr(iclasses)%eigen(ilevel)%vect))
       !call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%eigen(ilevel)%nu),& 
       !                                   kind(contr(iclasses)%eigen(ilevel)%nu))
       !call ArrayStart('contr%eigen%vect',alloc,size(contr(iclasses)%eigen(ilevel)%normal),& 
       !                                   kind(contr(iclasses)%eigen(ilevel)%normal))
       !
       nu_i(:) = PT%quanta%icoeffs(ilevel,:)
       !
       contr(iclasses)%eigen(ilevel)%vect(:,:) = eigen(ilevel,:,:)
       contr(iclasses)%eigen(ilevel)%degeneracy = sym%degen(gamma)
       contr(iclasses)%eigen(ilevel)%nu(:) = nu_i(:)
       contr(iclasses)%eigen(ilevel)%normal = nu_i
       contr(iclasses)%eigen(ilevel)%isym = gamma
       contr(iclasses)%eigen(ilevel)%gamma = trim(sym%label(gamma))
       contr(iclasses)%max_degen = max(contr(iclasses)%max_degen,contr(iclasses)%eigen(ilevel)%degeneracy)
       !
       termvalue = energy(ilevel)-ZPE
       contr(iclasses)%eigen(ilevel)%value = energy(ilevel)
       !
       if (job%verbose>=2) then 
         !
         write(my_fmt,'(a,i0,a)') "(i7,f18.8,2i4,2x,a4,",nmodes,"i4)"
         !
         write(out,my_fmt) ilevel,termvalue,sym%degen(gamma),gamma,trim(contr(iclasses)%eigen(ilevel)%gamma),nu_i(1:)
         !
       end if 
       !
       do ideg = 1,sym%degen(gamma)
         !
         iroot = iroot + 1
         contr(iclasses)%ideg(iroot)   = ideg
         contr(iclasses)%ilevel(iroot) = ilevel
         contr(iclasses)%iroot(ilevel,ideg) = iroot
         !
       enddo
       !
       contr(iclasses)%eigen(ilevel)%degeneracy = level_degen
       !
    enddo
    !
    nroots  = iroot
    !
    contr(iclasses)%nlevels = nlevels
    contr(iclasses)%nroots  = nroots
    contr(iclasses)%dimen   = dimen
    !  
    deallocate(energy,igamma,eigen,eigen_t)
    call ArrayStop('PThamiltonianMat_reduced-eigen')
    !
    deallocate(oldlevel)
    call ArrayStop('PThamiltonianMat_reduced-oldlevel')
    !
    call TimerStop('PThamil-contr..Mat')
    !
  end subroutine PThamiltonianMat_contracted_reduced



!
! The recursive perturbation theory is residing here 
!
  subroutine PTrun(Norder)
    !
    implicit none
    !
    integer(ik),intent(in)     :: Norder
    real(rk)                   :: F
    integer(ik)                :: ipol,jpol,jpol_t,ib,jb,ipower,nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
    integer(ik)                :: imode,jb_t,ib_t
    real(rk)                   :: Delta_ener,H12,H21
    !
    !
    if (job%verbose>=4) write(out,"(/'PTrun/start: recursive PT for the order ',i6)") Norder
    !
    call TimerStart('PTrun')
    !
    if (job%verbose>=4) then 
        write(out,"('   ipol     ib     jb          F')") 
    endif 
    !
    !
    do ipol = 0,PT%Polyad_max
       !
       do jpol = 0,PT%Polyad_max
          !
          !
          ! within the same resonans block we compute Hpol(Norder,ipol)%coeffs matrix
          !
          if (ipol==jpol) then
              !
              do ib = 1,PT%MaxIndex_nu(ipol)
                 !
                 nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,ib)
                 !
                 do jb = 1,PT%MaxIndex_nu(jpol)
                    ! 
                    nu_j(:) = PT%Index_nu(jpol)%icoeffs(:,jb)
                    !
                    ! We need to compute F - the right side of the PT equation
                    !
                    F = PTrightsideonflyF(Norder,ipol,ib,jb,jpol)
                    !
                    ! Hpol - resonanse energy matrix
                    !
                    PT%Hpol(Norder,ipol)%coeffs(ib,jb) = F
                    !
                    if (job%verbose>=4) then 
                        write(out,"(3i6,f18.8)") ipol,ib,jb,F
                    endif 
                    !
                    ! We assume that theta(i,i) = 0 and theta(i,j) = 0
                    ! for the resonanse contribution, therefore X = -theta(j,i)*(ener0_i-ener0_j) = 0
                    ! otherwise this term X must be included into Hpol: 
                    ! Hpol =  coeffs(i,j) + X
                    !
                 enddo
             enddo
          endif
       enddo
    enddo
    ! 
    ! Here we compute theta(Norder,ipol)%coeffs matrix
    ! 
    ! We use ipower to estimate ranges for largest quanta. 
    ! For the harmonic basis sets overlaping equals 1 <v|q|v+/-1>, i.e. the zero order hamiltonian
    ! connects |v> with |v+/-2>. 
    ! Then every new PT order brings additional level of overlaping, i.e.
    ! at the first  order <v|H_1|v+dv> = 0 for dv > 3
    ! at the second order <v|H_2|v+dv> = 0 for dv > 2*3
    ! at norder <v|H_norder|v+dv> = 0 for dv > ipower = norder*3
    ! In case of nonharmonic basis sets we take into account also the overlapping <v|q|v +/-i_overlapp> /=0
    ! We use this property to speed up the calculations evaluating integrals only within the non-zero ranges
    ! We also use an artificial limitation: 
    ! everthing that excede the predifined PT%ranges is also disregared. 
    !
    ipower = norder*(job%pot_pt_shift+1_ik)
    !
    if (job%verbose>=4) then 
        write(out,"('   ipol     ib     jb          F             Delta_ener            theta')") 
    endif 
    !
    ! If this is the last PT order, we will never need the corresponding theta. Lets skip it, then. 
    !
    if (Norder/=PT%Norder) then
       !
       do ipol = 0,PT%Polyad_max
          !
          do ib = 1,PT%MaxIndex_nu(ipol)
             !
             nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,ib)
             !
             do jb = 1,PT%RangeOrder(Norder)  ! PT%Maxcoeffs
                !
                nu_j = PT%active_space%icoeffs(:,jb)
                   !
                   ! 1st level of filter: check that every mode j is within the range ipower*PT%overlap(:)
                   !
                if (all( abs(nu_i(1:PT%Nmodes)-nu_j(1:PT%Nmodes) )<=ipower*PT%overlap(1:PT%Nmodes) ) .and. & 
                   !
                   ! 2d  level of filter: check that all together modes is within the range ipower*maxoverlap
                   !
                    sum( abs( nu_i(1:PT%Nmodes)-nu_j(1:PT%Nmodes) ) ) <=ipower*PT%maxoverlap .and. & 
                   !
                   ! 3d  level of filter: check that all modes are within the predifined ranges 
                   !
                    all( nu_j(1:)>=PT%range(1,1:) ).and. all( nu_j(1:)<=PT%range(2,1:) ) ) then
                   !
                   jpol_t =  PTpolyadRules(nu_j)
                   !
                   ! We calculate theta(Norder,ipol)%coeffs(ib,jb) only if this elements is not from the "ipol" block 
                   !
                   if (jpol_t/=ipol) then 
                      !
                      F = PTrightsideonflyF(Norder,ipol,ib,jb)
                      !
                      Delta_ener = PT%Ener0%coeffs(1,jb)-PT%Hpol(0,ipol)%coeffs(ib,ib)
                      !
                      ! we assume that Delta_ener .ne. 0 by definition, but we check it just in case
                      !
                      if ( abs(Delta_ener)<spacing(1.0d0)) then 
                         write(out,"('PTrun: Delta_ener is zero for ipol,ib,jb ',e18.8,3i7)") Delta_ener,ipol,ib,jb
                         stop 'PTrun: Delta_ener is zero'
                      endif 
                      !
                      PT%theta(Norder,ipol)%coeffs(ib,jb) =-F/Delta_ener
                      !
                      ! Check for the main PT-condition to be valid, i.e. F/Delta_ener << 1
                      !
                      if ( abs(F/Delta_ener)>job%PTthreshold) then 
                         write(out,"('PTrun: Pert. theory condition, F/Delta_ener>threshold ',2d18.8)") F/Delta_ener,job%PTthreshold
                         write(out,"('       Norder, ipol, ib, jb, F,Delta_ener: ',4i6,2f18.8)") Norder, ipol, ib, jb,F,Delta_ener
                         write(out,"(40i5)")  ( nu_i(imode),imode=0,min(40,PT%Nmodes) )
                         write(out,"(40i5)")  ( nu_j(imode),imode=0,min(20,PT%Nmodes) )
                         stop 'PTrun: Pert. theory condition F/Delta_ener is invalid'
                      endif 
                      !
                      if (job%verbose>=4) then 
                          if (abs(F)>sqrt(small_)) then 
                              write(out,"(3i7,3f18.8,' ->',30i5)") ipol,ib,jb,F,Delta_ener,F/Delta_ener,&
                                                                 ( nu_j(imode),imode=0,min(30,PT%Nmodes) )
                          endif
                      endif 
                      !
                      !
                   endif
                   !
                endif
                !
             enddo
             !
          enddo
          !
       enddo
       !
    endif
    !
    ! We print out the non-symmetrized Hpol matrix 
    !
    if (job%verbose>=4) then 
       write(out,"('PTrun: Hpol matrix values')") 
       do ipol = 0,PT%Polyad_max
          write(out,"('       Polyad = ',i5)") ipol
          do ib = 1,PT%MaxIndex_nu(ipol)
             write(out,"(40e14.5)") (PT%Hpol(Norder,ipol)%coeffs(ib,jb),jb=1,min(40,PT%MaxIndex_nu(ipol)))
          enddo 
       enddo
    endif 
    !
    ! We asume that the matrix Hpol is non symmetric.
    ! In order to symmetrize it, we employ theta coefficients, 
    ! which are so far were asemed to be zero within the resonanse block. 
    ! Now we define it in such a wy, that the Hpol becomes symmetric. 
    !
    ! Hpol'_{kl} =   1/2 (Hpol_{kl} + Hpol_{lk})
    ! theta_{kl} = -1/2 (Hpol_{kl} - Hpol_{lk})/(E_k - E_l)
    !
    do ipol = 0,PT%Polyad_max
       do ib = 1,PT%MaxIndex_nu(ipol)
          !
          !
          nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,ib)
          !
          ! the corresponding index for these quanta in the active space
          !
          ib_t = PTnu_index(nu_i,ipol)
          !
          do jb = 1,ib-1
             !
             H12 = PT%Hpol(Norder,ipol)%coeffs(ib,jb)
             H21 = PT%Hpol(Norder,ipol)%coeffs(jb,ib)
             !
             Delta_ener = PT%Hpol(0,ipol)%coeffs(ib,ib)-PT%Hpol(0,ipol)%coeffs(jb,jb)
             !
             nu_j(:) = PT%Index_nu(ipol)%icoeffs(:,jb)
             !
             jb_t = PTnu_index(nu_j,ipol)
             !
             ! Check for the main PT-condition to be valid, i.e. F/Delta_ener << 1
             !
             F = 0.5_rk*(H12-H21)
             !
             if (abs(F)>10.0*sqrt(small_)) then 
                !
                if ( abs(Delta_ener)<10.0*small_ ) then 
                   write(out,"('PTrun: Hpol cannot symmetrized for H12-H21 is big and E1-E2 small',2e18.8)") F,Delta_ener
                   write(out,"('       Norder, ipol, ib, jb: ',4i6,2f18.8)") Norder, ipol, ib, jb
                   write(out,"(40i5)")  ( nu_i(imode),imode=0,min(40,PT%Nmodes) )
                   write(out,"(40i5)")  ( nu_j(imode),imode=0,min(40,PT%Nmodes) )
                   stop 'PTrun-symm: Hpol cannot be symmetrized'
                endif 
                !
                PT%Hpol(Norder,ipol)%coeffs(ib,jb) = 0.5_rk*(H12+H21)
                PT%Hpol(Norder,ipol)%coeffs(jb,ib) = 0.5_rk*(H12+H21)
                !
                ! write(out,"('ipol,ib,jb,ib_t,jb_t, H12-H21 and E1-E2',5i6,2e18.8)") ipol,ib,jb,ib_t,jb_t,F,Delta_ener
                !
                ! theta is only defined for 
                !
                if (Norder<PT%Norder) then
                   !
                   PT%theta(Norder,ipol)%coeffs(ib,jb_t) =-F/Delta_ener
                   PT%theta(Norder,ipol)%coeffs(jb,ib_t) =-F/Delta_ener
                   !
                endif
                !
             endif
             !
          enddo
          ! 
       enddo 
    enddo

    !
    ! We print out the symmetrized Hpol matrix 
    !
    if (job%verbose>=2) then 
       write(out,"('PTrun: Hpol symmetrized matrix values')") 
       do ipol = 0,PT%Polyad_max
          write(out,"('       Polyad = ',i5)") ipol
          do ib = 1,PT%MaxIndex_nu(ipol)
             write(out,"(40e14.5)") (PT%Hpol(Norder,ipol)%coeffs(ib,jb),jb=1,min(40,PT%MaxIndex_nu(ipol)))
          enddo 
       enddo
    endif 
    !
    ! Check if the matrix is symmetric
    !
    do ipol = 0,PT%Polyad_max
       do ib = 1,PT%MaxIndex_nu(ipol)
          do jb = 1,ib-1
             if ( abs( PT%Hpol(Norder,ipol)%coeffs(ib,jb)-PT%Hpol(Norder,ipol)%coeffs(jb,ib) ) > 10.0*sqrt(small_) ) then 
                 write(out,"('PTrun: Warning! Matrix Hpol is not symmetric for ipol,ib,jb: ',3i7,2d17.7)") ipol,ib,jb, &
                           PT%Hpol(Norder,ipol)%coeffs(ib,jb),PT%Hpol(Norder,ipol)%coeffs(jb,ib)
             endif 
          enddo 
       enddo 
    enddo
    !
    ! Precalculated block-diagonal matrixes Hpol= sum(Hpol(:)) are diagonalized, which gives eigenvalues. 
    !
    call PTdiagonalization(Norder)
    !
    call TimerStop('PTrun')
    !
    if (job%verbose>=4) write(out,"('PTrun/end')") 


  end subroutine PTrun

!
! This function is an alternative to PTrightsideonflyF routine.  
! It calculates the Hmat matrix elements on the fly. It is expected that it can be faster to do it in this way, 
! rather than precalculatign Hmat. 
!
  function PTrightsideonflyF(Norder,ipol,ib,jb,jpol)   result(F)
    !
    implicit none
    !
    integer(ik),intent(in)           :: Norder,ipol,ib,jb
    integer(ik),intent(in),optional  :: jpol
    real(rk)                         ::  F

    integer(ik)                  :: iorder,ipower,kb,nu_k(0:PT%Nmodes),nu_i(0:PT%Nmodes),nu_j(0:PT%Nmodes)
    real(rk)                     :: F_t,mat_elem
    type(PTcoeffsT),pointer      :: h,th

    !
    !
    if (verbose>=6) write(out,"(/'PTrightsideF/start: right-side of the PT equation; order, ipol, ib, jb',4i5)") Norder, ipol, ib,jb
    call TimerStart('PTrightsideonflyF')

    ! F function at PTorder is constructed from theta, Hmat, and Hpol for iorder < PTorder,
    ! i.e. all relevant theta and Hpol are supposed to be already computed 
    ! Hmat are being calculated on the fly
    !
    ! ipower is the current power of the norlam coordinates at the current norder-level, i.e. 
    ! Hamiltonia(norder) is proportional to q^power = q_1^k1 q2^k2 q3^k3 ... where k1+k2+k3+...= power 
    ! power = norder + pot_pt_shift <= standartly power = norder + 2, because quadratic part q^2 belongs  to the zero order
    !
    nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,ib)
    !
    ! if it is for the resonant block 
    !
    if (present(jpol)) then 
       nu_j(:) = PT%Index_nu(jpol)%icoeffs(:,jb)
    else
       nu_j(:) = PT%active_space%icoeffs(:,jb)    
    endif
    !
    !
    mat_elem = 0.0_rk
    !
    ! iorder = Norder term
    !
    th => PT%theta(0,ipol)
    ! 
    if (all( nu_j(1:)>=PT%range(1,1:) ).and. all( nu_j(1:)<=PT%range(2,1:) ) .and. &
        !
        all( nu_i(1:)>=PT%range(1,1:) ).and. all( nu_i(1:)<=PT%range(2,1:) ) ) then
        !
        if (trim(job%PTtype)=='POWERS'.or. &
           (trim(job%PTtype)=='DIAGONAL'.and.any( nu_j(:)/=nu_i(:) ) ) ) then
            !
            mat_elem = FLmatrixelements(Norder,nu_j,nu_i)
            !
        endif
        !
    endif 
    !
    !call FLmatrixelements(norder,nu_j,nu_i,mat_elem)
    !
    F_t = mat_elem  ! th%coeffs(ib,ib) = 1
    !
    if (verbose>=7) write(out,"('F_t (0) = ',d18.8)") F_t
    if (verbose>=7) write(out,"('iorder,kb,mat_elem,th%coeffs(ib,kb) ')")
    !
    if (verbose>=7) write(out,"('norder,mat_elem ',i7,d18.8)") norder,mat_elem
    !
    do iorder = 1,Norder-1
       !
       ipower = iorder + job%pot_pt_shift
       !
       th => PT%theta(Norder-iorder,ipol)
       h  => PT%Hpol(iorder,ipol)
       !
       do kb = 1,PT%RangeOrder(Norder-iorder)
          !
          ! Here we try to calculate the Hmat matrix elements on the fly. 
          !
          nu_k = PT%active_space%icoeffs(:,kb)
          !
          !mat_elem = 0.0_rk
          !
          if (all( abs(nu_j(1:PT%Nmodes)-nu_k(1:PT%Nmodes))<=ipower*PT%overlap(1:PT%Nmodes) )    .and. & 
              !
              sum( abs( nu_j(1:PT%Nmodes)-nu_k(1:PT%Nmodes) ) ) <=ipower*PT%maxoverlap .and. & 
              !
              all( nu_k(1:)>=PT%range(1,1:) ).and. all( nu_k(1:)<=PT%range(2,1:) ) .and.&
              !
              all( nu_j(1:)>=PT%range(1,1:) ).and. all( nu_j(1:)<=PT%range(2,1:) ) ) then 
              !
              if (trim(job%PTtype)=='POWERS'.or. &
                 (trim(job%PTtype)=='DIAGONAL'.and.any( nu_j(:)/=nu_k(:) ) )) then
                  !
                 mat_elem = FLmatrixelements(iorder,nu_j,nu_k)
                 !
                 F_t = F_t + mat_elem*th%coeffs(ib,kb)
                  !
              endif
              !
              if (verbose>=7) write(out,"(2i7,2d18.8)") iorder,kb,mat_elem,th%coeffs(ib,kb)
              !
          endif 
          !
       enddo 
       !
       if (.not.present(jpol)) then 
          !
          !jpol_t =  PTpolyadRules(nu_j)
          !
          !if (all(nu_j(:)<=PT%quantaMax(Norder-iorder))) then
          !
          continue 
          !
          if (jb<=PT%RangeOrder(Norder-iorder)) then
             !
             do kb = 1,PT%MaxIndex_nu(ipol)
                !
                F_t = F_t - th%coeffs(kb,jb)*h%coeffs(ib,kb)
                !
             enddo
             !
             !if (jpol_t/=jpol) then 
             !   write(out,"('PTrightsideonflyF: jpol is not consistent with jpol_t:',2i8)") jpol,jpol_t
             !   stop 'PTrightsideonflyF: jpol is wrong'
             !endif 
             !
             ! Important! We assume that all theta(iorder,ipol)%fields(ib,kb) = 0
             !            for kb from the ipol-block 
             !
             !if (jpol_t==ipol) then 
             !
             !do kb = 1,PT%Maxcoeffs
             !   !
             !   nu_k(:) = PT%active_space%icoeffs(:,kb)
             !   !
             !   kpol_t =  PTpolyadRules(nu_k)
             !   !
             !   if (kpol_t<=PT%Polyad_max) then 
             !     !
             !     lb = PTnu_index(nu_k,ipol)
             !     !
             !     F_t = F_t - th%coeffs(ib,kb)*h%coeffs(jb,lb)
             !     !
             !   endif 
             !   !
             !enddo
             !
          endif
          !
          if (verbose>=7) write(out,"('iorder,F_t ',i7,d18.8)") iorder,F_t
          !
       endif
       !
    enddo
    !
    F  = F_t
    !
    if (verbose>=7) write(out,"(' F_t ',d18.8)") F_t
    !
    call TimerStop('PTrightsideonflyF')
    !
    if (verbose>=6) write(out,"('PTrightsideF/end')") 
    !
  end function PTrightsideonflyF



!
! Here we calculate the final eigenvalues (eigenfunctions are optional). 
! 1. We simply sum up Hpol(iorder) block-diagonal matrixes and 
! diagonalize them using a lapack routine
!
  subroutine PTdiagonalization(Norder)
     !
     implicit none
     !
     integer(ik),intent(in)       :: Norder   
     integer(ik)                  :: ipol
     integer(ik)                  :: iorder,ib,jb,imode,nu_i(0:PT%Nmodes),alloc,dimen,maxterm
     real(rk),allocatable         :: b(:,:),a(:,:)
     integer(ik)                  :: eigen_assignment(0:PT%Polyad_max,PT%Maxcoeffs)
     real(rk)                     :: termvalue,MaxEigenvects


     if (job%verbose>=5) write(out,"(/'PTdiagonalization/start: diagonalization of the block-diagonal forms')") 
     if (job%verbose>=3) write(out,"(/'Diagonalization of the block-diagonal forms')") 
     !
     !
     ! eigenvalues - field where we store the eigenvalues 
     ! must have been already allocated 
     !
     ! We diagonalize the Hpol matrix at every PT-order, summing up all previouse contribution. 
     ! In this way we can track the PT convergence 
     !
     do ipol = 0,PT%Polyad_max
        !
        dimen = PT%MaxIndex_nu(ipol)
        !
        ! The diagonalization will be done with Lapack. 
        ! We will need matrix "a" prepared in appropriate way 
        !
        allocate (a(dimen,dimen),b(dimen,1),stat=alloc)
        if (alloc/=0) then
           write (out,"(' PTdiagonalization/Error  ',i9,' trying to allocate array for a and b')") alloc
           stop 'PTdiagonalization, a and b  - out of memory'
        end if
        !
        ! Hpol - sum up all perturbation orders  -> "a"
        !
        a = 0  
        !
        do ib = 1,dimen
            do jb = 1,dimen
               !
               do iorder = 0,Norder
                  a(ib,jb) = a(ib,jb) + PT%Hpol(iorder,ipol)%coeffs(ib,jb)
               enddo
               !
               if (job%verbose>=6) then 
                  write(out,"(3i7,3f18.8)") ipol,ib,jb,a(ib,jb),a(jb,ib),a(ib,jb)-a(jb,ib)
               endif
               !
            enddo
        enddo 
        !
        b = 0
        !
        !  diagonalization with lapack_syev
        !
        call lapack_syev(a,b(:,1))
        !
        !
        ! Store eigenvalues
        !
        PT%eigenvalues(norder,ipol)%coeffs(:,1) = b(:,1)
        !
        ! Determine the assignment of the eigenvectors using the largest coefficient principle 
        ! 
        do ib=1,dimen
           !
           MaxEigenvects  = small_
           MaxTerm  = 1
           !
           do jb=1,dimen
              if (abs(a(jb,ib))>=MaxEigenvects) then 
                  MaxEigenvects = abs( a(jb,ib) )
                  MaxTerm = jb
              endif
           enddo
           !
           eigen_assignment(ipol,ib) = MaxTerm
           !
        enddo
        !
        !
        deallocate(a,b)
     enddo 
     !
     ! Printing out the convergence
     !
     write(out,"(/'Eigenvalues: convergence')") 
     !
     do ipol = 0,PT%Polyad_max
        !
        dimen = PT%MaxIndex_nu(ipol)
        !
        do ib = 1,dimen
           nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,ib)
           write(out,"(2i7,f18.8,' <=',f18.8,40d14.4)") & 
                     ipol,ib,PT%eigenvalues(Norder,ipol)%coeffs(ib,1),& 
                     PT%eigenvalues(0,ipol)%coeffs(ib,1), &
                    (PT%eigenvalues(iorder,ipol)%coeffs(ib,1)-PT%eigenvalues(iorder-1,ipol)%coeffs(ib,1),&
                     iorder=1,min(40,Norder))
           !
        enddo 
        !
     enddo

     !
     ! Reporting the final results 
     !
     write(out,"(/'Eigenvalues:',/'    pol      i       value        quanta')") 
     !
     do ipol = 0,PT%Polyad_max
        !
        dimen = PT%MaxIndex_nu(ipol)
        !
        do ib = 1,dimen
          jb = eigen_assignment(ipol,ib)
          nu_i(:) = PT%Index_nu(ipol)%icoeffs(:,jb)
          termvalue = PT%eigenvalues(Norder,ipol)%coeffs(ib,1)-PT%eigenvalues(Norder,0)%coeffs(1,1)
          write(out,"(2i7,f18.8,40i3)") ipol,ib,termvalue,(nu_i(imode),imode=0,min(40,PT%Nmodes))
        enddo 
        !
     enddo
     !
     if (job%verbose>=3) write(out,"('Done!')") 
     !
     if (job%verbose>=5) write(out,"('PTdiagonalization/end')") 
     !
  end subroutine PTdiagonalization   

    subroutine PT_exclude_specific_modes(imode1,imode2,rpower,diagonal_)
      !
      implicit none
      !
      !
      integer(ik),intent(in)           :: imode1,imode2
      integer(ik),optional,intent(in)  :: rpower
      !
      logical,intent(in),optional      :: diagonal_
      !
      integer(ik)  :: excluded_power,iterm,k(PT%Nmodes),k1,k2
      logical                          :: diagonal
      !
      type(PTcoeffT),pointer      :: fl
      character(len=cl)  :: job_is
      !
      if (present(diagonal_)) then 
        diagonal = diagonal_
      else
        diagonal = .true.
      endif 
      !
      fl => me%poten
      !
      fl%iorder = 0 
      !
      loop_term : do iterm = 1,fl%Ncoeff
         !
         k(:) = fl%IndexQ(:,iterm)
         !
         ! For the zero order case we allow only diagonal terms
         !
         ! Check if the current iterm belongs to the present calculation case
         ! another words, if poten*xi^k belongs to the current perturb. order
         !
         excluded_power = sum(k(1:imode1-1)) + sum(k(imode2+1:PT%Nmodes))
         !
         if (excluded_power>0) then 
           fl%iorder(iterm) = 1
           cycle loop_term
         endif
         !
         if (imode1>0.and.imode2<=PT%Nmodes) then 
           !
           if (.not.present(rpower)) then 
             !
             write(out,"('PT_exclude_specific_modes: illegal use of rpower, it has to present here')")
             stop 'PT_exclude_specific_modes: illegal use of rpower'
             !
           endif
           !
           excluded_power = sum(k(imode1:imode2))
           if (excluded_power>rpower) fl%iorder(iterm) = 1
           !
           if (diagonal.and..not.any(excluded_power==k(imode1:imode2))) fl%iorder(iterm) = 1
           !
         endif 
         !
       enddo loop_term
       !
       ! Vibrational part of the kinetic operator g_vib
       !
       do k1 = 1,PT%Nmodes
          do k2 = 1,PT%Nmodes
             !
             if ( me%gvib(k1,k2)%Ncoeff<1 ) cycle
             !
             fl => me%gvib(k1,k2)
             !
             fl%iorder = 0
             !
             do iterm = 1,fl%Ncoeff
                !
                k(:) = fl%IndexQ(:,iterm)
                !
                excluded_power = sum(k(1:imode1-1)) + sum(k(imode2+1:PT%Nmodes))
                !
                if (excluded_power>0.or.imode1>k1.or.k1>imode2.or.&
                                        imode1>k2.or.k2>imode2)  &
                                                  fl%iorder(iterm) = 1
               !
               if (imode1>0.and.imode2<=PT%Nmodes) then 
                 !
                 excluded_power = sum(k(imode1:imode2))
                 if (excluded_power>rpower-2) fl%iorder(iterm) = 1
                 !
                 if (diagonal.and..not.any(excluded_power==k(imode1:imode2))) fl%iorder(iterm) = 1
                 !
                 if (diagonal.and.k1/=k2) fl%iorder(iterm) = 1
                 !
               endif 
                !
             enddo
             ! 
          enddo
       enddo
       !
       ! Rotational and Coriolis parts
       !
       if (FLrotation) then 
         !
         do k1 = 1,3
            do k2 = 1,3
               !
               fl => me%grot(k1,k2)
               !
               if ( me%grot(k1,k2)%Ncoeff<1 ) cycle
               !
               fl%iorder = 0
               !
               do iterm = 1,fl%Ncoeff
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  !
                  excluded_power = sum(k(1:imode1-1)) + sum(k(imode2+1:PT%Nmodes))
                  !
                  if (excluded_power>0) fl%iorder(iterm) = 1
                  !
                  if (imode1>0.and.imode2<=PT%Nmodes) then 
                    !
                    excluded_power = sum(k(imode1:imode2))
                    if (excluded_power>rpower-2) fl%iorder(iterm) = 1
                    !
                  endif 
                  !
               enddo
               ! 
            enddo
         enddo
         !
         do k1 = 1,PT%Nmodes
            do k2 = 1,3
               !
               fl => me%gcor(k1,k2)
               !
               if ( me%gcor(k1,k2)%Ncoeff<1 ) cycle
               !
               fl%iorder = 0
               !
               do iterm = 1,fl%Ncoeff
                  !
                  k(:) = fl%IndexQ(:,iterm)
                  !
                  excluded_power = sum(k(1:imode1-1)) + sum(k(imode2+1:PT%Nmodes))
                  !
                  if (excluded_power>0.or.imode1>k1.or.k1>imode2) fl%iorder(iterm) = 1
                  !
                  if (imode1>0.and.imode2<=PT%Nmodes) then 
                    !
                    excluded_power = sum(k(imode1:imode2))
                    if (excluded_power>rpower-2) fl%iorder(iterm) = 1
                    !
                  endif 
                  !
               enddo
               ! 
            enddo
         enddo
         !
       endif
       !
       if (FLl2_coeffs) then
          do k1 = 1,PT%Nmodes
             do k2 = 1,PT%Nmodes
                !
                if ( me%L2(k1,k2)%Ncoeff<1 ) cycle
                !
                fl => me%L2(k1,k2)
                !
                fl%iorder = 0
                !
                do iterm = 1,fl%Ncoeff
                   !
                   k(:) = fl%IndexQ(:,iterm)
                   !
                   excluded_power = sum(k(1:imode1-1)) + sum(k(imode2+1:PT%Nmodes))
                   !
                   if (excluded_power>0.or.imode1>k1.or.k1>imode2.or.&
                                                imode1>k2.or.k2>imode2) then
                      fl%iorder(iterm) = 1
                      cycle 
                   endif
                   !
                   if (imode1>0.and.imode2<=PT%Nmodes) then 
                     !
                     excluded_power = sum(k(imode1:imode2))
                     if (excluded_power>rpower) fl%iorder(iterm) = 1
                     !
                     !if (diagonal.and..not.any(excluded_power==k(imode1:imode2))) fl%iorder(iterm) = 1
                     !
                     !if (diagonal.and.k1/=k2) fl%iorder(iterm) = 1
                     !
                   endif 
                   !
                enddo
                ! 
             enddo
          enddo
          !
          ! copy the iorder-object to a similar object into the field-unit:
          !
          job_is = 'L2vib'
          do k1 = 1,PT%Nmodes
             do k2 = 1,PT%Nmodes
                if ( me%L2(k1,k2)%Ncoeff<1 ) cycle
                call FLread_iorder_send(job_is,k1,k2,me%L2(k1,k2)%iorder(:))
             enddo
          enddo
          !
       endif
       !
       ! copy the iorder-object to a similar object into the field-unit:
       !
       job_is = 'poten'
       call FLread_iorder_send(job_is,1,1,me%poten%iorder(:))
       !
       job_is = 'gvib'
       do k1 = 1,PT%Nmodes
          do k2 = 1,PT%Nmodes
             if ( me%gvib(k1,k2)%Ncoeff<1 ) cycle
             call FLread_iorder_send(job_is,k1,k2,me%gvib(k1,k2)%iorder(:))
          enddo
       enddo
       !
       job_is = 'grot'
       do k1 = 1,3
          do k2 = 1,3
             if ( me%grot(k1,k2)%Ncoeff<1 ) cycle
             call FLread_iorder_send(job_is,k1,k2,me%grot(k1,k2)%iorder(:))
          enddo
       enddo
       !
       job_is = 'gcor'
       do k1 = 1,PT%Nmodes
          do k2 = 1,3
             if ( me%gcor(k1,k2)%Ncoeff<1 ) cycle
             call FLread_iorder_send(job_is,k1,k2,me%gcor(k1,k2)%iorder(:))
          enddo
       enddo
       !
    end subroutine PT_exclude_specific_modes

    subroutine partfunc_matexp_taylor(dimen,m,norm_thresh,max_deg,spur_thresh,max_order,spur)
       !
       implicit none
       !
       !
       integer(ik), intent(in)             :: dimen
       real(rk)                            :: m(:,:)
       real(rk), intent(in)                :: norm_thresh
       integer(ik), intent(in)             :: max_deg
       real(rk), intent(in)                :: spur_thresh
       integer(ik), intent(in)             :: max_order
       real(rk)                            :: spur,factor,temp1,temp2
       real(rk),allocatable                :: mexp(:,:)
       !
       integer(ik)                         :: info, iorder, idimen,jdimen,deg,kdimen,lda,ndimen,ldimen,i
       integer(hik)                        :: matsize
       real(rk)                            :: spur0, norm
       real(rk),allocatable                :: mcurr(:,:),vector(:),mcurr_(:,:),vector_(:),m_t(:)
       double precision                    :: alpha = 1.0d0,beta=0.0d0,zero=0.0_rk
       !
       integer(ik)                         :: cdimen,j_a,j_b
       integer(ik),allocatable             :: icoeff(:),icoeff_a(:),icoeff_b(:)
          !
          ! perform squaring
          !
          write(out, '(/1x, a/1x, a, 1x, a)') 'perform squaring', 'deg of 2', 'norm'
          !
          if (job%verbose>=2) call TimerStart('Partition function my mat-exp')
          !
          deg = 0
          !
          ndimen = size(m,dim=1)
          kdimen = size(m,dim=2)
          !
          norm = max( abs( maxval( m(:,kdimen),dim=1 ) ),abs( minval( m(:,kdimen),dim=1 ) ) )
          !
          !norm = maxval(m) / real(2**deg, kind = rk)
          !
          do
                if (deg > max_deg) then
                      write(out, '(/1x, a, 1x, i3, 1x, a)') 'max degree of 2', max_deg, 'is reached'
                      exit
                end if
                !
                norm = norm / real(2**deg, kind = rk)
                !
                write(out, '(1x, i3, 1x, es16.8)') deg, norm
                !
                if (abs(norm) <= norm_thresh) exit
                deg = deg + 1
                !
          end do
          !
          factor = 1.0_rk/real(2**deg, kind = rk)
          !
          !$omp parallel do private(idimen,jdimen) shared(m) schedule(dynamic)
          do idimen = 1,ndimen
            do jdimen = 1,kdimen
                m(idimen,jdimen) = m(idimen,jdimen)*factor
            end do
          end do
          !$omp end parallel do
          !
          !m = m / real(2**deg, kind = rk)
          !
          ! allocate arrays for storig matrix power and matrix exponential
          !
          allocate(mcurr(dimen, dimen), mexp(dimen,dimen),stat = info)
          !
          matsize = int(dimen,hik)*int(dimen,hik)
          !
          call ArrayStart('mcurr',info,1_ik,kind(mcurr),matsize)
          call ArrayStart('mexp',info,1_ik,kind(mexp),matsize)
          !
          if (.not.job%sparse) then
             allocate(mcurr_(dimen, dimen),stat = info)
             call ArrayStart('mcurr',info,1,kind(mcurr_),matsize)
          endif
          !
          allocate (vector(dimen),stat=info)
          call ArrayStart('vector',info,size(vector),kind(vector))
          !
          if (job%verbose>4) call MemoryReport
          !
          ! initialize first term of Taylor expansion
          !
          !mcurr = 0
          !forall(idimen = 1:dimen) mcurr(idimen, idimen) = 1.0_rk

          !$omp parallel do private(idimen,jdimen) shared(m) schedule(dynamic)
          do idimen = 1,dimen
            do jdimen = 1,dimen
                mcurr(idimen,jdimen) = 0.0_rk
                mexp (idimen,jdimen) = 0.0_rk
            end do
            mcurr(idimen,idimen) = 1.0_rk
            mexp (idimen,idimen) = 1.0_rk
          end do
          !$omp end parallel do
          !
          iorder = 0
          spur   = real(dimen, kind = rk)
          spur0  = spur
          !
          write(out, '(/1x, a/1x, a, 13x, a)') 'compute exponential', 'ord', 'spur'
          !
          ! loop over Taylor series
          !
          do
                iorder = iorder + 1
                if (iorder > max_order) then
                      write(out, '(/1x, a, 1x, i3, 1x, a)') 'max exp degree', max_order, 'is reached'
                      exit
                end if
                !
                norm = 1.0_rk/real(iorder, kind = rk)
                !
                !alpha = norm
                !
                !omp parallel private(vector,info) shared(mcurr,spur)
                !
                !omp do private(idimen) schedule(dynamic)
                !
                select case (job%sparse)
                  !
                case (.true.)
                  !
                  kdimen = size(m,dim=1)-1
                  lda = kdimen+1
                  !
                  !call dsbmv('L',dimen,kdimen,norm,m,lda,mcurr(:,idimen),1,beta,vector,1)

                  cdimen = 0
                  do jdimen = 1,dimen
                     !
                     if (abs(mcurr(jdimen,1)) > job%thresh) then
                        cdimen = cdimen + 1
                        !
                     end if
                     !
                  end do
                  !
                  if (cdimen<0.7*dimen) then
                    !
                    !$omp parallel private(vector_,icoeff,icoeff_a,icoeff_b,m_t,info) shared(mcurr)
                    allocate (vector_(dimen),icoeff(dimen),icoeff_a(dimen),icoeff_b(dimen),m_t(dimen),stat=info)
                    if (info/=0) then
                       write (out,"(' Error ',i9,' trying to allocate array vector_')") info
                       stop 'FLinitilize_Potential, vector_  - out of memory'
                    end if
                    !
                    !$omp do private(idimen,cdimen,j_a,j_b,jdimen,temp1,temp2,ldimen,ndimen,i) schedule(dynamic)
                    do idimen = 1,dimen
                      !
                      cdimen = 0 
                      icoeff(:) = zero
                      j_a = 1
                      j_b = 1
                      !
                      icoeff_a = dimen+1
                      icoeff_b = 0
                      !
                      do jdimen = 1,dimen
                         !
                         if (abs(mcurr(jdimen,idimen)) > job%thresh) then
                            cdimen = cdimen + 1
                            icoeff(cdimen) = jdimen
                            m_t(cdimen) = mcurr(jdimen,idimen)
                            !
                            forall(i=j_a:jdimen-1) icoeff_a(i) = cdimen
                            !
                            !if (jdimen-kdimen>0) then 
                            !  icoeff_b(j_b:jdimen-kdimen) = cdimen
                            !  j_b = jdimen-kdimen+1
                            !endif
                            !
                            j_a = jdimen
                            !
                         end if
                         !
                         icoeff_b(jdimen) = cdimen
                         !
                      end do
                      !
                      !icoeff_a = dimen
                      !icoeff_b = 1
                      !
                      if (cdimen>0.and..false.) then 
                        !
                        !j_a = icoeff(1)
                        j_b = icoeff(cdimen)-1
                        !
                        do i = cdimen,1,-1
                           !
                           !jdimen = icoeff(i)-1
                           ndimen = max(icoeff(i)-kdimen,1)
                           !
                           !if (jdimen>0) icoeff_a(j_a:jdimen) = i
                           !if (ndimen>0) icoeff_b(ndimen:j_b) = i
                           !
                           forall(jdimen=ndimen:j_b) icoeff_b(jdimen) = i
                           !
                           !j_a = jdimen+1
                           j_b = ndimen-1  ! min(dimen,ndimen-kdimen)
                           !
                        enddo
                      endif 
                      !
                      vector_ = zero
                      do jdimen = 1,idimen
                          temp1 = norm*mcurr(jdimen,idimen)
                          temp2 = zero
                          vector_(jdimen) = vector_(jdimen) + temp1*m(1,jdimen)
                          ldimen = 1 - jdimen
                          ndimen = min(dimen,jdimen+kdimen)
                          !
                          if (abs(temp1)>job%thresh) then
                            !ndimen = min(dimen,jdimen+kdimen)
                            do i = jdimen + 1,ndimen
                                vector_(i) = vector_(i) + temp1*m(ldimen+i,jdimen)
                            enddo
                          endif
                          !
                          do i = icoeff_a(jdimen),icoeff_b(ndimen)
                            !
                            !if (i>icoeff_b(jdimen).and.icoeff(i)<=ndimen) then 
                            !  continue
                            !endif 
                            !
                          ! do i = 1,cdimen
                          !   if (icoeff(i)<jdimen + 1.or.icoeff(i)>ndimen) cycle
                             temp2 = temp2 + m(ldimen+icoeff(i),jdimen)*m_t(i)
                          enddo
                          !
                          !vector_(jdimen) = vector_(jdimen) + norm*temp2
                          mcurr(jdimen,idimen) = vector_(jdimen) + norm*temp2
                          mcurr(idimen,jdimen) = mcurr(jdimen,idimen)
                          !
                      enddo
                      !
                      !mcurr(:,idimen) = vector_(:)
                      !
                      !spur = spur + mcurr(idimen, idimen)
                      !
                    enddo
                    !$omp end do
                    !
                    deallocate(vector_,icoeff,icoeff_a,icoeff_b,m_t)
                    !$omp end parallel
                    !
                    !do idimen = 1,dimen
                    !  !
                    !  spur = spur + mcurr(idimen, idimen)
                    !  !
                    !enddo
                    !
                    !
                  else
                    !
                    !$omp parallel private(vector_,info) shared(mcurr)
                    allocate (vector_(dimen),stat=info)
                    if (info/=0) then
                       write (out,"(' Error ',i9,' trying to allocate array vector_')") info
                       stop 'FLinitilize_Potential, vector_  - out of memory'
                    end if
                    !
                    !$omp do private(idimen,jdimen) schedule(dynamic)
                    do idimen = 1,dimen
                       !
                       !istart = bterm(idimen,1) ; iend   = bterm(idimen,2)
                       !
                       !nelem = iend-istart+1
                       !
                       !call matvec_sym(idimen,bterm(1:idimen,1:2),m(1:idimen,1:dimen),mcurr(1:dimen,idimen),vector(1:idimen))
                       !
                       !call dgemv('T',nelem,idimen,alpha,mcurr(istart:iend,1:idimen),nelem,m(idimen,1:nelem),1,beta,vector(1:idimen),1)
                       !
                       !factor = abs(dot_product(mcurr(:,idimen),mcurr(:,idimen))-mcurr(idimen,idimen))
                       !
                       !if (factor>spur_thresh*0.001_rk) then 
                         !
                         !call TimerStart('Partition dsbmv')
                         !
                         call dsbmv('L',dimen,kdimen,norm,m,lda,mcurr(:,idimen),1,beta,vector_,1)
                         !
                         !call TimerStop('Partition dsbmv')
                         !
                         !call dcopy(dimen,vector,1,mcurr(:,idimen),1)
                         !
                         !omp parallel do private(jdimen) shared(mcurr) schedule(dynamic)
                         do jdimen = 1, dimen
                               mcurr(jdimen,idimen) = vector_(jdimen)
                               !mexp (jdimen,idimen) = mexp(jdimen,idimen) + mcurr(jdimen,idimen)
                         end do
                         !omp end parallel do
                         !
                       !else
                       !  !
                       !  !$omp parallel do private(jdimen) shared(mcurr) schedule(dynamic)
                       !  do jdimen = 1,dimen
                       !     if (jdimen==idimen) cycle
                       !      mcurr(jdimen,idimen) = 0
                       !  end do
                       !  !$omp end parallel do
                       !  !
                       !  mcurr(idimen,idimen) = mcurr(idimen,idimen)*m(1,idimen)
                       !  !
                       !endif 
                       !
                       !spur = spur + mcurr(idimen, idimen)
                       !
                    end do
                    !$omp end do
                    !
                    deallocate(vector_)
                    !$omp end parallel
                    !
                  endif
                  !
                case (.false.)
                  !
                  call dgemm('N','N',dimen,dimen,dimen,alpha,m,dimen,mcurr,dimen,beta,mcurr_,dimen)
                  !
                  !$omp parallel do private(idimen) reduction(+:spur) shared(mcurr) schedule(dynamic)
                  do idimen = 1, dimen
                        mcurr(idimen,:) = mcurr_(idimen,:)*norm
                        spur = spur + mcurr(idimen,idimen)
                  end do
                  !$omp end parallel do
                  !
                end select
                !
                call TimerStart('Partition mexp+')
                !
                !$omp parallel do private(idimen) shared(mexp) schedule(dynamic)
                do idimen = 1, dimen
                      mexp(idimen,:) = mexp(idimen,:) + mcurr(idimen,:)
                end do
                !$omp end parallel do
                !
                call TimerStop('Partition mexp+')
                !
                !$omp parallel do private(idimen) reduction(+:spur) schedule(dynamic)
                do idimen = 1, dimen
                      spur = spur + mcurr(idimen, idimen)
                end do
                !$omp end parallel do
                !
                write(out, '(1x, i3, 1x, es16.8)') iorder, spur
                !
                if (abs(spur - spur0) <= spur_thresh) exit
                spur0 = spur
          end do
          !
          do iorder = 1, deg
                !
                !mexp = matmul(mexp, mexp)
                !
                call dgemm('N','N',dimen,dimen,dimen,alpha,mexp,dimen,mexp,dimen,beta,mcurr,dimen)
                !
                !$omp parallel do private(idimen) shared(mexp) schedule(dynamic)
                do idimen = 1, dimen
                      mexp(idimen,:) = mcurr(idimen,:)
                end do
                !$omp end parallel do
                !
                ! mexp = mcurr
                !
          end do          
          !
          spur = 0
          !
          !$omp parallel do private(idimen) reduction(+:spur) schedule(dynamic)
          do idimen = 1, dimen
                spur = spur + mcurr(idimen, idimen)
          end do
          !$omp end parallel do
          !
          deallocate (vector)
          deallocate(mexp,mcurr)
          if (allocated(mcurr_)) deallocate(mcurr_)
          call ArrayStop('mcurr')
          call ArrayStop('mexp')
          call ArrayStop('vector')
          !
          if (job%verbose>=2) call TimerStop('Partition function my mat-exp')
          !
    end subroutine partfunc_matexp_taylor



! ------------------------------------------------------------------
!     matrix vector subroutine
!
  subroutine matvec_sym(n,bterm,h,z,w)
     !
     implicit none
     !
     integer,intent(in)  :: n,bterm(n,2)
     double precision,intent(in)  :: h(:,:),z(:)
     double precision,intent(out)  :: w(n)

     ! matvec performs w = hamil * z f
  
      double precision,parameter :: alpha = 1.0d0,beta=0.0d0
      integer               :: k,istart,iend,dimen
      double precision,external    :: ddot
      !
      !$omp parallel do private(k,istart,iend,dimen) shared(w) schedule(dynamic)
      do k=1,n
         !
         istart = bterm(k,1)
         iend   = bterm(k,2)
         !
         dimen = iend-istart+1
         !
         w(k) = ddot(dimen,h(k,1:dimen),1,z(istart:iend),1)
         !
      enddo 
      !$omp end parallel do 
      !
      !enddo
      !
   return
  end subroutine matvec_sym


    subroutine PTstore_icontr_cnu(Maxcontracts,iunit,dir)

      integer(ik),intent(in) :: Maxcontracts,iunit
      character(len=18),intent(in)  :: dir
      integer(ik)   :: alloc
      character(len=18)  :: buf18
      integer(ik)        :: ncontr
      integer(ik),allocatable :: imat_t(:,:)
      !
      selectcase (trim(dir))
        !
      case ('SAVE')
        !
        write(iunit) Maxcontracts
        !
        write(iunit) 'icontr_cnu'
        !
        write(iunit) PT%icontr_cnu(0:PT%Nclasses,1:Maxcontracts)
        !
        write(iunit) 'icontr_ideg'
        !
        write(iunit) PT%icontr_ideg(0:PT%Nclasses,1:Maxcontracts)
        !
      case ('APPEND')
        !
        read(iunit) ncontr
        !
        if (Maxcontracts/=ncontr) then
          write (out,"(' Vib. kinetic checkpoint file ',a)") job%kinetmat_file
          write (out,"(' Actual and stored basis sizes at J=0 do not agree  ',2i8)") PT%Maxcontracts,ncontr
          stop 'PTrestore_rot_kinetic_matrix_elements - in file - illegal nroots '
        end if
        !
        allocate (imat_t(0:PT%Nclasses,ncontr),stat=alloc)
        call ArrayStart('mat_t',alloc,size(imat_t),kind(imat_t))
        !
        read(iunit) buf18(1:10)
        if (buf18(1:10)/='icontr_cnu') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': icontr_cnu is missing ',a)") job%kinetmat_file,buf18(1:10)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  icontr_cnu missing'
        end if
        !
        read(iunit) imat_t(0:PT%Nclasses,1:ncontr)
        !
        read(iunit) buf18(1:11)
        if (buf18(1:11)/='icontr_ideg') then
          write (out,"(' Vib. kinetic checkpoint file ',a,': icontr_ideg is missing ',a)") job%kinetmat_file,buf18(1:11)
          stop 'PTrestore_rot_kinetic_matrix_elements - in file -  icontr_ideg missing'
        end if
        !
        read(iunit) imat_t(0:PT%Nclasses,1:ncontr)
        !
        deallocate(imat_t)
        !
      end select
      !
    end subroutine PTstore_icontr_cnu

   
    subroutine PTdefine_contr_from_eigenvect(nroots,Neigenlevels,eigen)

       integer(ik),intent(in)  :: nroots,Neigenlevels
       type(PTeigenT),intent(in)  :: eigen(:)
       !
       integer(ik)             :: alloc,iroot,ilevel,ideg
       !
       nullify(contr(1)%ilevel,contr(1)%ideg,contr(1)%iroot,contr(1)%eigen,contr(1)%ilevel_chk,contr(1)%prim_bs%icoeffs)
       !
       if (associated(contr(1)%ilevel)) then 
          deallocate (contr(1)%ilevel,contr(1)%ideg,&
                    contr(1)%iroot,&
                    contr(1)%eigen,&
                    contr(1)%ilevel_chk,&
                    contr(1)%prim_bs%icoeffs,stat=alloc)
          if (alloc/=0) then
            stop 'PTdefine_contr_from_eigenvect, ilevel -  deallocation error'
          end if
       endif
       !
       allocate (contr(1)%ilevel(nroots),contr(1)%ideg(nroots),&
                 contr(1)%iroot(Neigenlevels,sym%Maxdegen),&
                 contr(1)%eigen(nroots),&
                 contr(1)%ilevel_chk(nroots),&
                 contr(1)%prim_bs%icoeffs(0:PT%Nmodes,nroots),&
                 stat=alloc)
       if (alloc/=0) then
          write (out,"(' Error ',i9,' trying to allocate ilevel-field')") alloc
          stop 'PTdefine_contr_from_eigenvect, ilevel -  out of memory'
       end if
       !
       contr(1)%max_degen = sym%Maxdegen
       contr(1)%nlevels = Neigenlevels
       contr(1)%nroots  = nroots
       !
       contr(1)%dimen  = nroots
       contr(1)%iroot  = 0 
       contr(1)%ilevel = 0
       contr(1)%ideg   = 0 
       contr(1)%prim_bs%icoeffs = 0
       !
       iroot = 0
       !
       do ilevel = 1,Neigenlevels
          !
          allocate(contr(1)%eigen(ilevel)%nu(0:PT%Nmodes),contr(1)%eigen(ilevel)%normal(0:PT%Nmodes),&
                   contr(1)%eigen(ilevel)%vect(nroots,eigen(ilevel)%ndeg),stat=alloc)
          if (alloc/=0) stop 'PTdefine_contr_from_eigenvect, ilevel -  out of memory'
          !
          contr(1)%eigen(ilevel)%vect = 0
          !
          contr(1)%eigen(ilevel)%degeneracy = eigen(ilevel)%ndeg
          contr(1)%eigen(ilevel)%value    = eigen(ilevel)%energy
          contr(1)%eigen(ilevel)%nu(:)    = eigen(ilevel)%quanta(:)
          contr(1)%eigen(ilevel)%normal(:) = eigen(ilevel)%normal(:)
          contr(1)%eigen(ilevel)%isym     = eigen(ilevel)%igamma
          contr(1)%eigen(ilevel)%gamma    = trim(sym%label(eigen(ilevel)%igamma))
          contr(1)%eigen(ilevel)%largest_coeff    = eigen(ilevel)%largest_coeff
          contr(1)%eigen(ilevel)%lquant = sym%lquant(contr(1)%eigen(ilevel)%isym)
          !
          if (trove%triatom_sing_resolve.and.job%bset(0)%range(2)/=0) then
            contr(1)%eigen(ilevel)%lquant = eigen(ilevel)%normal(0)
          endif
          !
          do ideg = 1,eigen(ilevel)%ndeg
            !
            iroot = iroot + 1
            !
            contr(1)%ilevel(iroot)      = ilevel
            contr(1)%ideg(iroot)        = ideg
            contr(1)%iroot(ilevel,ideg) = iroot
            contr(1)%ilevel_chk(iroot)  = iroot
            contr(1)%eigen(ilevel)%vect(iroot,ideg) = 1.0_rk
            !
          enddo 
          !
       enddo
       !
       PT%zpe_contr = eigen(1)%energy
       !
       ! In case of dvr we create a dummy set of dvr points, just in order read/write together with the rest of the contr-fields
       !
       if (trove%dvr) then
        !
        contr(1)%Ndvrpoints = 1
        !
        allocate (contr(1)%dvr_kindex(1,PT%Nmodes),stat=alloc)
        call ArrayStart('dvr-fields-kindex',alloc,size(contr(1)%dvr_kindex),kind(contr(1)%dvr_kindex))
        !
       endif 
       !
       ! Saving the contracted basis set vectors and all auxilery informaion.
       !
       if (trim(job%IOcontr_action)=='SAVE'.and.(.not.job%IOmatelem_split.or.job%iswap(1)<=1).or.&
           job%convert_model_j0) then
         !
         if (job%convert_model_j0) then 
           PT%Nclasses = 1
         endif
         !
         if (trim(job%IOj0contr_action)=='SAVE') then 
           !
           call PTcheck_point_contracted_space('SAVE')
           !
         endif
         !
       endif
       !
   end subroutine PTdefine_contr_from_eigenvect


   subroutine Diag_ulen(a,d)
      !
      real(rk),intent(inout)  ::  a(:,:),d(:)
      integer(ik)  ::  p,q,p1,q1,irot,i,n2,kp,kp1,ip1,j,iq1,kq1,ii,n,n5,n5p
      integer(ik)  ::  itmax = 50,alloc,kpn5,kqn5
      real(rk)     ::  sm,tresh,g,h,s,c,t,tau,theta,ff1,ff2,g1,h1,g2,h2,g3,h3,g4,h4
      real(rk)     ::  err,tol
      real(rk),allocatable  ::  b(:),z(:),ve(:,:)
      integer(hik) :: matsize
      !
      n = size(a,dim=1)
      !
      if (size(a,dim=2)/=n.or.size(d,dim=1)/=n) then
        write (out,"(' diag_u: wrong shapes of arrays a and d :',3i0)") n,size(a,dim=2),size(d,dim=1)
        stop 'diag_u - wrong shapes of arrays'
      end if
      !
      err = sqrt(small_)
      tol = sqrt(small_)
      !
      allocate(b(n),z(n),ve(n,n),stat=alloc)
      !
      matsize = int(n,hik)*int(n,hik)+int(2*n,hik)
      !
      call ArrayStart('diag_u-arrays',alloc,1,kind(err),matsize)
      !
      if (alloc/=0) then
        write (out,"(' diag_u: Error ',i8,' allocating matices a,b, and ve ')") alloc
        stop 'diag_u - cannot allocate a,b,ve'
      end if
      !
      !$omp parallel do private(p,q) shared(ve) schedule(dynamic)
      do p=1,n
        do q=1,n
          ve(p,q)=0
        enddo
        ve(p,p)=1.0_rk
      enddo
      !$omp end parallel do
      !
      !$omp parallel do private(p) shared(z,d,b) schedule(dynamic)
      do p=1,n
        !
        z(p)=0
        d(p)=a(p,p)
        b(p)=d(p)
        !
      enddo
      !$omp end parallel do
      !
      irot=0
      !
      loop_i : do i=1,itmax
        !
        if (job%verbose>=5) write(out,"('iter = ',i5)") i 
        !
        sm=0.0_rk
        n2=n-1
        !
        call TimerStart('cacl. sm')
        !
        !$omp parallel do private(p,kp,q,n5,kpn5) schedule(dynamic) reduction(+:sm)
        do p=1,n2
          kp=p+1
          !
          n5 = mod(n-kp+1,5) ; kpn5 = kp+n5-1
          !
          do q=kp,kpn5
            sm=sm+abs(a(p,q))
          enddo
          !
          kpn5 = kp+n5
          !
          do q=kpn5,n,5
            sm=sm+dabs(a(p,q))+dabs(a(p,q+1))+dabs(a(p,q+2))+dabs(a(p,q+3))+dabs(a(p,q+4))
          enddo
        enddo
        !$omp end parallel do
        !
        call TimerStop('cacl. sm')
        !
        if (job%verbose>=5) write(out,"('sm = ',g15.8)") sm 
        !
        if(sm.le.err) exit loop_i
        !
        tresh=small_
        !
        if(i<4) tresh=0.2_rk*sm/(real(n*n,rk))
        !
        loop_p : do p1=1,n2
          !
          if (job%verbose>=5) write(out,"('p = ',i5)") p1
          !
          kp1=p1+1
          loop_q1 : do q1=kp1,n
            !
            g=100.0_rk*dabs(a(p1,q1))
            !
            ff1=dabs(d(p1))*tol
            !ff2=dabs(d(p1))
            ff2=dabs(d(q1))*tol
            !ff4=dabs(d(q1))
            !
            if(i>=4.and.g<ff1.and.g<ff2) then 
              a(p1,q1)=0.0_rk
              cycle loop_q1
            endif
            !
            ff1=dabs(a(p1,q1))
            if(ff1<=tresh) cycle loop_q1
            !
            h=d(q1)-d(p1)
            ff1=dabs(h)+g
            ff2=dabs(h)

            if(ff1==ff2) then 
              !
              t=a(p1,q1)/h
              !
            else
              !
              theta=0.5_rk*h/a(p1,q1)
              t=1.0_rk/(dabs(theta)+dsqrt(1.0_rk+theta*theta))
              if(theta<0.0_rk) t=-t
              !
            endif
            !
            c=1.0_rk/dsqrt(1.0_rk+t*t)
            s=t*c
            !
            tau=s/(1.0_rk+c)
            h=t*a(p1,q1)
            z(p1)=z(p1)-h
            z(q1)=z(q1)+h
            d(p1)=d(p1)-h
            d(q1)=d(q1)+h
            !
            a(p1,q1)=0.0_rk
            !
            ip1=p1-1
            !
            n5 = mod(ip1,5)
            !
            call TimerStart('Inner-loops')
            !
            !$omp parallel do private(j,g,h) shared(a) schedule(dynamic)
            do j=1,n5
              !
              g=a(j,p1)
              h=a(j,q1)
              a(j,p1)=g-s*(h+g*tau)
              a(j,q1)=h+s*(g-h*tau)
              !
            end do
            !$omp end parallel do
            !
            n5p = n5 + 1
            !
            !$omp parallel do private(j,g,h,g1,h1,g2,h2,g3,h3,g4,h4) shared(a) schedule(dynamic)
            do j=n5p,ip1,5
              !
              g=a(j,p1)
              h=a(j,q1)
              a(j,p1)=g-s*(h+g*tau)
              a(j,q1)=h+s*(g-h*tau)
              !
              g1=a(j+1,p1)
              h1=a(j+1,q1)
              a(j+1,p1)=g1-s*(h1+g1*tau)
              a(j+1,q1)=h1+s*(g1-h1*tau)
              !
              g2=a(j+2,p1)
              h2=a(j+2,q1)
              a(j+2,p1)=g2-s*(h2+g2*tau)
              a(j+2,q1)=h2+s*(g2-h2*tau)
              !
              g3=a(j+3,p1)
              h3=a(j+3,q1)
              a(j+3,p1)=g3-s*(h3+g3*tau)
              a(j+3,q1)=h3+s*(g3-h3*tau)
              !
              g4=a(j+4,p1)
              h4=a(j+4,q1)
              a(j+4,p1)=g4-s*(h4+g4*tau)
              a(j+4,q1)=h4+s*(g4-h4*tau)
              !
            end do
            !$omp end parallel do
            !
            iq1=q1-1
            !
            n5 = mod(iq1-kp1+1,5) ; kpn5 = kp1+n5-1
            !
            !$omp parallel do private(j,g,h) shared(a) schedule(dynamic)
            do j=kp1,kpn5
              !
              g=a(p1,j)
              h=a(j,q1)
              a(p1,j)=g-s*(h+g*tau)
              a(j,q1)=h+s*(g-h*tau)
              !
            enddo
            !$omp end parallel do
            !
            kpn5 = kp1+n5
            !
            !$omp parallel do private(j,g,h,g1,h1,g2,h2,g3,h3,g4,h4) shared(a) schedule(dynamic)
            do j=kpn5,iq1,5
              !
              g=a(p1,j)
              h=a(j,q1)
              a(p1,j)=g-s*(h+g*tau)
              a(j,q1)=h+s*(g-h*tau)
              !
              g1=a(p1,j+1)
              h1=a(j+1,q1)
              a(p1,j+1)=g1-s*(h1+g1*tau)
              a(j+1,q1)=h1+s*(g1-h1*tau)
              !
              g2=a(p1,j+2)
              h2=a(j+2,q1)
              a(p1,j+2)=g2-s*(h2+g2*tau)
              a(j+2,q1)=h2+s*(g2-h2*tau)
              !
              g3=a(p1,j+3)
              h3=a(j+3,q1)
              a(p1,j+3)=g3-s*(h3+g3*tau)
              a(j+3,q1)=h3+s*(g3-h3*tau)
              !
              g4=a(p1,j+4)
              h4=a(j+4,q1)
              a(p1,j+4)=g4-s*(h4+g4*tau)
              a(j+4,q1)=h4+s*(g4-h4*tau)
              !
            enddo
            !$omp end parallel do
            !
            kq1=q1+1
            !
            n5 = mod(n-kq1+1,5) ; kqn5 = kq1+n5-1
            !
            !$omp parallel do private(j,g,h) shared(a) schedule(dynamic)
            do j=kq1,kqn5
              !
              g=a(p1,j)
              h=a(q1,j)
              a(p1,j)=g-s*(h+g*tau)
              a(q1,j)=h+s*(g-h*tau)
              !
            enddo
            !$omp end parallel do
            !
            kqn5 = kq1+n5
            !
            !$omp parallel do private(j,g,h,g1,h1,g2,h2,g3,h3,g4,h4) shared(a) schedule(dynamic)
            do j=kqn5,n,5
              !
              g=a(p1,j)
              h=a(q1,j)
              a(p1,j)=g-s*(h+g*tau)
              a(q1,j)=h+s*(g-h*tau)
              !
              g1=a(p1,j+1)
              h1=a(q1,j+1)
              a(p1,j+1)=g1-s*(h1+g1*tau)
              a(q1,j+1)=h1+s*(g1-h1*tau)
              !
              g2=a(p1,j+2)
              h2=a(q1,j+2)
              a(p1,j+2)=g2-s*(h2+g2*tau)
              a(q1,j+2)=h2+s*(g2-h2*tau)
              !
              g3=a(p1,j+3)
              h3=a(q1,j+3)
              a(p1,j+3)=g3-s*(h3+g3*tau)
              a(q1,j+3)=h3+s*(g3-h3*tau)
              !
              g4=a(p1,j+4)
              h4=a(q1,j+4)
              a(p1,j+4)=g4-s*(h4+g4*tau)
              a(q1,j+4)=h4+s*(g4-h4*tau)
              !
            enddo
            !$omp end parallel do
            !
            n5 = mod(n,5)
            !
            !$omp parallel do private(j,g,h) shared(ve) schedule(dynamic)
            do j=1,n5
              g=ve(j,p1)
              h=ve(j,q1)
              ve(j,p1)=g-s*(h+g*tau)
              ve(j,q1)=h+s*(g-h*tau)
            enddo
            !$omp end parallel do
            !
            n5p = n5 + 1
            !
            !$omp parallel do private(j,g,h,g1,h1,g2,h2,g3,h3,g4,h4) shared(ve) schedule(dynamic)
            do j=n5p,n,5
              !
              g=ve(j,p1)
              h=ve(j,q1)
              ve(j,p1)=g-s*(h+g*tau)
              ve(j,q1)=h+s*(g-h*tau)
              !
              g1=ve(j+1,p1)
              h1=ve(j+1,q1)
              ve(j+1,p1)=g1-s*(h1+g1*tau)
              ve(j+1,q1)=h1+s*(g1-h1*tau)
              !
              g2=ve(j+2,p1)
              h2=ve(j+2,q1)
              ve(j+2,p1)=g2-s*(h2+g2*tau)
              ve(j+2,q1)=h2+s*(g2-h2*tau)
              !
              g3=ve(j+3,p1)
              h3=ve(j+3,q1)
              ve(j+3,p1)=g3-s*(h3+g3*tau)
              ve(j+3,q1)=h3+s*(g3-h3*tau)
              !
              g4=ve(j+4,p1)
              h4=ve(j+4,q1)
              ve(j+4,p1)=g4-s*(h4+g4*tau)
              ve(j+4,q1)=h4+s*(g4-h4*tau)
              !
            enddo
            !$omp end parallel do
            !
            call TimerStop('Inner-loops')
            !
            irot=irot+1
            !
            !a(p1,q1)=0.0_rk
            !
          enddo loop_q1
        enddo loop_p
        !
        !$omp parallel do private(ii) shared(d,b,z) schedule(dynamic)
        do ii=1,n
          !
          d(ii)=b(ii)+z(ii)
          b(ii)=d(ii)
          z(ii)=0.0_rk
          !
        enddo
        !$omp end parallel do
        !
      enddo loop_i
      !
      !
      if (alloc/=0) then
        write (out,"(' diag_u: Error ',i8,' allocating matices a,b, and ve ')") alloc
        stop 'MLdiag_u - cannot allocate a,b,ve'
      end if
      !
      if (i==itmax) then 
         write (out,"('diag_u: no convergence after ',i8,' iterations')") i
         stop 'diag_u: no convergence'
      endif
      !
      call TimerStart('Sort vectors')
      !
      do j=1,n
        a(:,j) = ve(:, j)
      enddo
      !
      do i=1,n
        !
        g = d(i)
        !
        do j=i+1,n
          !
          if ( g>d(j)) then
            !
            g    = d(j)
            d(j) = d(i)
            d(i) = g
            !
            b(:)   = a(:,j)
            a(:,j) = a(:,i)
            a(:,i) = b(:)
            !
          endif 
          !
        enddo
        !
      enddo
      !
      call TimerStop('Sort vectors')
      !
      deallocate(b,z,ve)
      call ArrayStop('diag_u-arrays')

  end subroutine Diag_ulen

  subroutine Harmonic_polinom(nu,coeff,xval,fval,dfval)

    integer(ik),intent(in) :: nu
    real(ark),intent(in)   :: coeff,xval
    real(ark),intent(out)  :: fval,dfval
    real(ark)              :: xi,p1,p2,p3,v,vm1
    integer(ik)            :: n
       !
       xi  = xval/coeff
       !
       p1 = .75112554446494248285870300477622_ark/sqrt(coeff)  ! 1/pi^(1/4) *exp(-xi**2)
       !
       p2 = 0.0_ark
       !
       do n = 1,nu
         !
         v   = real(n,ark)
         vm1 = real(n-1,ark)
         !
         p3 = p2
         p2 = p1
         p1 = xi*sqrt(2.0_ark/v)*p2-sqrt(vm1/v)*p3
         !
       enddo
       !
       fval = p1
       !
       v   = real(nu,ark)
       !
       dfval = ( p2*sqrt(2.0_ark*v))/coeff
       !
  end subroutine Harmonic_polinom



  subroutine gauher(x,w,n)
  integer(ik) :: n,MAXIT
  real(ark) :: w(n),x(n)
  real(ark) ::  EPS,PIM4
  parameter (EPS=3.D-21,PIM4=.75112554446494248285870300477622_ark,MAXIT=40)
  integer(ik) :: i,its,j,m
  real(ark) ::p1,p2,p3,pp,z,z1
  m=(n+1)/2
  do i=1,m
    !
    if(i.eq.1)then
      z=sqrt(float(2*n+1))-1.85575*(2*n+1)**(-.16667)
    else if(i.eq.2)then
      z=z-1.14*n**.426/z
    else if (i.eq.3)then
      z=1.86*z-.86*x(1)
    else if (i.eq.4)then
      z=1.91*z-.91*x(2)
    else
      z=2.*z-x(i-2)
    endif
    do its=1,MAXIT
      p1=PIM4
      p2=0.0_ark
      do j=1,n
        p3=p2
        p2=p1
        p1=z*sqrt(2.0_ark/j)*p2-sqrt(real(j-1,ark)/real(j,ark))*p3
      enddo
      pp=sqrt(2.0_ark*n)*p2
      z1=z
      z=z1-p1/pp
      if(abs(z-z1).le.EPS) exit
      !
    enddo
    if (its==MAXIT) stop 'too many iterations in gauher'
    x(i)=z
    x(n+1-i)=-z
    w(i)=2.0_ark/(pp*pp)
    w(n+1-i)=w(i)
  enddo
  !
  return
  end subroutine gauher
  !C  (C) Copr. 1986-92 Numerical Recipes Software v%1jw#<0(9p#3.


 subroutine gaulegf(x1, x2, x, w, n)
  implicit none
  integer(ik), intent(in) :: n
  real(ark), intent(in) :: x1, x2
  real(ark), dimension(n), intent(out) :: x, w
  integer(ik) :: i, j, m
  real(ark) :: p1, p2, p3, pp, xl, xm, z, z1
  real(ark) , parameter :: eps=3.d-16
      
  m = (n+1)/2
  xm = 0.5_ark*(x2+x1)
  xl = 0.5_ark*(x2-x1)
  do i=1,m
    z = cos(3.1415926535897932385_ark*(i-0.25_ark)/(n+0.5_ark))
    z1 = 0.0
    do while(abs(z-z1) .gt. small_)
      p1 = 1.0_ark
      p2 = 0.0_ark
      do j=1,n
        p3 = p2
        p2 = p1
        p1 = ((2.0_ark*j-1.0_ark)*z*p2-(j-1.0_ark)*p3)/j
      end do
      pp = n*(z*p1-p2)/(z*z-1.0_ark)
      z1 = z
      z = z1 - p1/pp
    end do
    x(i) = xm - xl*z
    x(n+1-i) = xm + xl*z
    w(i) = (2.0_ark*xl)/((1.0_ark-z*z)*pp*pp)
    w(n+1-i) = w(i)
  end do
 end subroutine gaulegf

 subroutine gaulag(x,w,n,alf)
      !
      integer(ik),intent(in) ::  n
      real(ark),intent(in)   :: alf
      real(ark),intent(out)  :: w(n),x(n)
      real(rk)  :: eps=3.0-20_rk
      integer(ik) :: i,its,j,maxit=20
      real(ark) :: ai
      real(ark) :: p1,p2,p3,pp,z,z1
      !
      do i=1,n
        if(i.eq.1)then
          z=(1.+alf)*(3.+.92*alf)/(1.+2.4*n+1.8*alf)
        else if(i.eq.2)then
          z=z+(15.+6.25*alf)/(1.+.9*alf+2.5*n)
        else
          ai=i-2
          z=z+((1.+2.55*ai)/(1.9*ai)+1.26*ai*alf/(1.+3.5*ai))*(z-x(i-2))/(1.+.3*alf)
        endif
        !
        do its=1,maxit
          p1=1.d0
          p2=0.d0
          !
          do j=1,n
            p3=p2
            p2=p1
            p1=((2*j-1+alf-z)*p2-(j-1+alf)*p3)/j
          enddo
          pp=(n*p1-(n+alf)*p2)/z
          z1=z
          z=z1-p1/pp
          if(abs(z-z1).le.eps) exit
        enddo
        if (i>=n) stop 'too many iterations in gaulag'
        x(i)=z
        w(i)=-exp(gammln(alf+real(n,ark))-gammln(real(n,ark)))/(pp*n*p2)
        !
      enddo
      !
    !
 end subroutine gaulag


 real(ark) function gammln(xx)
      !
      real(ark) :: xx
      real(ark) :: cof(6),stp,x,tmp,ser,y
      integer(ik) :: j
      !
      data cof,stp/76.18009172947146d0,-86.50532032941677d0,24.01409824083091d0, & 
                  -1.231739572450155d0,.1208650973866179d-2,-.5395239384953d-5,2.5066282746310005d0/
      !
      x=xx
      y=x
      tmp=x+5.5_ark
      tmp=(x+0.5_ark)*log(tmp)-tmp
      ser=1.000000000190015_ark
      do j=1,6
        y=y+1.0_ark
        ser=ser+cof(j)/y
      enddo
      gammln=tmp+log(stp*ser/x)
      !
  end function gammln


subroutine PTstore_contr_matelem_II(jrot)
  !
  integer(ik),intent(in) :: jrot
  integer(ik) :: i, iclass, info, dimen, maxnterms, nterms_uniq(PT%Nclasses), nclasses, nmodes, &
                 n, iclass_imode(2,PT%Nclasses), nterms, nmodes_class, imode, jmode, kmode, lmode, & 
                 iterm, kterm, nprim, term(PT%Nmodes), &
                 ncomb, icomb, iterm_, nterms_, jterm, imode_, jmode_, icomb_maxnterms, imode1, & 
                 imode2,ipar,extF_rank,icoeff, kclass, nterms_field, nterms0
  integer(ik) ::  target_index(PT%Nmodes),Nfield_terms
  integer(ik)        :: poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,Jmax,L2vib_N,ipos,ipos_,iroot,ilevel,ideg
  integer(ik),allocatable :: extF_N(:), IndexQ(:,:),IndexQ0(:,:)
  integer(ik), allocatable :: icomb_nclasses(:), icomb_iclass(:,:), icomb_nterms(:), icomb_iterm(:,:), terms_uniq(:,:,:), &
                              iterm_uniq(:,:),iunique_iterm(:,:)


  integer(ik), allocatable :: ijmode_icomb_iterm(:,:,:), ijmode_icomb_nterms(:)



  integer(ik), allocatable :: terms(:,:)
  real(rk) :: coef_thresh, c
  real(rk), allocatable :: me_contr(:,:,:), ijmode_icomb_coefs(:,:)
  character(cl) :: func_tag,skey,sclass,skey_cls
  integer(hik)  :: matsize
  logical :: match
  logical            :: treat_rotation =.true.  ! switch off/on the rotation 
  logical            :: treat_vibration =.true.  ! switch off/on the vibration
  logical            :: treat_exfF=.false.       ! switch off/on the external field 
  !type(FLpolynomT),pointer     :: fl
  type(PTcoeffT),pointer        :: fl 
  !real(rk), allocatable :: prim_vect(:,:)
  !
  if ( ( .not.FLrotation.or.jrot/=0 ).and.trim(job%IOkinet_action)/='SAVE'.and.&
       ( trim(job%IOextF_action)/='SAVE'.and.trim(job%IOextF_action)/='SPLIT' ) ) return
  !  
  if (trim(job%IOkinet_action)=='CONVERT') return 
  if (job%vib_contract) return
  if ((trim(job%IOkinet_action)=='READ'.or.trim(job%IOkinet_action)=='VIB_READ').and.&
       trim(job%IOextF_action)/='SAVE'.and.trim(job%IOextF_action)/='SPLIT') return
  !
  if (trim(trove%IO_contrCI)=='READ') return
  !
  if (trim(trove%IO_contrCI)=='SAVE'.and.job%IOmatelem_split.and.job%iswap(1)>1) then
    !
    write(out,"('PTstore_contr_matelem: CONTR_CI should be set to READ if _MATELEM save split_ and slices>1')")
    !stop 'PTstore_contr_matelem: CONTR_CI should be set to READ for _MATELEM save split_ use'
    !
  endif
  !
  !if (any(trove%manifold_rank(:)/=0)) then
  !  write(out, '(/a)') 'PTstore_contr_matelem error: "non-rigid" case is not yet implemented'
  !  stop
  !endif
  !
  call TimerStart('PTstore_contr_matelem')
  !
  if (job%verbose>=4) write(out, '(/a/)')  'PTstore_contr_matelem/start: compute contracted matrix elements'
  !
  if (job%verbose>=4) write(out, '(1x,a,1x,i8)') 'total number of contracted functions:', PT%Maxcontracts
  if (job%verbose>=4) write(out, '(1x,a,1x,i3)') 'number of classes of contracted functions:', PT%Nclasses
  if (job%verbose>=4) write(out, '(1x,a,100(1x,i6))') 'number of contracted functions in each class:', contr(1:PT%Nclasses)%nroots
  !
  nclasses = PT%Nclasses
  nmodes = PT%Nmodes
  coef_thresh = job%exp_coeff_thresh
  !
  extF_rank = FLread_extF_rank()
  !
  allocate(extF_N(max(extF_rank,1)))
  !
  call FLread_fields_dimensions(poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,extF_N,L2vib_N)
  !
  ! expansion indices

  !
  target_index = 0 
  target_index(1) = max(potorder,kinorder,extForder)
  maxnterms = FLQindex(trove%Nmodes_e,target_index)
  !
  allocate(terms(size(FLIndexQ,dim=1),maxnterms), stat=info)
  call ArrayStart('PTstore_contr_matelem:terms',info,size(terms),kind(terms))
  !terms = FLindexQ
  maxnterms = FLQindex(trove%Nmodes_e,target_index,terms)
  !
  ! indexes of the first and the last mode in each class
  !
  do iclass=1, nclasses
    iclass_imode(1:2,iclass) = (/PT%mode_class(iclass,1), PT%mode_class(iclass,PT%mode_iclass(iclass))/)
  enddo
  !
  allocate(IndexQ(Nmodes,maxnterms), stat=info)
  call ArrayStart('PTstore_contr_matelem:IndexQ',info,size(IndexQ),kind(IndexQ))
  IndexQ = terms
  !
  ! exclude last class form IndexQ0
  imode1 = PT%mode_class(nclasses,1)
  nterms0 = FLQindex(imode1-1,target_index)
  allocate(IndexQ0(Nmodes,nterms0), stat=info)
  call ArrayStart('PTstore_contr_matelem:IndexQ0',info,size(IndexQ0),kind(IndexQ0))
  nterms0 = FLQindex(imode1-1,target_index,IndexQ0)
  !
  ! set all powers for the last class  and last mode to n, which is a running term, just to make sure it is unique and non-zero
  !forall(n=1:maxnterms) terms(Nmodes,n)=n

  ! set all powers for the last class  and last mode to 0
  !forall(n=1:maxnterms) terms(Nmodes,n)=0
  !
  if (job%verbose>=4) then 
      write(out, *)
      do iclass=1, nclasses
         write(out, '(1x,a,1x,i3,3x,a,1x,i3,1x,a,1x,i3,1x,a)') 'iclass =', iclass, 'imodes = [', iclass_imode(1,iclass), ':', &
                     iclass_imode(2,iclass), ']'
      enddo
  endif
  !
  ! estimate max number of expansion terms among all operators
  !
  !maxnterms = size(FLIndexQ,dim=2) 
                   !max( maxval(trove%g_rot(:,:)%Ncoeff), &
                   !maxval(trove%g_cor(:,:)%Ncoeff), &
                   !maxval(trove%g_vib(:,:)%Ncoeff), &
                   !trove%pseudo%Ncoeff, &
                   !trove%poten%Ncoeff)

  !
  target_index = 0 
  target_index(1) = max(potorder,kinorder,extForder)
  maxnterms = FLQindex(trove%Nmodes_e,target_index)
  !
  if (associated(trove%extf)) maxnterms = max(maxnterms,maxval(trove%extf(:)%Ncoeff))
  !
  if (job%verbose>=5) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all fields:', maxnterms
  !
  ! generate all possible combinations of classes
  !
  call combinations(nclasses, (/(iclass, iclass=1, nclasses)/), ncomb, icomb_nclasses, icomb_iclass)
  ! note: "icomb_nclasses" and "icomb_iclass" are allocated inside "combinations"
  !
  icomb_nclasses(0) = 0
  icomb_iclass(:,0) = 0
  !
  ! count allocated memory
  info = 0
  call ArrayStart('PTstore_contr_matelem:icomb_nclasses',info,size(icomb_nclasses),kind(icomb_nclasses))
  call ArrayStart('PTstore_contr_matelem:icomb_iclass',info,size(icomb_iclass),kind(icomb_iclass))
  !
  if (job%verbose>=5) then 
    write(out, '(/1x,a,1x,i3,1x,a)') 'combinations of classes (', ncomb+1, '):'
    do icomb=0, ncomb
      n = icomb_nclasses(icomb)
      write(out, '(1x,a,1x,i3,3x,a,1x,100(1x,i3))') 'icomb =', icomb, 'iclasses =', icomb_iclass(1:n,icomb)
    enddo
    !
  endif
  !
  ! for maximal expansion (maxnterms) split expansion terms into groups each for different combination of classes
  !
  allocate(icomb_nterms(0:ncomb), stat=info)
  call ArrayStart('PTstore_contr_matelem:icomb_nterms',info,size(icomb_nterms),kind(icomb_nterms))
  !
  call split_terms_comb(nmodes, maxnterms, terms(1:nmodes,1:maxnterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb))
  !
  if (job%verbose>=5) then 
     write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
    do icomb=0, ncomb
      write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
    enddo
  endif
  !
  if (sum(icomb_nterms(0:ncomb))/=maxnterms) then
    write(out, '(/a,1x,i6,1x,a,1x,i6)') &
    'PTstore_contr_matelem error: number of terms among all combinations of classes =', sum(icomb_nterms(0:ncomb)), &
    'differs from the total number of terms =', maxnterms
    stop
  endif
  !
  ! for maximal expansion (maxnterms) estimate max number of unique expansion terms for each class
  !
  allocate(terms_uniq(nmodes,maxnterms,nclasses), iterm_uniq(nclasses,maxnterms), stat=info)
  call ArrayStart('PTstore_contr_matelem:terms_uniq',info,size(terms_uniq),kind(terms_uniq))
  call ArrayStart('PTstore_contr_matelem:iterm_uniq',info,size(iterm_uniq),kind(iterm_uniq))
  !
  call split_terms_uniq(nmodes, maxnterms, terms(1:nmodes,1:maxnterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:maxnterms), terms_uniq(1:nmodes,1:maxnterms,1:nclasses))
  !
  if (job%verbose>=5) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
  !
  ! allocate array to keep indexes of terms split into groups each for different combinations of classes
  !
  allocate(icomb_iterm(maxval(icomb_nterms(0:ncomb)),0:ncomb), stat=info)
  call ArrayStart('PTstore_contr_matelem:icomb_iterm',info,size(icomb_iterm),kind(icomb_iterm))
  !
  allocate(iunique_iterm(maxnterms,2), stat=info)
  call ArrayStart('PTstore_contr_matelem:icomb_iterm',info,size(iunique_iterm),kind(iunique_iterm))
  !
  if ( trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT' ) treat_exfF = .true.
  !
  if (trim(job%IOkinet_action)=='READ'.or.(trim(job%IOkinet_action)=='NONE'.and.treat_exfF)) then
    treat_vibration = .false.
    treat_rotation = .false.
  endif 
  !
  !------------------------------------------------------------------!
  ! compute and store matrix elements of the vibrational part of KEO !
  !------------------------------------------------------------------!
  !
  if ( treat_vibration.and.(.not.job%IOmatelem_split.or.job%iswap(1)==0) ) then 
     !
     !
     if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of Gvib'
     !
     func_tag = 'Tvib'
     !
     target_index = 0 
     target_index(1) = KinOrder
     nterms= FLQindex(trove%Nmodes_e,target_index)
     nterms0= FLQindex(trove%Nmodes-1,target_index)
     !
     if (job%verbose>=5) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all elements of Gvib:', nterms
 
     call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms),&
                           nclasses, iclass_imode(1:2,1:nclasses), &
                           ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb),&
                           icomb_nterms(0:ncomb),icomb_iterm(:,0:ncomb),&
                           iunique_iterm(:,1:2) )
     !
     if (job%verbose>=4) then 
       write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
       do icomb=0, ncomb
         write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
       enddo
     endif
     !
     if (sum(icomb_nterms(0:ncomb))/=nterms) then
       write(out, '(/a,1x,i6,1x,a,1x,i6)') &
       'PTstore_contr_matelem error: number of Gvib expansion terms among all combinations of classes =', & 
                            sum(icomb_nterms(0:ncomb)),'differs from the total number of terms =', nterms
       stop
     endif
     !
     !nterms_uniq:  total number of terms in each class
     !terms_uniq :  powers for a given ipos in a given class 
     !iterm_uniq :  correlation from iterm to the uniq-position for a given class
     !
     call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
     !
     if (job%verbose>=5) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
     !
     ! compute and store contracted matrix elements for unique expansion terms only within each class
     !
     allocate(gvib_me(nclasses), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gvib_me(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     allocate(gvib_class(nclasses,0:nmodes,0:nmodes), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gvib_class(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     do iclass=1, nclasses-1
       !
       if (job%verbose>=5) write(out, '(/1x,a,1x,i3)') 'iclass = ', iclass
       !
       gvib_me(iclass)%nterms = nterms_uniq(iclass)
       !
       nmodes_class = iclass_imode(2,iclass) - iclass_imode(1,iclass) + 1
       dimen = contr(iclass)%nroots
       nprim = contr(iclass)%dimen
       !
       write(sclass,'(i4)') iclass
       skey_cls = 'gvib_class('//trim(adjustl(sclass))//')'
       !
       if (job%verbose>=5) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. modes, no. unique terms, no. basis functions:', &
                           nmodes_class, nterms_uniq(iclass), dimen
       !
       ! allocate array to keep contracted matrix elements
       !
       if (job%verbose>=6) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size =', &
                                 real(nterms_uniq(iclass)*max(dimen,nprim)**2)*8.0/1024.0**3, 'gb'
       !
       allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
       call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
       !
       !if (nprim>dimen) then
       !  write(out,"('PTstore_contr_matelem: Illegal array sizes of me_contr, nprim > dimen:',2i12)") nprim,dimen
       !  stop 'PTstore_contr_matelem: Illegal array sizes of me_contr, nprim > dimen'
       !endif
       !
       !matsize = int(nterms_uniq(iclass)*dimen*dimen,hik)
       !
       !if (job%verbose>=5) write(out,"('  Allocating ',i7,'x',i8,'x',i8,' = ',i12,' gvib matrix of ',f15.4,' gb')") & 
       !                    nterms_uniq(iclass),dimen,dimen,matsize,real(matsize,rk)*8.0_rk/1024.0_rk**3
       !
       !allocate(gvib_me(iclass)%me(nterms_uniq(iclass),dimen,dimen,nmodes,nmodes), stat=info)
       !write(sclass,'(i4)') iclass
       !skey = 'gvib_me('//trim(adjustl(sclass))//')'
       !call ArrayStart(trim(skey),info,1_ik,rk,matsize)
       !gvib_me(iclass)%me = 0
       !
       ! compute contracted matrix elements for operators: G, p_i*G, G*p_i, p_i*G*p_j
       !
       if (job%verbose>=5) write(out, '(3x,a,3x,a,5x,a)') 'p_i*Gvib*p_j:', 'i', 'j'
       !
       ! <G>
       !
       call calc_contr_matelem_expansion_p0(iclass,func_tag, nterms_uniq(iclass),terms_uniq(1:nmodes,1:nterms_uniq(iclass),&
                                            iclass),me_contr)
       call store_contr_matelem_expansion_II(0,0,iclass,func_tag,nmodes_class,nmodes_class,dimen,nterms_uniq(iclass),me_contr)
       !
       !do imode=1,nmodes
       !  if (iclass_imode(1,iclass)<=imode.and.imode<=iclass_imode(2,iclass)) cycle
       !  do jmode=1,nmodes 
       !    if (iclass_imode(1,iclass)<=jmode.and.jmode<=iclass_imode(2,iclass)) cycle
       !    gvib_me(iclass)%me(:,:,:,imode,jmode) = me_contr(:,:,:)
       !  enddo
       !enddo
       !
       allocate(gvib_class(iclass,0,0)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
       call ArrayStart(trim(skey_cls),info,1_ik,rk,size(gvib_class(iclass,0,0)%me,kind=hik))
       gvib_class(iclass,0,0)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
       !
       if (job%verbose>=5) write(out, '(17x,i3,3x,i3)') 0, 0
       !
       ! <p_i*G> and <G*p_i>
       !
       imode_ = 0
       do imode=iclass_imode(1,iclass), iclass_imode(2,iclass)
         imode_ = imode_ + 1
         !
         call calc_contr_matelem_expansion_p1(imode, iclass, func_tag, nterms_uniq(iclass), &
                                              terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
         call store_contr_matelem_expansion_II(0,imode_,iclass,func_tag,nmodes_class,nmodes_class,&
                                              dimen,nterms_uniq(iclass),me_contr)
         !
         !do jmode=1,nmodes
         !  if (iclass_imode(1,iclass)<=jmode.and.jmode<=iclass_imode(2,iclass)) cycle
         !  gvib_me(iclass)%me(:,:,:,jmode,imode) = me_contr(:,:,:)
         !enddo
         !
         allocate(gvib_class(iclass,0,imode_)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
         call ArrayStart(trim(skey_cls),info,1_ik,rk,size(gvib_class(iclass,0,imode_)%me,kind=hik))
         !
         gvib_class(iclass,0,imode_)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
         !
         if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, imode
         do iterm=1, nterms_uniq(iclass)
           me_contr(iterm,:,:) = -transpose(me_contr(iterm,:,:))
         enddo
         !
         call store_contr_matelem_expansion_II(imode_,0,iclass,func_tag,nmodes_class,nmodes_class,&
                                                dimen,nterms_uniq(iclass),me_contr)
         !
         !do jmode=1,nmodes 
         !  if (iclass_imode(1,iclass)<=jmode.and.jmode<=iclass_imode(2,iclass)) cycle
         !  gvib_me(iclass)%me(:,:,:,imode,jmode) = me_contr(:,:,:)
         !enddo
         !
         allocate(gvib_class(iclass,imode_,0)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
         call ArrayStart(trim(skey_cls),info,1_ik,rk,size(gvib_class(iclass,imode_,0)%me,kind=hik))
         gvib_class(iclass,imode_,0)%me = me_contr
         !
         if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') imode, 0
       enddo
       !
       ! <p_i*G*p_j>
       !
       imode_ = 0
       do imode=iclass_imode(1,iclass), iclass_imode(2,iclass)
         imode_ = imode_ + 1
         jmode_ = 0
         do jmode=iclass_imode(1,iclass), iclass_imode(2,iclass)
           jmode_ = jmode_ + 1
           !
           if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') imode, jmode
           !
           call calc_contr_matelem_expansion_p2(imode,jmode,iclass,func_tag,nterms_uniq(iclass),&
                                                terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass),me_contr)
           call store_contr_matelem_expansion_II(imode_,jmode_,iclass,func_tag,nmodes_class,nmodes_class,&
                                                dimen,nterms_uniq(iclass),me_contr)
           !
           !gvib_me(iclass)%me(:,:,:,imode,jmode) = me_contr(:,:,:)
           !
           allocate(gvib_class(iclass,imode_,jmode_)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
           call ArrayStart(trim(skey_cls),info,1_ik,rk,size(gvib_class(iclass,imode_,jmode_)%me,kind=hik))
           !
           gvib_class(iclass,imode_,jmode_)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
           !
         enddo
       enddo
       !
       deallocate(me_contr)
       call ArrayStop('PTstore_contr_matelem:me_contr')
       !
     enddo ! iclass
     !
     ! Build the correlation betweem comb-pos and icoeff-representations of the field 
     !
     if (job%verbose>=6) print*,"nterms,nterms0 = ",nterms,nterms0 
     !
     do imode=1,nmodes
       do jmode=1,nmodes
         !
         if (job%verbose>=6) write(out, '(1x,i6,1x,i6)') imode,jmode
         !
         fl => me%gvib(imode,jmode)
         !
         call correlate_field_expansions_sparse_to_by_classes(fl,func_tag,KinOrder,nterms,nterms0,IndexQ,&
                                                              IndexQ0,iterm_uniq(1:nclasses,1:nterms),nterms_uniq,terms_uniq)
         !
       enddo ! jmode
     enddo ! imode
     !
     call store_fast_ci_uniq(func_tag)
     !
  endif
  !
  if (treat_rotation) then 
     !
     !---------------------------------------------------------------!
     ! compute and store matrix elements of the Coriolis part of KEO !
     !---------------------------------------------------------------!
     !
     if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of Gcor'
     !
     func_tag = 'Tcor'
     !
     !nterms = maxval(trove%g_cor(1:nmodes,1:3)%Ncoeff)
     !
     target_index = 0 
     target_index(1) = KinOrder
     nterms= FLQindex(trove%Nmodes_e,target_index)
     nterms0= FLQindex(trove%Nmodes-1,target_index)
     !
     if (job%verbose>=5) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all elements of Gcor:', nterms
 
     call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb), &
                           icomb_iterm(:,0:ncomb))
     !
     if (job%verbose>=5) then 
       write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
       do icomb=0, ncomb
         write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
       enddo
     endif
     !
     if (sum(icomb_nterms(0:ncomb))/=nterms) then
       write(out, '(/a,1x,i6,1x,a,1x,i6)') &
       'PTstore_contr_matelem error: number of Gcor expansion terms among all combinations of classes =', &
       sum(icomb_nterms(0:ncomb)), &
       'differs from the total number of terms =', nterms
       stop
     endif
     !
     call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
     !
     if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
     !
     ! compute and store contracted matrix elements for unique expansion terms only within each class
     !
     allocate(gcor_me(nclasses), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gcor_me(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     allocate(gcor_class(nclasses,0:nmodes), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gcor_class(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     do iclass=1, nclasses-1
       !
       if (job%verbose>=5) write(out, '(/1x,a,1x,i3)') 'iclass = ', iclass
       !
       gcor_me(iclass)%nterms = nterms_uniq(iclass)
       !
       nmodes_class = iclass_imode(2,iclass) - iclass_imode(1,iclass) + 1
       dimen = contr(iclass)%nroots
       nprim = contr(iclass)%dimen
       !
       write(sclass,'(i4)') iclass
       skey_cls = 'gcor_class('//trim(adjustl(sclass))//')'
       !
       if (job%verbose>=5) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. modes, no. unique terms, no. basis functions:', &
                           nmodes_class, nterms_uniq(iclass), dimen
       !
       ! allocate array to keep contracted matrix elements
       !
       if (job%verbose>=6) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size =', &
                           real(nterms_uniq(iclass)*max(dimen,nprim)**2)*8.0/1024.0**3, 'gb'
       !
       allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
       call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
       !
       matsize = int(nterms_uniq(iclass)*dimen*dimen,hik)
       !
       if (job%verbose>=5) write(out,"('  Allocating ',i7,'x',i8,'x',i8,' = ',i12,' gcor matrix of ',f15.4,' gb')") & 
                           nterms_uniq(iclass),dimen,dimen,matsize,real(matsize,rk)*8.0_rk/1024.0_rk**3
       !
       !allocate(gcor_me(iclass)%me(nterms_uniq(iclass),dimen,dimen,nmodes,1), stat=info)
       !write(sclass,'(i4)') iclass
       !skey = 'gcor_me('//trim(adjustl(sclass))//')'
       !call ArrayStart(trim(skey),info,1,rk,matsize)
       !gcor_me(iclass)%me = 0
       !
       ! compute contracted matrix elements for operators: G, p_i*G
       !
       if (job%verbose>=5) write(out, '(3x,a,3x,a)') 'p_i*Gcor*p_j:', 'i'
       !
       ! <G>
       !
       call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), &
                                            terms_uniq(1:nmodes,1:nterms_uniq(iclass),&
       iclass), me_contr)
       call store_contr_matelem_expansion_II(0,0,iclass,func_tag,nmodes_class,0,dimen,nterms_uniq(iclass),me_contr)
       !
       allocate(gcor_class(iclass,0)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
       call ArrayStart(trim(skey_cls),info,1_ik,rk,size(gcor_class(iclass,0)%me,kind=hik))
       !
       gcor_class(iclass,0)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
       !
       !do imode=1,nmodes
       !  if (iclass_imode(1,iclass)<=imode.and.imode<=iclass_imode(2,iclass)) cycle
       !  gcor_me(iclass)%me(:,:,:,imode,1) = me_contr(:,:,:)
       !enddo
       !
       !if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, 0
       !
       ! <p_i*G>
       !
       imode_ = 0
       do imode=iclass_imode(1,iclass), iclass_imode(2,iclass)
         !
         imode_ = imode_ + 1
         call calc_contr_matelem_expansion_p1(imode,iclass, func_tag, nterms_uniq(iclass), &
                                              terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass),me_contr)
         call store_contr_matelem_expansion_II(imode_,0,iclass,func_tag,nmodes_class,0,dimen,nterms_uniq(iclass),me_contr)
         if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, imode
         !
         !gcor_me(iclass)%me(:,:,:,imode,1) = me_contr(:,:,:)
         !
         allocate(gcor_class(iclass,imode_)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
         call ArrayStart(trim(skey_cls),info,1_ik,rk,size(gcor_class(iclass,imode_)%me,kind=hik))
         !
         gcor_class(iclass,imode_)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
         !
       enddo
       !
       deallocate(me_contr)
       call ArrayStop('PTstore_contr_matelem:me_contr')
       !
     enddo ! iclass
     !
     ! The last class is special 
     !
     do imode=1, nmodes
       do jmode=1,3
         !
         fl => me%gcor(imode,jmode)
         !
         ! Build the correlation betweem uniq and icoeff-representations of the field 
         !
         call correlate_field_expansions_sparse_to_by_classes(fl,func_tag,KinOrder,maxnterms,nterms0,IndexQ,IndexQ0,&
                                                               iterm_uniq(1:nclasses,1:nterms),nterms_uniq,terms_uniq)
         !
       enddo
     enddo
     !
     call store_fast_ci_uniq(func_tag)
     !
     !-----------------------------------------------------------------!
     ! compute and store matrix elements of the rotational part of KEO !
     !-----------------------------------------------------------------!
     !
     if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of Grot'
     !
     func_tag = 'Trot'
     !
     if (job%verbose>=5) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all elements of Grot:', nterms
     !
     ! organize/split expansion terms into groups for different (0..ncomb) combinations of classes
     !
     call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb), &
                           icomb_iterm(:,0:ncomb))
     !
     if (job%verbose>=5) write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
     !
     do icomb=0, ncomb
       if (job%verbose>=5) write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
     enddo
     !
     if (sum(icomb_nterms(0:ncomb))/=nterms) then
       write(out, '(/a,1x,i6,1x,a,1x,i6)') &
            'PTstore_contr_matelem error: number of Grot expansion terms among all combinations of classes =', & 
            sum(icomb_nterms(0:ncomb)),'differs from the total number of terms =', nterms
       stop
     endif
     !
     call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
     !
     if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
     !
     ! compute and store contracted matrix elements for unique expansion terms only within each class
     !
     allocate(grot_me(nclasses), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate grot_me(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     allocate(grot_class(nclasses), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate grot_class(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     do iclass=1, nclasses-1
       !
       if (job%verbose>=5) write(out, '(/1x,a,1x,i3)') 'iclass = ', iclass
       !
       grot_me(iclass)%nterms = nterms_uniq(iclass)
       !
       nmodes_class = iclass_imode(2,iclass) - iclass_imode(1,iclass) + 1
       dimen = contr(iclass)%nroots
       nprim = contr(iclass)%dimen
       !
       write(sclass,'(i4)') iclass
       skey_cls = 'grot_class('//trim(adjustl(sclass))//')'
       !
       if (job%verbose>=5) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. modes, no. unique terms, no. basis functions:', &
                                                                  nmodes_class, nterms_uniq(iclass), dimen
       !
       ! allocate array to keep contracted matrix elements
       !
       if (job%verbose>=6) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size =', &
                                      real(nterms_uniq(iclass)*max(dimen,nprim)**2)*8.0/1024.0**3, 'gb'
       !
       allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
       call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
       !
       !matsize = int(nterms_uniq(iclass)*dimen*dimen,hik)
       !
       !if (job%verbose>=5) write(out,"('  Allocating ',i7,'x',i8,'x',i8,'x',i2,'x',i2,' = ',i12,' grot matrix of ',f15.4,' gb')") & 
       !                    nterms_uniq(iclass),dimen,dimen,1,1,matsize,real(matsize,rk)*8.0_rk/1024.0_rk**3
       !
       !allocate(grot_me(iclass)%me(nterms_uniq(iclass),dimen,dimen,1,1), stat=info)
       !write(sclass,'(i4)') iclass
       !skey = 'grot_me('//trim(adjustl(sclass))//')'
       !call ArrayStart(trim(skey),info,1,rk,matsize)
       !grot_me(iclass)%me = 0
       !
       ! compute contracted matrix elements for operators: G
       !
       if (job%verbose>=5) write(out, '(3x,a,3x,a,5x,a)') 'p_i*Grot*p_j:', 'i', 'j'
       if (job%verbose>=5) write(out, '(17x,i3,3x,i3)') 0, 0
       !
       ! <G>
       !
       call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), & 
                                            terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
       call store_contr_matelem_expansion_II(0,0,iclass,func_tag,0,0,dimen,nterms_uniq(iclass),me_contr)
       !
       allocate(grot_class(iclass)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
       call ArrayStart(trim(skey_cls),info,1_ik,rk,size(grot_class(iclass)%me,kind=hik))
       grot_class(iclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
       !
       !grot_me(iclass)%me(1:,1:dimen,1:dimen,1,1) = me_contr(1:,1:dimen,1:dimen)
       !
       deallocate(me_contr)
       call ArrayStop('PTstore_contr_matelem:me_contr')
       !
     enddo ! iclass
     !
     ! Now the last class

     !-----------------------------------------------------------------------!
     ! store expansion terms and coefficients for the rotational part of KEO !
     !-----------------------------------------------------------------------!
     !
     if (job%verbose>=4) write(out, '(/1x,a)') 'Store expansion coefficients for Grot'
     !
     !nterms = maxval(trove%g_rot(1:3,1:3)%Ncoeff)
     icomb_maxnterms = maxval(icomb_nterms(0:ncomb))
     !
     allocate(ijmode_icomb_iterm(nclasses,icomb_maxnterms,0:ncomb), ijmode_icomb_coefs(icomb_maxnterms,0:ncomb), & 
                                 ijmode_icomb_nterms(0:ncomb), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') &
       'error: failed to allocate ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms(0:ncomb)', &
       'nclasses, icomb_maxnterms, ncomb =', nclasses, icomb_maxnterms, ncomb
       stop
     endif
     !
     if (job%verbose>=4) write(out, '(3x,a,3x,a,3x,a,3x,a,3x,es16.8)') 'imode', 'jmode', 'no. terms', &
                                    'no. terms with Grot(imode,jmode) >=', coef_thresh
     !
     do imode=1, 3
       do jmode=1, 3
         !
         fl => me%grot(imode,jmode)
         !
         if (job%verbose>=6) write(out, '(1x,i6,1x,i6)') imode,jmode
         !
         ! Build the correlation betweem uniq_term(iclass) and icoeff-representations of the field 
         !
         call correlate_field_expansions_sparse_to_by_classes(fl,func_tag,KinOrder,maxnterms,nterms0,&
                                                              IndexQ,IndexQ0,iterm_uniq(1:nclasses,1:nterms),&
                                                              nterms_uniq,terms_uniq)
         !
       enddo ! jmode
     enddo ! imode
     !
     deallocate(ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms)


     !  enddo
     !enddo
     !
     call store_fast_ci_uniq(func_tag)
     !




  endif





  !
  if ( treat_vibration.and.(.not.job%IOmatelem_split.or.job%iswap(1)==0) ) then 
      !
      !------------------------------------------!
      ! compute and store matrix elements of PES !
      !------------------------------------------!
      !
      if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of PES'
      !
      func_tag = 'Vpot'
      !
      target_index = 0 
      target_index(1) = PotOrder
      nterms= FLQindex(trove%Nmodes_e,target_index)
      nterms0= FLQindex(trove%Nmodes-1,target_index)
      !
      if (job%verbose>=5) write(out, '(/1x,a,1x,i8)') 'number of expansion terms:', nterms
      !
      ! organize terms into groups for different combinations of classes
      !
      call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                            ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb),&
                            icomb_iterm(:,0:ncomb))
      !
      if (job%verbose>=5) then 
        write(out, '(/1x,a)') 'number of expansion terms for each combination of classes:'
        do icomb=0, ncomb
          write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
        enddo
      endif
      !
      if (sum(icomb_nterms(0:ncomb))/=nterms) then
        write(out, '(/a,1x,i6,1x,a,1x,i6)') &
        'PTstore_contr_matelem error: number of PES expansion terms among all combinations of classes =', &
         sum(icomb_nterms(0:ncomb)), &
        'differs from the total number of terms =', nterms
        stop
      endif
      !
      ! select only unique terms for each class
      !
      call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                            nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), &
                            terms_uniq(1:nmodes,1:nterms,1:nclasses))
      !
      if (job%verbose>=5) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', &
                          nterms_uniq(1:nclasses)
      !
      allocate(vpot_me(nclasses), stat=info)
      if (info/=0) then
        write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate vpot_me(nclasses)', 'nclasses =', nclasses
        stop
      endif
      !
      allocate(vpot_class(nclasses), stat=info)
      if (info/=0) then
        write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate vpot_class(nclasses)', 'nclasses =', nclasses
        stop
      endif
      !
      do iclass=1, nclasses-1
        !
        if (job%verbose>=5) write(out, '(/1x,a,1x,i3)') 'iclass = ', iclass
        !
        vpot_me(iclass)%nterms = nterms_uniq(iclass)
        !
        dimen = contr(iclass)%nroots
        nprim = contr(iclass)%dimen
        !
        write(sclass,'(i4)') iclass
        skey_cls = 'vpot_class('//trim(adjustl(sclass))//')'
        !
        if (job%verbose>=5) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. unique terms, no. basis functions:', &
                            nterms_uniq(iclass), dimen
        !
        if (job%verbose>=5) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size = ', &
                            real(nterms_uniq(iclass)*max(dimen,nprim)**2)*8.0/1024.0**3, 'gb'
        !
        matsize = int(nterms_uniq(iclass)*dimen*dimen,hik)
        !
        !if (job%verbose>=5) write(out,"('  Allocating ',i7,'x',i8,'x',i8,'x',i2,'x',i2,' = ',i12,' vpot matrix of ',f15.4,' gb')") & 
        !                    nterms_uniq(iclass),dimen,dimen,1,1,matsize,real(matsize,rk)*8.0_rk/1024.0_rk**3
        !
        allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
        !if (info/=0) then
        !  write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate me_contr(nterms_uniq,max(dimen,nprim),max(dimen,nprim))', &
        !  'nterms_uniq, dimen, nprim =', nterms_uniq(iclass), dimen, nprim
        !endif
        call ArrayStart('Vpot_me',info,1,rk,matsize)
        !
        !
        !allocate(Vpot_me(iclass)%me(nterms_uniq(iclass),dimen,dimen,1,1), stat=info)
        !write(sclass,'(i4)') iclass
        !skey = 'vpot_me('//trim(adjustl(sclass))//')'
        !vpot_me(iclass)%me = 0
        !
        call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), &
                                             terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
        call store_contr_matelem_expansion_II(0,0,iclass,func_tag,0,0,dimen,nterms_uniq(iclass),me_contr)
        !
        allocate(vpot_class(iclass)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
        call ArrayStart(trim(skey_cls),info,1_ik,rk,size(vpot_class(iclass)%me,kind=hik))
        !
        vpot_class(iclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
        !
        !Vpot_me(iclass)%me(:,:,:,1,1) = me_contr(:,:,:)
        !
        deallocate(me_contr)
        !
        call ArrayStop('Vpot_me')
        !
      enddo ! iclass
      !
      nmodes_class = iclass_imode(2,iclass) - iclass_imode(1,iclass) + 1
      !
      fl => me%poten
      !
      ! Build the correlation betweem uniq_term(iclass) and icoeff-representations of the field 
      !
      call correlate_field_expansions_sparse_to_by_classes(fl,func_tag,PotOrder,maxnterms,nterms0,IndexQ,IndexQ0,&
                                                           iterm_uniq(1:nclasses,1:nterms),nterms_uniq,terms_uniq)
      !
      call store_fast_ci_uniq(func_tag)
      !
  endif
  !
  ! External Funciton 
  !
  if (treat_exfF) then
     !any(trim(job%IOextF_action)==(/'SAVE','SPLIT'/))) then
     !
     extF_rank = FLread_extF_rank()
     !
     ! compute and store matrix elements of extF 
     !
     if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of extF'
     !
     func_tag = 'extF'
     !
     target_index = 0 
     target_index(1) = ExtFOrder
     nterms= FLQindex(trove%Nmodes_e,target_index)
     nterms0= FLQindex(trove%Nmodes-1,target_index)
     !
     if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'number of expansion terms:', nterms
     !
     ! organize terms into groups for different combinations of classes
     !
     call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb), &
                           icomb_iterm(:,0:ncomb))
     !
     if (job%verbose>=4) then 
       write(out, '(/1x,a)') 'number of expansion terms for each combination of classes:'
       do icomb=0, ncomb
         write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
       enddo
     endif  
     !
     if (sum(icomb_nterms(0:ncomb))/=nterms) then
       write(out, '(/a,1x,i6,1x,a,1x,i6)') &
       'PTstore_contr_matelem error: number of extF expansion terms among all combinations of classes =', &
        sum(icomb_nterms(0:ncomb)), &
       'differs from the total number of terms =', nterms
       stop
     endif
     !
     ! select only unique terms for each class
     !
     call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
     !
     if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
     !
     allocate(extF_me(nclasses), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate exftF_me(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     allocate(extF_class(nclasses), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate extF_class(nclasses)', 'nclasses =', nclasses
       stop
     endif
     !
     do iclass=1, nclasses-1
       !
       if (job%verbose>=5) write(out, '(/1x,a,1x,i3)') 'iclass = ', iclass
       !
       extF_me(iclass)%nterms = nterms_uniq(iclass)
       !
       dimen = contr(iclass)%nroots
       nprim = contr(iclass)%dimen
       !
       write(sclass,'(i4)') iclass
       skey_cls = 'extF_class('//trim(adjustl(sclass))//')'
       !
       if (job%verbose>=5) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. unique terms, no. basis functions:', &
                           nterms_uniq(iclass), dimen
       !
       if (job%verbose>=7) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size = ', &
       real(nterms_uniq(iclass)*max(dimen,nprim)**2)*8.0/1024.0**3, 'gb'
       !
       allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
       call ArrayStart('PTstore_contr_matelem:me_contr',info,1_ik,kind(me_contr),size(me_contr,kind=hik))
       !
       !matsize = int(nterms_uniq(iclass)*dimen*dimen,hik)
       !
       !if (job%verbose>=5) write(out,"('  Allocating ',i7,'x',i8,'x',i8,'x',i2,'x',i2,' = ',i12,' extF matrix of ',f15.4,' gb')") & 
       !                    nterms_uniq(iclass),dimen,dimen,1,1,matsize,real(matsize,rk)*8.0_rk/1024.0_rk**3
       !
       !allocate(extF_me(iclass)%me(nterms_uniq(iclass),dimen,dimen,1,1), stat=info)
       !write(sclass,'(i4)') iclass
       !skey = 'extF_me('//trim(adjustl(sclass))//')'
       !call ArrayStart(trim(skey),info,1,rk,matsize)
       !extF_me(iclass)%me = 0
       !
       call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), & 
                                            terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
       call store_contr_matelem_expansion_II(0,0,iclass,func_tag,0,0,dimen,nterms_uniq(iclass),me_contr)
       !
       allocate(extF_class(iclass)%me(nterms_uniq(iclass),dimen,dimen), stat=info)
       call ArrayStart(trim(skey_cls),info,1_ik,rk,size(extF_class(iclass)%me,kind=hik))
       extF_class(iclass)%me(1:,1:dimen,1:dimen) = me_contr(1:,1:dimen,1:dimen)
       !
       !extF_me(iclass)%me(:,:,:,1,1) = me_contr(:,:,:)
       !
       deallocate(me_contr)
       call ArrayStop('PTstore_contr_matelem:me_contr')
       !
     enddo ! iclass
     !
     do ipar=1, extF_rank
        !
        fl => me%ExtF(ipar)
        !
        if (job%verbose>=6) write(out, '(1x,i6)') ipar
        !
        ! Build the correlation betweem uniq_term(iclass) and icoeff-representations of the field 
        !
        call correlate_field_expansions_sparse_to_by_classes(fl,func_tag,ExtFOrder,maxnterms,nterms0,IndexQ,IndexQ0,&
                                                             iterm_uniq(1:nclasses,1:nterms),nterms_uniq,terms_uniq)
        !
     enddo
     !
     call store_fast_ci_uniq(func_tag)
     !
  endif
  !
  !---------------------------!
  ! store contraction indices !
  !---------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'store contraction indices ...'
  call store_contr_ind
  !
  ! Done
  !
  deallocate(icomb_nclasses, icomb_iclass, icomb_nterms, icomb_iterm, terms_uniq, iterm_uniq, terms)
  call ArrayStop('PTstore_contr_matelem:terms')
  call ArrayStop('PTstore_contr_matelem:icomb_nclasses')
  call ArrayStop('PTstore_contr_matelem:icomb_iclass')
  call ArrayStop('PTstore_contr_matelem:icomb_nterms')
  call ArrayStop('PTstore_contr_matelem:terms_uniq')
  call ArrayStop('PTstore_contr_matelem:iterm_uniq')
  call ArrayStop('PTstore_contr_matelem:icomb_iterm')
  !
  if (job%verbose>=4) write(out, '(/a)')  'PTstore_contr_matelem/done'
  !
  call TimerStop('PTstore_contr_matelem')
  !
  if (job%verbose>=3) call MemoryReport
  if (job%verbose>=3) call TimerReport
  !
  contains 


  subroutine match_terms(fl,icomb_in,iterm_in,iterm_out)
     !
     type(FLpolynomT),pointer :: fl
     integer(ik),intent(in)   :: icomb_in,iterm_in
     integer(ik),intent(out) :: iterm_out
     integer(ik) :: icomb_out,jterm_out,iterm,iclass
     real(rk) :: c
     logical :: match 
     character(len=cl) :: my_fmt !format for I/O specification
  
     ! check if we are able to recover all expansion terms from the unique for each class terms
     !
     nterms = fl%Ncoeff
     !
     iterm_out = 0
     icomb_out=0
     jterm_out = 0 
     !
     do iterm=1, nterms
       !
       c = real(fl%field(iterm,0),kind=rk)
       !
       if (abs(c)<coef_thresh) cycle
       match = .false.
       ! loop over combinations of classes
       !do icomb=0, ncomb
         ! loop over terms assigned to the current combination of classes
         !do jterm=1, ijmode_icomb_nterms(icomb)
           ! assemble term indices from unique for each class indices
           term = 0
           do iclass=1, nclasses
             imode1 = iclass_imode(1,iclass)
             imode2 = iclass_imode(2,iclass)
             term(imode1:imode2) = terms_uniq(imode1:imode2,iterm_in,iclass)
           enddo
           if (all(term(:)==terms(:,iterm))) match = .true.
           if (match) then 
              iterm_out = iterm
              exit
           endif
         !enddo
         !if (match) exit
       !enddo
       if (.not.match) then
         write(my_fmt,'(a,i0,a)') "(/a,1x,",nmodes,"(1x,i3),1x,2a)"
         write(out,my_fmt) 'PTstore_contr_matelem error(match_terms): failed while checking the expansion term = (',&
                            terms(:,iterm),fl%name, ')'
         stop
       endif
     enddo
     !
  end subroutine match_terms


  subroutine correlate_field_expansions_sparse_to_by_classes(fl,tag,NOrder,maxnterms,nterms0,IndexQ,IndexQ0,&
                                                             iterm_uniq,nterms_uniq,terms_uniq)
   !
   implicit none 
   !
   type(PTcoeffT),pointer :: fl 
   character(cl),intent(in)  :: tag
   integer(ik),intent(in) :: NOrder,maxnterms,IndexQ(PT%Nmodes,maxnterms),IndexQ0(PT%Nmodes,maxnterms),&
                             iterm_uniq(PT%nclasses,maxnterms),nterms_uniq(PT%Nclasses),nterms0,terms_uniq(:,:,:)
   !
   integer(ik) :: icoeff,iterm_,kclass,itermm,Nfield_terms,Nclasses,imode1,imode2,IndexQ_(PT%Nmodes,maxnterms),&
                  IndexS_(PT%Nmodes,maxnterms),jmode,nterms_,target_index(PT%Nmodes),nterms_icl,iterms_
   integer(ik),allocatable :: ifromsparse(:),itosparse(:)
   character(len=cl)       :: my_fmt !format for I/O specification
      !
      if (job%verbose>=6) write(out,"('correlate_field_expansions_sparse_to_by_classes')") 
      !
      Nclasses = PT%Nclasses
      !
      allocate(fl%uniq(Nclasses,fl%Ncoeff),stat=info)
      call ArrayStart(trim(tag)//'-uniq',info,size(fl%uniq),kind(fl%uniq))
      !
      allocate(fl%Nterms(Nclasses),stat=info)
      call ArrayStart(trim(tag)//'-uniq',info,size(fl%Nterms),kind(fl%Nterms))
      !
      allocate(fl%iterm(Nclasses,maxval(nterms_uniq)),stat=info)
      call ArrayStart(trim(tag)//'-uniq',info,size(fl%iterm),kind(fl%iterm))
      !
      allocate(ifromsparse(fl%Ncoeff),itosparse(maxnterms),stat=info)
      call ArrayStart('ifromsparse',info,size(ifromsparse),kind(ifromsparse))
      !
      allocate(fl%ifromsparse(fl%Ncoeff),stat=info)
      call ArrayStart(trim(tag)//'-ifromsparse',info,size(fl%ifromsparse),kind(fl%ifromsparse))
      !
      allocate(fl%icoeff(Nclasses),fl%iuniq(Nclasses),stat=info)
      !
      !target_index = IndexQ(:,maxnterms)
      !
      target_index = 0; target_index(1) = NOrder 
      !
      do iclass=1,Nclasses
        !
        imode1 = PT%mode_class(iclass,1)
        imode2 = PT%mode_class(iclass,PT%mode_iclass (iclass))
        !
        nterms_ = FLQindex(imode2,target_index)
        !nterms_= nterms_uniq(iclass)
        !
        if (iclass==Nclasses) nterms_= fl%Ncoeff
        !
        fl%icoeff(iclass)%isize(1) = nterms_
        allocate(fl%icoeff(iclass)%imat(nterms_),stat=info)
        call ArrayStart(trim(tag)//'-icoeff%imat',info,size(fl%icoeff(iclass)%imat),kind(fl%icoeff(iclass)%imat))
        !
        !nterms_ = nterms_uniq(iclass)
        !
        fl%iuniq(iclass)%isize(1) = nterms_
        allocate(fl%iuniq(iclass)%imat(nterms_),stat=info)
        call ArrayStart(trim(tag)//'-iuniq%imat',info,size(fl%iuniq(iclass)%imat),kind(fl%iuniq(iclass)%imat))
        !
      enddo
      !
      if (job%verbose>=5) write (out,"(  'Generating fl%uniq ...')")
      !
      itosparse = 0
      loop_icoeff : do icoeff = 1,fl%Ncoeff
        do iterm=1,maxnterms
            if (all(fl%IndexQ(:,icoeff)==IndexQ(:,iterm))) then
              ifromsparse(icoeff) = iterm
              itosparse(iterm) = icoeff
              cycle loop_icoeff 
            endif
        enddo
        !
        write(my_fmt,'(a,i0,a)') "(a,a,a,i8,",nmodes,"i4)"
        write(out,my_fmt) 'correlate_field_expansions...:', trim(tag),&
                          ' could not find a sparse-to-non-sparse-match for icoeff =',icoeff, fl%IndexQ(:,icoeff)
        stop 'correlate_field_expansions...: corr, could not find a sparse-not-sparse-match'
        !
      enddo loop_icoeff
      !
      ! reconstruct correlation from icoeff to uniq-term(iclass)
      !
      do icoeff = 1,fl%Ncoeff
        !
        iterm_ = ifromsparse(icoeff)
        !
        do kclass=1,Nclasses
          fl%uniq(kclass,icoeff) = iterm_uniq(kclass,iterm_)
        enddo
      enddo
      !
      fl%iterm = iterm_uniq
      fl%Nterms = nterms_uniq
      !
      if (job%verbose>=5) write (out,"(  'Generating IndexQ0 and fl%ifromsparse ...')")
      !
      imode1 = PT%mode_class(nclasses,1)
      write(my_fmt,'(a,i0,a)') "(a,a,a,i8,",nmodes,"i4)"
      !
      loop_iterm : do icoeff = 1,fl%Ncoeff
        do iterm=1,nterms0
            if (all(fl%IndexQ(:imode1-1,icoeff)==IndexQ0(:imode1-1,iterm))) then
              fl%ifromsparse(icoeff) = iterm
              cycle loop_iterm 
            endif
        enddo
        !
        write(out,my_fmt) 'correlate_field_expansions...:', trim(tag),&
                          ' could not find a sparse-to-(Nclasses-1)-match for icoeff =',icoeff, fl%IndexQ(:,icoeff)
        stop 'correlate_field_expansions...: could not find a sparse-to-(Nclasses-1)-match'
        !
      enddo loop_iterm
      !
      indexQ_ = 0
      indexS_ = 0 
      !
      write(my_fmt,'(a,i0,a)') "(a,a,a,i8,",nmodes,"i4)"
      !
      do iclass = Nclasses,2,-1
        !
        imode1 = PT%mode_class(iclass,1)
        imode2 = PT%mode_class(iclass,PT%mode_iclass (iclass))
        !
        nterms_icl = nterms_uniq(iclass)
        !
        target_index = 0; target_index(1) = NOrder 
        !
        nterms_ = FLQindex(imode2  ,target_index,indexQ_)
        iterms_ = FLQindex(imode1-1,target_index,indexS_)
        !
        if (iclass==nclasses) nterms_ = fl%Ncoeff
        !
        loop_iterm_class : do icoeff = 1,nterms_
          !
          iterm = icoeff
          if (iclass==Nclasses) iterm = ifromsparse(icoeff)
          !
          do jterm=1,iterms_
              if (all(indexQ_(:imode1-1,iterm)==IndexS_(:imode1-1,jterm))) then
                fl%icoeff(iclass)%imat(icoeff) = jterm
                cycle loop_iterm_class 
              endif
          enddo
          !
          write(out,my_fmt) 'correlate_field_expansions...:', trim(tag),&
                          ' could not find a sparse-to-non-sparse-match for icoeff =',icoeff, fl%IndexQ(:,icoeff)
          stop 'correlate_field_expansions...: could not find a sparse-to-iterm_class-match'
          !
        enddo loop_iterm_class
        !
      enddo

      write(my_fmt,'(a,i0,a)') "(a,a,a,i8,",nmodes,"i4)"
      do iclass = Nclasses,1,-1
        !
        imode1 = PT%mode_class(iclass,1)
        imode2 = PT%mode_class(iclass,PT%mode_iclass (iclass))
        !
        nterms_icl = nterms_uniq(iclass)
        !
        target_index = 0; target_index(1) = NOrder 
        !
        nterms_ = FLQindex(imode2  ,target_index,indexQ_)
        if (iclass==nclasses) nterms_ = fl%Ncoeff
        !
        iterms_ = nterms_uniq(iclass)
        !
        loop_iterm_uniq : do icoeff = 1,nterms_
          !
          iterm = icoeff
          if (iclass==Nclasses) iterm = ifromsparse(icoeff)
          !
          do jterm=1,iterms_
              if (all(indexQ_(imode1:imode2,iterm)==terms_uniq(imode1:imode2,jterm,iclass))) then
                fl%iuniq(iclass)%imat(icoeff) = jterm
                cycle loop_iterm_uniq 
              endif
          enddo
          !
          write(out,my_fmt) 'correlate_field_expansions...:', trim(tag),&
                          ' could not find a sparse-to-non-sparse-match for icoeff =',icoeff, fl%IndexQ(:,icoeff)
          stop 'correlate_field_expansions...: could not find a sparse-to-uniq-match'
          !
        enddo loop_iterm_uniq
        !
      enddo
      !
      fl%MaxNterms = 1
      !
      if (Nclasses>1) fl%MaxNterms = fl%icoeff(Nclasses-1)%isize(1)
      !
      ! new summation scheme by classes
      !
      Nfield_terms = product(nterms_uniq(:))
      !
      !allocate(fl%ifield(Nfield_terms),stat=info)
      !call ArrayStart('tag'//'-ifield',info,size(fl%ifield),kind(fl%ifield))
      !
      !if (job%verbose>=6) print*,"Nfield_terms = ", Nfield_terms
      !
      !call create_field_expansion_by_classes(maxnterms,nterms_uniq,terms_uniq,itosparse,fl%ifield)
      !
      deallocate(ifromsparse,itosparse)
      call ArrayStop('ifromsparse')
      !
  end subroutine correlate_field_expansions_sparse_to_by_classes
  !
end subroutine PTstore_contr_matelem_II



subroutine create_field_expansion_by_classes(maxnterms,nterms,terms_uniq,itosparse,ifield)
  !
  !
  implicit none
  !
  integer(ik),intent(in) :: maxnterms,nterms(PT%Nclasses),itosparse(maxnterms)
  integer(ik),intent(in) :: terms_uniq(PT%nmodes,maxnterms,PT%nclasses)
  integer(ik),intent(out) :: ifield(:)
  integer(ik) :: iclass
  integer(ik) :: itotal,iactual
  integer(ik) :: ipowers(PT%nmodes)
    !
    ! ititialization
    !
    iclass = 0
    ipowers = 0
    iactual = 0
    itotal = 0
    ifield = 0
    !
    call do_expansion(iclass+1_ik,ipowers,itotal,iactual,ifield)
    !
  contains

   recursive subroutine do_expansion(iclass,ipowers,itotal,iactual,ifield)
      !
      integer(ik) :: iclass
      integer(ik),intent(out) :: itotal,iactual,ifield(:)
      integer(ik) :: iterm,ipowers(PT%nmodes),qindex,isparse,imode1,imode2
      !
      imode1 = PT%mode_class(iclass,1)
      imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
      !
      if (iclass == PT%Nclasses) then
        !
        itotal = itotal + 1
        !
        !ipowers(imode1:imode2) = terms_uniq(imode1:imode2,iterm,iclass)
        !
        qindex = FLQindex(imode1-1,ipowers)
        !
        if (qindex>maxnterms) return
        !
        !isparse = itosparse(qindex)
        !
        !if (isparse==0) cycle
        !
        iactual = iactual + 1
        !
        ifield(itotal) = qindex ! isparse ! iactual
        !
        if (job%verbose>=7) print*,"iactual,itotal,qindex =  ", iactual,itotal,qindex
        if (job%verbose>=7) print*,"ipowers =  ", ipowers
        !
        return
        !
      else
        !
        if (job%verbose>=6) print*,"iclass,nterms(iclass) = ", iclass,nterms(iclass)
        !
        do iterm=1,nterms(iclass)
          !
          ipowers(imode1:imode2) = terms_uniq(imode1:imode2,iterm,iclass)
          !
          call do_expansion(iclass+1_ik,ipowers,itotal,iactual,ifield)
          !
        enddo
        !
      endif
      !
   end subroutine do_expansion
   !
end subroutine create_field_expansion_by_classes



recursive subroutine cartesian_product(nvec, nelem, elem, sym, minsum, maxsum, ivec, ind, nterms, cprod)

  integer(ik), intent(in)              :: nvec
  integer(ik), intent(in)              :: nelem(nvec)
  integer(ik), intent(in)              :: elem(maxval(nelem),nvec)
  logical, intent(in)                  :: sym
  integer(ik), intent(in)              :: minsum
  integer(ik), intent(in)              :: maxsum
  integer(ik), intent(in)              :: ivec
  integer(ik), intent(inout)           :: ind(nvec)
  integer(ik), intent(inout)           :: nterms
  integer(ik), intent(inout), optional :: cprod(:,:)

  integer(ik) :: ielem, i
  integer(ik) :: sumind

  if (ivec==1) nterms = 0

  do ielem=1, nelem(ivec)
    ind(ivec) = elem(ielem,ivec)
    sumind = sum(ind(1:ivec))
    if (sumind>maxsum) cycle
    if (ivec>1.and.sym.and..not.all((/(ind(i-1)<ind(i), i=2, ivec)/))) cycle
    if (ivec==nvec) then
      if (sumind<minsum) cycle
      nterms = nterms + 1
      if (present(cprod)) cprod(:,nterms) = ind
    else
      call cartesian_product(nvec, nelem, elem, sym, minsum, maxsum, ivec+1, ind, nterms, cprod)
    endif

  enddo

end subroutine cartesian_product



subroutine split_terms_uniq(nmodes, nterms, terms, nclasses, imode_class, nterms_class, iterm_class, terms_class)

  integer(ik), intent(in) :: nmodes, nterms, terms(nmodes,nterms), nclasses, imode_class(2,nclasses)
  integer(ik), intent(out) :: nterms_class(nclasses), iterm_class(nclasses,nterms), terms_class(nmodes,nterms,nclasses)

  integer(ik) :: iclass, imode1, imode2, iterm, jterm, ipos

  nterms_class = 0 ! total number of terms in each class
  terms_class = 0  ! powers for a given ipos in a given class 
  iterm_class = 0  ! correlation from iterm to the uniq-position for a given class

  do iclass=1, nclasses
    imode1 = imode_class(1,iclass)
    imode2 = imode_class(2,iclass)
    do iterm=1, nterms
      ipos = 0
      do jterm=1, nterms_class(iclass)
        if (all(terms_class(imode1:imode2,jterm,iclass)==terms(imode1:imode2,iterm))) then
          ipos = jterm
          exit
        endif
      enddo
      if (ipos==0) then
        nterms_class(iclass) = nterms_class(iclass) + 1
        terms_class(imode1:imode2,nterms_class(iclass),iclass) = terms(imode1:imode2,iterm)
        ipos = nterms_class(iclass)
      endif
      !
      ! correlation from iterm to the uniq-position for a given class 
      iterm_class(iclass,iterm) = ipos
    enddo
  enddo

end subroutine split_terms_uniq



subroutine split_terms_comb(nmodes, nterms, terms, nclasses, iclass_imode, ncomb, icomb_nclasses, icomb_iclass, &
                            icomb_nterms, icomb_iterm, iunique_from_iterm)

  integer(ik), intent(in) :: nmodes, nterms, terms(nmodes,nterms), nclasses, iclass_imode(2,nclasses), ncomb, &
                             icomb_nclasses(0:ncomb), icomb_iclass(nclasses,0:ncomb)
  integer(ik), intent(out) :: icomb_nterms(0:ncomb)
  integer(ik), intent(out), optional :: icomb_iterm(:,0:)
  integer(ik), intent(out), optional :: iunique_from_iterm(:,:)

  integer(ik) :: icomb, nclasses0, iclass0(nclasses), iclass, iclass_n, imode1, imode2, iterm, n, n0

  if (present(icomb_iterm)) icomb_iterm = 0
  icomb_nterms = 0

  do icomb=0, ncomb
    ! list of classes that are not present in the current combination
    nclasses0 = 0
    do iclass=1, nclasses
      n = icomb_nclasses(icomb)
      if (all(icomb_iclass(1:n,icomb)/=iclass)) then
        nclasses0 = nclasses0 + 1
        iclass0(nclasses0) = iclass
      endif
    enddo
    do iterm=1, nterms
      n = 0
      do iclass=1, icomb_nclasses(icomb)
        iclass_n = icomb_iclass(iclass,icomb)
        imode1 = iclass_imode(1,iclass_n)
        imode2 = iclass_imode(2,iclass_n)
        !
        ! n is the number of classes with non-zero-powers for a given term-power
        if (any(terms(imode1:imode2,iterm)>0)) n = n + 1
      enddo
      n0 = 0
      do iclass=1, nclasses0
        iclass_n = iclass0(iclass)
        imode1 = iclass_imode(1,iclass_n)
        imode2 = iclass_imode(2,iclass_n)
        !
        ! n0 is the number of classes with zero-powers for a given term-power
        if (all(terms(imode1:imode2,iterm)==0)) n0 = n0 + 1
      enddo
      if (n==icomb_nclasses(icomb).and.n0==nclasses0) then
        !
        ! number of elements in each combination
        icomb_nterms(icomb) = icomb_nterms(icomb) + 1
        if (present(icomb_iterm)) then
          !correlation from ipos,icomb to iterm 
          icomb_iterm(icomb_nterms(icomb),icomb) = iterm
        endif
        if (present(iunique_from_iterm)) then
          !
          ! inverse correlation from iterm to ipos,icomb
          iunique_from_iterm(iterm,1) = icomb_nterms(icomb) ! ipos
          iunique_from_iterm(iterm,2) = icomb               ! icomb
        endif
      endif
    enddo
  enddo

end subroutine split_terms_comb



subroutine calc_contr_matelem_expansion_Trot_Nclass(func_tag,nterms,terms,FLcoeff,prim_vect,me_contr)
  implicit none 

  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: nterms, terms(:,:)
  real(rk), intent(in)  :: FLcoeff(:,0:,0:)
  real(rk), intent(in) :: prim_vect(:,:)
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: iclass,kmode,info,alloc_p,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes), nu_j(PT%Nmodes), imode1, imode2, nmodes
  real(rk), allocatable :: tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='Trot') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_Trot_Nclass error: illegal field ', trim(func_tag)
    stop 'calc_contr_matelem_expansion_Trot_Nclass error: illegal field '
  endif
  call TimerStart('fast-ci: computing Trot_Nclass')
  !
  iclass = PT%Nclasses
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_Trot_Nclass error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_Trot_Nclass',info,size(tmat),kind(tmat))
  !
  imode2 = min(PT%Nmodes-1,imode2)
  !
  ! compute matrix elements between products of 1D functions
  !  
  !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
  do iprim=1, nprim
    nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
    do jprim=1, nprim
      nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
      do iterm=1, nterms
         do kmode=imode1, imode2
            me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
        enddo
        me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
      enddo
    enddo
  enddo  
  !$omp end parallel do
  !
  ! contraction coefficients
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_vect(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_vect(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0,me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(tmat)
  call ArrayStop('calc_contr_matelem_expansion_Trot_Nclass')
  call TimerStop('fast-ci: computing Trot_Nclass')
  !
end subroutine calc_contr_matelem_expansion_Trot_Nclass



subroutine calc_contr_matelem_expansion_vpot_Nclass(func_tag,nterms,terms,FLcoeff,prim_vect,me_contr)

  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: nterms, terms(:,:)
  real(rk), intent(in)  :: FLcoeff(:,0:,0:)
  real(rk), intent(in)  :: prim_vect(:,:)
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: iclass,kmode,info,alloc_p,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes), nu_j(PT%Nmodes), imode1, imode2, nmodes
  real(rk), allocatable :: tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='Vpot') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_vpot_Nclass error: illegal field ', trim(func_tag)
    stop 'calc_contr_matelem_expansion_vpot_Nclass error: illegal field '
  endif
  call TimerStart('fast-ci: computing Vpot_Nclass')
  !
  iclass = PT%Nclasses
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_vpot_Nclass error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_vpot_Nclass',info,size(tmat),kind(tmat))
  !
  imode2 = min(PT%Nmodes-1,imode2)
  !
  ! compute matrix elements between products of 1D functions
  !
  !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
  do iprim=1, nprim
    nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
    do jprim=1, nprim
      nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
      do iterm=1, nterms
         do kmode=imode1, imode2
           me_term(kmode) = me%vibmode(kmode,0)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
         enddo
         !
         me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
         !
      enddo
      !
    enddo
  enddo
  !$omp end parallel do
  !
  ! contraction coefficients
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_vect(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_vect(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0,me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(tmat)
  call ArrayStop('calc_contr_matelem_expansion_vpot_Nclass')
  call TimerStop('fast-ci: computing Vpot_Nclass')
  !
end subroutine calc_contr_matelem_expansion_vpot_Nclass


subroutine calc_contr_matelem_expansion_extF_Nclass(func_tag,nterms,terms,FLcoeff,prim_vect,me_contr)

  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: nterms, terms(:,:)
  real(rk), intent(in)  :: FLcoeff(:,0:,0:)
  real(rk), intent(in)  :: prim_vect(:,:)
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: iclass,kmode,ispecies,info,alloc_p,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes), nu_j(PT%Nmodes), imode1, imode2, nmodes
  real(rk), allocatable :: tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='extF') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_extF_Nclass error: illegal field ', trim(func_tag)
    stop 'calc_contr_matelem_expansion_extF_Nclass error: illegal field '
  endif
  call TimerStart('fast-ci: computing extF_Nclass')
  !
  iclass = PT%Nclasses
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_extF_Nclass error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_extF_Nclass',info,size(tmat),kind(tmat))
  !
  imode2 = min(PT%Nmodes-1,imode2)
  !
  ! compute matrix elements between products of 1D functions
  !
  !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,ispecies,me_term) shared(me_contr) schedule(dynamic)
  do iprim=1, nprim
    nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
    do jprim=1, nprim
      nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
      !
      do iterm=1, nterms
         do kmode=imode1, imode2
            me_term(kmode) = me%vibmode(kmode,3)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
        enddo
        !
        me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
        !
      enddo
      !
    enddo
  enddo  
  !$omp end parallel do
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_vect(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_vect(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0,me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(tmat)
  call ArrayStop('calc_contr_matelem_expansion_extF_Nclass')
  call TimerStop('fast-ci: computing extF_Nclass')
  !
end subroutine calc_contr_matelem_expansion_extF_Nclass



subroutine calc_contr_matelem_expansion_Tvib_Nclass(func_tag,imode,jmode,nterms,terms,FLcoeff,prim_vect,me_contr)
  !
  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: imode, jmode, nterms, terms(:,:)
  real(rk), intent(in)  :: FLcoeff(:,0:,0:)
  real(rk), intent(in)  :: prim_vect(:,:)
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: iclass,kmode,info,alloc_p,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes), nu_j(PT%Nmodes), imode1, imode2, nmodes
  real(rk), allocatable :: tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='Tvib') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_Tvib_Nclass error: illegal field ', trim(func_tag)
    stop 'calc_contr_matelem_expansion_Tvib_Nclass error: illegal field '
  endif
  call TimerStart('fast-ci: computing Tvib_Nclass')
  !
  iclass = PT%Nclasses
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_Tvib_Nclass error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_Tvib_Nclass',info,size(tmat),kind(tmat))
  !
  imode2 = min(PT%Nmodes-1,imode2)
  !
  ! compute matrix elements between products of 1D functions
  !
  !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
  do iprim=1, nprim
    nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
    do jprim=1, nprim
      nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
      !
      do iterm=1, nterms
        !
        do kmode=imode1,imode2
           if (kmode/=imode.and.kmode/=jmode) then
              me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
           elseif (kmode/=jmode) then
              me_term(kmode) =-me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_j(kmode),nu_i(kmode))
           elseif (kmode/=imode) then
              me_term(kmode) = me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
           else
              me_term(kmode) = me%vibmode(kmode,2)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
           endif
        enddo
        !
        me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
        !
      enddo
      !
    enddo
  enddo
  !$omp end parallel do
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_vect(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_vect(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0,me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(tmat)
  call ArrayStop('calc_contr_matelem_expansion_Tvib_Nclass')
  call TimerStop('fast-ci: computing Tvib_Nclass')
  !
end subroutine calc_contr_matelem_expansion_Tvib_Nclass



subroutine calc_contr_matelem_expansion_Tvib_Nclass_3(func_tag,imode,jmode,nterms,terms,FLcoeff,prim_vect,me_contr)
  !
  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: imode, jmode, nterms, terms(:,:)
  real(rk), intent(in)  :: FLcoeff(:,0:,0:)
  real(rk), intent(in)  :: prim_vect(:,:)
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: iclass,kmode,info,alloc_p,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes), nu_j(PT%Nmodes), imode1, imode2, nmodes
  real(rk), allocatable :: tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='Tvib') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_Tvib_Nclass_3 error: illegal field ', trim(func_tag)
    stop 'calc_contr_matelem_expansion_Tvib_Nclass_3 error: illegal field '
  endif
  call TimerStart('fast-ci: computing Tvib_Nclass')
  !
  iclass = PT%Nclasses
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_Tvib_Nclass_3 error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_Tvib_Nclass_3',info,size(tmat),kind(tmat))
  !
  imode2 = min(PT%Nmodes-1,imode2)
  !
  ! compute matrix elements between products of 1D functions
  !
  if (imode<imode1.and.jmode<imode1) then
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        !
        do iterm=1, nterms
          !
          do kmode=imode1,imode2
             me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          enddo
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
          !
        enddo
        !
      enddo
    enddo
    !$omp end parallel do
    !
  else
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        !
        do iterm=1, nterms
          !
          do kmode=imode1,imode2
             if (kmode/=imode.and.kmode/=jmode) then
                me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
             elseif (kmode/=jmode) then
                me_term(kmode) =-me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_j(kmode),nu_i(kmode))
             elseif (kmode/=imode) then
                me_term(kmode) = me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
             else
                me_term(kmode) = me%vibmode(kmode,2)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
             endif
          enddo
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
          !
        enddo
        !
      enddo
    enddo
    !$omp end parallel do
    !
  endif
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_vect(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_vect(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0,me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(tmat)
  call ArrayStop('calc_contr_matelem_expansion_Tvib_Nclass_3')
  call TimerStop('fast-ci: computing Tvib_Nclass')
  !
end subroutine calc_contr_matelem_expansion_Tvib_Nclass_3





subroutine calc_contr_matelem_expansion_Tvib_Nclass_2(func_tag,imode,jmode,nterms,terms,FLcoeff,prim_vect,me_contr)

  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: imode, jmode, nterms, terms(:,:)
  real(rk), intent(in)  :: FLcoeff(:,0:,0:)
  real(rk), intent(in)  :: prim_vect(:,:)
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: iclass,kmode,info,alloc_p,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes), nu_j(PT%Nmodes), imode1, imode2, nmodes
  real(rk), allocatable :: tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='Tvib') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_Tvib_Nclass error: illegal field ', trim(func_tag)
    stop 'calc_contr_matelem_expansion_Tvib_Nclass error: illegal field '
  endif
  call TimerStart('fast-ci: computing Tvib_Nclass')
  !
  iclass = PT%Nclasses
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_Tvib_Nclass error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_Tvib_Nclass',info,size(tmat),kind(tmat))
  !
  imode2 = min(PT%Nmodes-1,imode2)
  !
  if (imode<imode1.and.jmode<imode1) then
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        do iterm=1, nterms
          do kmode=imode1,imode2
             me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          enddo
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
        enddo
        !
      enddo
    enddo
    !$omp end parallel do
    !
  elseif (imode<imode1) then
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        do iterm=1, nterms
          do kmode=imode1,imode2
             me_term(kmode) = me%vibmode(imode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          enddo
          me_term(jmode) = me%vibmode(jmode,1)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
          !
        enddo
        !
      enddo
    enddo
    !$omp end parallel do
    !
  elseif (jmode<imode1) then
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        do iterm=1, nterms
          do kmode=imode1,imode2
             me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          enddo
          me_term(imode) = -me%vibmode(imode,1)%coeff(terms(imode,iterm),nu_j(imode),nu_i(imode))
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
          !
        enddo
        !
      enddo
    enddo
    !$omp end parallel do
    !
  elseif(imode/=jmode) then
    !
    ! compute matrix elements between products of 1D functions
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        !
        do iterm=1, nterms
          !
          do kmode=imode1,imode2
             me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          enddo
          me_term(imode) = -me%vibmode(imode,1)%coeff(terms(imode,iterm),nu_j(imode),nu_i(imode))
          me_term(jmode) = me%vibmode(jmode,1)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
          !
        enddo
        !
      enddo
    enddo
    !$omp end parallel do
    !
  else
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        !
        do iterm=1, nterms
          !
          do kmode=imode1,imode2
             me_term(kmode) = me%vibmode(kmode,2)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          enddo
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
          !
        enddo
        !
      enddo
    enddo
    !$omp end parallel do
    !
  endif
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_vect(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_vect(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0,me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(tmat)
  call ArrayStop('calc_contr_matelem_expansion_Tvib_Nclass')
  call TimerStop('fast-ci: computing Tvib_Nclass')
  !
end subroutine calc_contr_matelem_expansion_Tvib_Nclass_2


subroutine calc_contr_matelem_expansion_Tcor_Nclass(func_tag,imode,nterms,terms,FLcoeff,prim_vect,me_contr)

  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: imode, nterms, terms(:,:)
  real(rk), intent(in)  :: FLcoeff(:,0:,0:)
  real(rk), intent(in)  :: prim_vect(:,:)
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: iclass,kmode,info,alloc_p,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes), nu_j(PT%Nmodes), imode1, imode2, nmodes
  real(rk), allocatable :: tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='Tcor') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_Tcor_Nclass error: illegal field ', trim(func_tag)
    stop 'calc_contr_matelem_expansion_Tcor_Nclass error: illegal field '
  endif
  call TimerStart('fast-ci: computing Tcor_Nclass')
  !
  iclass = PT%Nclasses
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_Tcor_Nclass error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_Tcor_Nclass',info,size(tmat),kind(tmat))
  !
  imode2 = min(PT%Nmodes-1,imode2)
  !
  ! compute matrix elements between products of 1D functions
  !
  !$omp parallel do private(iprim,jprim,nu_i,nu_j,iterm,kmode,me_term) shared(me_contr) schedule(dynamic)
  do iprim=1, nprim
    nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
    do jprim=1, nprim
      nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
      do iterm=1, nterms
         do kmode=imode1, imode2
            !
            if (kmode==imode) then
               me_term(kmode) = me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))&
                               -me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_j(kmode),nu_i(kmode))
            else
               me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
            endif
            !
        enddo
        !
        me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))*Flcoeff(iterm,nu_i(Nmodes),nu_j(Nmodes))
        !
      enddo
      !
    enddo
    !
  enddo
  !$omp end parallel do
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_vect(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_vect(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0,me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(tmat)
  call ArrayStop('calc_contr_matelem_expansion_Tcor_Nclass')
  call TimerStop('fast-ci: computing Tcor_Nclass')
  !
end subroutine calc_contr_matelem_expansion_Tcor_Nclass



subroutine calc_contr_matelem_expansion_p0(iclass, func_tag, nterms, terms, me_contr)
  !
  integer(ik), intent(in) :: iclass, nterms, terms(:,:)
  character(cl), intent(in) :: func_tag
  real(rk), intent(out) :: me_contr(:,:,:)
  !
  integer(ik) :: imode,jmode,info,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes),nu_j(PT%Nmodes),imode1,imode2,nmodes,alloc_p
  real(rk), allocatable :: prim_coefs(:,:), tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  call TimerStart('fast-ci: computing P0 for '//trim(func_tag))
  !
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_p0 error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(prim_coefs(nprim,nroots),tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_p0',info,size(prim_coefs),kind(prim_coefs))
  call ArrayStart('calc_contr_matelem_expansion_p0',info,size(tmat),kind(tmat))
  !
  !
  ! compute matrix elements between products of 1D functions
  !
  select case (trim(func_tag))
  !
  case('Vpot')
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,jmode,iterm,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        do iterm=1, nterms
          do jmode=imode1,imode2
            me_term(jmode) = me%vibmode(jmode,0)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
          enddo
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))
        enddo
      enddo
    enddo
    !$omp end parallel do
    !
  case('Tvib','Trot','Tcor','pseu')
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,jmode,iterm,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(imode1:imode2) = contr(iclass)%prim_bs%icoeffs(imode1:imode2,iprim)
      do jprim=1, nprim
        nu_j(imode1:imode2) = contr(iclass)%prim_bs%icoeffs(imode1:imode2,jprim)
        do iterm=1, nterms
          do jmode=imode1, imode2
            me_term(jmode) = me%vibmode(jmode,-1)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
          enddo
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))
        enddo
      enddo
    enddo
    !$omp end parallel do
    !
  case ('extF')
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,jmode,iterm,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        do iterm=1, nterms
          do jmode=imode1, imode2
            me_term(jmode) = me%vibmode(jmode,3)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
          enddo
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))
        enddo
      enddo
    enddo
    !$omp end parallel do
    !
  case default 
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_p0 error: unknown type of field =', trim(func_tag)
    stop 'calc_contr_matelem_expansion_p0 error: unknown type of field'
  end select 
  !
  ! contraction coefficients
  !
  !$omp parallel do private(iroot,ilevel,ideg) shared(prim_coefs) schedule(static)
  do iroot=1, nroots
    ilevel = contr(iclass)%ilevel(iroot)
    ideg = contr(iclass)%ideg(iroot)
    prim_coefs(1:nprim,iroot) = contr(iclass)%eigen(ilevel)%vect(1:nprim,ideg)
  enddo
  !$omp end parallel do
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_coefs(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_coefs(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0, me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(prim_coefs, tmat)
  call ArrayStop('calc_contr_matelem_expansion_p0')
  !
  call TimerStop('fast-ci: computing P0 for '//trim(func_tag))
  !
end subroutine calc_contr_matelem_expansion_p0


subroutine calc_contr_matelem_expansion_p1(imode, iclass, func_tag, nterms, terms, me_contr)

  integer(ik), intent(in) :: imode, iclass, nterms, terms(:,:)
  character(cl), intent(in) :: func_tag
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: jmode,info,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes),nu_j(PT%Nmodes),imode1,imode2,nmodes,alloc_p
  real(rk), allocatable :: prim_coefs(:,:), tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  call TimerStart('fast-ci: computing P1 for '//trim(func_tag))
  !
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (imode>imode2.or.imode<imode1) then
    write(out, '(/a,1x,i3,1x,a,1x,i3)') 'calc_contr_matelem_expansion_p1 error: imode =', & 
                                        imode, 'is out of ranges for iclass =', iclass
    stop
  endif
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_p1 error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(prim_coefs(nprim,nroots),tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_p1',info,size(prim_coefs),kind(prim_coefs))
  call ArrayStart('calc_contr_matelem_expansion_p1',info,size(tmat),kind(tmat))
  !
  ! compute matrix elements between products of 1D functions
  select case (trim(func_tag))
    !
  case('Tvib')
    !
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,jmode,iterm,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      do jprim=1, nprim
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        do iterm=1, nterms
          do jmode=imode1, imode2
            if (jmode==imode) then
              me_term(jmode) = me%vibmode(jmode,1)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
            else
              me_term(jmode) = me%vibmode(jmode,-1)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
            endif
            !
          enddo
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))
          !
        enddo
        !
      enddo
      !
    enddo
    !$omp end parallel do
    !
  case('Tcor')
    ! 
    !$omp parallel do private(iprim,jprim,nu_i,nu_j,jmode,iterm,me_term) shared(me_contr) schedule(dynamic)
    do iprim=1, nprim
      nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
      !
      do jprim=1, nprim
        !
        nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
        do iterm=1, nterms
          do jmode=imode1, imode2
            if (jmode==imode) then
              me_term(jmode) = me%vibmode(jmode,1)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))&
                              -me%vibmode(jmode,1)%coeff(terms(jmode,iterm),nu_j(jmode),nu_i(jmode))
            else
              me_term(jmode) = me%vibmode(jmode,-1)%coeff(terms(jmode,iterm),nu_i(jmode),nu_j(jmode))
            endif
          enddo
          !
          me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))
          !
        enddo
        !
      enddo
      !
    enddo
    !$omp end parallel do
    !
  case default
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_p1 error: unknown type of field =', trim(func_tag)
    stop 'calc_contr_matelem_expansion_p1 error: unknown type of field'
  end select 
  !
  ! contraction coefficients

  !$omp parallel do private(iroot,ilevel,ideg) shared(prim_coefs) schedule(static)
  do iroot=1, nroots
    ilevel = contr(iclass)%ilevel(iroot)
    ideg = contr(iclass)%ideg(iroot)
    prim_coefs(1:nprim,iroot) = contr(iclass)%eigen(ilevel)%vect(1:nprim,ideg)
  enddo
  !$omp end parallel do
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_coefs(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_coefs(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0, me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(prim_coefs, tmat)
  !
  call ArrayStop('calc_contr_matelem_expansion_p1')
  call TimerStop('fast-ci: computing P1 for '//trim(func_tag))

end subroutine calc_contr_matelem_expansion_p1




subroutine calc_contr_matelem_expansion_p2(imode, jmode, iclass, func_tag, nterms, terms, me_contr)
  !
  integer(ik), intent(in) :: imode, jmode, iclass, nterms, terms(:,:)
  character(cl), intent(in) :: func_tag
  real(rk), intent(out) :: me_contr(:,:,:)

  integer(ik) :: kmode,info,iterm,ideg,nprim,iprim,jprim,nroots,ilevel,iroot,&
                 nu_i(PT%Nmodes),nu_j(PT%Nmodes),imode1,imode2,nmodes,alloc_p
  real(rk), allocatable :: prim_coefs(:,:), tmat(:,:)
  real(rk) :: me_term(PT%Nmodes)
  !
  if (trim(func_tag)/='Tvib') then
    write(out, '(/a,1x,a)') 'calc_contr_matelem_expansion_p2 error: unknown type of field =', trim(func_tag)
    stop 'calc_contr_matelem_expansion_p2 error: unknown type of field'
  endif
  !
  call TimerStart('fast-ci: computing P2 for '//trim(func_tag))
  !
  nmodes = PT%Nmodes
  imode1 = PT%mode_class(iclass,1)
  imode2 = PT%mode_class(iclass,PT%mode_iclass(iclass))
  nprim = contr(iclass)%dimen
  nroots = contr(iclass)%nroots
  !
  if (imode>imode2.or.imode<imode1) then
    write(out, '(/a,1x,i3,1x,a,1x,i3)') 'calc_contr_matelem_expansion_p2 error: imode =', & 
                                         imode, 'is out of ranges for iclass =', iclass
    stop
  endif
  !
  if (jmode>imode2.or.jmode<imode1) then
    write(out, '(/a,1x,i3,1x,a,1x,i3)') 'calc_contr_matelem_expansion_p2 error: jmode =', &
                                         jmode, 'is out of ranges for iclass =', iclass
    stop
  endif
  !
  if (max(nroots,nprim)/=size(me_contr,dim=2).or.max(nroots,nprim)/=size(me_contr,dim=3)) then
    write(out, '(/a)') 'calc_contr_matelem_expansion_p2 error: matrix "me_contr" has wrong dimensions'
    stop
  endif
  !
  allocate(prim_coefs(nprim,nroots),tmat(nprim,nroots),stat=info)
  call ArrayStart('calc_contr_matelem_expansion_p2',info,size(prim_coefs),kind(prim_coefs))
  call ArrayStart('calc_contr_matelem_expansion_p2',info,size(tmat),kind(tmat))
  !
  ! compute matrix elements between products of 1D functions
  !
  !$omp parallel do private(iprim,jprim,nu_i,nu_j,kmode,iterm,me_term) shared(me_contr) schedule(dynamic)
  do iprim=1, nprim
    nu_i(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,iprim)
    do jprim=1, nprim
      nu_j(1:nmodes) = contr(iclass)%prim_bs%icoeffs(1:nmodes,jprim)
      do iterm=1, nterms
        do kmode=imode1, imode2
          if (kmode/=imode.and.kmode/=jmode) then
            me_term(kmode) = me%vibmode(kmode,-1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          elseif (kmode/=jmode) then
            me_term(kmode) =-me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_j(kmode),nu_i(kmode))
          elseif (kmode/=imode) then
            me_term(kmode) = me%vibmode(kmode,1)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          else
            me_term(kmode) = me%vibmode(kmode,2)%coeff(terms(kmode,iterm),nu_i(kmode),nu_j(kmode))
          endif
        enddo
        me_contr(iterm,iprim,jprim) = product(me_term(imode1:imode2))
      enddo
    enddo
  enddo
  !$omp end parallel do
  !
  !
  ! contraction coefficients
  !
  !$omp parallel do private(iroot,ilevel,ideg) shared(prim_coefs) schedule(static)
  do iroot=1, nroots
    ilevel = contr(iclass)%ilevel(iroot)
    ideg = contr(iclass)%ideg(iroot)
    prim_coefs(1:nprim,iroot) = contr(iclass)%eigen(ilevel)%vect(1:nprim,ideg)
  enddo
  !$omp end parallel do
  !
  ! transform to contracted basis
  !
  do iterm=1, nterms
    call dgemm('N', 'N', nprim, nroots, nprim, 1.0d0, me_contr(iterm,1:nprim,1:nprim), nprim, &
               prim_coefs(1:nprim,1:nroots), nprim, 0.0d0, tmat(1:nprim,1:nroots), nprim)
    call dgemm('T', 'N', nroots, nroots, nprim, 1.0d0, prim_coefs(1:nprim,1:nroots), nprim, &
               tmat(1:nprim,1:nroots), nprim, 0.0d0, me_contr(iterm,1:nroots,1:nroots), nroots)
  enddo
  !
  deallocate(prim_coefs, tmat)
  !
  call ArrayStop('calc_contr_matelem_expansion_p2')
  call TimerStop('fast-ci: computing P2 for '//trim(func_tag))

end subroutine calc_contr_matelem_expansion_p2


subroutine combinations(nelem, elem_ind, ncomb_tot, nind, comb_ind)

  integer(ik), intent(in) :: nelem, elem_ind(nelem)
  integer(ik), intent(out) :: ncomb_tot
  integer(ik), allocatable, intent(out) :: nind(:), comb_ind(:,:)

  integer(ik) :: n, i, ind(nelem,nelem), ielem, ii(nelem), ncomb(nelem), info, icomb1, icomb2

  ! estimate number of combinations
  ncomb = 0
  do n=1, nelem
    forall(i=1:n) ind(1:nelem,i) = (/(elem_ind(ielem), ielem=1, nelem)/)
    call cartesian_product(n, (/(nelem, i=1, n)/), ind(1:nelem,1:n), .true., 0, sum(ind(:,1)), 1, ii(1:n), ncomb(n))
  enddo

  ! total number of combinations
  ncomb_tot = sum(ncomb(1:nelem))

  ! allocate arrays to keep different combinations
  if (allocated(comb_ind)) deallocate(comb_ind)
  if (allocated(nind)) deallocate(nind)
  allocate(comb_ind(nelem,0:ncomb_tot), nind(0:ncomb_tot), stat=info)
  if (info/=0) then
    write(out, '(/a/a,10(1x,i6))') 'combinations error: comb_ind(nelem,0:ncomb_tot), nind(0:ncomb_tot) - out of memory', &
    'nelem, ncomb_tot =', nelem, ncomb_tot
    stop
  endif
  comb_ind = 0
  nind = 0

  ! generate combinations
  icomb2 = 0
  do n=1, nelem
    icomb1 = icomb2 + 1
    icomb2 = icomb1 + ncomb(n) - 1
    nind(icomb1:icomb2) = n
    forall(i=1:n) ind(1:nelem,i) = (/(elem_ind(ielem), ielem=1, nelem)/)
    call cartesian_product(n, (/(nelem, i=1, n)/), ind(1:nelem,1:n), .true., 0, sum(ind(:,1)), 1, ii(1:n), ncomb(n), &
                           comb_ind(1:n,icomb1:icomb2))
  enddo

end subroutine combinations


  !
  ! Contracted matrix elements
  !
  subroutine PTcontracted_matelem_class_fast(jrot) 
    !
    integer(ik),intent(in)   :: jrot
    integer(ik)        :: PotOrder,KinOrder,extForder
    integer(ik)        :: poten_N,gvib_N,grot_N,gcor_N,Ncoeffs,jmax,L2vib_N
    integer(ik)        :: iclasses,ilevel,ideg,jdeg,alloc,dimen,iterm,k1,k2,Ndeg
    real(rk),allocatable :: grot_t(:,:),extF_t(:,:),hvib_t(:,:)
    !
    real(rk)           :: f_t
    integer(ik)        :: isize,iroot
    integer(ik)        :: dimen_p,chkptIO,extF_rank,chkptIO_,dumpIO_
    integer(hik)       :: rootsize,matsize
    !
    logical            :: treat_rotation =.false.  ! switch off/on the rotation 
    logical            :: treat_vibration =.true.  ! switch off/on the vibration
    logical            :: treat_exfF=.false.       ! switch off/on the external field 
    !
    double precision,parameter :: alpha = 1.0d0,beta=0.0d0
    character(len=cl)  :: job_is,buf,jchar1,jchar2,filename
    !
    integer(ik)        :: imu,Ncomb,junit,Nslices,Nswap,mdimen,mdimen_,icontr,jcontr
    integer(ik)        :: icoeff,icase,ilambda,jcoeff,idvr,iterm1,iterm2,islice,isymcoeff
    integer(ik),allocatable  :: extF_N(:)
    character(len=4) :: jchar
    character(len=18):: buf18
    !
    integer(ik), allocatable :: dimen_classes(:), nu_classes(:,:), iclass_nmodes(:), iclass_imode(:,:), iclass_ilambda(:,:,:), &
                                icomb_nclasses(:), icomb_iclass(:,:), icomb_nclasses0(:), icomb_iclass0(:,:), &
                                gvib_icomb_nterms(:,:,:), gvib_icomb_iterm(:,:,:,:,:), &
                                grot_icomb_nterms(:,:,:), grot_icomb_iterm(:,:,:,:,:), &
                                gcor_icomb_nterms(:,:,:), gcor_icomb_iterm(:,:,:,:,:), &
                                vpot_icomb_nterms(:,:,:), vpot_icomb_iterm(:,:,:,:,:), &
                                pseudo_icomb_nterms(:,:,:), pseudo_icomb_iterm(:,:,:,:,:), &
                                extF_icomb_nterms(:,:,:), extF_icomb_iterm(:,:,:,:,:)

    real(rk), allocatable :: enermax_classes(:)

    real(rk), allocatable :: gvib_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: grot_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: gcor_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: vpot_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: pseudo_icomb_coefs(:,:,:,:)
    real(rk), allocatable :: extF_icomb_coefs(:,:,:,:)
    !
    type me_type
      real(rk), allocatable :: me(:,:,:,:,:)
      integer(ik) :: nterms
    end type me_type
    !
    type(me_type), allocatable :: gvib_me(:)
    type(me_type), allocatable :: grot_me(:)
    type(me_type), allocatable :: gcor_me(:)
    type(me_type), allocatable :: vpot_me(:)
    type(me_type), allocatable :: pseudo_me(:)
    type(me_type), allocatable :: extF_me(:)
      !
      call TimerStart('Contracted matelements-class-fast')
      !
      !if (PT%Nclasses/=1) then 
      !  !
      !  write(out,"('PTcontracted_matelem_class_fast/end: This procedure has not been tested for Nclasses = ',i8,' yet')") PT%Nclasses
      !  stop 'PTcontracted_matelem_class_fast: illegal number of classes' 
      !  !
      !endif
      !
      if (verbose>=4) write(out,"('PTcontracted_matelem_class_fast/start: contracted matrix elements for the hamiltonian ')") 
      !
      extF_rank = FLread_extF_rank()
      !
      allocate(extF_N(max(extF_rank,1)))
      !
      call FLread_fields_dimensions(poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,extF_N,L2vib_N)
      !
      ! Some parts of the Hamiltonian are not needed if J=0 (neither grot nor gcor).
      ! We adopt treat_rotation to switch it on/off
      !
      if ((FLrotation.and.jrot/=0).or.trim(job%IOkinet_action)=='SAVE') treat_rotation = .true.
      !
      if (jrot/=0.and.trim(job%IOkinet_action)/='READ') then     
         write (out,"(/'PTcontracted_matelem_class_fast: the contracted matrix elements can be calculated only at J = 0')") 
         write (out,"('First run the J=0 case with IOkinet_action=SAVE')") 
         write (out,"('and switch to J/=0 with IOkinet_action=READ')") 
         stop 'PTcontracted_matelem_class_fast - illegal IOkinet_action for J/=0'
      endif 
      !
      !Ncoeffs = max(poten_N,gvib_N,grot_N,gcor_N)
      !
      ! Here we decide whether we need to compute the    matrix elements from 
      ! the pure vibrational part of the Hamiltonian. If our contracted basis set 
      ! has been built under all vib. modes combined into one class, 
      ! we can directly use the corresponding eigenvalues. 
      !
      if (job%vib_contract) then 
        !
        PTvibrational_me_calc = .false.
        !
        if (job%verbose>=3) then 
          write(out,"(/'The vibrational (J=0) part of the Hamiltonian is diagonal.')") 
          write(out,"('The corresponding matrix elements are not computed.'/'The vibrational eigenvalues are used instead.')") 
        endif 
        !
        treat_vibration = .false.
        !
        job%IOmatelem_split = .true.
        !
      endif 
      !
      ! Turn on the external field
      !
      if (trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT') treat_exfF = .true.
      !
      ! We assume that all matrix elements are simmetric, therefore we can use 
      ! a 1D array for storing only the upper half of the matrix.
      ! And this is the size of such 1D array.
      !
      mdimen = PT%Maxcontracts
      dimen_p = PT%max_deg_size
      !
      rootsize = int(dimen_p*mdimen,hik)
      !
      ! The vibrational (J=0) matrix elements of the rotational and coriolis 
      ! kinetic parts are retrieved now from the storage place (check_point). 
      ! For pure vibrational calculations we provide an option to store and restore 
      ! the matrix elements of the J=0 part of Hamiltonian
      !
      if (trim(job%IOkinet_action)=='READ'.or.trim(job%IOkinet_action)=='VIB_READ') then
        !
        treat_vibration = .false.
        treat_rotation = .false.
        !
      endif 
      !
      ! we can allow skipping the kinetic part completely if only the external function
      ! is required 
      !
      if (trim(job%IOkinet_action)=='NONE'.and.treat_exfF) then
        !
        treat_vibration = .false.
        treat_rotation = .false.
        !
      endif 
      !
      if (treat_vibration.or.treat_exfF.or.treat_rotation) then 
        !
        if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and.&
           (.not.job%IOmatelem_split.or.job%iswap(1)==0 )) then
          !
          if (FLrotation.and.jrot/=0) then 
            write (out,"(' IOkinet_action = SAVE is not working for J/=0 ')") 
            stop 'PTcontracted_matelem_class_fast - illegal IOkinet_action for J/=0'
          endif 
          !
          ! Prepare the checkpoint file
          !
          job_is ='Vib. matrix elements of the rot. kinetic part'
          call IOStart(trim(job_is),chkptIO)
          !
          open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=job%kinetmat_file)
          write(chkptIO) 'Start Kinetic part'
          !
          ! store the bookkeeping information about the contr. basis set
          !
          call PTstore_icontr_cnu(PT%Maxcontracts,chkptIO,job%IOkinet_action)
          !
          if (job%vib_rot_contr) then
            write(chkptIO) 'vib-rot'
          endif
          !
        endif 
        !
        call initialize_class_contr_objects
        !
        ! Temporar arrays allocation (for non-DVR, FBR integration)
        !
        matsize = PT%Nclasses*PT%Maxcontracts
        !
        if (job%verbose>=4) call MemoryReport
        !
        ! Initialize the Hamiltonian fields and basis functions in the DVR representation
        !
        if (trove%DVR) then
          !
          stop 'DVR is not implemented for PTcontracted_matelem_class_fast'
          !
        endif
        !
        if (.not.(trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and. & 
                  (job%IOmatelem_split.or.job%iswap(1)==0.and.job%iswap(1)/=(PT%Nmodes+3)*3 ) ) then

          !
          ! The vibrational part of the Hamiltonian
          !
          if (job%verbose>=4) write(out,"('  allocating hvib, ',i9,' elements...')") rootsize
          !
          allocate(hvib%me(mdimen,mdimen),stat=alloc)
          call ArrayStart('gvib-grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          hvib%me = 0
          !
          if (job%verbose>=5) call MemoryReport
          !
        endif
        !
        !---------------------------!
        ! Only when rotation is ON  !
        !---------------------------!
        !
        if (treat_rotation.and.trove%FBR) then
          !
          if (job%verbose>=2) write(out,"(/'Rotational part of the Kinetic energy operator...')")
          !
          if (job%verbose>=4) write(out,"('  allocating grot, ',i9,' elements...')") rootsize
          !
          if (job%IOmatelem_split) then
            !
            iterm1 = max(job%iswap(1),0)
            iterm2 = min(job%iswap(2),(PT%Nmodes+3)*3+1)
            !
            if (job%verbose>=4) write(out,"('  The matelem.chk will be divided into 1 + 3 x 3 + 3  = 1+12 chk-slices')")
            if (job%verbose>=4) write(out,"('  islice = 0 (gvib and poten), 1-9 (Grot), 10-12 (Gcor) ')")
            if (job%verbose>=4) write(out,"('  This run is for the checkpoint slices from ',i4,' to ',i4/)") iterm1,iterm2
            if (job%verbose>=4) write(out,"(/'  For a single chk-slice #i use MATELEM SAVE SPLIT i i ')")
            if (job%verbose>=4) write(out,"('  Vibrational chks correspond to slice 0; for vib. only use MATELEM SAVE 0 0')")
            if (job%verbose>=4) write(out,"('  For all slices run and stitched in one go use MATELEM SAVE SPLIT ')")
            !
          endif
          !
          if (job%vib_rot_contr) then 
            allocate(grot_t(mdimen,dimen_p),stat=alloc)
          else 
            allocate(grot_t(mdimen,mdimen),stat=alloc)
          endif
          !
          call ArrayStart('grot-gcor-fields',alloc,1,kind(f_t),rootsize)
          !
          if (job%verbose>=5) call MemoryReport
          !
          if (trim(job%IOkinet_action)=='SAVE'.and..not.job%IOmatelem_split) then
            !
            write(chkptIO) 'g_rot'
            !
          endif 
          !
          ! The vibrational (J=0) matrix elements of the rotational and coriolis 
          ! kinetic parts are being computed here. 
          !
          ! Run the loop over all term of the expansion of the Hamiltonian 
          !
          islice = 0
          !
          if (job%verbose>=2) call TimerStart('calc_grot_contr_matrix')
          !
          do k1 = 1,3
            do k2 = 1,3
              !
              islice = islice + 1
              !
              !if (job%IOmatelem_split.and.(islice<iterm1.or.iterm2<islice)) cycle
              !
              if ( job%IOmatelem_split ) then 
                if (islice<iterm1.or.iterm2<islice) cycle
                !
                call open_divided_slice(islice,'g_rot',job%matelem_suffix,chkptIO_)
                !
              endif
              !
              if (job%verbose>=4) write(out,"('k1,k2 = ',2i8)") k1,k2
              !
              grot_t = 0
              !
              do isymcoeff =1,PT%Maxsymcoeffs
                !
                Ndeg = PT%Index_deg(isymcoeff)%size1
                !
                if (job%vib_rot_contr) grot_t = 0
                !
                call calc_grot_contr_matrix(k1,k2,isymcoeff,grot_t)
                !
                if (job%vib_rot_contr) then 
                  !
                  !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(grot_t) schedule(dynamic)
                  do ideg=1,Ndeg
                     icontr = PT%icase2icontr(isymcoeff,ideg)
                     do jdeg=1,ideg-1
                        jcontr = PT%icase2icontr(isymcoeff,jdeg)
                        grot_t(icontr,jdeg) = grot_t(jcontr,ideg)
                    enddo
                  enddo
                  !$omp end parallel do
                  !
                  if (trim(job%IOkinet_action)=='SAVE'.and.job%IOmatelem_split) then
                    write(chkptIO_) grot_t(1:mdimen,1:Ndeg)
                  endif
                  !
                endif
                ! 
              enddo
              !
              if (.not.job%vib_rot_contr) then 
                !
                !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
                do icoeff=1,mdimen
                  do jcoeff=1,icoeff-1
                    grot_t(jcoeff,icoeff) = grot_t(icoeff,jcoeff)
                  enddo
                enddo
                !$omp end parallel do
                !
                if (trim(job%IOkinet_action)=='SAVE') then
                  !
                  if (job%IOmatelem_split) then
                     write(chkptIO_) grot_t
                  else
                     write(chkptIO) grot_t
                  endif
                  !
                endif
                !
              endif
              !
              if (job%IOmatelem_split) then 
                write(chkptIO_) 'g_rot'
                close(chkptIO_)
              endif
              !
            enddo
            !
          enddo
          !
          if (job%verbose>=2) call TimerStop('calc_grot_contr_matrix')
          !
          if (job%verbose>=2) write(out,"('...done!')")
          !
          if (job%verbose>=2) write(out,"(/'Coriolis part of the Kinetic energy operator...')")
          !
          if (trim(job%IOkinet_action)=='SAVE'.and..not.job%IOmatelem_split) then
            !
            write(chkptIO) 'g_cor'
            !
          endif
          !
          ! Run the loop over all term of the expansion of the Hamiltonian 
          !
          if (job%verbose>=2) call TimerStart('calc_gcor_contr_matrix')
          !
          k1 = 1
          !
          do k2 = 1,3
            !
            islice = islice + 1
            !
            if ( job%IOmatelem_split ) then 
              if (islice<iterm1.or.iterm2<islice) cycle
              !
              call open_divided_slice(islice,'g_cor',job%matelem_suffix,chkptIO_)
              !
            endif
            !
            if (job%verbose>=4) write(out,"('k1,k2 = ',2i8)") k1,k2
            !
            ! dumping or/and starting from the previously dumped record of the matelem-checkpoints
            !
            if (job%matelem_append.or.job%IOmatelem_dump) then
              !
              if (job%vib_rot_contr) then
                !
                write(out,"('Appending or dumping is not working with the vib-rot contraction scheme, remove them from input')")
                stop 'Appending or dumping is not working with the vib-rot'
                !
              endif
              !
              call open_dump_slice(islice,'g_cor',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
              !
            endif
            !
            grot_t = 0
            !
            do isymcoeff =1,PT%Maxsymcoeffs
              !
              Ndeg = PT%Index_deg(isymcoeff)%size1
              !
              if (job%vib_rot_contr) grot_t = 0
              !
              if (job%matelem_append) then
                 !
                 do ideg=1,Ndeg
                   !
                   icontr = PT%icase2icontr(isymcoeff,ideg)
                   !
                   read(dumpIO_) icontr,grot_t(icontr,1:icontr)
                   if ( icontr/=PT%icase2icontr(isymcoeff,ideg) ) then
                     write(out,"('Wrong record ',i9,' /= ',i9,' in the dump-chk file ',a)") &
                                  icontr,PT%icase2icontr(isymcoeff,ideg),trim(filename)
                     stop 'Wrong record in the dump-file'
                   endif
                   !
                 enddo
                 !
                 if (isymcoeff==job%iappend) job%matelem_append = .false.
                 !
              else ! no-append means calculation 
                 !
                 call calc_gcor_contr_matrix(k1,k2,isymcoeff,grot_t)
                 !
              endif 
              !
              !
              if (job%vib_rot_contr) then 
                  !
                  !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(grot_t) schedule(dynamic)
                  do ideg=1,Ndeg
                     icontr = PT%icase2icontr(isymcoeff,ideg)
                     do jdeg=1,ideg-1
                        jcontr = PT%icase2icontr(isymcoeff,jdeg)
                        grot_t(icontr,jdeg) =-grot_t(jcontr,ideg)
                     enddo
                  enddo
                  !$omp end parallel do
                  !
                  if (trim(job%IOkinet_action)=='SAVE'.and.job%IOmatelem_split) then
                      write(chkptIO_) grot_t(1:mdimen,1:Ndeg)
                  endif
                  !
              elseif (job%IOmatelem_dump.and..not.job%matelem_append) then 
                  !
                  do ideg=1,Ndeg
                    !
                    icontr = PT%icase2icontr(isymcoeff,ideg)
                    !
                    write(dumpIO_) icontr,grot_t(icontr,1:icontr)
                    !
                  enddo
                  !
              endif
              !
            enddo
            !
            if (job%IOmatelem_dump) close(dumpIO_)
            !
            if (.not.job%vib_rot_contr) then 
              !
              !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  grot_t(jcoeff,icoeff) = -grot_t(icoeff,jcoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              if (trim(job%IOkinet_action)=='SAVE') then
                !
                if (job%IOmatelem_split) then
                   write(chkptIO_) grot_t
                else
                   write(chkptIO) grot_t
                endif
                !
              endif
              !
            endif
            !
            if (job%IOmatelem_split) then 
              write(chkptIO_) 'g_cor'
              close(chkptIO_)
            endif
            !
          enddo
          !
          if (job%verbose>=2) call TimerStop('calc_gcor_contr_matrix')
          !
          deallocate(grot_t)
          call ArrayStop('grot-gcor-fields')
          !
          if (job%verbose>=2) write(out,"('...done!')")
          !
        endif
        !
        ! Vibrational part 
        !
        !islice = (PT%Nmodes+3)*3+1
        !
        if ( treat_vibration.and.(.not.job%IOmatelem_split.or.iterm1==0) ) then 
          !
          ! ----------------- FBR ------------------
          !
          if (job%verbose>=2) write(out,"(/'Vibrational kinetic part...')")
          if (job%verbose>=3) write(out,"(/'Dimensions of the contracted matrix  = ',2i0)") mdimen,dimen_p
          !
          if (job%vib_rot_contr) then 
            allocate(hvib_t(mdimen,dimen_p),stat=alloc)
          else 
            allocate(hvib_t(mdimen,mdimen),stat=alloc)
          endif
          !
          call ArrayStart('hvib-fields',alloc,1,kind(f_t),rootsize)
          !
          if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and. & 
                  (.not.job%IOmatelem_split.or.job%iswap(1)==0.or.job%iswap(1)==(PT%Nmodes+3)*3 ) ) then
             !
             write(chkptIO) 'hvib'
             !
          endif
          !
          if ( job%vib_rot_contr ) then
            !
            ! write hvib to the first "slice"
            islice = 0 
            call open_divided_slice(islice,'hvib',job%matelem_suffix,chkptIO_)
            !
          endif
          !
          ! dumping or/and starting from the previously dumped record of the matelem-checkpoints
          !
          if (job%matelem_append.or.job%IOmatelem_dump) then
            !
            if (job%vib_rot_contr) then
              !
              write(out,"('Appending or dumping is not working with the vib-rot contraction scheme, remove them from input')")
              stop 'Appending or dumping is not working with the vib-rot'
              !
            endif
            !
            islice = 0
            !
            call open_dump_slice(islice,'h_vib',job%matelem_suffix,job%matelem_append,job%IOmatelem_dump,dumpIO_)
            !
          endif
          !
          hvib_t = 0
          !
          if (job%verbose>=2) call TimerStart('calc_gvib_contr_matrix')
          !
          if (job%verbose>=4) write(out,"(/' hvib...',i12)") PT%Maxsymcoeffs
          !if (job%verbose>=4) write(out,"('  |',i8)",advance='NO')
          !
          do isymcoeff =1,PT%Maxsymcoeffs
            !
            if (job%verbose>=4.and.mod(isymcoeff,max(int(PT%Maxsymcoeffs/100),10))==0) write(out,"(i12)") isymcoeff
            !
            Ndeg = PT%Index_deg(isymcoeff)%size1
            !
            if (job%vib_rot_contr) hvib_t = 0
            !
            if (job%matelem_append) then
               !
               do ideg=1,Ndeg
                 !
                 icontr = PT%icase2icontr(isymcoeff,ideg)
                 !
                 read(dumpIO_) icontr,hvib_t(icontr,1:icontr)
                 if ( icontr/=PT%icase2icontr(isymcoeff,ideg) ) then
                   write(out,"('Wrong record ',i9,' /= ',i9,' in the vib dump-chk file ')") icontr,PT%icase2icontr(isymcoeff,ideg)
                   stop 'Wrong record in the dump-file'
                 endif
                 !
               enddo
               !
            else ! no-append means calculation 
               !
               call calc_gvib_contr_matrix(isymcoeff,hvib_t)
               !
            endif 
            !
            ! store the matrix elements 
            !
            if (job%vib_rot_contr) then 
               !
               if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and. & 
                       (.not.job%IOmatelem_split.or.job%iswap(1)==0.or.job%iswap(1)==(PT%Nmodes+3)*3 ) ) then
                    !
                    !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(hvib_t) schedule(dynamic)
                    do ideg=1,Ndeg
                      icontr = PT%icase2icontr(isymcoeff,ideg)
                      do jdeg=1,ideg-1
                        jcontr = PT%icase2icontr(isymcoeff,jdeg)
                        hvib_t(icontr,jdeg) = hvib_t(jcontr,ideg)
                      enddo
                    enddo
                    !$omp end parallel do
                    !
                    write(chkptIO_) hvib_t(1:mdimen,1:Ndeg)
                    !
                else
                    !
                    !$omp parallel do private(icontr,ideg,jcontr,jdeg) schedule(dynamic)
                    do ideg=1,Ndeg
                      icontr = PT%icase2icontr(isymcoeff,ideg)
                      do jdeg=1,ideg
                        jcontr = PT%icase2icontr(isymcoeff,jdeg)
                        hvib%me(jcontr,ideg) = hvib_t(jcontr,ideg)
                        hvib%me(icontr,jdeg) = hvib_t(jcontr,ideg)
                      enddo
                    enddo
                    !$omp end parallel do
                    !
                    !write(out,"('vib-rot: hvib must be stored, you should not be here!')")
                    !stop 'vib-rot: hvib must be stored, you should not be here!'
                    !
               endif
               !
            elseif (job%IOmatelem_dump.and..not.job%matelem_append) then 
               !
               do ideg=1,Ndeg
                 !
                 icontr = PT%icase2icontr(isymcoeff,ideg)
                 !
                 write(dumpIO_) icontr,hvib_t(icontr,1:icontr)
                 !
               enddo
               !
            endif
            !
            if (isymcoeff==job%iappend) job%matelem_append = .false.
            !
          enddo
          !
          if (job%IOmatelem_dump) close(dumpIO_)
          !
          !if (job%verbose>=4) write(out,"('| 100% done')") 
          !
          if (job%verbose>=2) call TimerStop('calc_gvib_contr_matrix')
          !
          if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE')) then 
            !
            if (.not.job%vib_rot_contr) then 
              !
              !$omp parallel do private(icoeff,jcoeff) shared(hvib_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  hvib_t(jcoeff,icoeff) = hvib_t(icoeff,jcoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              !write(chkptIO) hvib_t
              !
              if (trim(job%IOkinet_action)=='SAVE') then
                   write(chkptIO) hvib_t
              endif
              !
            endif 
            !
          else
            !
            !$omp parallel do private(icoeff,jcoeff) schedule(dynamic)
            do icoeff=1,mdimen
              do jcoeff=1,icoeff-1
                hvib%me(icoeff,jcoeff) = hvib_t(icoeff,jcoeff)
                hvib%me(jcoeff,icoeff) = hvib%me(icoeff,jcoeff)
              enddo
            enddo
            !$omp end parallel do
            !
          endif
          !
          if (job%verbose>=2) write(out,"(/'...done!')")
          !
          deallocate(hvib_t)
          call ArrayStop('hvib-fields')
          !
          if (job%vib_rot_contr) then
            write(chkptIO_) 'hvib'
            close(chkptIO_)
          endif
          !          
          call TimerReport
          !
        endif
        !
        !Finish the contracted checkpointing
        !
        if ((trim(job%IOkinet_action)=='SAVE'.or.trim(job%IOkinet_action)=='VIB_SAVE').and.&
           (.not.job%IOmatelem_split.or.job%iswap(1)==0 )) then
          !
          write(chkptIO) 'End Kinetic part'
          close(chkptIO,status='keep')
          !
        endif 
        !
        ! External field part 
        !
        if (treat_exfF) then 
          !
          if (job%verbose>=2) write(out,"(/'External function...')")
          !
          fitting%iparam(2) = min(fitting%iparam(2),extF_rank)
          fitting%iparam(1) = max(fitting%iparam(1),1)
          !
          if (.not.job%IOextF_divide) then
            !
            fitting%iparam = (/1,extF_rank/)
            !
            if (jrot/=0) then     
               write (out,"(/'PTcontracted_matelem_class: contr. matrix elements can be calculated only at J = 0')") 
               write (out,"('switch to  EXTERNAL NONE for j/=0')") 
               stop 'PTcontracted_matelem_class - illegal use of EXTERNAL for J/=0'
            endif 
            !
            ! Prepare the checkpoint file
            !
            job_is ='external field contracted matrix elements for J=0'
            call IOStart(trim(job_is),chkptIO)
            !
            open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=job%extFmat_file)
            write(chkptIO) 'Start external field'
            !
            ! store the matrix elements 
            !
            write(chkptIO) PT%Maxcontracts
            !
          endif 
          !
          if (job%vib_rot_contr) then 
            allocate(extF_t(mdimen,dimen_p),stat=alloc)
          else 
            allocate(extF_t(mdimen,mdimen),stat=alloc)
          endif
          call ArrayStart('extF-fields',alloc,1,kind(f_t),size(extF_t,kind=8))
          !
          do imu = fitting%iparam(1),fitting%iparam(2)
            !
            if (job%verbose>=4) write(out,"('imu = ',i8)",advance='NO') imu
            !
            if (.not.job%IOextF_divide) then 
              write(chkptIO) imu
            else
              !
              call open_divided_slice(imu,'extF',job%extmat_suffix,chkptIO_)
              !           
            endif
            !
            if (job%matelem_append.or.job%IOextmatelem_dump) then
              !
              if (job%vib_rot_contr) then
                !
                write(out,"('Appending or dumping is not working with the vib-rot contraction scheme, remove them from input')")
                stop 'Appending or dumping is not working with the vib-rot'
                !
              endif
              !
              call open_dump_slice(islice,'extF_',job%extmat_suffix,job%extmatelem_append,job%IOextmatelem_dump,dumpIO_)
              !
            endif
            !
            do isymcoeff =1,PT%Maxsymcoeffs
              !
              Ndeg = PT%Index_deg(isymcoeff)%size1
              !
              if (job%vib_rot_contr) extF_t = 0
              !
              if (job%extmatelem_append) then
                 !
                 do ideg=1,Ndeg
                   !
                   icontr = PT%icase2icontr(isymcoeff,ideg)
                   !
                   read(dumpIO_) icontr,extF_t(icontr,1:icontr)
                   if ( icontr/=PT%icase2icontr(isymcoeff,ideg) ) then
                     write(out,"('Wrong record ',i9,' /= ',i9,' in the dump-chk file ',a)") &
                     icontr,PT%icase2icontr(isymcoeff,ideg),trim(filename)
                     stop 'Wrong record in the dump-file'
                   endif
                   !
                 enddo
                 !
                 if (isymcoeff==job%iextappend) job%extmatelem_append = .false.
                 !
              else ! no-append means calculation 
                 !
                 call calc_extF_contr_matrix(imu,isymcoeff,extF_t)
                 !
              endif 
              !
              !call calc_extF_contr_matrix(imu,isymcoeff,extF_t)
              !
              if (job%vib_rot_contr) then 
                 !
                 !$omp parallel do private(ideg,icontr,jcontr,jdeg) shared(extF_t) schedule(dynamic)
                 do ideg=1,Ndeg
                    icontr = PT%icase2icontr(isymcoeff,ideg)
                    do jdeg=1,ideg-1
                       jcontr = PT%icase2icontr(isymcoeff,jdeg)
                       extF_t(icontr,jdeg) = extF_t(jcontr,ideg)
                   enddo
                 enddo
                 !$omp end parallel do
                 !
                 if (job%IOextF_divide) then
                   write(chkptIO_) extF_t(1:mdimen,1:Ndeg)
                 endif

                 !omp parallel do private(ideg,jdeg) shared(hvib_t) schedule(dynamic)
                 !do ideg=1,Ndeg
                 !  do jdeg=1,ideg-1   
                 !    extF_t(isymcoeff+jdeg-1,ideg) = extF_t(isymcoeff+ideg-1,jdeg)
                 !  enddo
                 !enddo
                 !omp end parallel do
                 !
                 !if (job%IOextF_divide) then 
                 !  !
                 !  call write_divided_slice(imu,'extF',job%extmat_suffix,mdimen,Ndeg,extF_t)
                 !  !
                 !else
                 !  !
                 !  write(chkptIO) extF_t(1:mdimen,1:Ndeg)
                 !  !
                 !endif

                  !
              elseif (job%IOextmatelem_dump.and..not.job%extmatelem_append) then 
                 !
                 do ideg=1,Ndeg
                   !
                   icontr = PT%icase2icontr(isymcoeff,ideg)
                   !
                   write(dumpIO_) icontr,extF_t(icontr,1:icontr)
                   !
                 enddo
                 !
              endif
              !
            enddo
            !
            if (job%IOextmatelem_dump) close(dumpIO_)
            !
            if (.not.job%vib_rot_contr) then 
              !
              !$omp parallel do private(icoeff,jcoeff) shared(grot_t) schedule(dynamic)
              do icoeff=1,mdimen
                do jcoeff=1,icoeff-1
                  extF_t(jcoeff,icoeff) = extF_t(icoeff,jcoeff)
                enddo
              enddo
              !$omp end parallel do
              !
              if (job%IOextF_divide) then
                 write(chkptIO_) extF_t
              else
                 write(chkptIO) extF_t
              endif
              !
            endif
            !
            if (job%IOextF_divide) then 
              write(chkptIO_) 'extF'
              close(chkptIO_)
            endif
            !
            !if (job%vib_rot_contr) then 
            !   !
            !   !$omp parallel do private(icoeff,jcoeff) shared(extF_t) schedule(dynamic)
            !   do icoeff=1,mdimen
            !     do jcoeff=1,icoeff-1
            !       extF_t(icoeff,jcoeff) = extF_t(jcoeff,icoeff)
            !     enddo
            !   enddo
            !   !$omp end parallel do
            !   !
            !   if (job%IOextF_divide) then 
            !     !
            !     call write_divided_slice(imu,'extF',job%extmat_suffix,mdimen,mdimen,extF_t)
            !     !
            !   else
            !     !
            !     write(chkptIO) extF_t
            !     !
            !   endif
            !   !
            !endif
            !
            if (job%verbose>=4) write(out,"('...done')",advance='YES') 
            !
          enddo
          !
          deallocate(extF_t)
          call ArrayStop('extF-fields')
          if (.not.job%IOextF_divide) write(chkptIO) 'End external field'
          !
          if (job%verbose>=2) write(out,"('...done!')")
          !
        endif
        !
        call de_initialize_class_contr_objects
        !
      endif 
      !
      ! Rotational matrix elements 
      !
      iclasses = 0 
      dimen   = contr(0)%nlevels
      dimen_p = contr(0)%dimen
      !
      if (FLrotation) then
         !
         if (job%rotsym_do) then
           !
           call PTrot_contracted_matelem_class(jrot)
           !
         else
           !
           if (job%verbose>=2) write(out,"(/'Rotational part...')")
           !
           job_is = 'rot'
           !
           allocate(contr(0)%rot(7),stat=alloc)
           !
           isize = (jmax+1)*(jmax+2)/2
           !
           do k1 =1,size(contr(0)%rot(:))
             !
             allocate(contr(0)%rot(k1)%coeff3d(isize,-2:2,0:1),stat=alloc)
             call ArrayStart('gvib-grot-gcor-fields',alloc,size(contr(0)%rot(k1)%coeff3d),kind(f_t))
             !
           enddo 
           !
           do k1 = 1,7
             !
             call FLread_coeff_matelem(job_is,k1,1,contr(0)%rot(k1)%coeff3d(:,:,:))
             !
           enddo
           !
         endif
         !
      endif
      !
      ! We have completed transformation of the matrix elements from the standard primitive 
      ! representation to the contarcted representaion.
      ! We can free some memory by deallocating the primitive objects. 
      !
      call FLfree_primitive_objects
      !
      deallocate(extF_N)
      !
      if (verbose>=4) call MemoryReport
      !
      if (verbose>=4) write(out,"('PTcontracted_matelem_class_fast/stop: contracted matrix elements for the hamiltonian ')") 
      !
      call TimerStop('Contracted matelements-class-fast')
      !
      !
  contains 
    !
    !
    subroutine open_dump_slice(islice,name,suffix,append,dump,chkptIO)
        !
        integer(ik),intent(in) :: islice
        character(len=*),intent(in) :: name,suffix
        logical,intent(in) :: append,dump
        integer(ik),intent(out)     :: chkptIO
        character(len=4) :: jchar
        character(len=cl) :: filename
          !
          write(job_is,"('dump matrix')")
          !
          call IOStart(trim(job_is),chkptIO)
          !
          write(jchar, '(i4)') islice
          !
          filename = trim(suffix)//trim(adjustl(jchar))//'_dump.chk'
          !
          if (append.and.dump) then 
            open(chkptIO,form='unformatted',action='readwrite',position='rewind',status='old',file=filename)
          elseif(dump) then
            open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
          else
            open(chkptIO,form='unformatted',action='read',position='rewind',status='old',file=filename)
          endif
          !
    end subroutine open_dump_slice
    !
    !
    subroutine open_divided_slice(islice,name,suffix,chkptIO)
        !
        integer(ik),intent(in) :: islice
        character(len=*),intent(in) :: name,suffix
        integer(ik),intent(out)     :: chkptIO
        character(len=4) :: jchar
        character(len=cl) :: filename
        !
        write(job_is,"('single swap_matrix')")
        !
        call IOStart(trim(job_is),chkptIO)
        !
        write(jchar, '(i4)') islice
        !
        filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
        !
        open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
        !
        write(chkptIO) trim(name)
        !
    end subroutine open_divided_slice
    !
    subroutine write_divided_slice(islice,name,suffix,N,M,field)
      !
      integer(ik),intent(in) :: islice
      character(len=*),intent(in) :: name,suffix
      integer(ik),intent(in)      :: N,M
      real(rk),intent(in)         :: field(N,M)
      character(len=4) :: jchar
      integer(ik)            :: chkptIO
      character(len=cl)      :: filename
      !
      write(job_is,"('single swap_matrix')")
      !
      call IOStart(trim(job_is),chkptIO)
      !
      write(jchar, '(i4)') islice
      !
      filename = trim(suffix)//trim(adjustl(jchar))//'.chk'
      !
      open(chkptIO,form='unformatted',action='write',position='rewind',status='replace',file=filename)
      !
      write(chkptIO) trim(name)
      !
      write(chkptIO) field
      !
      write(chkptIO) trim(name)
      !
      close(chkptIO)
      !
    end subroutine write_divided_slice
    !
    subroutine initialize_class_contr_objects
       !
       integer(ik) :: nmodes,nclasses,info,iclass,maxncontr,jclass,imode,icomb,n,extF_rank,ideg,icontr,isymcoeff
       real(rk) :: coef_thresh,energy_i
       character(cl) :: func_tag_, sclass, skey
       integer(hik)  :: matsize
       !
       nmodes = PT%Nmodes
       nclasses = PT%Nclasses
       coef_thresh = job%exp_coeff_thresh
       !
       ! indexes of modes in each class
       !
       allocate(iclass_nmodes(nclasses), iclass_imode(nmodes,nclasses), stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast:iclass_nmodes',info,size(iclass_nmodes),kind(iclass_nmodes))
       call ArrayStart('PTcontracted_matelem_class_fast:iclass_imode',info,size(iclass_imode),kind(iclass_imode))
       !
       do iclass=1, nclasses
         iclass_nmodes(iclass) = PT%mode_class(iclass,PT%mode_iclass(iclass)) - PT%mode_class(iclass,1) + 1
         iclass_imode(1:iclass_nmodes(iclass),iclass) = PT%mode_class(iclass,1:PT%mode_iclass(iclass))
       enddo
       !
       ! read contraction indices - indices of contracted functions that form CI product function
       !
       call read_contr_ind(maxncontr, nclasses, dimen_classes, nu_classes)
       ! note: "dimen_classes", "nu_classes" are allocated inside "read_contr_ind"
       ! count allocated memory
       info = 0
       call ArrayStart('PTcontracted_matelem_class_fast:dimen_classes',info,1,kind(dimen_classes),size(dimen_classes,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:nu_classes',info,1,kind(nu_classes),size(nu_classes,kind=hik))
       !   
       if (job%verbose>=4) write(out, '(1x,a,1x,i6)') 'total number of functions:', maxncontr
       if (job%verbose>=4) write(out, '(1x,a,1x,i2)') 'number of classes of contracted functions:', nclasses
       if (job%verbose>=4) write(out, '(1x,a,100(1x,i4))') 'number of contracted functions in each class:', &
                           dimen_classes(1:nclasses)
       !   
       !--------------------------------------------------!
       ! read expansion terms for vibrational part of KEO !
       !--------------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for vibrational part of KEO'
       func_tag_ = 'Tvib'
       !
       call read_expansion_terms(func_tag_, nclasses, nmodes, nmodes, ncomb, icomb_nclasses, icomb_iclass, &
                                 gvib_icomb_nterms, gvib_icomb_iterm, gvib_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "gvib_icomb_nterms", "gvib_icomb_iterm", "gvib_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       info = 0
       !
       call ArrayStart('PTcontracted_matelem_class_fast:gvib_icomb_nterms',info,1,kind(gvib_icomb_nterms),&
                        size(gvib_icomb_nterms,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:gvib_icomb_iterm',info,1,kind(gvib_icomb_iterm),&
                        size(gvib_icomb_iterm,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:gvib_icomb_coefs',info,1,kind(gvib_icomb_coefs),&
                        size(gvib_icomb_coefs,kind=hik))
       !
       !------------------------------------------------------------!
       ! read primitive matrix elements for vibrational part of KEO !
       !------------------------------------------------------------!
       !   
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for vibrational part of KEO'
       func_tag_ = 'Tvib'
       allocate(gvib_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gvib_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses
         dimen = dimen_classes(iclass)
         call read_contr_matelem_expansion(iclass, func_tag_, dimen, iclass_nmodes(iclass), iclass_nmodes(iclass), &
                                           gvib_me(iclass)%nterms, gvib_me(iclass)%me)
         ! note: "me" are allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'PTcontracted_matelem_class_fast:gvib_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(gvib_me(iclass)%me,kind=hik))
       enddo
       !
       if (job%verbose>=4) call MemoryReport
       !   
       !-------------------------------------------------!
       ! read expansion terms for rotational part of KEO !
       !-------------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for rotational part of KEO'
       func_tag_ = 'Trot'
       !
       call read_expansion_terms(func_tag_, nclasses, 3, 3, ncomb, icomb_nclasses, icomb_iclass, grot_icomb_nterms, &
                                 grot_icomb_iterm, grot_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "grot_icomb_nterms", "grot_icomb_iterm", "grot_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       info = 0
       call ArrayStart('PTcontracted_matelem_class_fast:grot_icomb_nterms',info,1,kind(grot_icomb_nterms),&
                       size(grot_icomb_nterms,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:grot_icomb_iterm',info,1,kind(grot_icomb_iterm),&
                       size(grot_icomb_iterm,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:grot_icomb_coefs',info,1,kind(grot_icomb_coefs),&
                       size(grot_icomb_coefs,kind=hik))
       !
       !-----------------------------------------------------------!
       ! read primitive matrix elements for rotational part of KEO !
       !-----------------------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for rotational part of KEO'
       func_tag_ = 'Trot'
       allocate(grot_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate grot_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses
         dimen = dimen_classes(iclass)
         call read_contr_matelem_expansion(iclass, func_tag_, dimen, 0, 0, grot_me(iclass)%nterms, grot_me(iclass)%me)
         ! note: "me" is allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'PTcontracted_matelem_class_fast:grot_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(grot_me(iclass)%me,kind=hik))
       enddo
       !
       if (job%verbose>=4) call MemoryReport
       !
       !-----------------------------------------------!
       ! read expansion terms for Coriolis part of KEO !
       !-----------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for Coriolis part of KEO'
       func_tag_ = 'Tcor'
       !   
       call read_expansion_terms(func_tag_, nclasses, nmodes, 3, ncomb, icomb_nclasses, icomb_iclass, gcor_icomb_nterms, & 
                                 gcor_icomb_iterm, gcor_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "gcor_icomb_nterms", "gcor_icomb_iterm", "gcor_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       info = 0
       call ArrayStart('PTcontracted_matelem_class_fast:gcor_icomb_nterms',info,1,kind(gcor_icomb_nterms),&
                       size(gcor_icomb_nterms,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:gcor_icomb_iterm',info,1,kind(gcor_icomb_iterm),&
                       size(gcor_icomb_iterm,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:gcor_icomb_coefs',info,1,kind(gcor_icomb_coefs),&
                       size(gcor_icomb_coefs,kind=hik))
       !
       !---------------------------------------------------------!
       ! read primitive matrix elements for Coriolis part of KEO !
       !---------------------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for Coriolis part of KEO'
       func_tag_ = 'Tcor'
       allocate(gcor_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate gcor_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses
         dimen = dimen_classes(iclass)
         call read_contr_matelem_expansion(iclass, func_tag_, dimen, 0, iclass_nmodes(iclass), gcor_me(iclass)%nterms, &
                                           gcor_me(iclass)%me)
         ! note: "me" is allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'PTcontracted_matelem_class_fast:gcor_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(gcor_me(iclass)%me,kind=hik))
       enddo
       !
       if (job%verbose>=4) call MemoryReport
       !
       !------------------------------!
       ! read expansion terms for PES !
       !------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for PES'
       func_tag_ = 'Vpot'
       !
       call read_expansion_terms(func_tag_, nclasses, 1, 1, ncomb, icomb_nclasses, icomb_iclass, vpot_icomb_nterms,&
                                 vpot_icomb_iterm, vpot_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "vpot_icomb_nterms", "vpot_icomb_iterm", "vpot_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       info = 0
       call ArrayStart('PTcontracted_matelem_class_fast:vpot_icomb_nterms',info,1,kind(vpot_icomb_nterms),&
                       size(vpot_icomb_nterms,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:vpot_icomb_iterm',info,1,kind(vpot_icomb_iterm),&
                       size(vpot_icomb_iterm,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:vpot_icomb_coefs',info,1,kind(vpot_icomb_coefs),&
                       size(vpot_icomb_coefs,kind=hik))
       !
       !----------------------------------------!
       ! read primitive matrix elements for PES !
       !----------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for PES'
       func_tag_ = 'Vpot'
       allocate(vpot_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate vpot_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses
         dimen = dimen_classes(iclass)
         call read_contr_matelem_expansion(iclass, func_tag_, dimen, 0, 0, vpot_me(iclass)%nterms, vpot_me(iclass)%me)
         ! note: "me" is allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'PTcontracted_matelem_class_fast:vpot_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(vpot_me(iclass)%me,kind=hik))
         !
       enddo
       !
       if (job%verbose>=4) call MemoryReport
       !
       !------------------------------------------!
       ! read expansion terms for pseudopotential !
       !------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for pseudopotential'
       func_tag_ = 'pseu'
       !
       call read_expansion_terms(func_tag_, nclasses, 1, 1, ncomb, icomb_nclasses, icomb_iclass, pseudo_icomb_nterms, &
                                 pseudo_icomb_iterm, pseudo_icomb_coefs)
       ! note: "icomb_nclasses", "icomb_iclass", "pseudo_icomb_nterms", "pseudo_icomb_iterm", "pseudo_icomb_coefs" are allocated inside "read_expansion_terms"
       !
       ! count allocated memory
       info = 0
       call ArrayStart('PTcontracted_matelem_class_fast:pseudo_icomb_nterms',info,1,kind(pseudo_icomb_nterms),&
                       size(pseudo_icomb_nterms,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:pseudo_icomb_iterm',info,1,kind(pseudo_icomb_iterm),&
                       size(pseudo_icomb_iterm,kind=hik))
       call ArrayStart('PTcontracted_matelem_class_fast:pseudo_icomb_coefs',info,1,kind(pseudo_icomb_coefs),&
                       size(pseudo_icomb_coefs,kind=hik))
       !
       !----------------------------------------------------!
       ! read primitive matrix elements for pseudopotential !
       !----------------------------------------------------!
       !
       if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for pseudopotential'
       func_tag_ = 'pseu'
       allocate(pseudo_me(nclasses), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate pseudo_me(nclasses)', 'nclasses =', nclasses
         stop
       endif
       do iclass=1, nclasses
         dimen = dimen_classes(iclass)
         call read_contr_matelem_expansion(iclass, func_tag_, dimen, 0, 0, pseudo_me(iclass)%nterms, pseudo_me(iclass)%me)
         ! note: "me" is allocated inside "read_contr_matelem_expansion"
         !
         ! count allocated memory
         write(sclass,'(i4)') iclass
         skey = 'PTcontracted_matelem_class_fast:pseudo_me('//trim(adjustl(sclass))//')'
         info = 0
         call ArrayStart(trim(skey),info,1,rk,size(pseudo_me(iclass)%me,kind=hik))
         !
       enddo
       !
       if (job%verbose>=4) call MemoryReport
       !
       !
       !
       allocate(iclass_ilambda(PT%Nmodes,PT%Nclasses,PT%Nclasses), stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast:iclass_ilambda',info,size(iclass_ilambda),kind(iclass_ilambda))
       !
       do iclass=1, nclasses
         do jclass=1, nclasses
           if (jclass/=iclass) then
             iclass_ilambda(:,jclass,iclass) = 0
           else
             iclass_ilambda(1:iclass_nmodes(iclass),jclass,iclass) = (/( imode, imode=1,iclass_nmodes(iclass) )/)
           endif
         enddo
       enddo
       !
       allocate(icomb_nclasses0(0:ncomb), icomb_iclass0(nclasses,0:ncomb), stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast:icomb_nclasses0',info,size(icomb_nclasses0),kind(icomb_nclasses0))
       call ArrayStart('PTcontracted_matelem_class_fast:icomb_iclass0',info,size(icomb_iclass0),kind(icomb_iclass0))
       icomb_nclasses0 = 0
       icomb_nclasses0(0) = nclasses
       icomb_iclass0(1:icomb_nclasses0(0),0) = (/(iclass, iclass=1, icomb_nclasses0(0))/)
       do icomb=1, ncomb
         n = icomb_nclasses(icomb)
         do iclass=1, nclasses
           if (all(icomb_iclass(1:n,icomb)/=iclass)) then
             icomb_nclasses0(icomb) = icomb_nclasses0(icomb) + 1
             icomb_iclass0(icomb_nclasses0(icomb),icomb) = iclass
           endif
         enddo
       enddo
       !
       if ( trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT' ) then
          !
          ! read expansion terms for ExtF 
          !
          if (job%verbose>=3) write(out, '(1x,a)') 'Read expansion terms for ExtF'
          func_tag_ = 'extF'
          extF_rank = FLread_extF_rank()
          !
          call read_expansion_terms(func_tag_, nclasses, extF_rank, 1, ncomb, icomb_nclasses, icomb_iclass, &
                                    extF_icomb_nterms, extF_icomb_iterm, extF_icomb_coefs)
          
          ! note: "icomb_nclasses", "icomb_iclass", "extF_icomb_nterms", "extF_icomb_iterm", "extF_icomb_coefs" are allocated inside "read_expansion_terms"
          !
          ! count allocated memory
          info = 0
          call ArrayStart('PTcontracted_matelem_class_fast:extF_icomb_nterms',info,1,kind(extF_icomb_nterms),&
                           size(extF_icomb_nterms,kind=hik))
          call ArrayStart('PTcontracted_matelem_class_fast:extF_icomb_iterm',info,1,kind(extF_icomb_iterm),&
                           size(extF_icomb_iterm,kind=hik))
          call ArrayStart('PTcontracted_matelem_class_fast:extF_icomb_coefs',info,1,kind(extF_icomb_coefs),&
                           size(extF_icomb_coefs,kind=hik))
          !
          if (job%verbose>=4) call MemoryReport
          !
          ! read primitive matrix elements for ExtF 
          !
          if (job%verbose>=3) write(out, '(1x,a)') 'Read primitive matrix elements for extF'
          func_tag_ = 'extF'
          allocate(extF_me(nclasses), stat=info)
          if (info/=0) then
            write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate extF_me(nclasses)', 'nclasses =', nclasses
            stop
          endif
          do iclass=1, nclasses
            dimen = dimen_classes(iclass)
            call read_contr_matelem_expansion(iclass, func_tag_, dimen, 0, 0, extF_me(iclass)%nterms, extF_me(iclass)%me)
            ! note: "me" is allocated inside "read_contr_matelem_expansion"
            ! count allocated memory
            write(sclass,'(i4)') iclass
            skey = 'PTcontracted_matelem_class_fast:extF_me('//trim(adjustl(sclass))//')'
            info = 0
            call ArrayStart(trim(skey),info,1,rk,size(extF_me(iclass)%me,kind=hik))
          enddo
          !
       endif
       !
       ! define the maximal energy within each isymmcoeff combination for different ideg, 
       ! which will be needed for enercut_matelem
       !
       if (allocated(enermax_classes)) deallocate(enermax_classes) 
       !
       allocate(enermax_classes(PT%Maxsymcoeffs),stat=info)
       call ArrayStart('PTcontracted_matelem_class_fast:enermax_classes',info,1,kind(enermax_classes),&
                       size(enermax_classes,kind=hik))
       !
       enermax_classes = 0
       !
       do isymcoeff = 1,PT%Maxsymcoeffs
         !
         enermax_classes(isymcoeff) = 0
         !
         icontr = PT%icase2icontr(isymcoeff,1)
         !
         enermax_classes(isymcoeff) = PTcontrenergy_zero(PT%icontr_cnu(:,icontr))
         !
         do ideg = 2,PT%Index_deg(isymcoeff)%size1
           !
           icontr = PT%icase2icontr(isymcoeff,ideg)
           !
           energy_i = PTcontrenergy_zero(PT%icontr_cnu(:,icontr))
           !
           enermax_classes(isymcoeff) = min(energy_i,enermax_classes(isymcoeff))
           !
         enddo
       enddo      
       !
       call MemoryReport
       !
    end subroutine initialize_class_contr_objects
    !
    !
    subroutine de_initialize_class_contr_objects
      !
      integer(ik) :: iclass
      character(cl) :: skey,sclass
      integer(ik) :: nmodes,nclasses
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      !
      write(out, '(/1x,a)') 'free memory'
  
      deallocate(iclass_nmodes, iclass_imode)
      call ArrayStop('PTcontracted_matelem_class_fast:iclass_nmodes')
      call ArrayStop('PTcontracted_matelem_class_fast:iclass_imode')
  
      deallocate(dimen_classes,nu_classes,enermax_classes)
      call ArrayStop('PTcontracted_matelem_class_fast:dimen_classes')
      call ArrayStop('PTcontracted_matelem_class_fast:nu_classes')
      call ArrayStop('PTcontracted_matelem_class_fast:enermax_classes')
  
      deallocate(icomb_nclasses, icomb_iclass)
  
      deallocate(gvib_icomb_nterms, gvib_icomb_iterm, gvib_icomb_coefs)
      call ArrayStop('PTcontracted_matelem_class_fast:gvib_icomb_nterms')
      call ArrayStop('PTcontracted_matelem_class_fast:gvib_icomb_iterm')
      call ArrayStop('PTcontracted_matelem_class_fast:gvib_icomb_coefs')
  
      deallocate(gvib_me)
      do iclass=1, nclasses
        write(sclass,'(i4)') iclass
        skey = 'PTcontracted_matelem_class_fast:gvib_me('//trim(adjustl(sclass))//')'
        call ArrayStop(trim(skey))
      enddo
  
      deallocate(grot_icomb_nterms, grot_icomb_iterm, grot_icomb_coefs)
      call ArrayStop('PTcontracted_matelem_class_fast:grot_icomb_nterms')
      call ArrayStop('PTcontracted_matelem_class_fast:grot_icomb_iterm')
      call ArrayStop('PTcontracted_matelem_class_fast:grot_icomb_coefs')
  
      deallocate(grot_me)
      do iclass=1, nclasses
        write(sclass,'(i4)') iclass
        skey = 'PTcontracted_matelem_class_fast:grot_me('//trim(adjustl(sclass))//')'
        call ArrayStop(trim(skey))
      enddo
  
      deallocate(gcor_icomb_nterms, gcor_icomb_iterm, gcor_icomb_coefs)
      call ArrayStop('PTcontracted_matelem_class_fast:gcor_icomb_nterms')
      call ArrayStop('PTcontracted_matelem_class_fast:gcor_icomb_iterm')
      call ArrayStop('PTcontracted_matelem_class_fast:gcor_icomb_coefs')
  
      deallocate(gcor_me)
      do iclass=1, nclasses
        write(sclass,'(i4)') iclass
        skey = 'PTcontracted_matelem_class_fast:gcor_me('//trim(adjustl(sclass))//')'
        call ArrayStop(trim(skey))
      enddo
  
      deallocate(vpot_icomb_nterms, vpot_icomb_iterm, vpot_icomb_coefs)
      call ArrayStop('PTcontracted_matelem_class_fast:vpot_icomb_nterms')
      call ArrayStop('PTcontracted_matelem_class_fast:vpot_icomb_iterm')
      call ArrayStop('PTcontracted_matelem_class_fast:vpot_icomb_coefs')
  
      deallocate(vpot_me)
      do iclass=1, nclasses
        write(sclass,'(i4)') iclass
        skey = 'PTcontracted_matelem_class_fast:vpot_me('//trim(adjustl(sclass))//')'
        call ArrayStop(trim(skey))
      enddo

      deallocate(pseudo_icomb_nterms, pseudo_icomb_iterm, pseudo_icomb_coefs)
      call ArrayStop('PTcontracted_matelem_class_fast:pseudo_icomb_nterms')
      call ArrayStop('PTcontracted_matelem_class_fast:pseudo_icomb_iterm')
      call ArrayStop('PTcontracted_matelem_class_fast:pseudo_icomb_coefs')
  
      deallocate(pseudo_me)
      do iclass=1, nclasses
        write(sclass,'(i4)') iclass
        skey = 'PTcontracted_matelem_class_fast:pseudo_me('//trim(adjustl(sclass))//')'
        call ArrayStop(trim(skey))
      enddo

      !
      if (treat_exfF) then
        !
        deallocate(ExtF_icomb_nterms, ExtF_icomb_iterm, ExtF_icomb_coefs)
        call ArrayStop('PTcontracted_matelem_class_fast:extF_icomb_nterms')
        call ArrayStop('PTcontracted_matelem_class_fast:extF_icomb_iterm')
        call ArrayStop('PTcontracted_matelem_class_fast:extF_icomb_coefs')
     
        deallocate(ExtF_me)
        do iclass=1, nclasses
          write(sclass,'(i4)') iclass
          skey = 'PTcontracted_matelem_class_fast:extF_me('//trim(adjustl(sclass))//')'
          call ArrayStop(trim(skey))
        enddo
        !
      endif
  
      deallocate(iclass_ilambda)
      call ArrayStop('PTcontracted_matelem_class_fast:iclass_ilambda')
  
      deallocate(icomb_nclasses0, icomb_iclass0)
      call ArrayStop('PTcontracted_matelem_class_fast:icomb_nclasses0')
      call ArrayStop('PTcontracted_matelem_class_fast:icomb_iclass0')
  
      write(out, '(/a)') 'PTcontracted_matelem_class_fast/done'
      !
    end  subroutine de_initialize_class_contr_objects   
    !
    !
    !
    subroutine  calc_grot_contr_matrix(k1,k2,isymcoeff,grot)
      !
      integer(ik),intent(in) :: k1,k2,isymcoeff
      !
      !integer(ik),intent(in) :: nu_classes(PT%Nclasses,PT%Maxcontracts)
      !integer(ik),intent(in) :: grot_icomb_nterms(0:ncomb,3,3)
      !
      real(rk),intent(out)   :: grot(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),energy_j
      integer(ik) :: icomb,iterm,nclasses,icontr,jcontr,nterms,n0,iclass,iclass_n,nmodes,klass,nu_i,nu_j,n,kclass
      integer(ik) :: iterm_uniq,Maxcontracts,jsymcoeff
      !
      Maxcontracts = PT%Maxcontracts
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,matelem,icomb,iterm,nterms,n0,n,iclass_n,kclass,nu_i,nu_j,&
        !$omp& iterm_uniq,me_class0) shared(grot) schedule(dynamic)
        do jcontr=1,icontr
          !
          jsymcoeff = PT%icontr2icase(jcontr,1)
          energy_j = enermax_classes(jsymcoeff)
          !
          if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem ) cycle
          !
          matelem = 0
          !
          ! zero-order expansion term
          icomb = 0
          iterm = 1
          if (grot_icomb_nterms(icomb,k1,k2)>0) then
            if (all(nu_classes(1:nclasses,icontr)==nu_classes(1:nclasses,jcontr))) then
              matelem = matelem + grot_icomb_coefs(iterm,icomb,k1,k2)
            endif
          endif
          !
          do icomb=1, ncomb
            !
            nterms = grot_icomb_nterms(icomb,k1,k2)
            if (nterms<=0) cycle
            !
            ! orthogonality of contracted functions
            n0 = icomb_nclasses0(icomb)
            if (n0>0) then
              if (any( (/(nu_classes(icomb_iclass0(iclass,icomb),icontr)/=&
                          nu_classes(icomb_iclass0(iclass,icomb),jcontr),iclass=1,n0)/) ) ) cycle
            endif
            !
            n = icomb_nclasses(icomb)
            do iterm=1, nterms
              do iclass_n=1, n
                kclass = icomb_iclass(iclass_n,icomb)
                nu_i = nu_classes(kclass,icontr)
                nu_j = nu_classes(kclass,jcontr)
                iterm_uniq = grot_icomb_iterm(kclass,iterm,icomb,k1,k2)
                me_class0(iclass_n) = grot_me(kclass)%me(iterm_uniq,nu_i,nu_j,0,0)
              enddo
              if (n>0) then
                matelem = matelem + product(me_class0(1:n)) * grot_icomb_coefs(iterm,icomb,k1,k2)
              endif
            enddo
            !
          enddo ! icomb
          !
          if (job%vib_rot_contr) then 
            grot(jcontr,ideg) = matelem
          else
            grot(icontr,jcontr) = matelem
          endif
          !
        enddo
      !$omp end parallel do
      enddo
      !
    end subroutine calc_grot_contr_matrix 
    !
    !
    subroutine  calc_gcor_contr_matrix(k1,k2,isymcoeff,gcor)
      !
      integer(ik),intent(in) :: k1,k2,isymcoeff
      real(rk),intent(out) :: gcor(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),prod0,coef_thresh,matelem0,energy_j
      integer(ik) :: icomb,iterm,nclasses,icontr,jcontr,nterms,n0,iclass,iclass_n,nmodes,klass,nu_i,nu_j,n,kclass
      integer(ik) :: iterm_uniq,imode,imode_,Maxcontracts,jsymcoeff
      !
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      Maxcontracts = PT%Maxcontracts
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,matelem,iclass,imode,imode_,icomb,iterm,kclass,nu_i,nu_j,&
        !$omp& ilambda,imu,iterm_uniq,me_class0,nterms,n0,iclass_n,prod0,matelem0,n) shared(gcor) schedule(dynamic)
        do jcontr=1,icontr
           !
           jsymcoeff = PT%icontr2icase(jcontr,1)
           energy_j = enermax_classes(jsymcoeff)
           !
           if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem ) cycle
           !
           matelem = 0
           !
           do iclass=1, nclasses
             do imode=1, iclass_nmodes(iclass)
               imode_ = iclass_imode(imode,iclass)
               !   
               ! zero-order expansion term
               icomb = 0
               iterm = 1
               if (gcor_icomb_nterms(icomb,imode_,k2)>0) then
                 do kclass=1, nclasses
                   nu_i = nu_classes(kclass,icontr)
                   nu_j = nu_classes(kclass,jcontr)
                   ilambda = iclass_ilambda(imode,kclass,iclass)
                   iterm_uniq = gcor_icomb_iterm(kclass,iterm,icomb,imode_,k2)
                   me_class0(kclass) = gcor_me(kclass)%me(iterm_uniq,nu_i,nu_j,0,ilambda)
                  enddo
                  matelem = matelem + product(me_class0(1:nclasses)) * gcor_icomb_coefs(iterm,icomb,imode_,k2)
               endif
               !
               do icomb=1, ncomb
                 !
                 nterms = gcor_icomb_nterms(icomb,imode_,k2)
                 if (nterms<=0) cycle
     
                 ! orthogonality of contracted functions
                 if ( any( (/( iclass_ilambda(imode,icomb_iclass0(iclass_n,icomb),iclass)==0 .and. &
                               nu_classes(icomb_iclass0(iclass_n,icomb),icontr)/=&
                               nu_classes(icomb_iclass0(iclass_n,icomb),jcontr), &
                               iclass_n=1,icomb_nclasses0(icomb))/) ) ) cycle
     
                 n0 = icomb_nclasses0(icomb)
                 do iclass_n=1, n0
                   kclass = icomb_iclass0(iclass_n,icomb)
                   nu_i = nu_classes(kclass,icontr)
                   nu_j = nu_classes(kclass,jcontr)
                   ilambda = iclass_ilambda(imode,kclass,iclass)
                   iterm_uniq = gcor_icomb_iterm(kclass,1,0,imode_,k2)
                   me_class0(iclass_n) = gcor_me(kclass)%me(iterm_uniq,nu_i,nu_j,0,ilambda)
                 enddo
                 if (n0>0) then
                   prod0 = product(me_class0(1:n0))
                   if (abs(prod0)<coef_thresh) cycle
                 else
                   prod0 = 1.0_rk
                 endif
                 !
                 matelem0 = 0.0_rk
                 n = icomb_nclasses(icomb)
                 do iterm=1, nterms
                   do iclass_n=1, n
                     kclass = icomb_iclass(iclass_n,icomb)
                     nu_i = nu_classes(kclass,icontr)
                     nu_j = nu_classes(kclass,jcontr)
                     ilambda = iclass_ilambda(imode,kclass,iclass)
                     iterm_uniq = gcor_icomb_iterm(kclass,iterm,icomb,imode_,k2)
                     me_class0(iclass_n) = gcor_me(kclass)%me(iterm_uniq,nu_i,nu_j,0,ilambda)
                   enddo
                   if (n>0) then
                     matelem0 = matelem0 + product(me_class0(1:n)) * gcor_icomb_coefs(iterm,icomb,imode_,k2)
                   endif
                 enddo
                 !
                 matelem = matelem + matelem0 * prod0
                 !
               enddo ! icomb
               !
             enddo
           enddo
           !
           if (job%vib_rot_contr) then 
             gcor(jcontr,ideg) = matelem
           else
             gcor(icontr,jcontr) = matelem
           endif
           !
           !if (icontr/=jcontr) matelem = -matelem
           !
        enddo
       !$omp end parallel do 
     enddo
     !
    end subroutine  calc_gcor_contr_matrix
    !
    !
    subroutine  calc_gvib_contr_matrix(isymcoeff,hvib)
      !
      integer(ik),intent(in) :: isymcoeff
      real(rk),intent(out) :: hvib(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),coef_thresh,matelem0,prod0,energy_j,energy_i
      integer(ik) :: icomb,iterm,nclasses,icontr,jcontr,nterms,n0,iclass,iclass_n,nmodes,klass,nu_i,nu_j,n,kclass
      integer(ik) :: iterm_uniq,jclass,imode,jmode,imode_,jmode_,Maxcontracts,jsymcoeff,jdeg
      !
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      coef_thresh = job%exp_coeff_thresh
      energy_i = enermax_classes(isymcoeff)
      !
      Maxcontracts = PT%Maxcontracts
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,matelem,iclass,jclass,imode,imode_,jmode,jmode_,icomb,iterm,kclass, &
        !$omp&         nu_i,nu_j,ilambda,imu,iterm_uniq,me_class0,nterms,n0,iclass_n,prod0,matelem0,n) &
        !$omp&         shared(hvib) schedule(dynamic)
        do jcontr=1,icontr
           !
           jsymcoeff = PT%icontr2icase(jcontr,1)
           energy_j = enermax_classes(jsymcoeff)
           !
           if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem.and.abs(energy_i-energy_j)>job%enercutoff%DeltaE ) cycle
           !        
           matelem = 0
           !
           do iclass=1, nclasses
             do imode=1, iclass_nmodes(iclass)
               imode_ = iclass_imode(imode,iclass)
               do jclass=1, nclasses
                 do jmode=1, iclass_nmodes(jclass)
                   jmode_ = iclass_imode(jmode,jclass)
                   !
                   ! zero-order expansion term
                   icomb = 0
                   iterm = 1
                   if (gvib_icomb_nterms(icomb,imode_,jmode_)>0) then
                     do kclass=1, nclasses
                       nu_i = nu_classes(kclass,icontr)
                       nu_j = nu_classes(kclass,jcontr)
                       ilambda = iclass_ilambda(imode,kclass,iclass)
                       imu = iclass_ilambda(jmode,kclass,jclass)
                       iterm_uniq = gvib_icomb_iterm(kclass,iterm,icomb,imode_,jmode_)
                       me_class0(kclass) = gvib_me(kclass)%me(iterm_uniq,nu_i,nu_j,ilambda,imu)
                     enddo
                     !
                     !f_t = gvib_icomb_coefs(iterm,icomb,imode_,jmode_)
                     !f_t = product(me_class0(1:nclasses))
                     !f_t = product(me_class0(1:nclasses)) * gvib_icomb_coefs(iterm,icomb,imode_,jmode_)
                     !
                     matelem = matelem + product(me_class0(1:nclasses)) * gvib_icomb_coefs(iterm,icomb,imode_,jmode_)
                   endif
                   !
                   do icomb=1, ncomb
                     !
                     nterms = gvib_icomb_nterms(icomb,imode_,jmode_)
                     if (nterms<=0) cycle
                     !
                     ! orthogonality of contracted functions
                     if ( any( (/( iclass_ilambda(imode,icomb_iclass0(iclass_n,icomb),iclass)==0 .and. &
                                   iclass_ilambda(jmode,icomb_iclass0(iclass_n,icomb),jclass)==0 .and. &
                                   nu_classes(icomb_iclass0(iclass_n,icomb),icontr)/=&
                                   nu_classes(icomb_iclass0(iclass_n,icomb),jcontr),iclass_n=1,icomb_nclasses0(icomb))/) ) ) cycle
                     !
                     n0 = icomb_nclasses0(icomb)
                     do iclass_n=1, n0
                       kclass = icomb_iclass0(iclass_n,icomb)
                       nu_i = nu_classes(kclass,icontr)
                       nu_j = nu_classes(kclass,jcontr)
                       ilambda = iclass_ilambda(imode,kclass,iclass)
                       imu = iclass_ilambda(jmode,kclass,jclass)
                       iterm_uniq = gvib_icomb_iterm(kclass,1,0,imode_,jmode_)
                       me_class0(iclass_n) = gvib_me(kclass)%me(iterm_uniq,nu_i,nu_j,ilambda,imu)
                     enddo
                     !
                     !if (n0>0) then
                       prod0 = 1.0_rk
                       prod0 = product(me_class0(1:n0))
                       if (abs(prod0)<coef_thresh) cycle
                     !else
                     !  prod0 = 1.0_rk
                     !endif
                     !
                     matelem0 = 0
                     n = icomb_nclasses(icomb)
                     do iterm=1, nterms
                       do iclass_n=1, n
                         kclass = icomb_iclass(iclass_n,icomb)
                         nu_i = nu_classes(kclass,icontr)
                         nu_j = nu_classes(kclass,jcontr)
                         ilambda = iclass_ilambda(imode,kclass,iclass)
                         imu = iclass_ilambda(jmode,kclass,jclass)
                         iterm_uniq = gvib_icomb_iterm(kclass,iterm,icomb,imode_,jmode_)
                         me_class0(iclass_n) = gvib_me(kclass)%me(iterm_uniq,nu_i,nu_j,ilambda,imu)
                       enddo
                       if (n>0) then
                         matelem0 = matelem0 + product(me_class0(1:n)) * gvib_icomb_coefs(iterm,icomb,imode_,jmode_)
                       endif
                     enddo
                     !
                     matelem = matelem + matelem0 * prod0
                     !
                   enddo ! icomb
                   !
                 enddo
               enddo
             enddo
           enddo
           !
           matelem = -0.5_rk*matelem
           !
           ! potential part
           !
           ! zero-order expansion term
           icomb = 0
           iterm = 1
           if (vpot_icomb_nterms(icomb,1,1)>0) then
             if (all(nu_classes(1:nclasses,icontr)==nu_classes(1:nclasses,jcontr))) then
               matelem = matelem + vpot_icomb_coefs(iterm,icomb,1,1)
             endif
           endif
           !
           do icomb=1, ncomb
             !
             nterms = vpot_icomb_nterms(icomb,1,1)
             if (nterms<=0) cycle
             !
             ! orthogonality of contracted functions
             n0 = icomb_nclasses0(icomb)
             if (n0>0) then
               if (any( (/(nu_classes(icomb_iclass0(iclass,icomb),icontr)/=&
                          nu_classes(icomb_iclass0(iclass,icomb),jcontr), iclass=1,n0)/) ) ) cycle
             endif
             !
             n = icomb_nclasses(icomb)
             do iterm=1, nterms
               do iclass_n=1, n
                 kclass = icomb_iclass(iclass_n,icomb)
                 nu_i = nu_classes(kclass,icontr)
                 nu_j = nu_classes(kclass,jcontr)
                 iterm_uniq = vpot_icomb_iterm(kclass,iterm,icomb,1,1)
                 me_class0(iclass_n) = vpot_me(kclass)%me(iterm_uniq,nu_i,nu_j,0,0)
               enddo
               if (n>0) then
                 matelem = matelem + product(me_class0(1:n)) * vpot_icomb_coefs(iterm,icomb,1,1)
               endif
             enddo
             !
           enddo ! icomb
           !
           ! pseudopotential part
           !
           ! zero-order expansion term
           icomb = 0
           iterm = 1
           if (pseudo_icomb_nterms(icomb,1,1)>0) then
             if (all(nu_classes(1:nclasses,icontr)==nu_classes(1:nclasses,jcontr))) then
               matelem = matelem + pseudo_icomb_coefs(iterm,icomb,1,1)
             endif
           endif
           !
           do icomb=1, ncomb
             !
             nterms = pseudo_icomb_nterms(icomb,1,1)
             if (nterms<=0) cycle
             !
             ! orthogonality of contracted functions
             n0 = icomb_nclasses0(icomb)
             if (n0>0) then
               if (any( (/(nu_classes(icomb_iclass0(iclass,icomb),icontr)/=&
                           nu_classes(icomb_iclass0(iclass,icomb),jcontr), iclass=1,n0)/) ) ) cycle
             endif
             !
             n = icomb_nclasses(icomb)
             do iterm=1, nterms
               do iclass_n=1, n
                 kclass = icomb_iclass(iclass_n,icomb)
                 nu_i = nu_classes(kclass,icontr)
                 nu_j = nu_classes(kclass,jcontr)
                 iterm_uniq = pseudo_icomb_iterm(kclass,iterm,icomb,1,1)
                 me_class0(iclass_n) = pseudo_me(kclass)%me(iterm_uniq,nu_i,nu_j,0,0)
               enddo
               if (n>0) then
                 matelem = matelem + product(me_class0(1:n)) * pseudo_icomb_coefs(iterm,icomb,1,1)
               endif
             enddo
             !
           enddo ! icomb
           !
           if (job%vib_rot_contr) then 
             hvib(jcontr,ideg) = matelem
           else
             hvib(icontr,jcontr) = matelem
           endif
           !
         enddo
        !$omp end parallel do 
      enddo
      !
    end subroutine  calc_gvib_contr_matrix
    !
    subroutine  calc_extF_contr_matrix(k1,isymcoeff,extF)
      !
      integer(ik),intent(in) :: k1,isymcoeff
      !
      !integer(ik),intent(in) :: nu_classes(PT%Nclasses,PT%Maxcontracts)
      !integer(ik),intent(in) :: grot_icomb_nterms(0:ncomb,3,3)
      !
      real(rk),intent(out)   :: extF(:,:)
      !
      real(rk) :: matelem,me_class0(PT%Nclasses),energy_j
      integer(ik) :: icomb,iterm,nclasses,icontr,jcontr,nterms,n0,iclass,iclass_n,nmodes,klass,nu_i,nu_j,n,kclass
      integer(ik) :: iterm_uniq,Maxcontracts,jsymcoeff
      !
      Maxcontracts = PT%Maxcontracts
      nmodes = PT%Nmodes
      nclasses = PT%Nclasses
      !
      do ideg = 1,PT%Index_deg(isymcoeff)%size1
        !
        icontr = PT%icase2icontr(isymcoeff,ideg)
        !
        !$omp parallel do private(jcontr,energy_j,jsymcoeff,matelem,icomb,iterm,nterms,n0,n,iclass_n,kclass,nu_i,nu_j,&
        !$omp&         iterm_uniq,me_class0) shared(hvib) schedule(dynamic)
        do jcontr=1,icontr
           !
           jsymcoeff = PT%icontr2icase(jcontr,1)
           energy_j = enermax_classes(jsymcoeff)
           !
           if ( isymcoeff/=jsymcoeff.and.energy_j>job%enercutoff%matelem ) cycle
           !        
           matelem = 0
           !
           ! ExtF part
           !
           ! zero-order expansion term
           icomb = 0
           iterm = 1
           if (ExtF_icomb_nterms(icomb,k1,1)>0) then
             if (all(nu_classes(1:nclasses,icontr)==nu_classes(1:nclasses,jcontr))) then
               matelem = matelem + ExtF_icomb_coefs(iterm,icomb,k1,1)
             endif
           endif
           !
           do icomb=1, ncomb
             !
             nterms = ExtF_icomb_nterms(icomb,k1,1)
             if (nterms<=0) cycle
             !
             ! orthogonality of contracted functions
             n0 = icomb_nclasses0(icomb)
             if (n0>0) then
               if (any( (/(nu_classes(icomb_iclass0(iclass,icomb),icontr)/=&
                           nu_classes(icomb_iclass0(iclass,icomb),jcontr), iclass=1,n0)/) ) ) cycle
             endif
             !
             n = icomb_nclasses(icomb)
             do iterm=1, nterms
               do iclass_n=1, n
                 kclass = icomb_iclass(iclass_n,icomb)
                 nu_i = nu_classes(kclass,icontr)
                 nu_j = nu_classes(kclass,jcontr)
                 iterm_uniq = ExtF_icomb_iterm(kclass,iterm,icomb,k1,1)
                 me_class0(iclass_n) = ExtF_me(kclass)%me(iterm_uniq,nu_i,nu_j,0,0)
               enddo
               if (n>0) then
                 matelem = matelem + product(me_class0(1:n)) * ExtF_icomb_coefs(iterm,icomb,k1,1)
               endif
             enddo
             !
           enddo ! icomb
           !
           if (job%vib_rot_contr) then 
             extF(jcontr,ideg) = matelem
           else
             extF(icontr,jcontr) = matelem
           endif
           !
         enddo
        !$omp end parallel do 
      enddo
      !
    end subroutine calc_extF_contr_matrix 
    !
  end subroutine PTcontracted_matelem_class_fast 


subroutine PTstore_contr_matelem(jrot)
  !
  integer(ik),intent(in) :: jrot
  integer(ik) :: i, iclass, info, dimen, maxnterms, nterms_uniq(PT%Nclasses), nclasses, nmodes, &
                 n, iclass_imode(2,PT%Nclasses), nterms, nmodes_class, imode, jmode, iterm, kterm, nprim, term(PT%Nmodes), &
                 ncomb, icomb, iterm_, nterms_, jterm, imode_, jmode_, icomb_maxnterms, imode1, imode2,ipar,extF_rank
  integer(ik), allocatable :: icomb_nclasses(:), icomb_iclass(:,:), icomb_nterms(:), icomb_iterm(:,:), terms_uniq(:,:,:), &
                              iterm_uniq(:,:), ijmode_icomb_iterm(:,:,:), ijmode_icomb_nterms(:)
  integer(ik), allocatable :: terms(:,:)
  real(rk) :: coef_thresh, c
  real(rk), allocatable :: me_contr(:,:,:), ijmode_icomb_coefs(:,:)
  character(cl) :: func_tag
  logical :: match
  logical            :: treat_rotation =.false.  ! switch off/on the rotation 
  logical            :: treat_vibration =.true.  ! switch off/on the vibration
  logical            :: treat_exfF=.false.       ! switch off/on the external field 
  integer (ik)       :: itosparse,icoeff,nterms0
  integer(ik)        :: target_index(PT%Nmodes),Nfield_terms
  integer(ik)        :: poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,Jmax,L2vib_N,ipos,ipos_,iroot,ilevel,ideg
  integer(ik),allocatable :: extF_N(:), IndexQ(:,:),IndexQ0(:,:)
  character(len=cl)  :: my_fmt !format for I/O specification
  !
  if ((.not.FLrotation.or.jrot/=0).and.trim(job%IOkinet_action)/='SAVE'.and.&
       trim(job%IOextF_action)/='SAVE'.and.trim(job%IOextF_action)/='SPLIT') return
  !  
  if (trim(job%IOkinet_action)=='CONVERT') return 
  if (job%vib_contract) return
  if ( ( trim(job%IOkinet_action)=='READ'.or.trim(job%IOkinet_action)=='VIB_READ' ).and.&
         trim(job%IOextF_action)=='SAVE' ) return
  !
  if (trim(trove%IO_contrCI)=='READ') return
  !
  if (trim(trove%IO_contrCI)=='SAVE'.and.job%IOmatelem_split.and.job%iswap(1)>1) then
    !
    write(out,"('PTstore_contr_matelem: CONTR_CI should be set to READ if _MATELEM save split_ and slices>1')")
    stop 'PTstore_contr_matelem: CONTR_CI should be set to READ for _MATELEM save split_ use'
    !
  endif
  !
  if (any(trove%manifold_rank(:)/=0)) then
    write(out, '(/a)') 'PTstore_contr_matelem error: "non-rigid" case is not implemented'
    stop
  endif
  !
  call TimerStart('PTstore_contr_matelem')
  !
  if (job%verbose>=4) write(out, '(/a/)')  'PTstore_contr_matelem/start: compute contracted matrix elements'
  !
  if (job%verbose>=4) write(out, '(1x,a,1x,i8)') 'total number of contracted functions:', PT%Maxcontracts
  if (job%verbose>=4) write(out, '(1x,a,1x,i3)') 'number of classes of contracted functions:', PT%Nclasses
  if (job%verbose>=4) write(out, '(1x,a,100(1x,i6))') 'number of contracted functions in each class:', contr(1:PT%Nclasses)%nroots
  !
  nclasses = PT%Nclasses
  nmodes = PT%Nmodes
  coef_thresh = job%exp_coeff_thresh
  !
  extF_rank = FLread_extF_rank()
  !
  allocate(extF_N(max(extF_rank,1)))
  !
  call FLread_fields_dimensions(poten_N,gvib_N,grot_N,gcor_N,potorder,kinorder,extForder,jmax,extF_N,L2vib_N)
  !
  ! expansion indices
  !
  target_index = 0 
  target_index(1) = max(potorder,kinorder,extForder)
  maxnterms = FLQindex(trove%Nmodes_e,target_index)
  !
  allocate(terms(size(FLIndexQ,dim=1),size(FLIndexQ,dim=2)), stat=info)
  call ArrayStart('PTstore_contr_matelem:terms',info,size(terms),kind(terms))
  !terms = FLindexQ
  maxnterms = FLQindex(trove%Nmodes_e,target_index,terms)
  !
  ! indexes of the first and the last mode in each class
  !
  do iclass=1, nclasses
    iclass_imode(1:2,iclass) = (/PT%mode_class(iclass,1), PT%mode_class(iclass,PT%mode_iclass(iclass))/)
  enddo
  !
  if (job%verbose>=4) then 
      write(out, *)
      do iclass=1, nclasses
         write(out, '(1x,a,1x,i3,3x,a,1x,i3,1x,a,1x,i3,1x,a)') 'iclass =', iclass, 'imodes = [', iclass_imode(1,iclass),&
                     ':', iclass_imode(2,iclass), ']'
      enddo
  endif
  !
  allocate(IndexQ(Nmodes,maxnterms), stat=info)
  call ArrayStart('PTstore_contr_matelem:IndexQ',info,size(IndexQ),kind(IndexQ))
  IndexQ = terms
  !
  ! exclude last class form IndexQ0
  imode1 = PT%mode_class(nclasses,1)
  nterms0 = FLQindex(imode1-1,target_index)
  allocate(IndexQ0(Nmodes,nterms0), stat=info)
  call ArrayStart('PTstore_contr_matelem:IndexQ0',info,size(IndexQ0),kind(IndexQ0))
  nterms0 = FLQindex(imode1-1,target_index,IndexQ0)
  !
  ! estimate max number of expansion terms among all operators
  !
  !maxnterms = max( maxval(trove%g_rot(:,:)%Ncoeff), &
  !                 maxval(trove%g_cor(:,:)%Ncoeff), &
  !                 maxval(trove%g_vib(:,:)%Ncoeff), &
  !                 trove%pseudo%Ncoeff, &
  !                 trove%poten%Ncoeff)
  !
  target_index = 0 
  target_index(1) = max(potorder,kinorder,extForder)
  maxnterms = FLQindex(trove%Nmodes_e,target_index)
  !
  if (associated(trove%extf)) maxnterms = max(maxnterms,maxval(trove%extf(:)%Ncoeff))
  !
  if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all fields:', maxnterms
  !
  ! generate all possible combinations of classes
  !
  call combinations(nclasses, (/(iclass, iclass=1, nclasses)/), ncomb, icomb_nclasses, icomb_iclass)
  ! note: "icomb_nclasses" and "icomb_iclass" are allocated inside "combinations"
  !
  icomb_nclasses(0) = 0
  icomb_iclass(:,0) = 0
  !
  ! count allocated memory
  info = 0
  call ArrayStart('PTstore_contr_matelem:icomb_nclasses',info,size(icomb_nclasses),kind(icomb_nclasses))
  call ArrayStart('PTstore_contr_matelem:icomb_iclass',info,size(icomb_iclass),kind(icomb_iclass))
  !
  if (job%verbose>=4) then 
    write(out, '(/1x,a,1x,i3,1x,a)') 'combinations of classes (', ncomb+1, '):'
    do icomb=0, ncomb
      n = icomb_nclasses(icomb)
      write(out, '(1x,a,1x,i3,3x,a,1x,100(1x,i3))') 'icomb =', icomb, 'iclasses =', icomb_iclass(1:n,icomb)
    enddo
    !
  endif
  !
  ! for maximal expansion (maxnterms) split expansion terms into groups each for different combination of classes
  !
  allocate(icomb_nterms(0:ncomb), stat=info)
  call ArrayStart('PTstore_contr_matelem:icomb_nterms',info,size(icomb_nterms),kind(icomb_nterms))
  !
  call split_terms_comb(nmodes, maxnterms, terms(1:nmodes,1:maxnterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb))
  !
  if (job%verbose>=4) then 
     write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
    do icomb=0, ncomb
      write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
    enddo
  endif
  !
  if (sum(icomb_nterms(0:ncomb))/=maxnterms) then
    write(out, '(/a,1x,i6,1x,a,1x,i6)') &
    'PTstore_contr_matelem error: number of terms among all combinations of classes =', sum(icomb_nterms(0:ncomb)),&
     'differs from the total number of terms =', maxnterms
    stop
  endif
  !
  ! for maximal expansion (maxnterms) estimate max number of unique expansion terms for each class
  !
  allocate(terms_uniq(nmodes,maxnterms,nclasses), iterm_uniq(nclasses,maxnterms), stat=info)
  call ArrayStart('PTstore_contr_matelem:terms_uniq',info,size(terms_uniq),kind(terms_uniq))
  call ArrayStart('PTstore_contr_matelem:iterm_uniq',info,size(iterm_uniq),kind(iterm_uniq))
  !
  call split_terms_uniq(nmodes, maxnterms, terms(1:nmodes,1:maxnterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:maxnterms), terms_uniq(1:nmodes,1:maxnterms,1:nclasses))
  !
  if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
  !
  ! allocate array to keep indexes of terms split into groups each for different combinations of classes
  !
  allocate(icomb_iterm(maxval(icomb_nterms(0:ncomb)),0:ncomb), stat=info)
  call ArrayStart('PTstore_contr_matelem:icomb_iterm',info,size(icomb_iterm),kind(icomb_iterm))
  !
  !------------------------------------------------------------------!
  ! compute and store matrix elements of the vibrational part of KEO !
  !------------------------------------------------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of Gvib'
  !
  func_tag = 'Tvib'
  !
  !nterms = maxval(trove%g_vib(1:nmodes,1:nmodes)%Ncoeff)
  !
  target_index = 0 
  target_index(1) = KinOrder
  nterms= FLQindex(trove%Nmodes_e,target_index)
  nterms0= FLQindex(trove%Nmodes-1,target_index)
  !
  if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all elements of Gvib:', nterms

  call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), &
                        icomb_nterms(0:ncomb), icomb_iterm(:,0:ncomb))
  !
  if (job%verbose>=4) then 
    write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
    do icomb=0, ncomb
      write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
    enddo
  endif
  !
  if (sum(icomb_nterms(0:ncomb))/=nterms) then
    write(out, '(/a,1x,i6,1x,a,1x,i6)') &
    'PTstore_contr_matelem error: number of Gvib expansion terms among all combinations of classes =',sum(icomb_nterms(0:ncomb)),&
    'differs from the total number of terms =', nterms
    stop
  endif
  !
  call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
  !
  if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
  !
  ! compute and store contracted matrix elements for unique expansion terms only within each class
  !
  do iclass=1, nclasses
    !
    if (job%verbose>=4) write(out, '(/1x,a,1x,i3)') 'start contracted matrix elements for iclass', iclass
    !
    nmodes_class = iclass_imode(2,iclass) - iclass_imode(1,iclass) + 1
    dimen = contr(iclass)%nroots
    nprim = contr(iclass)%dimen
    !
    if (job%verbose>=4) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. modes, no. unique terms, no. basis functions:', nmodes_class,&
        nterms_uniq(iclass), dimen
    !
    ! allocate array to keep contracted matrix elements
    !
    if (job%verbose>=4) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size =', & 
        real(nterms_uniq(iclass))*real(max(dimen,nprim))**2*8.0/1024.0**3, 'gb'
    !
    allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
    if (info/=0) then
      write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate me_contr(nterms_uniq,max(dimen,nprim),max(dimen,nprim))', &
      'nterms_uniq, dimen, nprim =', nterms_uniq(iclass), dimen, nprim
    endif
    !
    ! compute contracted matrix elements for operators: G, p_i*G, G*p_i, p_i*G*p_j
    !
    if (job%verbose>=4) write(out, '(3x,a,3x,a,5x,a)') 'p_i*Gvib*p_j:', 'i', 'j'
    !
    ! <G>
    !
    call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), &
                                         terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
    call store_contr_matelem_expansion(0, 0, iclass, func_tag, nmodes_class, nmodes_class, dimen, nterms_uniq(iclass),me_contr)
    !
    if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, 0
    !
    ! <p_i*G> and <G*p_i>
    !
    imode_ = 0
    do imode=iclass_imode(1,iclass), iclass_imode(2,iclass)
      imode_ = imode_ + 1
      call calc_contr_matelem_expansion_p1(imode, iclass, func_tag, nterms_uniq(iclass), & 
                                           terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
      call store_contr_matelem_expansion(0,imode_,iclass,func_tag,nmodes_class,nmodes_class,dimen,nterms_uniq(iclass),me_contr)
      if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, imode
      do iterm=1, nterms_uniq(iclass)
        me_contr(iterm,:,:) = -transpose(me_contr(iterm,:,:))
      enddo
      call store_contr_matelem_expansion(imode_, 0,iclass,func_tag,nmodes_class,nmodes_class,dimen,nterms_uniq(iclass),me_contr)
      if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') imode, 0
    enddo
    !
    ! <p_i*G*p_j>
    !
    imode_ = 0
    do imode=iclass_imode(1,iclass), iclass_imode(2,iclass)
      imode_ = imode_ + 1
      jmode_ = 0
      do jmode=iclass_imode(1,iclass), iclass_imode(2,iclass)
        jmode_ = jmode_ + 1
        call calc_contr_matelem_expansion_p2(imode, jmode, iclass, func_tag, nterms_uniq(iclass), & 
                                             terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
        call store_contr_matelem_expansion(imode_,jmode_,iclass,func_tag,nmodes_class,nmodes_class,&
                                           dimen,nterms_uniq(iclass),me_contr)
        if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') imode, jmode
      enddo
    enddo
    !
    deallocate(me_contr)
    !
  enddo ! iclass
  !
  !------------------------------------------------------------------------!
  ! store expansion terms and coefficients for the vibrational part of KEO !
  !------------------------------------------------------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'Store expansion coefficients for Gvib'
  !
  !nterms = maxval(trove%g_vib(1:nmodes,1:nmodes)%Ncoeff)
  icomb_maxnterms = maxval(icomb_nterms(0:ncomb))
  !
  allocate(ijmode_icomb_iterm(nclasses,icomb_maxnterms,0:ncomb),&
           ijmode_icomb_coefs(icomb_maxnterms,0:ncomb),ijmode_icomb_nterms(0:ncomb), stat=info)
  if (info/=0) then
    write(out, '(/a/a,10(1x,i8))') &
    'error: failed to allocate ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms(0:ncomb)', &
    'nclasses, icomb_maxnterms, ncomb =', nclasses, icomb_maxnterms, ncomb
    stop
  endif
  !
  if (job%verbose>=4) write(out, '(3x,a,3x,a,3x,a,3x,a,3x,es16.8)') 'imode', 'jmode', 'no. terms', & 
                                 'no. terms with Gvib(imode,jmode) >=', coef_thresh
  !
  do imode=1, nmodes
    do jmode=1, nmodes
      !
      do icomb=0, ncomb
        jterm = 0
        do iterm_=1, icomb_nterms(icomb)
          iterm = icomb_iterm(iterm_,icomb)
          !
          c = 0 
          !itosparse = 0
          loop_icoeff_g_vib : do icoeff = 1,trove%g_vib(jmode,imode)%Ncoeff
            !
            if (trove%g_vib(jmode,imode)%ifromsparse(icoeff) == iterm) then 
              !
              c = real(trove%g_vib(jmode,imode)%field(icoeff,0),kind=rk)
              !
              exit loop_icoeff_g_vib
              !
            endif 
            !
          enddo loop_icoeff_g_vib
          !
          !c = real(trove%g_vib(jmode,imode)%field(iterm,0),kind=rk)
          !
          if (icomb==0) then
            jterm = jterm + 1
            ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
            ijmode_icomb_coefs(jterm,icomb) = c
          elseif (abs(c)>=coef_thresh) then
            jterm = jterm + 1
            ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
            ijmode_icomb_coefs(jterm,icomb) = c
          endif
        enddo
        ijmode_icomb_nterms(icomb) = jterm
      enddo
      !
      nterms_ = sum(ijmode_icomb_nterms(0:ncomb))
      if (job%verbose>=4) write(out, '(5x,i3,5x,i3,6x,i6,6x,i6,1x,f10.1,a)') jmode, imode, nterms, nterms_, &
                                real(nterms_)/real(nterms)*100.0, '%'
      !
      call store_expansion_terms(func_tag, jmode, imode, nclasses, nmodes, nmodes, ncomb, icomb_nclasses(0:ncomb), &
                                 icomb_iclass(1:nclasses,0:ncomb),icomb_maxnterms, ijmode_icomb_nterms(0:ncomb),&
                                 ijmode_icomb_iterm(:,:,0:ncomb),ijmode_icomb_coefs(:,0:ncomb))
      !
      if (verbose>=5) then 
        ! check if we are able to recover all expansion terms from the unique for each class terms
        !do iterm=1, nterms
        !
        write(my_fmt,'(a,i0,a)') "(/a,1x,",nmodes,"(1x,i3),1x,a)"
        !
        do icoeff = 1,trove%g_vib(jmode,imode)%Ncoeff
          !
          iterm = trove%g_vib(jmode,imode)%ifromsparse(icoeff)
          !
          c = real(trove%g_vib(jmode,imode)%field(icoeff,0),kind=rk)
          !
          if (abs(c)<coef_thresh) cycle
          match = .false.
          ! loop over combinations of classes
          do icomb=0, ncomb
            ! loop over terms assigned to the current combination of classes
            do jterm=1, ijmode_icomb_nterms(icomb)
              ! assemble term indices from unique for each class indices
              term = 0
              do iclass=1, nclasses
                imode1 = iclass_imode(1,iclass)
                imode2 = iclass_imode(2,iclass)
                kterm = ijmode_icomb_iterm(iclass,jterm,icomb)
                term(imode1:imode2) = terms_uniq(imode1:imode2,kterm,iclass)
              enddo
              if (all(term(:)==terms(:,iterm))) match = .true.
              if (match) exit
            enddo
            if (match) exit
          enddo
          if (.not.match) then
            write(out,my_fmt) 'PTstore_contr_matelem error: failed while checking the Gvib expansion term = (', &
                              terms(:,iterm), ')'
            stop
          endif
        enddo
     endif
     !
    enddo ! jmode
  enddo ! imode
  !
  deallocate(ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms)
  !
  !if (treat_rotation) then
      !
      !---------------------------------------------------------------!
      ! compute and store matrix elements of the Coriolis part of KEO !
      !---------------------------------------------------------------!
      !
      if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of Gcor'
      !
      func_tag = 'Tcor'
      !
      !nterms = maxval(trove%g_cor(1:nmodes,1:3)%Ncoeff)
      !
      target_index = 0 
      target_index(1) = KinOrder
      nterms= FLQindex(trove%Nmodes_e,target_index)
      nterms0= FLQindex(trove%Nmodes-1,target_index)
      !
      if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all elements of Gcor:',nterms

      call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                            ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb),&
                            icomb_nterms(0:ncomb),icomb_iterm(:,0:ncomb))
      !
      if (job%verbose>=4) then 
        write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
        do icomb=0, ncomb
          write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
        enddo
      endif
      !
      if (sum(icomb_nterms(0:ncomb))/=nterms) then
        write(out, '(/a,1x,i6,1x,a,1x,i6)') &
        'PTstore_contr_matelem error: number of Gcor expansion terms among all combinations of classes =',&
         sum(icomb_nterms(0:ncomb)),'differs from the total number of terms =', nterms
        stop
      endif
      !
      call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                            nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
      !
      if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
      !
      ! compute and store contracted matrix elements for unique expansion terms only within each class
      !
      do iclass=1, nclasses
        !
        if (job%verbose>=4) write(out, '(/1x,a,1x,i3)') 'start contracted matrix elements for iclass', iclass
        !
        nmodes_class = iclass_imode(2,iclass) - iclass_imode(1,iclass) + 1
        dimen = contr(iclass)%nroots
        nprim = contr(iclass)%dimen
        !
        if (job%verbose>=4) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. modes, no. unique terms, no. basis functions:', &
                            nmodes_class, nterms_uniq(iclass), dimen
        !
        ! allocate array to keep contracted matrix elements
        !
        if (job%verbose>=4) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size =', & 
                            real(nterms_uniq(iclass))*real(max(dimen,nprim))**2*8.0/1024.0**3, 'gb'
        !
        allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
        if (info/=0) then
          write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate me_contr(nterms_uniq,max(dimen,nprim),max(dimen,nprim))', &
          'nterms_uniq, dimen, nprim =', nterms_uniq(iclass), dimen, nprim
        endif
        !
        ! compute contracted matrix elements for operators: G, p_i*G
        !
        if (job%verbose>=4) write(out, '(3x,a,3x,a)') 'p_i*Grot*p_j:', 'i'
        !
        ! <G>
        !
        call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), & 
                                             terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
        call store_contr_matelem_expansion(0, 0, iclass, func_tag, 0, nmodes_class, dimen, nterms_uniq(iclass), me_contr)
        !
        if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, 0
        !
        ! <p_i*G>
        !
        imode_ = 0
        do imode=iclass_imode(1,iclass), iclass_imode(2,iclass)
          imode_ = imode_ + 1
          call calc_contr_matelem_expansion_p1(imode, iclass, func_tag, nterms_uniq(iclass), & 
                                               terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
          call store_contr_matelem_expansion(0, imode_, iclass, func_tag, 0, nmodes_class, dimen, nterms_uniq(iclass),&
                                             me_contr)
          if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, imode
        enddo

        deallocate(me_contr)

      enddo ! iclass
      !
      !---------------------------------------------------------------------!
      ! store expansion terms and coefficients for the Coriolis part of KEO !
      !---------------------------------------------------------------------!
      !
      if (job%verbose>=4) write(out, '(/1x,a)') 'Store expansion coefficients for Gcor'
      !
      !nterms = maxval(trove%g_cor(1:nmodes,1:3)%Ncoeff)
      icomb_maxnterms = maxval(icomb_nterms(0:ncomb))
      !
      allocate(ijmode_icomb_iterm(nclasses,icomb_maxnterms,0:ncomb), ijmode_icomb_coefs(icomb_maxnterms,0:ncomb),&
                                  ijmode_icomb_nterms(0:ncomb), stat=info)
      if (info/=0) then
        write(out, '(/a/a,10(1x,i8))') &
        'error: failed to allocate ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms(0:ncomb)', &
        'nclasses, icomb_maxnterms, ncomb =', nclasses, icomb_maxnterms, ncomb
        stop
      endif
      !
      if (job%verbose>=4) write(out, '(3x,a,3x,a,3x,a,3x,a,3x,es16.8)') 'imode', 'jmode', &
                                'no. terms', 'no. terms with Gcor(imode,jmode) >=', coef_thresh
      !
      do imode=1, 3
        do jmode=1, nmodes
          !
          do icomb=0, ncomb
            jterm = 0
            do iterm_=1, icomb_nterms(icomb)
              iterm = icomb_iterm(iterm_,icomb)
              !c = real(trove%g_cor(jmode,imode)%field(iterm,0),kind=rk)

              c = 0 
              loop_icoeff_g_cor : do icoeff = 1,trove%g_cor(jmode,imode)%Ncoeff
                !
                if (trove%g_cor(jmode,imode)%ifromsparse(icoeff) == iterm) then 
                  !
                  c = real(trove%g_cor(jmode,imode)%field(icoeff,0),kind=rk)
                  !
                  exit loop_icoeff_g_cor
                  !
                endif 
                !
              enddo loop_icoeff_g_cor


              if (icomb==0) then
                jterm = jterm + 1
                ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
                ijmode_icomb_coefs(jterm,icomb) = c
              elseif (abs(c)>=coef_thresh) then
                jterm = jterm + 1
                ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
                ijmode_icomb_coefs(jterm,icomb) = c
              endif
            enddo
            ijmode_icomb_nterms(icomb) = jterm
          enddo
          !
          nterms_ = sum(ijmode_icomb_nterms(0:ncomb))
          if (job%verbose>=4) write(out, '(5x,i3,5x,i3,6x,i6,6x,i6,1x,f10.1,a)') jmode, imode, &
                                     nterms, nterms_, real(nterms_)/real(nterms)*100.0, '%'
          !
          call store_expansion_terms(func_tag, jmode, imode, nclasses, nmodes, 3, ncomb, icomb_nclasses(0:ncomb),&
                                     icomb_iclass(1:nclasses,0:ncomb), &
                                     icomb_maxnterms, ijmode_icomb_nterms(0:ncomb), ijmode_icomb_iterm(:,:,0:ncomb),&
                                     ijmode_icomb_coefs(:,0:ncomb))
          !
          if (verbose>=5) then 
             ! check if we are able to recover all expansion terms from the unique for each class terms
             write(my_fmt,'(a,i0,a)') "(/a,1x,",nmodes,"(1x,i3),1x,a)"
             do icoeff = 1,trove%g_cor(jmode,imode)%Ncoeff
               !
               iterm = trove%g_cor(jmode,imode)%ifromsparse(icoeff)
               c = real(trove%g_cor(jmode,imode)%field(iterm,0),kind=rk)
               if (abs(c)<coef_thresh) cycle
               match = .false.
               ! loop over combinations of classes
               do icomb=0, ncomb
                 ! loop over terms assigned to the current combination of classes
                 do jterm=1, ijmode_icomb_nterms(icomb)
                   ! assemble term indices from unique for each class indices
                   term = 0
                   do iclass=1, nclasses
                     imode1 = iclass_imode(1,iclass)
                     imode2 = iclass_imode(2,iclass)
                     kterm = ijmode_icomb_iterm(iclass,jterm,icomb)
                     term(imode1:imode2) = terms_uniq(imode1:imode2,kterm,iclass)
                   enddo
                   if (all(term(:)==terms(:,iterm))) match = .true.
                   if (match) exit
                 enddo
                 if (match) exit
               enddo
               if (.not.match) then
                   write(out,my_fmt) 'PTstore_contr_matelem error: failed while checking the Gvib expansion term = (', &
                                     terms(:,iterm), ')'


                 stop
               endif
             enddo
          endif
          !
        enddo ! jmode
      enddo ! imode
      !
      deallocate(ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms)
      !
      !-----------------------------------------------------------------!
      ! compute and store matrix elements of the rotational part of KEO !
      !-----------------------------------------------------------------!
      !
      if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of Grot'
      !
      func_tag = 'Trot'
      !
      !nterms = maxval(trove%g_rot(1:3,1:3)%Ncoeff)
      target_index = 0 
      target_index(1) = KinOrder
      nterms= FLQindex(trove%Nmodes_e,target_index)
      !
      if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'max number of expansion terms among all elements of Grot:', nterms
      !
      ! organize/split expansion terms into groups for different (0..ncomb) combinations of classes
      !
      call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                            ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb), &
                            icomb_iterm(:,0:ncomb))
      !
      if (job%verbose>=4) write(out, '(/1x,a)') 'max number of expansion terms for each combination of classes:'
      !
      do icomb=0, ncomb
        if (job%verbose>=4) write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
      enddo
      !
      if (sum(icomb_nterms(0:ncomb))/=nterms) then
        write(out, '(/a,1x,i6,1x,a,1x,i6)') &
        'PTstore_contr_matelem error: number of Grot expansion terms among all combinations of classes =', &
         sum(icomb_nterms(0:ncomb)), &
        'differs from the total number of terms =', nterms
        stop
      endif
      !
      call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                            nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
      !
      if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
      !
      ! compute and store contracted matrix elements for unique expansion terms only within each class
      !
      do iclass=1, nclasses
        !
        if (job%verbose>=4) write(out, '(/1x,a,1x,i3)') 'start contracted matrix elements for iclass', iclass
        !
        nmodes_class = iclass_imode(2,iclass) - iclass_imode(1,iclass) + 1
        dimen = contr(iclass)%nroots
        nprim = contr(iclass)%dimen
        !
        if (job%verbose>=4) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. modes, no. unique terms, no. basis functions:', &
                            nmodes_class, nterms_uniq(iclass), dimen
        !
        ! allocate array to keep contracted matrix elements
        !
        if (job%verbose>=4) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size =', &
                                 real(nterms_uniq(iclass))*real(max(dimen,nprim))**2*8.0/1024.0**3, 'gb'
        !
        allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
        if (info/=0) then
          write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate me_contr(nterms_uniq,max(dimen,nprim),max(dimen,nprim))', &
          'nterms_uniq, dimen, nprim =', nterms_uniq(iclass), dimen, nprim
        endif
        !
        ! compute contracted matrix elements for operators: G
        !
        if (job%verbose>=4) write(out, '(3x,a,3x,a,5x,a)') 'p_i*Gvib*p_j:', 'i', 'j'
        !
        ! <G>
        !
        call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), &
                                             terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
        call store_contr_matelem_expansion(0, 0, iclass, func_tag, 0, 0, dimen, nterms_uniq(iclass), me_contr)
        if (job%verbose>=4) write(out, '(17x,i3,3x,i3)') 0, 0
        !
        deallocate(me_contr)
        !
      enddo ! iclass
      !
      !-----------------------------------------------------------------------!
      ! store expansion terms and coefficients for the rotational part of KEO !
      !-----------------------------------------------------------------------!
      !
      if (job%verbose>=4) write(out, '(/1x,a)') 'Store expansion coefficients for Grot'
      !
      !nterms = maxval(trove%g_rot(1:3,1:3)%Ncoeff)
      icomb_maxnterms = maxval(icomb_nterms(0:ncomb))
      !
      allocate(ijmode_icomb_iterm(nclasses,icomb_maxnterms,0:ncomb), ijmode_icomb_coefs(icomb_maxnterms,0:ncomb), &
                                 ijmode_icomb_nterms(0:ncomb), stat=info)
      if (info/=0) then
        write(out, '(/a/a,10(1x,i8))') &
        'error: failed to allocate ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms(0:ncomb)', &
        'nclasses, icomb_maxnterms, ncomb =', nclasses, icomb_maxnterms, ncomb
        stop
      endif
      !
      if (job%verbose>=4) write(out, '(3x,a,3x,a,3x,a,3x,a,3x,es16.8)') 'imode', 'jmode', 'no. terms', &
                          'no. terms with Grot(imode,jmode) >=', coef_thresh
      !
      do imode=1, 3
        do jmode=1, 3
          !
          do icomb=0, ncomb
            jterm = 0
            do iterm_=1, icomb_nterms(icomb)
              iterm = icomb_iterm(iterm_,icomb)
              !c = real(trove%g_rot(jmode,imode)%field(iterm,0),kind=rk)

              c = 0 
              loop_icoeff_g_rot : do icoeff = 1,trove%g_rot(jmode,imode)%Ncoeff
                !
                if (trove%g_rot(jmode,imode)%ifromsparse(icoeff) == iterm) then 
                  !
                  c = real(trove%g_rot(jmode,imode)%field(icoeff,0),kind=rk)
                  !
                  exit loop_icoeff_g_rot
                  !
                endif 
                !
              enddo loop_icoeff_g_rot


              if (icomb==0) then
                jterm = jterm + 1
                ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
                ijmode_icomb_coefs(jterm,icomb) = c
              elseif (abs(c)>=coef_thresh) then
                jterm = jterm + 1
                ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
                ijmode_icomb_coefs(jterm,icomb) = c
              endif
            enddo
            ijmode_icomb_nterms(icomb) = jterm
          enddo
          !
          nterms_ = sum(ijmode_icomb_nterms(0:ncomb))
          if (job%verbose>=4) write(out, '(5x,i3,5x,i3,6x,i6,6x,i6,1x,f10.1,a)') jmode, imode, nterms, &
                                    nterms_, real(nterms_)/real(nterms)*100.0, '%'
          !
          call store_expansion_terms(func_tag, jmode, imode, nclasses, 3, 3, ncomb, icomb_nclasses(0:ncomb), &
                                     icomb_iclass(1:nclasses,0:ncomb), &
                                     icomb_maxnterms, ijmode_icomb_nterms(0:ncomb), ijmode_icomb_iterm(:,:,0:ncomb), &
                                     ijmode_icomb_coefs(:,0:ncomb))
          !
          if (verbose>=5) then 
             ! check if we are able to recover all expansion terms from the unique for each class terms
             write(my_fmt,'(a,i0,a)') "(/a,1x,",nmodes,"(1x,i3),1x,a)"
             do icoeff = 1,trove%g_rot(jmode,imode)%Ncoeff
               !
               iterm = trove%g_rot(jmode,imode)%ifromsparse(icoeff)
               c = real(trove%g_rot(jmode,imode)%field(iterm,0),kind=rk)
               if (abs(c)<coef_thresh) cycle
               match = .false.
               ! loop over combinations of classes
               do icomb=0, ncomb
                 ! loop over terms assigned to the current combination of classes
                 do jterm=1, ijmode_icomb_nterms(icomb)
                   ! assemble term indices from unique for each class indices
                   term = 0
                   do iclass=1, nclasses
                     imode1 = iclass_imode(1,iclass)
                     imode2 = iclass_imode(2,iclass)
                     kterm = ijmode_icomb_iterm(iclass,jterm,icomb)
                     term(imode1:imode2) = terms_uniq(imode1:imode2,kterm,iclass)
                   enddo
                   if (all(term(:)==terms(:,iterm))) match = .true.
                   if (match) exit
                 enddo
                 if (match) exit
               enddo
               if (.not.match) then
                 !write(out, '(/a,1x,<nmodes>(1x,i3),1x,a)') 'PTstore_contr_matelem error: failed while checking the Grot expansion term = (', terms(:,iterm), ')'
                 write(out,my_fmt) 'PTstore_contr_matelem error: failed while checking the Gvib expansion term = (', &
                                   terms(:,iterm), ')'
                 stop
               endif
             enddo
          endif
          !
        enddo ! jmode
      enddo ! imode
      !
      deallocate(ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms)
      !
  !endif
  !
  !------------------------------------------!
  ! compute and store matrix elements of PES !
  !------------------------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of PES'
  !
  func_tag = 'Vpot'
  !
  !nterms = trove%poten%Ncoeff
  !
  target_index = 0 
  target_index(1) = PotOrder
  nterms= FLQindex(trove%Nmodes_e,target_index)
  nterms0= FLQindex(trove%Nmodes-1,target_index)
  !
  if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'number of expansion terms:', nterms
  !
  ! organize terms into groups for different combinations of classes
  !
  call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb), &
                        icomb_iterm(:,0:ncomb))
  !
  if (job%verbose>=4) then 
    write(out, '(/1x,a)') 'number of expansion terms for each combination of classes:'
    do icomb=0, ncomb
      write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
    enddo
  endif
  !
  if (sum(icomb_nterms(0:ncomb))/=nterms) then
    write(out, '(/a,1x,i6,1x,a,1x,i6)') &
    'PTstore_contr_matelem error: number of PES expansion terms among all combinations of classes =',&
     sum(icomb_nterms(0:ncomb)), &
    'differs from the total number of terms =', nterms
    stop
  endif
  !
  ! select only unique terms for each class
  !
  call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
  !
  if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
  !
  do iclass=1, nclasses
    !
    if (job%verbose>=4) write(out, '(/1x,a,1x,i3)') 'start contracted matrix elements for iclass', iclass
    !
    dimen = contr(iclass)%nroots
    nprim = contr(iclass)%dimen
    !
    if (job%verbose>=4) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. unique terms, no. basis functions:', nterms_uniq(iclass), dimen
    !
    if (job%verbose>=4) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size = ', & 
                              real(nterms_uniq(iclass))*real(max(dimen,nprim))**2*8.0/1024.0**3, 'gb'
    !
    allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
    if (info/=0) then
      write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate me_contr(nterms_uniq,max(dimen,nprim),max(dimen,nprim))', &
      'nterms_uniq, dimen, nprim =', nterms_uniq(iclass), dimen, nprim
    endif
    !
    call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), &
                                         terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
    call store_contr_matelem_expansion(0, 0, iclass, func_tag, 0, 0, dimen, nterms_uniq(iclass), me_contr)
    !
    deallocate(me_contr)
    !
  enddo ! iclass
  !
  !------------------------------------------------!
  ! store expansion terms and coefficients for PES !
  !------------------------------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'store expansion coefficients for PES'
  !
  !nterms = trove%poten%Ncoeff
  icomb_maxnterms = maxval(icomb_nterms(0:ncomb))
  !
  allocate(ijmode_icomb_iterm(nclasses,icomb_maxnterms,0:ncomb), ijmode_icomb_coefs(icomb_maxnterms,0:ncomb), &
           ijmode_icomb_nterms(0:ncomb), stat=info)
  if (info/=0) then
    write(out, '(/a/a,10(1x,i8))') &
    'error: failed to allocate ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms(0:ncomb)', &
    'nclasses, icomb_maxnterms, ncomb =', nclasses, icomb_maxnterms, ncomb
    stop
  endif
  !
  if (job%verbose>=4) write(out, '(3x,a,3x,a,3x,es16.8)') 'no. terms', 'no. terms with PES >=', coef_thresh
  !
  do icomb=0, ncomb
    jterm = 0
    do iterm_=1, icomb_nterms(icomb)
      iterm = icomb_iterm(iterm_,icomb)
      !c = real(trove%poten%field(iterm,0),kind=rk)
      !
      c = 0 
      loop_icoeff_poten : do icoeff = 1,trove%poten%Ncoeff
        !
        if (trove%poten%ifromsparse(icoeff) == iterm) then 
          !
          c = real(trove%poten%field(icoeff,0),kind=rk)
          !
          exit loop_icoeff_poten
          !
        endif 
        !
      enddo loop_icoeff_poten
      !
      if (icomb==0) then
        jterm = jterm + 1
        ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
        ijmode_icomb_coefs(jterm,icomb) = c
      elseif (abs(c)>=coef_thresh) then
        jterm = jterm + 1
        ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
        ijmode_icomb_coefs(jterm,icomb) = c
      endif
    enddo
    ijmode_icomb_nterms(icomb) = jterm
  enddo
  !
  nterms_ = sum(ijmode_icomb_nterms(0:ncomb))
  if (job%verbose>=4) write(out, '(6x,i6,6x,i6,1x,f10.1,a)') nterms, nterms_, real(nterms_)/real(nterms)*100.0, '%'
  !
  call store_expansion_terms(func_tag, 1, 1, nclasses, 1, 1, ncomb, icomb_nclasses(0:ncomb), &
                             icomb_iclass(1:nclasses,0:ncomb), &
                             icomb_maxnterms, ijmode_icomb_nterms(0:ncomb), ijmode_icomb_iterm(:,:,0:ncomb), &
                             ijmode_icomb_coefs(:,0:ncomb))
  !
  if (verbose>=5) then 
     ! check if we are able to recover all expansion terms from the unique for each class terms
     write(my_fmt,'(a,i0,a)') "(/a,1x,",nmodes,"(1x,i3),1x,a)"
     !
     do icoeff = 1,trove%poten%Ncoeff
       !
       iterm = trove%poten%ifromsparse(icoeff)
       !
       c = real(trove%poten%field(iterm,0),kind=rk)
       if (abs(c)<coef_thresh) cycle
       match = .false.
       ! loop over combinations of classes
       do icomb=0, ncomb
         ! loop over terms assigned to the current combination of classes
         do jterm=1, ijmode_icomb_nterms(icomb)
           ! assemble term indices from unique for each class indices
           term = 0
           do iclass=1, nclasses
             imode1 = iclass_imode(1,iclass)
             imode2 = iclass_imode(2,iclass)
             kterm = ijmode_icomb_iterm(iclass,jterm,icomb)
             term(imode1:imode2) = terms_uniq(imode1:imode2,kterm,iclass)
           enddo
           if (all(term(:)==terms(:,iterm))) match = .true.
           if (match) exit
         enddo
         if (match) exit
       enddo
       if (.not.match) then
         !write(out, '(/a,1x,<nmodes>(1x,i3),1x,a)') 'PTstore_contr_matelem error: failed while checking the PES expansion term = (', terms(:,iterm), ')'
         write(out,my_fmt) 'PTstore_contr_matelem error: failed while checking the Gvib expansion term = (', &
                            terms(:,iterm), ')'
         stop
       endif
     enddo
  endif
  !
  deallocate(ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms)
  !
  !------------------------------------------------------!
  ! compute and store matrix elements of pseudopotential !
  !------------------------------------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of pseudopotential'
  !
  func_tag = 'pseu'
  !
  !nterms = trove%pseudo%Ncoeff
  !
  target_index = 0 
  target_index(1) = KinOrder
  nterms= FLQindex(trove%Nmodes_e,target_index)
  nterms0= FLQindex(trove%Nmodes-1,target_index)
  !
  if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'number of expansion terms:', nterms
  !
  ! organize terms into groups for different combinations of classes
  !
  call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), icomb_nterms(0:ncomb),&
                        icomb_iterm(:,0:ncomb))
  !
  if (job%verbose>=4) then 
    write(out, '(/1x,a)') 'number of expansion terms for each combination of classes:'
    do icomb=0, ncomb
      write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
    enddo
  endif
  !
  if (sum(icomb_nterms(0:ncomb))/=nterms) then
    write(out, '(/a,1x,i6,1x,a,1x,i6)') &
    'PTstore_contr_matelem error: number of pseudopotential expansion terms among all combinations of classes =', &
     sum(icomb_nterms(0:ncomb)), &
    'differs from the total number of terms =', nterms
    stop
  endif
  !
  ! select only unique terms for each class
  !
  call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                        nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), terms_uniq(1:nmodes,1:nterms,1:nclasses))
  !
  if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', nterms_uniq(1:nclasses)
  !
  do iclass=1, nclasses
    !
    if (job%verbose>=4) write(out, '(/1x,a,1x,i3)') 'start contracted matrix elements for iclass', iclass
    !
    dimen = contr(iclass)%nroots
    nprim = contr(iclass)%dimen
    !
    if (job%verbose>=4) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. unique terms, no. basis functions:', nterms_uniq(iclass), dimen
    !
    if (job%verbose>=4) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size = ', & 
                              real(nterms_uniq(iclass))*real(max(dimen,nprim))**2*8.0/1024.0**3, 'gb'
    !
    allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
    if (info/=0) then
      write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate me_contr(nterms_uniq,max(dimen,nprim),max(dimen,nprim))', &
      'nterms_uniq, dimen, nprim =', nterms_uniq(iclass), dimen, nprim
    endif
    !
    call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), & 
                                         terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
    call store_contr_matelem_expansion(0, 0, iclass, func_tag, 0, 0, dimen, nterms_uniq(iclass), me_contr)
    !
    deallocate(me_contr)
    !
  enddo ! iclass
  !
  !------------------------------------------------------------!
  ! store expansion terms and coefficients for pseudopotential !
  !------------------------------------------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'store expansion coefficients for pseudopotential'
  !
  !nterms = trove%pseudo%Ncoeff
  icomb_maxnterms = maxval(icomb_nterms(0:ncomb))
  !
  allocate(ijmode_icomb_iterm(nclasses,icomb_maxnterms,0:ncomb), ijmode_icomb_coefs(icomb_maxnterms,0:ncomb), &
                              ijmode_icomb_nterms(0:ncomb), stat=info)
  if (info/=0) then
    write(out, '(/a/a,10(1x,i8))') &
    'error: failed to allocate ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms(0:ncomb)', &
    'nclasses, icomb_maxnterms, ncomb =', nclasses, icomb_maxnterms, ncomb
    stop
  endif
  !
  if (job%verbose>=4) write(out, '(3x,a,3x,a,3x,es16.8)') 'no. terms', 'no. terms with pseudopotential >=', coef_thresh
  !
  do icomb=0, ncomb
    jterm = 0
    do iterm_=1, icomb_nterms(icomb)
      iterm = icomb_iterm(iterm_,icomb)
      !c = real(trove%pseudo%field(iterm,0),kind=rk)

      c = 0 
      loop_icoeff_pseudo : do icoeff = 1,trove%pseudo%Ncoeff
        !
        if (trove%pseudo%ifromsparse(icoeff) == iterm) then 
          !
          c = real(trove%pseudo%field(icoeff,0),kind=rk)
          !
          exit loop_icoeff_pseudo
          !
        endif 
        !
      enddo loop_icoeff_pseudo


      if (icomb==0) then
        jterm = jterm + 1
        ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
        ijmode_icomb_coefs(jterm,icomb) = c
      elseif (abs(c)>=coef_thresh) then
        jterm = jterm + 1
        ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
        ijmode_icomb_coefs(jterm,icomb) = c
      endif
    enddo
    ijmode_icomb_nterms(icomb) = jterm
  enddo
  !
  nterms_ = sum(ijmode_icomb_nterms(0:ncomb))
  if (job%verbose>=4) write(out, '(6x,i6,6x,i6,1x,f10.1,a)') nterms, nterms_, real(nterms_)/real(nterms)*100.0, '%'
  !
  call store_expansion_terms(func_tag, 1, 1, nclasses, 1, 1, ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), &
                             icomb_maxnterms, ijmode_icomb_nterms(0:ncomb), &
                             ijmode_icomb_iterm(:,:,0:ncomb), ijmode_icomb_coefs(:,0:ncomb))
  !
  if (verbose>=5) then 
     ! check if we are able to recover all expansion terms from the unique for each class terms
     write(my_fmt,'(a,i0,a)') "(/a,1x,",nmodes,"(1x,i3),1x,a)"
     do icoeff = 1,trove%pseudo%Ncoeff
       !
       iterm = trove%pseudo%ifromsparse(icoeff)
       !
       c = real(trove%pseudo%field(iterm,0),kind=rk)
       if (abs(c)<coef_thresh) cycle
       match = .false.
       ! loop over combinations of classes
       do icomb=0, ncomb
         ! loop over terms assigned to the current combination of classes
         do jterm=1, ijmode_icomb_nterms(icomb)
           ! assemble term indices from unique for each class indices
           term = 0
           do iclass=1, nclasses
             imode1 = iclass_imode(1,iclass)
             imode2 = iclass_imode(2,iclass)
             kterm = ijmode_icomb_iterm(iclass,jterm,icomb)
             term(imode1:imode2) = terms_uniq(imode1:imode2,kterm,iclass)
           enddo
           if (all(term(:)==terms(:,iterm))) match = .true.
           if (match) exit
         enddo
         if (match) exit
       enddo
       if (.not.match) then
         write(out,my_fmt) 'PTstore_contr_matelem error: failed while checking the Gvib expansion term = (', &
                            terms(:,iterm), ')'
         stop
         stop
       endif
     enddo
  endif
  !
  deallocate(ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms)
  !
  !
  if (trim(job%IOextF_action)=='SAVE'.or.trim(job%IOextF_action)=='SPLIT') then 
     !
     extF_rank = FLread_extF_rank()
     !
     ! compute and store matrix elements of extF 
     !
     if (job%verbose>=4) write(out, '(/1x,a)') 'Compute and store matrix elements of extF'
     !
     func_tag = 'extF'
     !
     !nterms = maxval(trove%extf(:)%Ncoeff)
     !
     target_index = 0 
     target_index(1) = ExtFOrder
     nterms= FLQindex(trove%Nmodes_e,target_index)
     nterms0= FLQindex(trove%Nmodes-1,target_index)
     !
     if (job%verbose>=4) write(out, '(/1x,a,1x,i8)') 'number of expansion terms:', nterms
     !
     ! organize terms into groups for different combinations of classes
     !
     call split_terms_comb(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           ncomb, icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb), &
                           icomb_nterms(0:ncomb), icomb_iterm(:,0:ncomb))
     !
     if (job%verbose>=4) then 
       write(out, '(/1x,a)') 'number of expansion terms for each combination of classes:'
       do icomb=0, ncomb
         write(out, '(1x,a,1x,i3,3x,a,1x,i6)') 'icomb =', icomb, 'nterms =', icomb_nterms(icomb)
       enddo
     endif  
     !
     if (sum(icomb_nterms(0:ncomb))/=nterms) then
       write(out, '(/a,1x,i6,1x,a,1x,i6)') &
       'PTstore_contr_matelem error: number of extF expansion terms among all combinations of classes =', & 
        sum(icomb_nterms(0:ncomb)), 'differs from the total number of terms =', nterms
       stop
     endif
     !
     ! select only unique terms for each class
     !
     call split_terms_uniq(nmodes, nterms, terms(1:nmodes,1:nterms), nclasses, iclass_imode(1:2,1:nclasses), &
                           nterms_uniq(1:nclasses), iterm_uniq(1:nclasses,1:nterms), &
                           terms_uniq(1:nmodes,1:nterms,1:nclasses))
     !
     if (job%verbose>=4) write(out, '(/1x,a,100(1x,i6))') 'max number of unique terms in each class:', &
                         nterms_uniq(1:nclasses)
     !
     do iclass=1, nclasses
 
       if (job%verbose>=4) write(out, '(/1x,a,1x,i3)') 'start contracted matrix elements for iclass', iclass
 
       dimen = contr(iclass)%nroots
       nprim = contr(iclass)%dimen
 
       if (job%verbose>=4) write(out, '(1x,a,1x,i3,1x,i6,1x,i6)') 'no. unique terms, no. basis functions:', &
                                 nterms_uniq(iclass), dimen
 
       if (job%verbose>=4) write(out, '(1x,a,1x,f10.3,1x,a)') 'allocate array "me_contr", size = ', &
                           real(nterms_uniq(iclass))*real(max(dimen,nprim))**2*8.0/1024.0**3, 'gb'
 
       allocate(me_contr(nterms_uniq(iclass),max(dimen,nprim),max(dimen,nprim)), stat=info)
       if (info/=0) then
         write(out, '(/a/a,10(1x,i8))') 'error: failed to allocate me_contr(nterms_uniq,max(dimen,nprim),max(dimen,nprim))', &
         'nterms_uniq, dimen, nprim =', nterms_uniq(iclass), dimen, nprim
         stop
       endif
 
       call calc_contr_matelem_expansion_p0(iclass, func_tag, nterms_uniq(iclass), &
                                            terms_uniq(1:nmodes,1:nterms_uniq(iclass),iclass), me_contr)
       call store_contr_matelem_expansion(0, 0, iclass, func_tag, 0, 0, dimen, nterms_uniq(iclass), me_contr)
 
       deallocate(me_contr)
 
     enddo ! iclass
     !
     ! store expansion terms and coefficients for extF 
     !
     if (job%verbose>=4) write(out, '(/1x,a)') 'store expansion coefficients for extF'
     !
     !nterms = maxval(trove%extf(:)%Ncoeff)
     icomb_maxnterms = maxval(icomb_nterms(0:ncomb))
     !
     allocate(ijmode_icomb_iterm(nclasses,icomb_maxnterms,0:ncomb), ijmode_icomb_coefs(icomb_maxnterms,0:ncomb), &
              ijmode_icomb_nterms(0:ncomb), stat=info)
     if (info/=0) then
       write(out, '(/a/a,10(1x,i8))') &
       'error: failed to allocate ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms(0:ncomb)', &
       'nclasses, icomb_maxnterms, ncomb =', nclasses, icomb_maxnterms, ncomb
       stop
     endif
     !
     if (job%verbose>=4) write(out, '(3x,a,3x,a,3x,a,3x,es16.8)') 'ipar', 'no. terms', &
                         'no. terms with Grot(imode,jmode) >=', coef_thresh
     !
     do ipar=1, extF_rank
        !
        do icomb=0, ncomb
         jterm = 0
         do iterm_=1, icomb_nterms(icomb)
           iterm = icomb_iterm(iterm_,icomb)
           !c = real(trove%extF(ipar)%field(iterm,0),kind=rk)

           c = 0 
           loop_icoeff_extF: do icoeff = 1,trove%extF(ipar)%Ncoeff
             !
             if (trove%extF(ipar)%ifromsparse(icoeff) == iterm) then 
               !
               c = real(trove%extF(ipar)%field(icoeff,0),kind=rk)
               !
               exit loop_icoeff_extF
               !
             endif 
             !
           enddo loop_icoeff_extF


           
           if (icomb==0) then
             jterm = jterm + 1
             ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
             ijmode_icomb_coefs(jterm,icomb) = c
           elseif (abs(c)>=coef_thresh) then
             jterm = jterm + 1
             ijmode_icomb_iterm(1:nclasses,jterm,icomb) = iterm_uniq(1:nclasses,iterm)
             ijmode_icomb_coefs(jterm,icomb) = c
           endif
         enddo
         ijmode_icomb_nterms(icomb) = jterm
       enddo
       !
       nterms_ = sum(ijmode_icomb_nterms(0:ncomb))
       if (job%verbose>=4) write(out, '(6x,i6,6x,i6,1x,f10.1,a)') nterms, nterms_, real(nterms_)/real(nterms)*100.0, '%'
       !
       call store_expansion_terms(func_tag, ipar, 1, nclasses, extF_rank, 1, ncomb, icomb_nclasses(0:ncomb), &
                                  icomb_iclass(1:nclasses,0:ncomb), &
                                  icomb_maxnterms, ijmode_icomb_nterms(0:ncomb), ijmode_icomb_iterm(:,:,0:ncomb), &
                                  ijmode_icomb_coefs(:,0:ncomb))
       !
       if (verbose>=5) then 
          ! check if we are able to recover all expansion terms from the unique for each class terms
          write(my_fmt,'(a,i0,a)') "(/a,1x,",nmodes,"(1x,i3),1x,a)"
          !
          do icoeff = 1,trove%extF(ipar)%Ncoeff
            !
            iterm = trove%extF(ipar)%ifromsparse(icoeff)

            c = real(trove%extF(ipar)%field(iterm,0),kind=rk)
            if (abs(c)<coef_thresh) cycle
            match = .false.
            ! loop over combinations of classes
            do icomb=0, ncomb
              ! loop over terms assigned to the current combination of classes
              do jterm=1, ijmode_icomb_nterms(icomb)
                ! assemble term indices from unique for each class indices
                term = 0
                do iclass=1, nclasses
                  imode1 = iclass_imode(1,iclass)
                  imode2 = iclass_imode(2,iclass)
                  kterm = ijmode_icomb_iterm(iclass,jterm,icomb)
                  term(imode1:imode2) = terms_uniq(imode1:imode2,kterm,iclass)
                enddo
                if (all(term(:)==terms(:,iterm))) match = .true.
                if (match) exit
              enddo
              if (match) exit
            enddo
            if (.not.match) then
                 write(out,my_fmt) 'PTstore_contr_matelem error: failed while checking the Gvib expansion term = (', &
                                    terms(:,iterm), ')'
              stop
            endif
          enddo
       endif
       !
     enddo
     !
     deallocate(ijmode_icomb_iterm, ijmode_icomb_coefs, ijmode_icomb_nterms)
     !
  endif
  !
  !---------------------------!
  ! store contraction indices !
  !---------------------------!
  !
  if (job%verbose>=4) write(out, '(/1x,a)') 'store contraction indices ...'
  call store_contr_ind
  !
  ! Done
  !
  deallocate(icomb_nclasses, icomb_iclass, icomb_nterms, icomb_iterm, terms_uniq, iterm_uniq, terms)
  call ArrayStop('PTstore_contr_matelem:terms')
  call ArrayStop('PTstore_contr_matelem:icomb_nclasses')
  call ArrayStop('PTstore_contr_matelem:icomb_iclass')
  call ArrayStop('PTstore_contr_matelem:icomb_nterms')
  call ArrayStop('PTstore_contr_matelem:terms_uniq')
  call ArrayStop('PTstore_contr_matelem:iterm_uniq')
  call ArrayStop('PTstore_contr_matelem:icomb_iterm')
  !
  if (job%verbose>=4) write(out, '(/a)')  'PTstore_contr_matelem/done'
  !
  call TimerStop('PTstore_contr_matelem')
  !
  if (job%verbose>=3) call MemoryReport
  if (job%verbose>=3) call TimerReport
  !
end subroutine PTstore_contr_matelem



subroutine store_contr_matelem_expansion(k1, k2, iclass, func_tag, nmodes_class1, nmodes_class2, ncontr, nterms_class, me_contr)

  integer(ik), intent(in) :: k1, k2, iclass, nmodes_class1, nmodes_class2, ncontr, nterms_class
  character(cl), intent(in) :: func_tag
  real(rk), intent(in) :: me_contr(:,:,:)

  integer(ik) :: IOunit, info
  character(cl) :: IOname, filename
  character(4) :: sclass
  logical :: createfile, closefile

  write(sclass,'(i4)') iclass
  filename = 'contrME_'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'

  createfile = .false.
  closefile = .false.
  if (k1==0.and.k2==0) createfile = .true.
  if (k1==nmodes_class1.and.k2==nmodes_class2) closefile = .true.

  if (k1<0.or.k1>nmodes_class1) then
    write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a)') 'store_contr_matelem_expansion error: k1 =', k1, &
                 'is out of ranges = [', 0, ':', nmodes_class1, ']'
    stop
  endif

  if (k2<0.or.k2>nmodes_class2) then
    write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a)') 'store_contr_matelem_expansion error: k1 =', k1, &
                'is out of ranges = [', 0, ':', nmodes_class2, ']'
    stop
  endif

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  if (createfile) then
    open(IOunit,form='unformatted',action='write',position='rewind',status='replace',file=filename,iostat=info)
  else
    open(IOunit,form='unformatted',action='write',position='append',status='old',file=filename,iostat=info)
  endif

  if (info/=0) then
    write(out, '(/a,a,a)') 'store_contr_matelem_expansion error: cannot create/append file "', trim(filename), '"'
    stop
  endif

  if (createfile) then
    write(IOunit) 'Start contracted matrix elements'
    write(IOunit) iclass, func_tag, nmodes_class1, nmodes_class2, ncontr, nterms_class
  endif

  write(IOunit) k1, k2
  write(IOunit) me_contr(1:nterms_class,1:ncontr,1:ncontr)

  if (closefile) then
    write(IOunit) 'End'
  endif

  close(IOunit)
  call IOStop(trim(IOname))

end subroutine store_contr_matelem_expansion



subroutine read_contr_matelem_expansion(iclass, func_tag, ncontr, nmodes_class1, nmodes_class2, nterms_class, me_contr)

  integer(ik), intent(in) :: iclass, ncontr, nmodes_class1, nmodes_class2
  character(4), intent(in) :: func_tag
  integer(ik), intent(out) :: nterms_class
  real(rk), allocatable, intent(out) :: me_contr(:,:,:,:,:)

  integer(ik) :: IOunit, info, iclass_, ncontr_, nmodes_class1_, nmodes_class2_, k1, k2, k1_, k2_
  character(cl) :: IOname, filename, buf, func_tag_, sclass

  write(sclass,'(i4)') iclass
  filename = 'contrME_'//trim(adjustl(sclass))//'_'//trim(func_tag)//'.chk'

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='read',position='rewind',status='old',file=filename,iostat=info)
  if (info/=0) then
    write(out, '(/a,a,a)') 'read_contr_matelem_expansion error: cannot open file "', trim(filename), '"'
    stop 'read_contr_matelem_expansion error'
  endif

  read(IOunit) buf(1:32)
  if (buf(1:32)/='Start contracted matrix elements') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_matelem_expansion error: file "', trim(filename), '" has bogus header', &
    'read:', buf(1:32), &
    'expected:', 'Start contracted matrix elements'
    stop 'read_contr_matelem_expansion error'
  endif

  read(IOunit) iclass_, func_tag_, nmodes_class1_, nmodes_class2_, ncontr_, nterms_class

  if (iclass/=iclass_.or.trim(func_tag)/=trim(func_tag_).or.nmodes_class1/=nmodes_class1_.or.&
      nmodes_class2/=nmodes_class2_.or.ncontr/=ncontr_) then
    write(out, '(/a,a,a/a,1x,i0,1x,a,3(1x,i0)/a,1x,i0,1x,a,3(1x,i0))') &
    'read_contr_matelem_expansion error: file "', trim(filename), '" has bogus header', &
    'read: ', iclass_, trim(func_tag_), nmodes_class1_, nmodes_class2_, ncontr_, &
    'expected:', iclass, trim(func_tag), nmodes_class1, nmodes_class2, ncontr
    stop 'read_contr_matelem_expansion error'
  endif

  if (allocated(me_contr)) deallocate(me_contr)
  allocate(me_contr(nterms_class,ncontr,ncontr,0:nmodes_class1,0:nmodes_class2), stat=info)

  if (info/=0) then
    write(out, '(/a/a,10(1x,i8))') &
    'read_contr_matelem_expansion error: failed to allocate me_contr', &
    'nterms_class, ncontr, nmodes_class1, nmodes_class2 =', nterms_class, ncontr, nmodes_class1, nmodes_class2
    stop 'read_contr_matelem_expansion error'
  endif
  me_contr = 0.0

  do k1=0, nmodes_class1
    do k2=0, nmodes_class2
      read(IOunit) k1_, k2_
      if (k1_<0.or.k1_>nmodes_class1) then
        write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a,1x,i3)') &
        'read_contr_matelem_expansion error: index of element k1 =', k1_,&
        'is out of ranges = [', 0, ':', nmodes_class1, '] for class =', iclass
        stop 'read_contr_matelem_expansion error'
      endif
      if (k2_<0.or.k2_>nmodes_class2) then
        write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a,1x,i3,1x,a,1x,i3)') &
        'read_contr_matelem_expansion error: index of element k2 =', k2_,&
        'is out of ranges = [', 0, ':', nmodes_class2, '] for class =', iclass
        stop 'read_contr_matelem_expansion error'
      endif
      read(IOunit,iostat=info) me_contr(1:nterms_class,1:ncontr,1:ncontr,k1_,k2_)
      if (info/=0) then
        write(out, '(/a,a,a,1x,i3,1x,i3)') 'read_contr_matelem_expansion error while reading file "',&
        trim(filename), '", element k1, k2 =', k1, k2
        stop 'read_contr_matelem_expansion error'
      endif
    enddo
  enddo

  read(IOunit) buf(1:3)
  if (buf(1:3)/='End') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_matelem_expansion error: file "', trim(filename), '" has bogus footer', &
    'read:', buf(1:3), &
    'expected:', 'End'
    stop 'read_contr_matelem_expansion error'
  endif

  close(IOunit)
  call IOStop(trim(IOname))

end subroutine read_contr_matelem_expansion


subroutine store_expansion_terms(func_tag, k1, k2, nclasses, nmodes1, nmodes2, ncomb, icomb_nclasses, icomb_iclass, &
                                 icomb_maxnterms, icomb_nterms, icomb_iterm_uniq, icomb_coefs)

  integer(ik), intent(in) :: k1, k2, nclasses, nmodes1, nmodes2, ncomb, icomb_nclasses(0:ncomb), &
                             icomb_iclass(nclasses,0:ncomb), &
                             icomb_maxnterms, icomb_nterms(0:ncomb), icomb_iterm_uniq(:,:,0:)
  character(cl), intent(in) :: func_tag
  real(rk), intent(in) :: icomb_coefs(:,0:)

  integer(ik) :: info, IOunit, icomb
  character(cl) :: filename, IOname
  logical :: createfile, closefile

  filename = 'contrME_terms_'//trim(func_tag)//'.chk'

  createfile = .false.
  closefile = .false.
  if (k1==1.and.k2==1) createfile = .true.
  if (k1==nmodes1.and.k2==nmodes2) closefile = .true.

  if (k1<1.or.k1>nmodes1) then
    write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'store_expansion_terms error: k1 =', k1, &
    'is out of ranges = [', 1, ':', nmodes1, ']'
    stop
  endif

  if (k2<1.or.k2>nmodes2) then
    write(out, '(/a,1x,i3,1x,a,1x,i3,1x,a)') 'store_expansion_terms error: k2 =', k2, &
    'is out of ranges = [', 1, ':', nmodes2, ']'
    stop
  endif

  IOname = filename
  call IOStart(trim(IOname), IOunit)

  if (createfile) then
    open(IOunit,form='unformatted',action='write',position='rewind',status='replace',file=filename,iostat=info)
  else
    open(IOunit,form='unformatted',action='write',position='append',status='old',file=filename,iostat=info)
  endif

  if (info/=0) then
    write(out, '(/a,a,a)') 'store_expansion_terms error: cannot create/append file "', trim(filename), '"'
    stop
  endif

  if (createfile) then
    write(IOunit) 'Start expansion'
    write(IOunit) func_tag, nclasses, nmodes1, nmodes2, ncomb, icomb_maxnterms
    write(IOunit) icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb)
  endif

  write(IOunit) k1, k2
  do icomb=0, ncomb
    write(IOunit) icomb_nterms(icomb)
    write(IOunit) icomb_iterm_uniq(1:nclasses,1:icomb_nterms(icomb),icomb)
    write(IOunit) icomb_coefs(1:icomb_nterms(icomb),icomb)
  enddo

  if (closefile) then
    write(IOunit) 'End'
  endif

  close(IOunit)
  call IOStop(trim(IOname))

end subroutine store_expansion_terms



subroutine read_expansion_terms(func_tag, nclasses, nmodes1, nmodes2, ncomb, icomb_nclasses, &
                                icomb_iclass, icomb_nterms, icomb_iterm, icomb_coefs)

  character(cl), intent(in) :: func_tag
  integer(ik), intent(in) :: nclasses, nmodes1, nmodes2
  integer(ik), intent(out) :: ncomb
  integer(ik), allocatable, intent(out) :: icomb_nclasses(:), icomb_iclass(:,:), icomb_nterms(:,:,:),&
                                           icomb_iterm(:,:,:,:,:)
  real(rk), allocatable, intent(out) :: icomb_coefs(:,:,:,:)

  integer(ik) :: info, IOunit, nclasses_, nmodes1_, nmodes2_, k1, k2, imode, jmode, icomb, icomb_maxnterms
  character(cl) :: filename, IOname, buf, func_tag_

  filename = 'contrME_terms_'//trim(func_tag)//'.chk'

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='read',position='rewind',status='old',file=filename,iostat=info)
  if (info/=0) then
    write(out, '(/a,a,a)') 'read_terms error: cannot open file "', trim(filename), '"'
    stop
  endif

  read(IOunit) buf(1:15)
  if (buf(1:15)/='Start expansion') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_expansion_terms error: file "', trim(filename), '" has bogus header', &
    'read:', buf(1:15), &
    'expected:', 'Start expansion'
    stop
  endif

  read(IOunit) func_tag_, nclasses_, nmodes1_, nmodes2_, ncomb, icomb_maxnterms

  if (nclasses/=nclasses_.or.trim(func_tag)/=trim(func_tag_).or.nmodes1/=nmodes1_.or.nmodes2/=nmodes2_) then
    write(out, '(/a,a,a/a,1x,i0,1x,a,1x,i0,1x,i0/a,1x,i0,1x,a,1x,i0,1x,i0)') &
    'read_expansion_terms error: file "', trim(filename), '" has bogus header', &
    'read: ', nclasses_, trim(func_tag_), nmodes1_, nmodes2_, &
    'expected:', nclasses, trim(func_tag), nmodes1, nmodes2
    stop
  endif

  if (allocated(icomb_nclasses)) deallocate(icomb_nclasses)
  if (allocated(icomb_iclass)) deallocate(icomb_iclass)
  if (allocated(icomb_nterms)) deallocate(icomb_nterms)
  if (allocated(icomb_iterm)) deallocate(icomb_iterm)
  if (allocated(icomb_coefs)) deallocate(icomb_coefs)

  allocate(icomb_nclasses(0:ncomb), &
           icomb_iclass(nclasses,0:ncomb), &
           icomb_nterms(0:ncomb,nmodes1,nmodes2), &
           icomb_iterm(nclasses,icomb_maxnterms,0:ncomb,nmodes1,nmodes2), &
           icomb_coefs(icomb_maxnterms,0:ncomb,nmodes1,nmodes2), stat=info)

  if (info/=0) then
    call MemoryReport
    write(out, '(/a/a/a,10(1x,i8))') 'read_expansion_terms error: failed to allocate icomb_nclasses, icomb_iclass', &
    'icomb_nterms(0:ncomb,nmodes1,nmodes2), icomb_iterm, icomb_coefs', &
    'ncomb, nclasses, nmodes1, nmodes2, icomb_maxnterms =', ncomb, nclasses, nmodes1, nmodes2, icomb_maxnterms
    stop
  endif
  !
  icomb_nterms = 0
  icomb_iterm  = 0
  icomb_coefs  = 0
  !
  read(IOunit) icomb_nclasses(0:ncomb), icomb_iclass(1:nclasses,0:ncomb)
  !
  do imode=1, nmodes1
    do jmode=1, nmodes2
      read(IOunit) k1, k2
      do icomb=0, ncomb
        read(IOunit) icomb_nterms(icomb,k1,k2)
        read(IOunit) icomb_iterm(1:nclasses,1:icomb_nterms(icomb,k1,k2),icomb,k1,k2)
        read(IOunit) icomb_coefs(1:icomb_nterms(icomb,k1,k2),icomb,k1,k2)
      enddo
    enddo
  enddo
  !
  read(IOunit) buf(1:3)
  if (buf(1:3)/='End') then
    write(out, '(/a,a,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_expansion_terms error: file "', trim(filename), '" has bogus footer', &
    'read:', buf(1:3), &
    'expected:', 'End'
    stop
  endif
  !
  close(IOunit)
  call IOStop(trim(IOname))

end subroutine read_expansion_terms


subroutine store_contr_ind

  integer(ik) :: icoeff, icase, ilambda, iclass, ideg, ilevel, iroot(PT%Nclasses), info, IOunit
  character(cl) :: filename, IOname

  filename = 'contrME_ind.chk'

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='write',position='rewind',status='replace',file=filename,iostat=info)
  if (info/=0) then
    write(out, '(/a,1x,a)') 'store_contr_ind error: cannot create file', trim(filename)
    stop
  endif

  write(IOunit) 'Start contracted indices'
  write(IOunit) PT%Maxcontracts, PT%Nclasses
  write(IOunit) contr(1:PT%Nclasses)%nroots

  do icoeff=1, PT%Maxcontracts
    icase = PT%icontr2icase(icoeff,1)
    ilambda = PT%icontr2icase(icoeff,2)
    do iclass=1, PT%Nclasses
      ideg = PT%Index_deg(icase)%icoeffs(iclass,ilambda)
      ilevel = PT%contractive_space(iclass,icase)
      iroot(iclass) = contr(iclass)%iroot(ilevel,ideg)
    enddo
    write(IOunit) icoeff, iroot(1:PT%Nclasses)
  enddo

  write(IOunit) 'End'
  close(IOunit)
  call IOStop(trim(IOname))

end subroutine store_contr_ind




subroutine read_contr_ind(ncontr, nclasses, dimen_classes, nu_classes)

  integer(ik), intent(out) :: ncontr, nclasses
  integer(ik), allocatable, intent(out) :: dimen_classes(:), nu_classes(:,:)

  integer(ik) :: icontr, jcontr, info, IOunit
  character(cl) :: filename, IOname, buf

  filename = 'contrME_ind.chk'

  IOname = filename
  call IOStart(trim(IOname), IOunit)
  open(IOunit,form='unformatted',action='read',position='rewind',status='old',file=filename,iostat=info)
  if (info/=0) then
    write(out, '(/a,1x,a)') 'read_contr_ind error: cannot open file', trim(filename)
    stop
  endif

  read(IOunit) buf(1:24)
  if (buf(1:24)/='Start contracted indices') then
    write(out, '(/a,1x,a,1x,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_ind error: file', trim(filename), 'has bogus header', &
    'read:', buf(1:24), 'expected:', 'Start contracted indices'
    stop
  endif

  read(IOunit) ncontr, nclasses
  !
  if (allocated(nu_classes)) deallocate(nu_classes)
  if (allocated(dimen_classes)) deallocate(dimen_classes)
  !
  allocate(nu_classes(nclasses,ncontr), dimen_classes(nclasses),stat=info)
  if (info/=0) then
    write(out, '(/a/a,2(1x,i6))') &
    'read_contr_ind error: nu_classes(nclasses,ncontr), dimen_classes(nclasses), - out of memory', &
    'nclasses, ncontr =', nclasses, ncontr
    stop
  endif

  read(IOunit) dimen_classes(1:nclasses)
  do icontr=1, ncontr
    read(IOunit) jcontr, nu_classes(1:nclasses,jcontr)
  enddo

  read(IOunit) buf(1:3)
  if (buf(1:3)/='End') then
    write(out, '(/a,1x,a,1x,a/a,1(1h"),a,1(1h")/a,1(1h"),a,1(1h"))') &
    'read_contr_ind error: file', trim(filename), 'has bogus footer', &
    'read:', buf(1:3), 'expected:', 'End'
    stop
  endif

  close(IOunit)
  call IOStop(trim(IOname))

end subroutine read_contr_ind



  !
 end module perturbation

! just  in case if you will be reading binary files, written on intel/amd,
! on ibm machines using XLF compiler, add the following code into your
! program (on ibm)
! call setrteopts("ufmt_littleendian=unit")
! where unit is binary file unit number, you can also provide a few unit
! numbers.
! The problem was in that the ibm architecture have different bytes
! ordering, just opposite to that on intel/amd.


#include "errors.fpp"

module test_mpi_io
  use mpi_f08
  use funit
  use mpi_aux
  use io_handler_base
  use io_handler_mpi
  use errors
  use accuracy

  implicit none

  @TestCase
  type, extends(TestCase) :: TestMPI
  contains
    procedure :: setUp     ! overides generic
    procedure :: tearDown  ! overrides generic
  end type TestMPI

  integer,external :: INDXL2G

  logical :: is_mpi_initialised = .false.
  integer, parameter :: totalTestCount = 5 ! CHANGE ME TO NUMBER OF TESTS
  integer :: currentTestCount = 0

  contains

  subroutine setUp(this)
    class(TestMPI), intent(inout) :: this
    currentTestCount = currentTestCount + 1
    if (is_mpi_initialised .eqv. .false.) then
      call co_init_comms()
      is_mpi_initialised = .true.
    endif
  end subroutine setUp

  subroutine tearDown(this)
    class(TestMPI), intent(inout) :: this
    if (is_mpi_initialised .eqv. .true. .and. currentTestCount == totalTestCount) then
      call co_finalize_comms()
    endif
  end subroutine tearDown

  @test
  subroutine testMPIWritingScalars(this)
    class(TestMPI), intent(inout) :: this

    type(ioHandlerMPI) :: ioHandler

    real :: true_real = 4.0, in_real
    complex :: true_complex = (5.0, 1.0), in_complex
    integer :: true_integer = 5, in_integer
    character (len=11) :: true_str = "test string", in_str

    integer :: iounit, stat
    character(len=*), parameter :: fname = "test.dat"
    character(len=*), parameter :: position = "asis"
    character(len=*), parameter :: status = "unknown"
    character(len=*), parameter :: form = "unformatted"
    character(len=*), parameter :: access = "sequential"

    type(ErrorType) :: err

    integer :: ierr, rank, allocinfo = 0

    ! Set up MPI
    call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
    if(ierr.ne.0) print *, "Error: could not get rank"

    ! Write
    call ioHandler%open(fname, err, action='write', &
      form=form, access=access, status=status, position=position)
    HANDLE_ERROR(err)

    ! Test writing scalars
    call ioHandler%write(true_integer) ! int
    call ioHandler%write(true_real) ! double
    call ioHandler%write(true_complex) ! complex
    call ioHandler%write(true_str) ! string

    call ioHandler%close()

    ! Only test result on main process
    if(rank == 0) then
      open(newunit=iounit, iostat=stat, action='read', file=fname, &
        form=form, access=access, status=status, position=position)

      read(iounit) in_integer
      @assertTrue(in_integer == true_integer)

      read(iounit) in_real
      @assertTrue(in_real == true_real)

      read(iounit) in_complex
      @assertTrue(in_complex == true_complex)

      read(iounit) in_str
      @assertTrue(in_str == true_str)

      ! Remove test file
      if (stat == 0) close(iounit, status='delete')

    endif

  end subroutine

  @test
  subroutine testMPIWritingBlacsDistArray(this)
    class(TestMPI), intent(inout) :: this

    type(ioHandlerMPI) :: ioHandler

    integer, parameter :: array2DNRow = 4
    integer, parameter :: array2DNCol = 3
    real(rk), allocatable :: array2D(:,:)
    real(rk) :: in_array2D(array2DNRow,array2DNCol)
    integer :: array2D_descr(9) = 0
    type(MPI_Datatype) :: array2D_block_type

    integer :: true_integer = 5, in_integer

    integer :: iounit, stat
    character(len=*), parameter :: fname = "test.dat"
    character(len=*), parameter :: position = "asis"
    character(len=*), parameter :: status = "unknown"
    character(len=*), parameter :: form = "unformatted"
    character(len=*), parameter :: access = "sequential"

    integer i, j
    integer :: gi = 0, gj = 0, MB, NB, RSRC, CSRC
    type(ErrorType) :: err

    integer :: ierr, rank, allocinfo = 0

    ! Set up MPI
    call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
    if(ierr.ne.0) print *, "Error: could not get rank"

    ! Set up 2D Array
    call co_block_type_init(array2D, array2DNCol, array2DNRow, array2D_descr, allocinfo, array2D_block_type)
    if(allocinfo.ne.0) print *, "ERROR: couldn't allocate array"

    MB = array2D_descr(5)
    NB = array2D_descr(6)

    RSRC = array2D_descr(7)
    CSRC = array2D_descr(8)

    do i=1,size(array2D,1)
      do j=1,size(array2D,2)
        gi = INDXL2G (i, MB, myprow, RSRC, nprow)
        gj = INDXL2G (j, NB, mypcol, CSRC, npcol)
        array2D(i,j) = array2DNCol*(gi-1) + (gj)
      end do
    end do

    ! Write
    call ioHandler%open(fname, err, action='write', &
      form=form, access=access, status=status, position=position)
    HANDLE_ERROR(err)

    ! Test writing an array
    call ioHandler%write(array2D, array2D_descr, array2D_block_type)

    ! Test writing something after array
    call ioHandler%write(true_integer)

    ! Test writing another array
    call ioHandler%write(array2D, array2D_descr, array2D_block_type)

    call ioHandler%close()

    ! Only test result on main process
    if(rank == 0) then
      open(newunit=iounit, iostat=stat, action='read', file=fname, &
        form=form, access=access, status=status, position=position)

      read(iounit) in_array2D
      do i=1,array2DNRow
        do j=1,array2DNCol
          @assertTrue(in_array2D(i,j) == array2DNCol*(i-1) + j)
        end do
      end do

      read(iounit) in_integer
      @assertTrue(in_integer == true_integer)

      read(iounit) in_array2D
      do i=1,array2DNRow
        do j=1,array2DNCol
          @assertTrue(in_array2D(i,j) == array2DNCol*(i-1) + j)
        end do
      end do

      ! Remove test file
      if (stat == 0) close(iounit, status='delete')

    endif

  end subroutine

  @test
  subroutine testMPIWritingColumnDistArray(this)
    class(TestMPI), intent(inout) :: this
    type(ioHandlerMPI) :: ioHandler

    integer :: dimen = 51
    integer :: b, icoeff, jcoeff
    integer :: _startdim, _enddim, _blocksize

    integer :: iounit, stat
    character(len=*), parameter :: fname = "test.dat"
    character(len=*), parameter :: position = "asis"
    character(len=*), parameter :: status = "unknown"
    character(len=*), parameter :: form = "unformatted"
    character(len=*), parameter :: access = "sequential"

    real(rk) :: grot_full(dimen, dimen)
    real(rk), allocatable :: grot_t(:,:)
    real(rk),allocatable :: recvbuf(:,:,:)

    integer :: true_integer = 5, in_integer

    integer :: i,j

    type(MPI_File) :: chkptMPIIO
    integer :: ierr, rank, allocinfo = 0

    type(ErrorType) :: err

    call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
    if(ierr.ne.0) print *, "Error: could not get rank"

    call co_init_distr(dimen, _startdim, _enddim, _blocksize)

    call co_create_distr_array(grot_t, dimen)

    grot_t = 0

    ! Fill local chunk of symmetric matrix
    do b=1,comm_size
      if (send_or_recv(b).ge.0) then
        do icoeff=co_startdim,co_enddim
          do jcoeff=((b-1)*co_localsize)+1,b*co_localsize
            grot_t(jcoeff,icoeff) = jcoeff*icoeff
          enddo
        enddo
      endif
    enddo

    ! Distribute between processes and save
    allocate(recvbuf(co_localsize,co_localsize,comm_size))
    call co_distr_data(grot_t, recvbuf, co_localsize, co_startdim, co_enddim)

    call ioHandler%open(fname, err, action='write', &
      form=form, access=access, status=status, position=position)
    HANDLE_ERROR(err)

    ! Test writing something before array
    call ioHandler%write(true_integer)

    ! Test writing an array
    call ioHandler%write(grot_t, dimen)

    ! Test writing something after array
    call ioHandler%write(true_integer)

    ! Test writing another array
    call ioHandler%write(grot_t, dimen)

    ! Test writing something after second array
    call ioHandler%write(true_integer)

    call ioHandler%close()

    ! Check output
    if(rank == 0) then
      open(newunit=iounit, iostat=stat, action='read', file=fname, &
        form=form, access=access, status=status, position=position)

      read(iounit) in_integer
      @assertTrue(in_integer == true_integer)

      read(iounit) grot_full
      do i=1,dimen
        do j=1,dimen
          @assertTrue(grot_full(i,j) == i*j)
        end do
      end do

      read(iounit) in_integer
      @assertTrue(in_integer == true_integer)

      read(iounit) grot_full
      do i=1,dimen
        do j=1,dimen
          @assertTrue(grot_full(i,j) == i*j)
        end do
      end do

      read(iounit) in_integer
      @assertTrue(in_integer == true_integer)

      close(iounit, status='delete')
    endif

  end subroutine testMPIWritingColumnDistArray

  @test
  subroutine testMPIReadScalars(this)
    class(TestMPI), intent(inout) :: this
    type(ioHandlerMPI) :: ioHandler

    real :: true_real = 4.0, in_real
    complex :: true_complex = (5.0, 1.0), in_complex
    integer :: true_integer = 5, in_integer
    character (len=11) :: true_str = "test string", in_str

    integer :: iounit, stat
    character(len=*), parameter :: fname = "test.dat"
    character(len=*), parameter :: position = "asis"
    character(len=*), parameter :: status = "unknown"
    character(len=*), parameter :: form = "unformatted"
    character(len=*), parameter :: access = "sequential"

    integer :: ierr, rank, allocinfo = 0
    type(ErrorType) :: err

    ! Set up MPI
    call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
    if(ierr.ne.0) print *, "Error: could not get rank"

    ! Write test file
    if(rank == 0) then
      open(newunit=iounit, iostat=stat, action='write', file=fname, &
        form=form, access=access, status=status, position=position)

      write(iounit) true_integer ! int
      write(iounit) true_real ! double
      write(iounit) true_complex ! complex
      write(iounit) true_str ! string

      if (stat == 0) close(iounit)
    endif

    call MPI_Barrier(MPI_COMM_WORLD)

    ! Read test file
    call ioHandler%open(fname, err, \
      action='read', form=form, access=access, status=status, position=position)
    HANDLE_ERROR(err)

    call ioHandler%read(in_integer)
    @assertTrue(in_integer == true_integer)

    call ioHandler%read(in_real)
    @assertTrue(in_real == true_real)

    call ioHandler%read(in_complex)
    @assertTrue(in_complex == true_complex)

    call ioHandler%read(in_str)
    @assertTrue(in_str == true_str)

    call ioHandler%close()

    if(rank == 0) then
      ! Cleanup test file
      open(newunit=iounit, iostat=stat, action='read', file=fname)
      if (stat == 0) close(iounit, status='delete')
    endif

  end subroutine

  @test
  subroutine testMPIReadBlacsDistArray(this)
    class(TestMPI), intent(inout) :: this
    type(ioHandlerMPI) :: ioHandler

    integer, parameter :: array2DNRow = 4
    integer, parameter :: array2DNCol = 3
    real(rk) :: array2D(array2DNRow,array2DNCol)
    real(rk), allocatable :: in_array2D(:,:)
    integer :: array2D_descr(9) = 0
    type(MPI_Datatype) :: array2D_block_type

    integer :: true_integer = 5, in_integer

    integer :: iounit, stat
    character(len=*), parameter :: fname = "test.dat"
    character(len=*), parameter :: position = "asis"
    character(len=*), parameter :: status = "unknown"
    character(len=*), parameter :: form = "unformatted"
    character(len=*), parameter :: access = "sequential"

    integer i, j
    integer :: gi = 0, gj = 0, MB, NB, RSRC, CSRC
    integer :: ierr, rank, allocinfo = 0
    type(ErrorType) :: err

    ! Set up 2D array
    do i=1,array2DNRow
      do j=1,array2DNCol
        array2D(i,j) = array2DNCol*(i-1) + j
      end do
    end do

    ! Set up MPI
    call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
    if(ierr.ne.0) print *, "Error: could not get rank"

    ! Set up 2D array block type
    call co_block_type_init(in_array2D, array2DNCol, array2DNRow, array2D_descr, allocinfo, array2D_block_type)
    if(allocinfo.ne.0) print *, "ERROR: couldn't allocate array"

    MB = array2D_descr(5)
    NB = array2D_descr(6)

    RSRC = array2D_descr(7)
    CSRC = array2D_descr(8)

    ! Write test file
    if(rank == 0) then
      open(newunit=iounit, iostat=stat, action='write', file=fname, &
        form=form, access=access, status=status, position=position)

      write(iounit) true_integer ! int
      write(iounit) array2D ! 2D array
      write(iounit) true_integer ! int
      write(iounit) array2D ! 2D array
      write(iounit) true_integer ! int

      if (stat == 0) close(iounit)
    endif

    call MPI_Barrier(MPI_COMM_WORLD)

    ! Read test file
    call ioHandler%open(fname, err, \
      action='read', form=form, access=access, status=status, position=position)
    HANDLE_ERROR(err)

    call ioHandler%read(in_integer)
    @assertTrue(in_integer == true_integer)

    call ioHandler%read(in_array2D, array2D_descr, array2D_block_type)
    do i=1,size(in_array2D,1)
      do j=1,size(in_array2D,2)
        gi = INDXL2G (i, MB, myprow, RSRC, nprow)
        gj = INDXL2G (j, NB, mypcol, CSRC, npcol)
        @assertTrue(in_array2D(i,j) == array2DNCol*(gi-1) + (gj))
      end do
    end do

    call ioHandler%read(true_integer)
    @assertTrue(in_integer == true_integer)

    call ioHandler%read(in_array2D, array2D_descr, array2D_block_type)
    do i=1,size(in_array2D,1)
      do j=1,size(in_array2D,2)
        gi = INDXL2G (i, MB, myprow, RSRC, nprow)
        gj = INDXL2G (j, NB, mypcol, CSRC, npcol)
        @assertTrue(in_array2D(i,j) == array2DNCol*(gi-1) + (gj))
      end do
    end do

    call ioHandler%read(true_integer)
    @assertTrue(in_integer == true_integer)

    call ioHandler%close()

    if(rank == 0) then
      ! Cleanup test file
      open(newunit=iounit, iostat=stat, action='read', file=fname)
      if (stat == 0) close(iounit, status='delete')
    endif

  end subroutine
end module
